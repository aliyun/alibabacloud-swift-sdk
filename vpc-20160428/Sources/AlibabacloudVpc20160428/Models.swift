import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ActivateRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class ActivateRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ActivateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ActivateRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ActiveFlowLogRequest : Tea.TeaModel {
    public var flowLogId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowLogId") {
            self.flowLogId = dict["FlowLogId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ActiveFlowLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ActiveFlowLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActiveFlowLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ActiveFlowLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddBgpNetworkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dstCidrBlock: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dstCidrBlock != nil {
            map["DstCidrBlock"] = self.dstCidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DstCidrBlock") {
            self.dstCidrBlock = dict["DstCidrBlock"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class AddBgpNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddBgpNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBgpNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddBgpNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCommonBandwidthPackageIpRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ipInstanceId: String?

    public var ipType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipInstanceId != nil {
            map["IpInstanceId"] = self.ipInstanceId!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpInstanceId") {
            self.ipInstanceId = dict["IpInstanceId"] as! String
        }
        if dict.keys.contains("IpType") {
            self.ipType = dict["IpType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AddCommonBandwidthPackageIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCommonBandwidthPackageIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCommonBandwidthPackageIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCommonBandwidthPackageIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCommonBandwidthPackageIpsRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ipInstanceIds: [String]?

    public var ipType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipInstanceIds != nil {
            map["IpInstanceIds"] = self.ipInstanceIds!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpInstanceIds") {
            self.ipInstanceIds = dict["IpInstanceIds"] as! [String]
        }
        if dict.keys.contains("IpType") {
            self.ipType = dict["IpType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AddCommonBandwidthPackageIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCommonBandwidthPackageIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCommonBandwidthPackageIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCommonBandwidthPackageIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGlobalAccelerationInstanceIpRequest : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var ipInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ipInstanceId != nil {
            map["IpInstanceId"] = self.ipInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalAccelerationInstanceId") {
            self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
        }
        if dict.keys.contains("IpInstanceId") {
            self.ipInstanceId = dict["IpInstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AddGlobalAccelerationInstanceIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddGlobalAccelerationInstanceIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGlobalAccelerationInstanceIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGlobalAccelerationInstanceIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddIPv6TranslatorAclListEntryRequest : Tea.TeaModel {
    public var aclEntryComment: String?

    public var aclEntryIp: String?

    public var aclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntryComment != nil {
            map["AclEntryComment"] = self.aclEntryComment!
        }
        if self.aclEntryIp != nil {
            map["AclEntryIp"] = self.aclEntryIp!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntryComment") {
            self.aclEntryComment = dict["AclEntryComment"] as! String
        }
        if dict.keys.contains("AclEntryIp") {
            self.aclEntryIp = dict["AclEntryIp"] as! String
        }
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AddIPv6TranslatorAclListEntryResponseBody : Tea.TeaModel {
    public var aclEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntryId != nil {
            map["AclEntryId"] = self.aclEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntryId") {
            self.aclEntryId = dict["AclEntryId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddIPv6TranslatorAclListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddIPv6TranslatorAclListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddIPv6TranslatorAclListEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPublicIpAddressPoolCidrBlockRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var cidrMask: Int32?

    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.cidrMask != nil {
            map["CidrMask"] = self.cidrMask!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("CidrMask") {
            self.cidrMask = dict["CidrMask"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PublicIpAddressPoolId") {
            self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AddPublicIpAddressPoolCidrBlockResponseBody : Tea.TeaModel {
    public var cidrBlock: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPublicIpAddressPoolCidrBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPublicIpAddressPoolCidrBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPublicIpAddressPoolCidrBlockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSourcesToTrafficMirrorSessionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorSessionId: String?

    public var trafficMirrorSourceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        if self.trafficMirrorSourceIds != nil {
            map["TrafficMirrorSourceIds"] = self.trafficMirrorSourceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrafficMirrorSessionId") {
            self.trafficMirrorSessionId = dict["TrafficMirrorSessionId"] as! String
        }
        if dict.keys.contains("TrafficMirrorSourceIds") {
            self.trafficMirrorSourceIds = dict["TrafficMirrorSourceIds"] as! [String]
        }
    }
}

public class AddSourcesToTrafficMirrorSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddSourcesToTrafficMirrorSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSourcesToTrafficMirrorSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSourcesToTrafficMirrorSessionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocateEipAddressRequest : Tea.TeaModel {
    public var activityId: Int64?

    public var autoPay: Bool?

    public var bandwidth: String?

    public var clientToken: String?

    public var description_: String?

    public var ISP: String?

    public var instanceChargeType: String?

    public var instanceId: String?

    public var internetChargeType: String?

    public var ipAddress: String?

    public var name: String?

    public var netmode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var pricingCycle: String?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionTypes: [String]?

    public var zone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.netmode != nil {
            map["Netmode"] = self.netmode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionTypes != nil {
            map["SecurityProtectionTypes"] = self.securityProtectionTypes!
        }
        if self.zone != nil {
            map["Zone"] = self.zone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivityId") {
            self.activityId = dict["ActivityId"] as! Int64
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ISP") {
            self.ISP = dict["ISP"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Netmode") {
            self.netmode = dict["Netmode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("PublicIpAddressPoolId") {
            self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityProtectionTypes") {
            self.securityProtectionTypes = dict["SecurityProtectionTypes"] as! [String]
        }
        if dict.keys.contains("Zone") {
            self.zone = dict["Zone"] as! String
        }
    }
}

public class AllocateEipAddressResponseBody : Tea.TeaModel {
    public var allocationId: String?

    public var eipAddress: String?

    public var orderId: Int64?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("EipAddress") {
            self.eipAddress = dict["EipAddress"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class AllocateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocateEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocateEipAddressProRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var bandwidth: String?

    public var clientToken: String?

    public var ISP: String?

    public var instanceChargeType: String?

    public var instanceId: String?

    public var internetChargeType: String?

    public var ipAddress: String?

    public var netmode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var pricingCycle: String?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionTypes: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.netmode != nil {
            map["Netmode"] = self.netmode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionTypes != nil {
            map["SecurityProtectionTypes"] = self.securityProtectionTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ISP") {
            self.ISP = dict["ISP"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("Netmode") {
            self.netmode = dict["Netmode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("PublicIpAddressPoolId") {
            self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityProtectionTypes") {
            self.securityProtectionTypes = dict["SecurityProtectionTypes"] as! [String]
        }
    }
}

public class AllocateEipAddressProResponseBody : Tea.TeaModel {
    public var allocationId: String?

    public var eipAddress: String?

    public var orderId: Int64?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("EipAddress") {
            self.eipAddress = dict["EipAddress"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class AllocateEipAddressProResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateEipAddressProResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocateEipAddressProResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocateEipSegmentAddressRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var clientToken: String?

    public var eipMask: String?

    public var internetChargeType: String?

    public var isp: String?

    public var netmode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.eipMask != nil {
            map["EipMask"] = self.eipMask!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.netmode != nil {
            map["Netmode"] = self.netmode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zone != nil {
            map["Zone"] = self.zone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EipMask") {
            self.eipMask = dict["EipMask"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Netmode") {
            self.netmode = dict["Netmode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Zone") {
            self.zone = dict["Zone"] as! String
        }
    }
}

public class AllocateEipSegmentAddressResponseBody : Tea.TeaModel {
    public var eipSegmentInstanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipSegmentInstanceId != nil {
            map["EipSegmentInstanceId"] = self.eipSegmentInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipSegmentInstanceId") {
            self.eipSegmentInstanceId = dict["EipSegmentInstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AllocateEipSegmentAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateEipSegmentAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocateEipSegmentAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocateIpv6AddressRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var addressType: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6Address: String?

    public var ipv6AddressDescription: String?

    public var ipv6AddressName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [AllocateIpv6AddressRequest.Tag]?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressType != nil {
            map["AddressType"] = self.addressType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressDescription != nil {
            map["Ipv6AddressDescription"] = self.ipv6AddressDescription!
        }
        if self.ipv6AddressName != nil {
            map["Ipv6AddressName"] = self.ipv6AddressName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressType") {
            self.addressType = dict["AddressType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! String
        }
        if dict.keys.contains("Ipv6AddressDescription") {
            self.ipv6AddressDescription = dict["Ipv6AddressDescription"] as! String
        }
        if dict.keys.contains("Ipv6AddressName") {
            self.ipv6AddressName = dict["Ipv6AddressName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [AllocateIpv6AddressRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AllocateIpv6AddressRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class AllocateIpv6AddressResponseBody : Tea.TeaModel {
    public var ipv6Address: String?

    public var ipv6AddressId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! String
        }
        if dict.keys.contains("Ipv6AddressId") {
            self.ipv6AddressId = dict["Ipv6AddressId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class AllocateIpv6AddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateIpv6AddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocateIpv6AddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocateIpv6InternetBandwidthRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var clientToken: String?

    public var dryRun: Bool?

    public var internetChargeType: String?

    public var ipv6AddressId: String?

    public var ipv6GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Ipv6AddressId") {
            self.ipv6AddressId = dict["Ipv6AddressId"] as! String
        }
        if dict.keys.contains("Ipv6GatewayId") {
            self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AllocateIpv6InternetBandwidthResponseBody : Tea.TeaModel {
    public var internetBandwidthId: String?

    public var ipv6AddressId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.internetBandwidthId != nil {
            map["InternetBandwidthId"] = self.internetBandwidthId!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InternetBandwidthId") {
            self.internetBandwidthId = dict["InternetBandwidthId"] as! String
        }
        if dict.keys.contains("Ipv6AddressId") {
            self.ipv6AddressId = dict["Ipv6AddressId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AllocateIpv6InternetBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateIpv6InternetBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocateIpv6InternetBandwidthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocateVpcIpv6CidrRequest : Tea.TeaModel {
    public var addressPoolType: String?

    public var clientToken: String?

    public var ipv6CidrBlock: String?

    public var ipv6Isp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ipv6Isp != nil {
            map["Ipv6Isp"] = self.ipv6Isp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolType") {
            self.addressPoolType = dict["AddressPoolType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
        }
        if dict.keys.contains("Ipv6Isp") {
            self.ipv6Isp = dict["Ipv6Isp"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AllocateVpcIpv6CidrResponseBody : Tea.TeaModel {
    public var ipv6CidrBlock: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AllocateVpcIpv6CidrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateVpcIpv6CidrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocateVpcIpv6CidrResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyPhysicalConnectionLOARequest : Tea.TeaModel {
    public class PMInfo : Tea.TeaModel {
        public var PMCertificateNo: String?

        public var PMCertificateType: String?

        public var PMContactInfo: String?

        public var PMGender: String?

        public var PMName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.PMCertificateNo != nil {
                map["PMCertificateNo"] = self.PMCertificateNo!
            }
            if self.PMCertificateType != nil {
                map["PMCertificateType"] = self.PMCertificateType!
            }
            if self.PMContactInfo != nil {
                map["PMContactInfo"] = self.PMContactInfo!
            }
            if self.PMGender != nil {
                map["PMGender"] = self.PMGender!
            }
            if self.PMName != nil {
                map["PMName"] = self.PMName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PMCertificateNo") {
                self.PMCertificateNo = dict["PMCertificateNo"] as! String
            }
            if dict.keys.contains("PMCertificateType") {
                self.PMCertificateType = dict["PMCertificateType"] as! String
            }
            if dict.keys.contains("PMContactInfo") {
                self.PMContactInfo = dict["PMContactInfo"] as! String
            }
            if dict.keys.contains("PMGender") {
                self.PMGender = dict["PMGender"] as! String
            }
            if dict.keys.contains("PMName") {
                self.PMName = dict["PMName"] as! String
            }
        }
    }
    public var bandwidth: Int32?

    public var clientToken: String?

    public var companyName: String?

    public var constructionTime: String?

    public var instanceId: String?

    public var lineType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var PMInfo: [ApplyPhysicalConnectionLOARequest.PMInfo]?

    public var peerLocation: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var si: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.companyName != nil {
            map["CompanyName"] = self.companyName!
        }
        if self.constructionTime != nil {
            map["ConstructionTime"] = self.constructionTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lineType != nil {
            map["LineType"] = self.lineType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.PMInfo != nil {
            var tmp : [Any] = []
            for k in self.PMInfo! {
                tmp.append(k.toMap())
            }
            map["PMInfo"] = tmp
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.si != nil {
            map["Si"] = self.si!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CompanyName") {
            self.companyName = dict["CompanyName"] as! String
        }
        if dict.keys.contains("ConstructionTime") {
            self.constructionTime = dict["ConstructionTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LineType") {
            self.lineType = dict["LineType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PMInfo") {
            var tmp : [ApplyPhysicalConnectionLOARequest.PMInfo] = []
            for v in dict["PMInfo"] as! [Any] {
                var model = ApplyPhysicalConnectionLOARequest.PMInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.PMInfo = tmp
        }
        if dict.keys.contains("PeerLocation") {
            self.peerLocation = dict["PeerLocation"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Si") {
            self.si = dict["Si"] as! String
        }
    }
}

public class ApplyPhysicalConnectionLOAResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ApplyPhysicalConnectionLOAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyPhysicalConnectionLOAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyPhysicalConnectionLOAResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceRegionId: String?

    public var instanceType: String?

    public var mode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceRegionId != nil {
            map["InstanceRegionId"] = self.instanceRegionId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceRegionId") {
            self.instanceRegionId = dict["InstanceRegionId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Mode") {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class AssociateEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateEipAddressBatchRequest : Tea.TeaModel {
    public var bindedInstanceId: String?

    public var bindedInstanceType: String?

    public var clientToken: String?

    public var instanceIds: [String]?

    public var mode: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindedInstanceId != nil {
            map["BindedInstanceId"] = self.bindedInstanceId!
        }
        if self.bindedInstanceType != nil {
            map["BindedInstanceType"] = self.bindedInstanceType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindedInstanceId") {
            self.bindedInstanceId = dict["BindedInstanceId"] as! String
        }
        if dict.keys.contains("BindedInstanceType") {
            self.bindedInstanceType = dict["BindedInstanceType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("Mode") {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AssociateEipAddressBatchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateEipAddressBatchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateEipAddressBatchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateEipAddressBatchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var haVipId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AssociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateNetworkAclRequest : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resource: [AssociateNetworkAclRequest.Resource]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            var tmp : [Any] = []
            for k in self.resource! {
                tmp.append(k.toMap())
            }
            map["Resource"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Resource") {
            var tmp : [AssociateNetworkAclRequest.Resource] = []
            for v in dict["Resource"] as! [Any] {
                var model = AssociateNetworkAclRequest.Resource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resource = tmp
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AssociateNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociatePhysicalConnectionToVirtualBorderRouterRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var enableIpv6: String?

    public var localGatewayIp: String?

    public var localIpv6GatewayIp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peerIpv6GatewayIp: String?

    public var peeringIpv6SubnetMask: String?

    public var peeringSubnetMask: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public var vlanId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.localIpv6GatewayIp != nil {
            map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peerIpv6GatewayIp != nil {
            map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
        }
        if self.peeringIpv6SubnetMask != nil {
            map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CircuitCode") {
            self.circuitCode = dict["CircuitCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableIpv6") {
            self.enableIpv6 = dict["EnableIpv6"] as! String
        }
        if dict.keys.contains("LocalGatewayIp") {
            self.localGatewayIp = dict["LocalGatewayIp"] as! String
        }
        if dict.keys.contains("LocalIpv6GatewayIp") {
            self.localIpv6GatewayIp = dict["LocalIpv6GatewayIp"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerGatewayIp") {
            self.peerGatewayIp = dict["PeerGatewayIp"] as! String
        }
        if dict.keys.contains("PeerIpv6GatewayIp") {
            self.peerIpv6GatewayIp = dict["PeerIpv6GatewayIp"] as! String
        }
        if dict.keys.contains("PeeringIpv6SubnetMask") {
            self.peeringIpv6SubnetMask = dict["PeeringIpv6SubnetMask"] as! String
        }
        if dict.keys.contains("PeeringSubnetMask") {
            self.peeringSubnetMask = dict["PeeringSubnetMask"] as! String
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! String
        }
    }
}

public class AssociatePhysicalConnectionToVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociatePhysicalConnectionToVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociatePhysicalConnectionToVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociatePhysicalConnectionToVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateRouteTableRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class AssociateRouteTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateRouteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateRouteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateRouteTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateRouteTableWithGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var gatewayId: String?

    public var gatewayType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayType != nil {
            map["GatewayType"] = self.gatewayType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! String
        }
        if dict.keys.contains("GatewayType") {
            self.gatewayType = dict["GatewayType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class AssociateRouteTableWithGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateRouteTableWithGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateRouteTableWithGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateRouteTableWithGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateRouteTablesWithVpcGatewayEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableIds != nil {
            map["RouteTableIds"] = self.routeTableIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointId") {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableIds") {
            self.routeTableIds = dict["RouteTableIds"] as! [String]
        }
    }
}

public class AssociateRouteTablesWithVpcGatewayEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateRouteTablesWithVpcGatewayEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateRouteTablesWithVpcGatewayEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateRouteTablesWithVpcGatewayEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateVpcCidrBlockRequest : Tea.TeaModel {
    public var IPv6CidrBlock: String?

    public var ipVersion: String?

    public var ipamPoolId: String?

    public var ipv6Isp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var secondaryCidrBlock: String?

    public var secondaryCidrMask: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.IPv6CidrBlock != nil {
            map["IPv6CidrBlock"] = self.IPv6CidrBlock!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ipamPoolId != nil {
            map["IpamPoolId"] = self.ipamPoolId!
        }
        if self.ipv6Isp != nil {
            map["Ipv6Isp"] = self.ipv6Isp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.secondaryCidrBlock != nil {
            map["SecondaryCidrBlock"] = self.secondaryCidrBlock!
        }
        if self.secondaryCidrMask != nil {
            map["SecondaryCidrMask"] = self.secondaryCidrMask!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IPv6CidrBlock") {
            self.IPv6CidrBlock = dict["IPv6CidrBlock"] as! String
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("IpamPoolId") {
            self.ipamPoolId = dict["IpamPoolId"] as! String
        }
        if dict.keys.contains("Ipv6Isp") {
            self.ipv6Isp = dict["Ipv6Isp"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecondaryCidrBlock") {
            self.secondaryCidrBlock = dict["SecondaryCidrBlock"] as! String
        }
        if dict.keys.contains("SecondaryCidrMask") {
            self.secondaryCidrMask = dict["SecondaryCidrMask"] as! Int32
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class AssociateVpcCidrBlockResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateVpcCidrBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateVpcCidrBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateVpcCidrBlockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateVpnGatewayWithCertificateRequest : Tea.TeaModel {
    public var certificateId: String?

    public var certificateType: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.certificateType != nil {
            map["CertificateType"] = self.certificateType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateId") {
            self.certificateId = dict["CertificateId"] as! String
        }
        if dict.keys.contains("CertificateType") {
            self.certificateType = dict["CertificateType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class AssociateVpnGatewayWithCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateVpnGatewayWithCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateVpnGatewayWithCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateVpnGatewayWithCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachDhcpOptionsSetToVpcRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class AttachDhcpOptionsSetToVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachDhcpOptionsSetToVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDhcpOptionsSetToVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachDhcpOptionsSetToVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachVbrToVpconnRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var regionId: String?

    public var token: String?

    public var vbrId: String?

    public var vpconnId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        if self.vpconnId != nil {
            map["VpconnId"] = self.vpconnId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
        if dict.keys.contains("VpconnId") {
            self.vpconnId = dict["VpconnId"] as! String
        }
    }
}

public class AttachVbrToVpconnResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var virtualPhysicalConnection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.virtualPhysicalConnection != nil {
            map["VirtualPhysicalConnection"] = self.virtualPhysicalConnection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VirtualPhysicalConnection") {
            self.virtualPhysicalConnection = dict["VirtualPhysicalConnection"] as! String
        }
    }
}

public class AttachVbrToVpconnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachVbrToVpconnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachVbrToVpconnResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelCommonBandwidthPackageIpBandwidthRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var eipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.eipId != nil {
            map["EipId"] = self.eipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("EipId") {
            self.eipId = dict["EipId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelCommonBandwidthPackageIpBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelCommonBandwidthPackageIpBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelCommonBandwidthPackageIpBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelCommonBandwidthPackageIpBandwidthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelPhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelPhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckCanAllocateVpcPrivateIpAddressRequest : Tea.TeaModel {
    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CheckCanAllocateVpcPrivateIpAddressResponseBody : Tea.TeaModel {
    public var canAllocate: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.canAllocate != nil {
            map["CanAllocate"] = self.canAllocate!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CanAllocate") {
            self.canAllocate = dict["CanAllocate"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckCanAllocateVpcPrivateIpAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckCanAllocateVpcPrivateIpAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckCanAllocateVpcPrivateIpAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckVpnBgpEnabledRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CheckVpnBgpEnabledResponseBody : Tea.TeaModel {
    public var bgpEnabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpEnabled != nil {
            map["BgpEnabled"] = self.bgpEnabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpEnabled") {
            self.bgpEnabled = dict["BgpEnabled"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckVpnBgpEnabledResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckVpnBgpEnabledResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckVpnBgpEnabledResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CompletePhysicalConnectionLOARequest : Tea.TeaModel {
    public var clientToken: String?

    public var finishWork: Bool?

    public var instanceId: String?

    public var lineCode: String?

    public var lineLabel: String?

    public var lineSPContactInfo: String?

    public var lineServiceProvider: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.finishWork != nil {
            map["FinishWork"] = self.finishWork!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lineCode != nil {
            map["LineCode"] = self.lineCode!
        }
        if self.lineLabel != nil {
            map["LineLabel"] = self.lineLabel!
        }
        if self.lineSPContactInfo != nil {
            map["LineSPContactInfo"] = self.lineSPContactInfo!
        }
        if self.lineServiceProvider != nil {
            map["LineServiceProvider"] = self.lineServiceProvider!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("FinishWork") {
            self.finishWork = dict["FinishWork"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LineCode") {
            self.lineCode = dict["LineCode"] as! String
        }
        if dict.keys.contains("LineLabel") {
            self.lineLabel = dict["LineLabel"] as! String
        }
        if dict.keys.contains("LineSPContactInfo") {
            self.lineSPContactInfo = dict["LineSPContactInfo"] as! String
        }
        if dict.keys.contains("LineServiceProvider") {
            self.lineServiceProvider = dict["LineServiceProvider"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CompletePhysicalConnectionLOAResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CompletePhysicalConnectionLOAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CompletePhysicalConnectionLOAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CompletePhysicalConnectionLOAResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmPhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ConfirmPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfirmPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfirmPhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConnectRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class ConnectRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConnectRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConnectRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConnectRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConvertBandwidthPackageRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ConvertBandwidthPackageResponseBody : Tea.TeaModel {
    public var convertInstanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.convertInstanceId != nil {
            map["ConvertInstanceId"] = self.convertInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConvertInstanceId") {
            self.convertInstanceId = dict["ConvertInstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConvertBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConvertBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConvertBandwidthPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyNetworkAclEntriesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sourceNetworkAclId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceNetworkAclId != nil {
            map["SourceNetworkAclId"] = self.sourceNetworkAclId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceNetworkAclId") {
            self.sourceNetworkAclId = dict["SourceNetworkAclId"] as! String
        }
    }
}

public class CopyNetworkAclEntriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CopyNetworkAclEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyNetworkAclEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyNetworkAclEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBgpGroupRequest : Tea.TeaModel {
    public var authKey: String?

    public var clientToken: String?

    public var description_: String?

    public var ipVersion: String?

    public var isFakeAsn: Bool?

    public var localAsn: Int64?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerAsn: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeQuota: Int32?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.isFakeAsn != nil {
            map["IsFakeAsn"] = self.isFakeAsn!
        }
        if self.localAsn != nil {
            map["LocalAsn"] = self.localAsn!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerAsn != nil {
            map["PeerAsn"] = self.peerAsn!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeQuota != nil {
            map["RouteQuota"] = self.routeQuota!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("IsFakeAsn") {
            self.isFakeAsn = dict["IsFakeAsn"] as! Bool
        }
        if dict.keys.contains("LocalAsn") {
            self.localAsn = dict["LocalAsn"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerAsn") {
            self.peerAsn = dict["PeerAsn"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteQuota") {
            self.routeQuota = dict["RouteQuota"] as! Int32
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
    }
}

public class CreateBgpGroupResponseBody : Tea.TeaModel {
    public var bgpGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpGroupId") {
            self.bgpGroupId = dict["BgpGroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBgpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBgpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBgpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBgpPeerRequest : Tea.TeaModel {
    public var bfdMultiHop: Int32?

    public var bgpGroupId: String?

    public var clientToken: String?

    public var enableBfd: Bool?

    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bfdMultiHop != nil {
            map["BfdMultiHop"] = self.bfdMultiHop!
        }
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableBfd != nil {
            map["EnableBfd"] = self.enableBfd!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerIpAddress != nil {
            map["PeerIpAddress"] = self.peerIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BfdMultiHop") {
            self.bfdMultiHop = dict["BfdMultiHop"] as! Int32
        }
        if dict.keys.contains("BgpGroupId") {
            self.bgpGroupId = dict["BgpGroupId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableBfd") {
            self.enableBfd = dict["EnableBfd"] as! Bool
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerIpAddress") {
            self.peerIpAddress = dict["PeerIpAddress"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateBgpPeerResponseBody : Tea.TeaModel {
    public var bgpPeerId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpPeerId != nil {
            map["BgpPeerId"] = self.bgpPeerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpPeerId") {
            self.bgpPeerId = dict["BgpPeerId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBgpPeerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBgpPeerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBgpPeerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCommonBandwidthPackageRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var clientToken: String?

    public var description_: String?

    public var ISP: String?

    public var internetChargeType: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var ratio: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionTypes: [String]?

    public var zone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ratio != nil {
            map["Ratio"] = self.ratio!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionTypes != nil {
            map["SecurityProtectionTypes"] = self.securityProtectionTypes!
        }
        if self.zone != nil {
            map["Zone"] = self.zone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ISP") {
            self.ISP = dict["ISP"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Ratio") {
            self.ratio = dict["Ratio"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityProtectionTypes") {
            self.securityProtectionTypes = dict["SecurityProtectionTypes"] as! [String]
        }
        if dict.keys.contains("Zone") {
            self.zone = dict["Zone"] as! String
        }
    }
}

public class CreateCommonBandwidthPackageResponseBody : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateCommonBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommonBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCommonBandwidthPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomerGatewayRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var asn: String?

    public var authKey: String?

    public var clientToken: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [CreateCustomerGatewayRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asn != nil {
            map["Asn"] = self.asn!
        }
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asn") {
            self.asn = dict["Asn"] as! String
        }
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateCustomerGatewayRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateCustomerGatewayRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateCustomerGatewayResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomerGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomerGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomerGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDefaultVSwitchRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6CidrBlock: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateDefaultVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateDefaultVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDefaultVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDefaultVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDefaultVpcRequest : Tea.TeaModel {
    public var clientToken: String?

    public var enableIpv6: Bool?

    public var ipv6CidrBlock: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableIpv6") {
            self.enableIpv6 = dict["EnableIpv6"] as! Bool
        }
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateDefaultVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeTableId: String?

    public var VRouterId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateDefaultVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDefaultVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDefaultVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDhcpOptionsSetRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dhcpOptionsSetDescription: String?

    public var dhcpOptionsSetName: String?

    public var domainName: String?

    public var domainNameServers: String?

    public var dryRun: Bool?

    public var ipv6LeaseTime: String?

    public var leaseTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateDhcpOptionsSetRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetDescription != nil {
            map["DhcpOptionsSetDescription"] = self.dhcpOptionsSetDescription!
        }
        if self.dhcpOptionsSetName != nil {
            map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainNameServers != nil {
            map["DomainNameServers"] = self.domainNameServers!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6LeaseTime != nil {
            map["Ipv6LeaseTime"] = self.ipv6LeaseTime!
        }
        if self.leaseTime != nil {
            map["LeaseTime"] = self.leaseTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetDescription") {
            self.dhcpOptionsSetDescription = dict["DhcpOptionsSetDescription"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetName") {
            self.dhcpOptionsSetName = dict["DhcpOptionsSetName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainNameServers") {
            self.domainNameServers = dict["DomainNameServers"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv6LeaseTime") {
            self.ipv6LeaseTime = dict["Ipv6LeaseTime"] as! String
        }
        if dict.keys.contains("LeaseTime") {
            self.leaseTime = dict["LeaseTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateDhcpOptionsSetRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateDhcpOptionsSetRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateDhcpOptionsSetResponseBody : Tea.TeaModel {
    public var dhcpOptionsSetId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateDhcpOptionsSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDhcpOptionsSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDhcpOptionsSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateExpressCloudConnectionRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var contactMail: String?

    public var contactTel: String?

    public var description_: String?

    public var IDCardNo: String?

    public var idcSP: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerCity: String?

    public var peerLocation: String?

    public var portType: String?

    public var redundantEccId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.contactMail != nil {
            map["ContactMail"] = self.contactMail!
        }
        if self.contactTel != nil {
            map["ContactTel"] = self.contactTel!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.IDCardNo != nil {
            map["IDCardNo"] = self.IDCardNo!
        }
        if self.idcSP != nil {
            map["IdcSP"] = self.idcSP!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerCity != nil {
            map["PeerCity"] = self.peerCity!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantEccId != nil {
            map["RedundantEccId"] = self.redundantEccId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ContactMail") {
            self.contactMail = dict["ContactMail"] as! String
        }
        if dict.keys.contains("ContactTel") {
            self.contactTel = dict["ContactTel"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IDCardNo") {
            self.IDCardNo = dict["IDCardNo"] as! String
        }
        if dict.keys.contains("IdcSP") {
            self.idcSP = dict["IdcSP"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerCity") {
            self.peerCity = dict["PeerCity"] as! String
        }
        if dict.keys.contains("PeerLocation") {
            self.peerLocation = dict["PeerLocation"] as! String
        }
        if dict.keys.contains("PortType") {
            self.portType = dict["PortType"] as! String
        }
        if dict.keys.contains("RedundantEccId") {
            self.redundantEccId = dict["RedundantEccId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateExpressCloudConnectionResponseBody : Tea.TeaModel {
    public var eccId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eccId != nil {
            map["EccId"] = self.eccId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EccId") {
            self.eccId = dict["EccId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateExpressCloudConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExpressCloudConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateExpressCloudConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateExpressConnectTrafficQosRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosDescription: String?

    public var qosName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var tags: [CreateExpressConnectTrafficQosRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosDescription != nil {
            map["QosDescription"] = self.qosDescription!
        }
        if self.qosName != nil {
            map["QosName"] = self.qosName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosDescription") {
            self.qosDescription = dict["QosDescription"] as! String
        }
        if dict.keys.contains("QosName") {
            self.qosName = dict["QosName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateExpressConnectTrafficQosRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateExpressConnectTrafficQosRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateExpressConnectTrafficQosResponseBody : Tea.TeaModel {
    public var qosId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateExpressConnectTrafficQosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExpressConnectTrafficQosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateExpressConnectTrafficQosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateExpressConnectTrafficQosQueueRequest : Tea.TeaModel {
    public var bandwidthPercent: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueDescription: String?

    public var queueName: String?

    public var queueType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPercent != nil {
            map["BandwidthPercent"] = self.bandwidthPercent!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueDescription != nil {
            map["QueueDescription"] = self.queueDescription!
        }
        if self.queueName != nil {
            map["QueueName"] = self.queueName!
        }
        if self.queueType != nil {
            map["QueueType"] = self.queueType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPercent") {
            self.bandwidthPercent = dict["BandwidthPercent"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueDescription") {
            self.queueDescription = dict["QueueDescription"] as! String
        }
        if dict.keys.contains("QueueName") {
            self.queueName = dict["QueueName"] as! String
        }
        if dict.keys.contains("QueueType") {
            self.queueType = dict["QueueType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class CreateExpressConnectTrafficQosQueueResponseBody : Tea.TeaModel {
    public var qosId: String?

    public var queueId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateExpressConnectTrafficQosQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExpressConnectTrafficQosQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateExpressConnectTrafficQosQueueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateExpressConnectTrafficQosRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dstCidr: String?

    public var dstIPv6Cidr: String?

    public var dstPortRange: String?

    public var matchDscp: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var protocol_: String?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var remarkingDscp: Int32?

    public var resourceOwnerAccount: String?

    public var ruleDescription: String?

    public var ruleName: String?

    public var srcCidr: String?

    public var srcIPv6Cidr: String?

    public var srcPortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dstCidr != nil {
            map["DstCidr"] = self.dstCidr!
        }
        if self.dstIPv6Cidr != nil {
            map["DstIPv6Cidr"] = self.dstIPv6Cidr!
        }
        if self.dstPortRange != nil {
            map["DstPortRange"] = self.dstPortRange!
        }
        if self.matchDscp != nil {
            map["MatchDscp"] = self.matchDscp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remarkingDscp != nil {
            map["RemarkingDscp"] = self.remarkingDscp!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.ruleDescription != nil {
            map["RuleDescription"] = self.ruleDescription!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.srcCidr != nil {
            map["SrcCidr"] = self.srcCidr!
        }
        if self.srcIPv6Cidr != nil {
            map["SrcIPv6Cidr"] = self.srcIPv6Cidr!
        }
        if self.srcPortRange != nil {
            map["SrcPortRange"] = self.srcPortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DstCidr") {
            self.dstCidr = dict["DstCidr"] as! String
        }
        if dict.keys.contains("DstIPv6Cidr") {
            self.dstIPv6Cidr = dict["DstIPv6Cidr"] as! String
        }
        if dict.keys.contains("DstPortRange") {
            self.dstPortRange = dict["DstPortRange"] as! String
        }
        if dict.keys.contains("MatchDscp") {
            self.matchDscp = dict["MatchDscp"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemarkingDscp") {
            self.remarkingDscp = dict["RemarkingDscp"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("RuleDescription") {
            self.ruleDescription = dict["RuleDescription"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SrcCidr") {
            self.srcCidr = dict["SrcCidr"] as! String
        }
        if dict.keys.contains("SrcIPv6Cidr") {
            self.srcIPv6Cidr = dict["SrcIPv6Cidr"] as! String
        }
        if dict.keys.contains("SrcPortRange") {
            self.srcPortRange = dict["SrcPortRange"] as! String
        }
    }
}

public class CreateExpressConnectTrafficQosRuleResponseBody : Tea.TeaModel {
    public var qosId: String?

    public var queueId: String?

    public var requestId: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class CreateExpressConnectTrafficQosRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExpressConnectTrafficQosRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateExpressConnectTrafficQosRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var jobDuration: Int32?

    public var jobType: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.jobDuration != nil {
            map["JobDuration"] = self.jobDuration!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("JobDuration") {
            self.jobDuration = dict["JobDuration"] as! Int32
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class CreateFailoverTestJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFailoverTestJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowLogRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aggregationInterval: Int32?

    public var description_: String?

    public var flowLogName: String?

    public var ipVersion: String?

    public var logStoreName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var projectName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [CreateFlowLogRequest.Tag]?

    public var trafficPath: [String]?

    public var trafficType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregationInterval != nil {
            map["AggregationInterval"] = self.aggregationInterval!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.flowLogName != nil {
            map["FlowLogName"] = self.flowLogName!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.logStoreName != nil {
            map["LogStoreName"] = self.logStoreName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.trafficPath != nil {
            map["TrafficPath"] = self.trafficPath!
        }
        if self.trafficType != nil {
            map["TrafficType"] = self.trafficType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AggregationInterval") {
            self.aggregationInterval = dict["AggregationInterval"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FlowLogName") {
            self.flowLogName = dict["FlowLogName"] as! String
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("LogStoreName") {
            self.logStoreName = dict["LogStoreName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateFlowLogRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateFlowLogRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TrafficPath") {
            self.trafficPath = dict["TrafficPath"] as! [String]
        }
        if dict.keys.contains("TrafficType") {
            self.trafficType = dict["TrafficType"] as! String
        }
    }
}

public class CreateFlowLogResponseBody : Tea.TeaModel {
    public var flowLogId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowLogId") {
            self.flowLogId = dict["FlowLogId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateFlowLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFlowLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateForwardEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryName: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portBreak: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portBreak != nil {
            map["PortBreak"] = self.portBreak!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ExternalIp") {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ExternalPort") {
            self.externalPort = dict["ExternalPort"] as! String
        }
        if dict.keys.contains("ForwardEntryName") {
            self.forwardEntryName = dict["ForwardEntryName"] as! String
        }
        if dict.keys.contains("ForwardTableId") {
            self.forwardTableId = dict["ForwardTableId"] as! String
        }
        if dict.keys.contains("InternalIp") {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("InternalPort") {
            self.internalPort = dict["InternalPort"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PortBreak") {
            self.portBreak = dict["PortBreak"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateForwardEntryResponseBody : Tea.TeaModel {
    public var forwardEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFullNatEntryRequest : Tea.TeaModel {
    public var accessIp: String?

    public var accessPort: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var fullNatEntryDescription: String?

    public var fullNatEntryName: String?

    public var fullNatTableId: String?

    public var ipProtocol: String?

    public var natIp: String?

    public var natIpPort: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessIp != nil {
            map["AccessIp"] = self.accessIp!
        }
        if self.accessPort != nil {
            map["AccessPort"] = self.accessPort!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.fullNatEntryDescription != nil {
            map["FullNatEntryDescription"] = self.fullNatEntryDescription!
        }
        if self.fullNatEntryName != nil {
            map["FullNatEntryName"] = self.fullNatEntryName!
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpPort != nil {
            map["NatIpPort"] = self.natIpPort!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessIp") {
            self.accessIp = dict["AccessIp"] as! String
        }
        if dict.keys.contains("AccessPort") {
            self.accessPort = dict["AccessPort"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("FullNatEntryDescription") {
            self.fullNatEntryDescription = dict["FullNatEntryDescription"] as! String
        }
        if dict.keys.contains("FullNatEntryName") {
            self.fullNatEntryName = dict["FullNatEntryName"] as! String
        }
        if dict.keys.contains("FullNatTableId") {
            self.fullNatTableId = dict["FullNatTableId"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("NatIp") {
            self.natIp = dict["NatIp"] as! String
        }
        if dict.keys.contains("NatIpPort") {
            self.natIpPort = dict["NatIpPort"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateFullNatEntryResponseBody : Tea.TeaModel {
    public var fullNatEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fullNatEntryId != nil {
            map["FullNatEntryId"] = self.fullNatEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FullNatEntryId") {
            self.fullNatEntryId = dict["FullNatEntryId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFullNatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFullNatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFullNatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGlobalAccelerationInstanceRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var bandwidthType: String?

    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceLocation: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthType != nil {
            map["BandwidthType"] = self.bandwidthType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceLocation != nil {
            map["ServiceLocation"] = self.serviceLocation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("BandwidthType") {
            self.bandwidthType = dict["BandwidthType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceLocation") {
            self.serviceLocation = dict["ServiceLocation"] as! String
        }
    }
}

public class CreateGlobalAccelerationInstanceResponseBody : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var ipAddress: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalAccelerationInstanceId") {
            self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateGlobalAccelerationInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGlobalAccelerationInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateGlobalAccelerationInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHaVipRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateHaVipRequest.Tag]?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateHaVipRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateHaVipRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateHaVipResponseBody : Tea.TeaModel {
    public var haVipId: String?

    public var ipAddress: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHighReliablePhysicalConnectionRequest : Tea.TeaModel {
    public class ApList : Tea.TeaModel {
        public var accessPointId: String?

        public var bandwidth: Int64?

        public var circuitCode: String?

        public var description_: String?

        public var lineOperator: String?

        public var name: String?

        public var peerLocation: String?

        public var portNum: Int32?

        public var regionId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointId != nil {
                map["AccessPointId"] = self.accessPointId!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.circuitCode != nil {
                map["CircuitCode"] = self.circuitCode!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.lineOperator != nil {
                map["LineOperator"] = self.lineOperator!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.peerLocation != nil {
                map["PeerLocation"] = self.peerLocation!
            }
            if self.portNum != nil {
                map["PortNum"] = self.portNum!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessPointId") {
                self.accessPointId = dict["AccessPointId"] as! String
            }
            if dict.keys.contains("Bandwidth") {
                self.bandwidth = dict["Bandwidth"] as! Int64
            }
            if dict.keys.contains("CircuitCode") {
                self.circuitCode = dict["CircuitCode"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("LineOperator") {
                self.lineOperator = dict["LineOperator"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PeerLocation") {
                self.peerLocation = dict["PeerLocation"] as! String
            }
            if dict.keys.contains("PortNum") {
                self.portNum = dict["PortNum"] as! Int32
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var apList: [CreateHighReliablePhysicalConnectionRequest.ApList]?

    public var clientToken: String?

    public var deviceAdvancedCapacity: [String]?

    public var dryRun: String?

    public var highReliableType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateHighReliablePhysicalConnectionRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.apList != nil {
            var tmp : [Any] = []
            for k in self.apList! {
                tmp.append(k.toMap())
            }
            map["ApList"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.deviceAdvancedCapacity != nil {
            map["DeviceAdvancedCapacity"] = self.deviceAdvancedCapacity!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.highReliableType != nil {
            map["HighReliableType"] = self.highReliableType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ApList") {
            var tmp : [CreateHighReliablePhysicalConnectionRequest.ApList] = []
            for v in dict["ApList"] as! [Any] {
                var model = CreateHighReliablePhysicalConnectionRequest.ApList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.apList = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DeviceAdvancedCapacity") {
            self.deviceAdvancedCapacity = dict["DeviceAdvancedCapacity"] as! [String]
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! String
        }
        if dict.keys.contains("HighReliableType") {
            self.highReliableType = dict["HighReliableType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PortType") {
            self.portType = dict["PortType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateHighReliablePhysicalConnectionRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateHighReliablePhysicalConnectionRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateHighReliablePhysicalConnectionResponseBody : Tea.TeaModel {
    public class ErrorInfoList : Tea.TeaModel {
        public class ErrorInfoList : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var errorInfoList: [CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList.ErrorInfoList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorInfoList != nil {
                var tmp : [Any] = []
                for k in self.errorInfoList! {
                    tmp.append(k.toMap())
                }
                map["errorInfoList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("errorInfoList") {
                var tmp : [CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList.ErrorInfoList] = []
                for v in dict["errorInfoList"] as! [Any] {
                    var model = CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList.ErrorInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorInfoList = tmp
            }
        }
    }
    public class PhysicalConnectionList : Tea.TeaModel {
        public class PhysicalConnectionList : Tea.TeaModel {
            public var instanceId: String?

            public var regionNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.regionNo != nil {
                    map["RegionNo"] = self.regionNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("RegionNo") {
                    self.regionNo = dict["RegionNo"] as! String
                }
            }
        }
        public var physicalConnectionList: [CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList.PhysicalConnectionList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.physicalConnectionList != nil {
                var tmp : [Any] = []
                for k in self.physicalConnectionList! {
                    tmp.append(k.toMap())
                }
                map["physicalConnectionList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("physicalConnectionList") {
                var tmp : [CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList.PhysicalConnectionList] = []
                for v in dict["physicalConnectionList"] as! [Any] {
                    var model = CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList.PhysicalConnectionList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.physicalConnectionList = tmp
            }
        }
    }
    public var errorInfoList: CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList?

    public var physicalConnectionList: CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorInfoList?.validate()
        try self.physicalConnectionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorInfoList != nil {
            map["ErrorInfoList"] = self.errorInfoList?.toMap()
        }
        if self.physicalConnectionList != nil {
            map["PhysicalConnectionList"] = self.physicalConnectionList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorInfoList") {
            var model = CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList()
            model.fromMap(dict["ErrorInfoList"] as! [String: Any])
            self.errorInfoList = model
        }
        if dict.keys.contains("PhysicalConnectionList") {
            var model = CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList()
            model.fromMap(dict["PhysicalConnectionList"] as! [String: Any])
            self.physicalConnectionList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateHighReliablePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHighReliablePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateHighReliablePhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIPv6TranslatorRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var bandwidth: Int32?

    public var clientToken: String?

    public var duration: Int32?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var pricingCycle: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class CreateIPv6TranslatorResponseBody : Tea.TeaModel {
    public var ipv6TranslatorId: String?

    public var name: String?

    public var orderId: Int64?

    public var requestId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6TranslatorId") {
            self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class CreateIPv6TranslatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIPv6TranslatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIPv6TranslatorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIPv6TranslatorAclListRequest : Tea.TeaModel {
    public var aclName: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclName") {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateIPv6TranslatorAclListResponseBody : Tea.TeaModel {
    public var aclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIPv6TranslatorAclListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIPv6TranslatorAclListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIPv6TranslatorAclListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIPv6TranslatorEntryRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclStatus: String?

    public var aclType: String?

    public var allocateIpv6Port: Int32?

    public var backendIpv4Addr: String?

    public var backendIpv4Port: Int32?

    public var entryBandwidth: Int32?

    public var entryDescription: String?

    public var entryName: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var transProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclStatus != nil {
            map["AclStatus"] = self.aclStatus!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.allocateIpv6Port != nil {
            map["AllocateIpv6Port"] = self.allocateIpv6Port!
        }
        if self.backendIpv4Addr != nil {
            map["BackendIpv4Addr"] = self.backendIpv4Addr!
        }
        if self.backendIpv4Port != nil {
            map["BackendIpv4Port"] = self.backendIpv4Port!
        }
        if self.entryBandwidth != nil {
            map["EntryBandwidth"] = self.entryBandwidth!
        }
        if self.entryDescription != nil {
            map["EntryDescription"] = self.entryDescription!
        }
        if self.entryName != nil {
            map["EntryName"] = self.entryName!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.transProtocol != nil {
            map["TransProtocol"] = self.transProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclStatus") {
            self.aclStatus = dict["AclStatus"] as! String
        }
        if dict.keys.contains("AclType") {
            self.aclType = dict["AclType"] as! String
        }
        if dict.keys.contains("AllocateIpv6Port") {
            self.allocateIpv6Port = dict["AllocateIpv6Port"] as! Int32
        }
        if dict.keys.contains("BackendIpv4Addr") {
            self.backendIpv4Addr = dict["BackendIpv4Addr"] as! String
        }
        if dict.keys.contains("BackendIpv4Port") {
            self.backendIpv4Port = dict["BackendIpv4Port"] as! Int32
        }
        if dict.keys.contains("EntryBandwidth") {
            self.entryBandwidth = dict["EntryBandwidth"] as! Int32
        }
        if dict.keys.contains("EntryDescription") {
            self.entryDescription = dict["EntryDescription"] as! String
        }
        if dict.keys.contains("EntryName") {
            self.entryName = dict["EntryName"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorId") {
            self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TransProtocol") {
            self.transProtocol = dict["TransProtocol"] as! String
        }
    }
}

public class CreateIPv6TranslatorEntryResponseBody : Tea.TeaModel {
    public var ipv6TranslatorEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6TranslatorEntryId != nil {
            map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6TranslatorEntryId") {
            self.ipv6TranslatorEntryId = dict["Ipv6TranslatorEntryId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIPv6TranslatorEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIPv6TranslatorEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIPv6TranslatorEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIpsecServerRequest : Tea.TeaModel {
    public var clientIpPool: String?

    public var clientToken: String?

    public var dryRun: String?

    public var effectImmediately: Bool?

    public var ikeConfig: String?

    public var ipSecServerName: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var psk: String?

    public var pskEnabled: Bool?

    public var regionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipSecServerName != nil {
            map["IpSecServerName"] = self.ipSecServerName!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.psk != nil {
            map["Psk"] = self.psk!
        }
        if self.pskEnabled != nil {
            map["PskEnabled"] = self.pskEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientIpPool") {
            self.clientIpPool = dict["ClientIpPool"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! String
        }
        if dict.keys.contains("EffectImmediately") {
            self.effectImmediately = dict["EffectImmediately"] as! Bool
        }
        if dict.keys.contains("IkeConfig") {
            self.ikeConfig = dict["IkeConfig"] as! String
        }
        if dict.keys.contains("IpSecServerName") {
            self.ipSecServerName = dict["IpSecServerName"] as! String
        }
        if dict.keys.contains("IpsecConfig") {
            self.ipsecConfig = dict["IpsecConfig"] as! String
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Psk") {
            self.psk = dict["Psk"] as! String
        }
        if dict.keys.contains("PskEnabled") {
            self.pskEnabled = dict["PskEnabled"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class CreateIpsecServerResponseBody : Tea.TeaModel {
    public var creationTime: String?

    public var ipsecServerId: String?

    public var ipsecServerName: String?

    public var regionId: String?

    public var requestId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.ipsecServerName != nil {
            map["IpsecServerName"] = self.ipsecServerName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("IpsecServerId") {
            self.ipsecServerId = dict["IpsecServerId"] as! String
        }
        if dict.keys.contains("IpsecServerName") {
            self.ipsecServerName = dict["IpsecServerName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class CreateIpsecServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpsecServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIpsecServerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIpv4GatewayRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv4GatewayDescription: String?

    public var ipv4GatewayName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateIpv4GatewayRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv4GatewayDescription != nil {
            map["Ipv4GatewayDescription"] = self.ipv4GatewayDescription!
        }
        if self.ipv4GatewayName != nil {
            map["Ipv4GatewayName"] = self.ipv4GatewayName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv4GatewayDescription") {
            self.ipv4GatewayDescription = dict["Ipv4GatewayDescription"] as! String
        }
        if dict.keys.contains("Ipv4GatewayName") {
            self.ipv4GatewayName = dict["Ipv4GatewayName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateIpv4GatewayRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateIpv4GatewayRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateIpv4GatewayResponseBody : Tea.TeaModel {
    public var ipv4GatewayId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv4GatewayId") {
            self.ipv4GatewayId = dict["Ipv4GatewayId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateIpv4GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpv4GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIpv4GatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIpv6EgressOnlyRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ipv6GatewayId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Ipv6GatewayId") {
            self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateIpv6EgressOnlyRuleResponseBody : Tea.TeaModel {
    public var ipv6EgressRuleId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6EgressRuleId != nil {
            map["Ipv6EgressRuleId"] = self.ipv6EgressRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6EgressRuleId") {
            self.ipv6EgressRuleId = dict["Ipv6EgressRuleId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIpv6EgressOnlyRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpv6EgressOnlyRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIpv6EgressOnlyRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIpv6GatewayRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateIpv6GatewayRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateIpv6GatewayRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateIpv6GatewayRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateIpv6GatewayResponseBody : Tea.TeaModel {
    public var ipv6GatewayId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6GatewayId") {
            self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateIpv6GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpv6GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIpv6GatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNatGatewayRequest : Tea.TeaModel {
    public class AccessMode : Tea.TeaModel {
        public var modeValue: String?

        public var tunnelType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modeValue != nil {
                map["ModeValue"] = self.modeValue!
            }
            if self.tunnelType != nil {
                map["TunnelType"] = self.tunnelType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModeValue") {
                self.modeValue = dict["ModeValue"] as! String
            }
            if dict.keys.contains("TunnelType") {
                self.tunnelType = dict["TunnelType"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var accessMode: CreateNatGatewayRequest.AccessMode?

    public var autoPay: Bool?

    public var clientToken: String?

    public var description_: String?

    public var duration: String?

    public var eipBindMode: String?

    public var icmpReplyEnabled: Bool?

    public var instanceChargeType: String?

    public var internetChargeType: String?

    public var name: String?

    public var natType: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pricingCycle: String?

    public var privateLinkEnabled: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var spec: String?

    public var tag: [CreateNatGatewayRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessMode?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode?.toMap()
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.eipBindMode != nil {
            map["EipBindMode"] = self.eipBindMode!
        }
        if self.icmpReplyEnabled != nil {
            map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.privateLinkEnabled != nil {
            map["PrivateLinkEnabled"] = self.privateLinkEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            var model = CreateNatGatewayRequest.AccessMode()
            model.fromMap(dict["AccessMode"] as! [String: Any])
            self.accessMode = model
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("EipBindMode") {
            self.eipBindMode = dict["EipBindMode"] as! String
        }
        if dict.keys.contains("IcmpReplyEnabled") {
            self.icmpReplyEnabled = dict["IcmpReplyEnabled"] as! Bool
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NatType") {
            self.natType = dict["NatType"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("PrivateLinkEnabled") {
            self.privateLinkEnabled = dict["PrivateLinkEnabled"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityProtectionEnabled") {
            self.securityProtectionEnabled = dict["SecurityProtectionEnabled"] as! Bool
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateNatGatewayRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateNatGatewayRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateNatGatewayShrinkRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var accessModeShrink: String?

    public var autoPay: Bool?

    public var clientToken: String?

    public var description_: String?

    public var duration: String?

    public var eipBindMode: String?

    public var icmpReplyEnabled: Bool?

    public var instanceChargeType: String?

    public var internetChargeType: String?

    public var name: String?

    public var natType: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pricingCycle: String?

    public var privateLinkEnabled: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var spec: String?

    public var tag: [CreateNatGatewayShrinkRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessModeShrink != nil {
            map["AccessMode"] = self.accessModeShrink!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.eipBindMode != nil {
            map["EipBindMode"] = self.eipBindMode!
        }
        if self.icmpReplyEnabled != nil {
            map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.privateLinkEnabled != nil {
            map["PrivateLinkEnabled"] = self.privateLinkEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessModeShrink = dict["AccessMode"] as! String
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("EipBindMode") {
            self.eipBindMode = dict["EipBindMode"] as! String
        }
        if dict.keys.contains("IcmpReplyEnabled") {
            self.icmpReplyEnabled = dict["IcmpReplyEnabled"] as! Bool
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NatType") {
            self.natType = dict["NatType"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("PrivateLinkEnabled") {
            self.privateLinkEnabled = dict["PrivateLinkEnabled"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityProtectionEnabled") {
            self.securityProtectionEnabled = dict["SecurityProtectionEnabled"] as! Bool
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateNatGatewayShrinkRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateNatGatewayShrinkRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateNatGatewayResponseBody : Tea.TeaModel {
    public class ForwardTableIds : Tea.TeaModel {
        public var forwardTableId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardTableId != nil {
                map["ForwardTableId"] = self.forwardTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardTableId") {
                self.forwardTableId = dict["ForwardTableId"] as! [String]
            }
        }
    }
    public class FullNatTableIds : Tea.TeaModel {
        public var fullNatTableId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fullNatTableId != nil {
                map["FullNatTableId"] = self.fullNatTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FullNatTableId") {
                self.fullNatTableId = dict["FullNatTableId"] as! [String]
            }
        }
    }
    public class SnatTableIds : Tea.TeaModel {
        public var snatTableId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snatTableId != nil {
                map["SnatTableId"] = self.snatTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnatTableId") {
                self.snatTableId = dict["SnatTableId"] as! [String]
            }
        }
    }
    public var forwardTableIds: CreateNatGatewayResponseBody.ForwardTableIds?

    public var fullNatTableIds: CreateNatGatewayResponseBody.FullNatTableIds?

    public var natGatewayId: String?

    public var requestId: String?

    public var snatTableIds: CreateNatGatewayResponseBody.SnatTableIds?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forwardTableIds?.validate()
        try self.fullNatTableIds?.validate()
        try self.snatTableIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardTableIds != nil {
            map["ForwardTableIds"] = self.forwardTableIds?.toMap()
        }
        if self.fullNatTableIds != nil {
            map["FullNatTableIds"] = self.fullNatTableIds?.toMap()
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatTableIds != nil {
            map["SnatTableIds"] = self.snatTableIds?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardTableIds") {
            var model = CreateNatGatewayResponseBody.ForwardTableIds()
            model.fromMap(dict["ForwardTableIds"] as! [String: Any])
            self.forwardTableIds = model
        }
        if dict.keys.contains("FullNatTableIds") {
            var model = CreateNatGatewayResponseBody.FullNatTableIds()
            model.fromMap(dict["FullNatTableIds"] as! [String: Any])
            self.fullNatTableIds = model
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnatTableIds") {
            var model = CreateNatGatewayResponseBody.SnatTableIds()
            model.fromMap(dict["SnatTableIds"] as! [String: Any])
            self.snatTableIds = model
        }
    }
}

public class CreateNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNatGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNatIpRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natGatewayId: String?

    public var natIp: String?

    public var natIpCidr: String?

    public var natIpDescription: String?

    public var natIpName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpDescription != nil {
            map["NatIpDescription"] = self.natIpDescription!
        }
        if self.natIpName != nil {
            map["NatIpName"] = self.natIpName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatIp") {
            self.natIp = dict["NatIp"] as! String
        }
        if dict.keys.contains("NatIpCidr") {
            self.natIpCidr = dict["NatIpCidr"] as! String
        }
        if dict.keys.contains("NatIpDescription") {
            self.natIpDescription = dict["NatIpDescription"] as! String
        }
        if dict.keys.contains("NatIpName") {
            self.natIpName = dict["NatIpName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateNatIpResponseBody : Tea.TeaModel {
    public var natIp: String?

    public var natIpId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpId != nil {
            map["NatIpId"] = self.natIpId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatIp") {
            self.natIp = dict["NatIp"] as! String
        }
        if dict.keys.contains("NatIpId") {
            self.natIpId = dict["NatIpId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNatIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNatIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNatIpCidrRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var natIpCidrDescription: String?

    public var natIpCidrName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpCidrDescription != nil {
            map["NatIpCidrDescription"] = self.natIpCidrDescription!
        }
        if self.natIpCidrName != nil {
            map["NatIpCidrName"] = self.natIpCidrName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatIpCidr") {
            self.natIpCidr = dict["NatIpCidr"] as! String
        }
        if dict.keys.contains("NatIpCidrDescription") {
            self.natIpCidrDescription = dict["NatIpCidrDescription"] as! String
        }
        if dict.keys.contains("NatIpCidrName") {
            self.natIpCidrName = dict["NatIpCidrName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateNatIpCidrResponseBody : Tea.TeaModel {
    public var natIpCidrId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natIpCidrId != nil {
            map["NatIpCidrId"] = self.natIpCidrId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatIpCidrId") {
            self.natIpCidrId = dict["NatIpCidrId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNatIpCidrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatIpCidrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNatIpCidrResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkAclRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var networkAclName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateNetworkAclRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkAclName") {
            self.networkAclName = dict["NetworkAclName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateNetworkAclRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateNetworkAclRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateNetworkAclResponseBody : Tea.TeaModel {
    public class NetworkAclAttribute : Tea.TeaModel {
        public class EgressAclEntries : Tea.TeaModel {
            public class EgressAclEntry : Tea.TeaModel {
                public var description_: String?

                public var destinationCidrIp: String?

                public var networkAclEntryId: String?

                public var networkAclEntryName: String?

                public var policy: String?

                public var port: String?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.destinationCidrIp != nil {
                        map["DestinationCidrIp"] = self.destinationCidrIp!
                    }
                    if self.networkAclEntryId != nil {
                        map["NetworkAclEntryId"] = self.networkAclEntryId!
                    }
                    if self.networkAclEntryName != nil {
                        map["NetworkAclEntryName"] = self.networkAclEntryName!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DestinationCidrIp") {
                        self.destinationCidrIp = dict["DestinationCidrIp"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryId") {
                        self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryName") {
                        self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public var egressAclEntry: [CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.egressAclEntry != nil {
                    var tmp : [Any] = []
                    for k in self.egressAclEntry! {
                        tmp.append(k.toMap())
                    }
                    map["EgressAclEntry"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EgressAclEntry") {
                    var tmp : [CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry] = []
                    for v in dict["EgressAclEntry"] as! [Any] {
                        var model = CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.egressAclEntry = tmp
                }
            }
        }
        public class IngressAclEntries : Tea.TeaModel {
            public class IngressAclEntry : Tea.TeaModel {
                public var description_: String?

                public var networkAclEntryId: String?

                public var networkAclEntryName: String?

                public var policy: String?

                public var port: String?

                public var protocol_: String?

                public var sourceCidrIp: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.networkAclEntryId != nil {
                        map["NetworkAclEntryId"] = self.networkAclEntryId!
                    }
                    if self.networkAclEntryName != nil {
                        map["NetworkAclEntryName"] = self.networkAclEntryName!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    if self.sourceCidrIp != nil {
                        map["SourceCidrIp"] = self.sourceCidrIp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryId") {
                        self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryName") {
                        self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                    if dict.keys.contains("SourceCidrIp") {
                        self.sourceCidrIp = dict["SourceCidrIp"] as! String
                    }
                }
            }
            public var ingressAclEntry: [CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ingressAclEntry != nil {
                    var tmp : [Any] = []
                    for k in self.ingressAclEntry! {
                        tmp.append(k.toMap())
                    }
                    map["IngressAclEntry"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IngressAclEntry") {
                    var tmp : [CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry] = []
                    for v in dict["IngressAclEntry"] as! [Any] {
                        var model = CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ingressAclEntry = tmp
                }
            }
        }
        public class Resources : Tea.TeaModel {
            public class Resource : Tea.TeaModel {
                public var resourceId: String?

                public var resourceType: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceId != nil {
                        map["ResourceId"] = self.resourceId!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceId") {
                        self.resourceId = dict["ResourceId"] as! String
                    }
                    if dict.keys.contains("ResourceType") {
                        self.resourceType = dict["ResourceType"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var resource: [CreateNetworkAclResponseBody.NetworkAclAttribute.Resources.Resource]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resource != nil {
                    var tmp : [Any] = []
                    for k in self.resource! {
                        tmp.append(k.toMap())
                    }
                    map["Resource"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Resource") {
                    var tmp : [CreateNetworkAclResponseBody.NetworkAclAttribute.Resources.Resource] = []
                    for v in dict["Resource"] as! [Any] {
                        var model = CreateNetworkAclResponseBody.NetworkAclAttribute.Resources.Resource()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.resource = tmp
                }
            }
        }
        public var creationTime: String?

        public var description_: String?

        public var egressAclEntries: CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries?

        public var ingressAclEntries: CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries?

        public var networkAclId: String?

        public var networkAclName: String?

        public var regionId: String?

        public var resources: CreateNetworkAclResponseBody.NetworkAclAttribute.Resources?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.egressAclEntries?.validate()
            try self.ingressAclEntries?.validate()
            try self.resources?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.egressAclEntries != nil {
                map["EgressAclEntries"] = self.egressAclEntries?.toMap()
            }
            if self.ingressAclEntries != nil {
                map["IngressAclEntries"] = self.ingressAclEntries?.toMap()
            }
            if self.networkAclId != nil {
                map["NetworkAclId"] = self.networkAclId!
            }
            if self.networkAclName != nil {
                map["NetworkAclName"] = self.networkAclName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resources != nil {
                map["Resources"] = self.resources?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EgressAclEntries") {
                var model = CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries()
                model.fromMap(dict["EgressAclEntries"] as! [String: Any])
                self.egressAclEntries = model
            }
            if dict.keys.contains("IngressAclEntries") {
                var model = CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries()
                model.fromMap(dict["IngressAclEntries"] as! [String: Any])
                self.ingressAclEntries = model
            }
            if dict.keys.contains("NetworkAclId") {
                self.networkAclId = dict["NetworkAclId"] as! String
            }
            if dict.keys.contains("NetworkAclName") {
                self.networkAclName = dict["NetworkAclName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Resources") {
                var model = CreateNetworkAclResponseBody.NetworkAclAttribute.Resources()
                model.fromMap(dict["Resources"] as! [String: Any])
                self.resources = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var networkAclAttribute: CreateNetworkAclResponseBody.NetworkAclAttribute?

    public var networkAclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAclAttribute?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclAttribute != nil {
            map["NetworkAclAttribute"] = self.networkAclAttribute?.toMap()
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclAttribute") {
            var model = CreateNetworkAclResponseBody.NetworkAclAttribute()
            model.fromMap(dict["NetworkAclAttribute"] as! [String: Any])
            self.networkAclAttribute = model
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePhysicalConnectionRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var accessPointId: String?

    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var deviceAdvancedCapacity: [String]?

    public var lineOperator: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerLocation: String?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreatePhysicalConnectionRequest.Tag]?

    public var type: String?

    public var bandwidth: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.deviceAdvancedCapacity != nil {
            map["DeviceAdvancedCapacity"] = self.deviceAdvancedCapacity!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.bandwidth != nil {
            map["bandwidth"] = self.bandwidth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPointId") {
            self.accessPointId = dict["AccessPointId"] as! String
        }
        if dict.keys.contains("CircuitCode") {
            self.circuitCode = dict["CircuitCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DeviceAdvancedCapacity") {
            self.deviceAdvancedCapacity = dict["DeviceAdvancedCapacity"] as! [String]
        }
        if dict.keys.contains("LineOperator") {
            self.lineOperator = dict["LineOperator"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerLocation") {
            self.peerLocation = dict["PeerLocation"] as! String
        }
        if dict.keys.contains("PortType") {
            self.portType = dict["PortType"] as! String
        }
        if dict.keys.contains("RedundantPhysicalConnectionId") {
            self.redundantPhysicalConnectionId = dict["RedundantPhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreatePhysicalConnectionRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreatePhysicalConnectionRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("bandwidth") {
            self.bandwidth = dict["bandwidth"] as! Int32
        }
    }
}

public class CreatePhysicalConnectionResponseBody : Tea.TeaModel {
    public var physicalConnectionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePhysicalConnectionOccupancyOrderRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var instanceChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var physicalConnectionId: String?

    public var pricingCycle: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreatePhysicalConnectionOccupancyOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var orderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! String
            }
        }
    }
    public var data: CreatePhysicalConnectionOccupancyOrderResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreatePhysicalConnectionOccupancyOrderResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePhysicalConnectionOccupancyOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePhysicalConnectionOccupancyOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePhysicalConnectionOccupancyOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePhysicalConnectionSetupOrderRequest : Tea.TeaModel {
    public var accessPointId: String?

    public var autoPay: Bool?

    public var clientToken: String?

    public var lineOperator: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPointId") {
            self.accessPointId = dict["AccessPointId"] as! String
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("LineOperator") {
            self.lineOperator = dict["LineOperator"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PortType") {
            self.portType = dict["PortType"] as! String
        }
        if dict.keys.contains("RedundantPhysicalConnectionId") {
            self.redundantPhysicalConnectionId = dict["RedundantPhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreatePhysicalConnectionSetupOrderResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var physicalConnectionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePhysicalConnectionSetupOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePhysicalConnectionSetupOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePhysicalConnectionSetupOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePublicIpAddressPoolRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var bizType: String?

    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var isp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionTypes: [String]?

    public var tag: [CreatePublicIpAddressPoolRequest.Tag]?

    public var zones: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionTypes != nil {
            map["SecurityProtectionTypes"] = self.securityProtectionTypes!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zones != nil {
            map["Zones"] = self.zones!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityProtectionTypes") {
            self.securityProtectionTypes = dict["SecurityProtectionTypes"] as! [String]
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreatePublicIpAddressPoolRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreatePublicIpAddressPoolRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Zones") {
            self.zones = dict["Zones"] as! [String]
        }
    }
}

public class CreatePublicIpAddressPoolResponseBody : Tea.TeaModel {
    public var publicIpAddressPoolId: String?

    public var pulbicIpAddressPoolId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.pulbicIpAddressPoolId != nil {
            map["PulbicIpAddressPoolId"] = self.pulbicIpAddressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PublicIpAddressPoolId") {
            self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("PulbicIpAddressPoolId") {
            self.pulbicIpAddressPoolId = dict["PulbicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreatePublicIpAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePublicIpAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePublicIpAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRouteEntriesRequest : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public var description_: String?

        public var dstCidrBlock: String?

        public var ipVersion: Int32?

        public var name: String?

        public var nextHop: String?

        public var nextHopType: String?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dstCidrBlock != nil {
                map["DstCidrBlock"] = self.dstCidrBlock!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DstCidrBlock") {
                self.dstCidrBlock = dict["DstCidrBlock"] as! String
            }
            if dict.keys.contains("IpVersion") {
                self.ipVersion = dict["IpVersion"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NextHop") {
                self.nextHop = dict["NextHop"] as! String
            }
            if dict.keys.contains("NextHopType") {
                self.nextHopType = dict["NextHopType"] as! String
            }
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntries: [CreateRouteEntriesRequest.RouteEntries]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntries") {
            var tmp : [CreateRouteEntriesRequest.RouteEntries] = []
            for v in dict["RouteEntries"] as! [Any] {
                var model = CreateRouteEntriesRequest.RouteEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeEntries = tmp
        }
    }
}

public class CreateRouteEntriesResponseBody : Tea.TeaModel {
    public class FailedRouteEntries : Tea.TeaModel {
        public var dstCidrBlock: String?

        public var failedCode: String?

        public var failedMessage: String?

        public var nextHop: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstCidrBlock != nil {
                map["DstCidrBlock"] = self.dstCidrBlock!
            }
            if self.failedCode != nil {
                map["FailedCode"] = self.failedCode!
            }
            if self.failedMessage != nil {
                map["FailedMessage"] = self.failedMessage!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DstCidrBlock") {
                self.dstCidrBlock = dict["DstCidrBlock"] as! String
            }
            if dict.keys.contains("FailedCode") {
                self.failedCode = dict["FailedCode"] as! String
            }
            if dict.keys.contains("FailedMessage") {
                self.failedMessage = dict["FailedMessage"] as! String
            }
            if dict.keys.contains("NextHop") {
                self.nextHop = dict["NextHop"] as! String
            }
        }
    }
    public var failedCount: Int32?

    public var failedRouteEntries: [CreateRouteEntriesResponseBody.FailedRouteEntries]?

    public var requestId: String?

    public var routeEntryIds: [String]?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.failedRouteEntries != nil {
            var tmp : [Any] = []
            for k in self.failedRouteEntries! {
                tmp.append(k.toMap())
            }
            map["FailedRouteEntries"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntryIds != nil {
            map["RouteEntryIds"] = self.routeEntryIds!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedCount") {
            self.failedCount = dict["FailedCount"] as! Int32
        }
        if dict.keys.contains("FailedRouteEntries") {
            var tmp : [CreateRouteEntriesResponseBody.FailedRouteEntries] = []
            for v in dict["FailedRouteEntries"] as! [Any] {
                var model = CreateRouteEntriesResponseBody.FailedRouteEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.failedRouteEntries = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntryIds") {
            self.routeEntryIds = dict["RouteEntryIds"] as! [String]
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
    }
}

public class CreateRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRouteEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRouteEntryRequest : Tea.TeaModel {
    public class NextHopList : Tea.TeaModel {
        public var nextHopId: String?

        public var nextHopType: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextHopId") {
                self.nextHopId = dict["NextHopId"] as! String
            }
            if dict.keys.contains("NextHopType") {
                self.nextHopType = dict["NextHopType"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopList: [CreateRouteEntryRequest.NextHopList]?

    public var nextHopType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryName: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopList != nil {
            var tmp : [Any] = []
            for k in self.nextHopList! {
                tmp.append(k.toMap())
            }
            map["NextHopList"] = tmp
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("NextHopId") {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopList") {
            var tmp : [CreateRouteEntryRequest.NextHopList] = []
            for v in dict["NextHopList"] as! [Any] {
                var model = CreateRouteEntryRequest.NextHopList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nextHopList = tmp
        }
        if dict.keys.contains("NextHopType") {
            self.nextHopType = dict["NextHopType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntryName") {
            self.routeEntryName = dict["RouteEntryName"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class CreateRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntryId") {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
    }
}

public class CreateRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRouteTableRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var associateType: String?

    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableName: String?

    public var tag: [CreateRouteTableRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associateType != nil {
            map["AssociateType"] = self.associateType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssociateType") {
            self.associateType = dict["AssociateType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableName") {
            self.routeTableName = dict["RouteTableName"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateRouteTableRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateRouteTableRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateRouteTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class CreateRouteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRouteTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRouterInterfaceRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var accessPointId: String?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var clientToken: String?

    public var description_: String?

    public var fastLinkMode: Bool?

    public var healthCheckSourceIp: String?

    public var healthCheckTargetIp: String?

    public var instanceChargeType: String?

    public var name: String?

    public var oppositeAccessPointId: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: String?

    public var oppositeRegionId: String?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var pricingCycle: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var role: String?

    public var routerId: String?

    public var routerType: String?

    public var spec: String?

    public var tags: [CreateRouterInterfaceRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fastLinkMode != nil {
            map["FastLinkMode"] = self.fastLinkMode!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeAccessPointId != nil {
            map["OppositeAccessPointId"] = self.oppositeAccessPointId!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeRegionId != nil {
            map["OppositeRegionId"] = self.oppositeRegionId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPointId") {
            self.accessPointId = dict["AccessPointId"] as! String
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FastLinkMode") {
            self.fastLinkMode = dict["FastLinkMode"] as! Bool
        }
        if dict.keys.contains("HealthCheckSourceIp") {
            self.healthCheckSourceIp = dict["HealthCheckSourceIp"] as! String
        }
        if dict.keys.contains("HealthCheckTargetIp") {
            self.healthCheckTargetIp = dict["HealthCheckTargetIp"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OppositeAccessPointId") {
            self.oppositeAccessPointId = dict["OppositeAccessPointId"] as! String
        }
        if dict.keys.contains("OppositeInterfaceId") {
            self.oppositeInterfaceId = dict["OppositeInterfaceId"] as! String
        }
        if dict.keys.contains("OppositeInterfaceOwnerId") {
            self.oppositeInterfaceOwnerId = dict["OppositeInterfaceOwnerId"] as! String
        }
        if dict.keys.contains("OppositeRegionId") {
            self.oppositeRegionId = dict["OppositeRegionId"] as! String
        }
        if dict.keys.contains("OppositeRouterId") {
            self.oppositeRouterId = dict["OppositeRouterId"] as! String
        }
        if dict.keys.contains("OppositeRouterType") {
            self.oppositeRouterType = dict["OppositeRouterType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
        if dict.keys.contains("RouterType") {
            self.routerType = dict["RouterType"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateRouterInterfaceRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateRouterInterfaceRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class CreateRouterInterfaceResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public var requestId: String?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class CreateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSnatEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var eipAffinity: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snatEntryName: String?

    public var snatIp: String?

    public var snatTableId: String?

    public var sourceCIDR: String?

    public var sourceVSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.eipAffinity != nil {
            map["EipAffinity"] = self.eipAffinity!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.snatTableId != nil {
            map["SnatTableId"] = self.snatTableId!
        }
        if self.sourceCIDR != nil {
            map["SourceCIDR"] = self.sourceCIDR!
        }
        if self.sourceVSwitchId != nil {
            map["SourceVSwitchId"] = self.sourceVSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EipAffinity") {
            self.eipAffinity = dict["EipAffinity"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnatEntryName") {
            self.snatEntryName = dict["SnatEntryName"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
        if dict.keys.contains("SnatTableId") {
            self.snatTableId = dict["SnatTableId"] as! String
        }
        if dict.keys.contains("SourceCIDR") {
            self.sourceCIDR = dict["SourceCIDR"] as! String
        }
        if dict.keys.contains("SourceVSwitchId") {
            self.sourceVSwitchId = dict["SourceVSwitchId"] as! String
        }
    }
}

public class CreateSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snatEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
    }
}

public class CreateSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSslVpnClientCertRequest : Tea.TeaModel {
    public var clientToken: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslVpnServerId") {
            self.sslVpnServerId = dict["SslVpnServerId"] as! String
        }
    }
}

public class CreateSslVpnClientCertResponseBody : Tea.TeaModel {
    public var name: String?

    public var requestId: String?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SslVpnClientCertId") {
            self.sslVpnClientCertId = dict["SslVpnClientCertId"] as! String
        }
    }
}

public class CreateSslVpnClientCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSslVpnClientCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSslVpnClientCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSslVpnServerRequest : Tea.TeaModel {
    public var cipher: String?

    public var clientIpPool: String?

    public var clientToken: String?

    public var compress: Bool?

    public var enableMultiFactorAuth: Bool?

    public var IDaaSApplicationId: String?

    public var IDaaSInstanceId: String?

    public var IDaaSRegionId: String?

    public var localSubnet: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var port: Int32?

    public var proto: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipher != nil {
            map["Cipher"] = self.cipher!
        }
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compress != nil {
            map["Compress"] = self.compress!
        }
        if self.enableMultiFactorAuth != nil {
            map["EnableMultiFactorAuth"] = self.enableMultiFactorAuth!
        }
        if self.IDaaSApplicationId != nil {
            map["IDaaSApplicationId"] = self.IDaaSApplicationId!
        }
        if self.IDaaSInstanceId != nil {
            map["IDaaSInstanceId"] = self.IDaaSInstanceId!
        }
        if self.IDaaSRegionId != nil {
            map["IDaaSRegionId"] = self.IDaaSRegionId!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.proto != nil {
            map["Proto"] = self.proto!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cipher") {
            self.cipher = dict["Cipher"] as! String
        }
        if dict.keys.contains("ClientIpPool") {
            self.clientIpPool = dict["ClientIpPool"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Compress") {
            self.compress = dict["Compress"] as! Bool
        }
        if dict.keys.contains("EnableMultiFactorAuth") {
            self.enableMultiFactorAuth = dict["EnableMultiFactorAuth"] as! Bool
        }
        if dict.keys.contains("IDaaSApplicationId") {
            self.IDaaSApplicationId = dict["IDaaSApplicationId"] as! String
        }
        if dict.keys.contains("IDaaSInstanceId") {
            self.IDaaSInstanceId = dict["IDaaSInstanceId"] as! String
        }
        if dict.keys.contains("IDaaSRegionId") {
            self.IDaaSRegionId = dict["IDaaSRegionId"] as! String
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Proto") {
            self.proto = dict["Proto"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class CreateSslVpnServerResponseBody : Tea.TeaModel {
    public var name: String?

    public var requestId: String?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SslVpnServerId") {
            self.sslVpnServerId = dict["SslVpnServerId"] as! String
        }
    }
}

public class CreateSslVpnServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSslVpnServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSslVpnServerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTrafficMirrorFilterRequest : Tea.TeaModel {
    public class EgressRules : Tea.TeaModel {
        public var action: String?

        public var destinationCidrBlock: String?

        public var destinationPortRange: String?

        public var priority: Int32?

        public var protocol_: String?

        public var sourceCidrBlock: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.destinationPortRange != nil {
                map["DestinationPortRange"] = self.destinationPortRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrBlock != nil {
                map["SourceCidrBlock"] = self.sourceCidrBlock!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("DestinationPortRange") {
                self.destinationPortRange = dict["DestinationPortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("SourceCidrBlock") {
                self.sourceCidrBlock = dict["SourceCidrBlock"] as! String
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
        }
    }
    public class IngressRules : Tea.TeaModel {
        public var action: String?

        public var destinationCidrBlock: String?

        public var destinationPortRange: String?

        public var priority: Int32?

        public var protocol_: String?

        public var sourceCidrBlock: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.destinationPortRange != nil {
                map["DestinationPortRange"] = self.destinationPortRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrBlock != nil {
                map["SourceCidrBlock"] = self.sourceCidrBlock!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("DestinationPortRange") {
                self.destinationPortRange = dict["DestinationPortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("SourceCidrBlock") {
                self.sourceCidrBlock = dict["SourceCidrBlock"] as! String
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var egressRules: [CreateTrafficMirrorFilterRequest.EgressRules]?

    public var ingressRules: [CreateTrafficMirrorFilterRequest.IngressRules]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateTrafficMirrorFilterRequest.Tag]?

    public var trafficMirrorFilterDescription: String?

    public var trafficMirrorFilterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.egressRules != nil {
            var tmp : [Any] = []
            for k in self.egressRules! {
                tmp.append(k.toMap())
            }
            map["EgressRules"] = tmp
        }
        if self.ingressRules != nil {
            var tmp : [Any] = []
            for k in self.ingressRules! {
                tmp.append(k.toMap())
            }
            map["IngressRules"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.trafficMirrorFilterDescription != nil {
            map["TrafficMirrorFilterDescription"] = self.trafficMirrorFilterDescription!
        }
        if self.trafficMirrorFilterName != nil {
            map["TrafficMirrorFilterName"] = self.trafficMirrorFilterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EgressRules") {
            var tmp : [CreateTrafficMirrorFilterRequest.EgressRules] = []
            for v in dict["EgressRules"] as! [Any] {
                var model = CreateTrafficMirrorFilterRequest.EgressRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.egressRules = tmp
        }
        if dict.keys.contains("IngressRules") {
            var tmp : [CreateTrafficMirrorFilterRequest.IngressRules] = []
            for v in dict["IngressRules"] as! [Any] {
                var model = CreateTrafficMirrorFilterRequest.IngressRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ingressRules = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateTrafficMirrorFilterRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateTrafficMirrorFilterRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TrafficMirrorFilterDescription") {
            self.trafficMirrorFilterDescription = dict["TrafficMirrorFilterDescription"] as! String
        }
        if dict.keys.contains("TrafficMirrorFilterName") {
            self.trafficMirrorFilterName = dict["TrafficMirrorFilterName"] as! String
        }
    }
}

public class CreateTrafficMirrorFilterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceGroupId: String?

    public var trafficMirrorFilterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TrafficMirrorFilterId") {
            self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
        }
    }
}

public class CreateTrafficMirrorFilterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTrafficMirrorFilterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTrafficMirrorFilterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTrafficMirrorFilterRulesRequest : Tea.TeaModel {
    public class EgressRules : Tea.TeaModel {
        public var action: String?

        public var destinationCidrBlock: String?

        public var destinationPortRange: String?

        public var priority: Int32?

        public var protocol_: String?

        public var sourceCidrBlock: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.destinationPortRange != nil {
                map["DestinationPortRange"] = self.destinationPortRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrBlock != nil {
                map["SourceCidrBlock"] = self.sourceCidrBlock!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("DestinationPortRange") {
                self.destinationPortRange = dict["DestinationPortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("SourceCidrBlock") {
                self.sourceCidrBlock = dict["SourceCidrBlock"] as! String
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
        }
    }
    public class IngressRules : Tea.TeaModel {
        public var action: String?

        public var destinationCidrBlock: String?

        public var destinationPortRange: String?

        public var priority: Int32?

        public var protocol_: String?

        public var sourceCidrBlock: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.destinationPortRange != nil {
                map["DestinationPortRange"] = self.destinationPortRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrBlock != nil {
                map["SourceCidrBlock"] = self.sourceCidrBlock!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("DestinationPortRange") {
                self.destinationPortRange = dict["DestinationPortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("SourceCidrBlock") {
                self.sourceCidrBlock = dict["SourceCidrBlock"] as! String
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var egressRules: [CreateTrafficMirrorFilterRulesRequest.EgressRules]?

    public var ingressRules: [CreateTrafficMirrorFilterRulesRequest.IngressRules]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.egressRules != nil {
            var tmp : [Any] = []
            for k in self.egressRules! {
                tmp.append(k.toMap())
            }
            map["EgressRules"] = tmp
        }
        if self.ingressRules != nil {
            var tmp : [Any] = []
            for k in self.ingressRules! {
                tmp.append(k.toMap())
            }
            map["IngressRules"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EgressRules") {
            var tmp : [CreateTrafficMirrorFilterRulesRequest.EgressRules] = []
            for v in dict["EgressRules"] as! [Any] {
                var model = CreateTrafficMirrorFilterRulesRequest.EgressRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.egressRules = tmp
        }
        if dict.keys.contains("IngressRules") {
            var tmp : [CreateTrafficMirrorFilterRulesRequest.IngressRules] = []
            for v in dict["IngressRules"] as! [Any] {
                var model = CreateTrafficMirrorFilterRulesRequest.IngressRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ingressRules = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrafficMirrorFilterId") {
            self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
        }
    }
}

public class CreateTrafficMirrorFilterRulesResponseBody : Tea.TeaModel {
    public class EgressRules : Tea.TeaModel {
        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public class IngressRules : Tea.TeaModel {
        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public var egressRules: [CreateTrafficMirrorFilterRulesResponseBody.EgressRules]?

    public var ingressRules: [CreateTrafficMirrorFilterRulesResponseBody.IngressRules]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.egressRules != nil {
            var tmp : [Any] = []
            for k in self.egressRules! {
                tmp.append(k.toMap())
            }
            map["EgressRules"] = tmp
        }
        if self.ingressRules != nil {
            var tmp : [Any] = []
            for k in self.ingressRules! {
                tmp.append(k.toMap())
            }
            map["IngressRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EgressRules") {
            var tmp : [CreateTrafficMirrorFilterRulesResponseBody.EgressRules] = []
            for v in dict["EgressRules"] as! [Any] {
                var model = CreateTrafficMirrorFilterRulesResponseBody.EgressRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.egressRules = tmp
        }
        if dict.keys.contains("IngressRules") {
            var tmp : [CreateTrafficMirrorFilterRulesResponseBody.IngressRules] = []
            for v in dict["IngressRules"] as! [Any] {
                var model = CreateTrafficMirrorFilterRulesResponseBody.IngressRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ingressRules = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateTrafficMirrorFilterRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTrafficMirrorFilterRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTrafficMirrorFilterRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTrafficMirrorSessionRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var enabled: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var packetLength: Int32?

    public var priority: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateTrafficMirrorSessionRequest.Tag]?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorSessionDescription: String?

    public var trafficMirrorSessionName: String?

    public var trafficMirrorSourceIds: [String]?

    public var trafficMirrorTargetId: String?

    public var trafficMirrorTargetType: String?

    public var virtualNetworkId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.packetLength != nil {
            map["PacketLength"] = self.packetLength!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorSessionDescription != nil {
            map["TrafficMirrorSessionDescription"] = self.trafficMirrorSessionDescription!
        }
        if self.trafficMirrorSessionName != nil {
            map["TrafficMirrorSessionName"] = self.trafficMirrorSessionName!
        }
        if self.trafficMirrorSourceIds != nil {
            map["TrafficMirrorSourceIds"] = self.trafficMirrorSourceIds!
        }
        if self.trafficMirrorTargetId != nil {
            map["TrafficMirrorTargetId"] = self.trafficMirrorTargetId!
        }
        if self.trafficMirrorTargetType != nil {
            map["TrafficMirrorTargetType"] = self.trafficMirrorTargetType!
        }
        if self.virtualNetworkId != nil {
            map["VirtualNetworkId"] = self.virtualNetworkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PacketLength") {
            self.packetLength = dict["PacketLength"] as! Int32
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateTrafficMirrorSessionRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateTrafficMirrorSessionRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TrafficMirrorFilterId") {
            self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
        }
        if dict.keys.contains("TrafficMirrorSessionDescription") {
            self.trafficMirrorSessionDescription = dict["TrafficMirrorSessionDescription"] as! String
        }
        if dict.keys.contains("TrafficMirrorSessionName") {
            self.trafficMirrorSessionName = dict["TrafficMirrorSessionName"] as! String
        }
        if dict.keys.contains("TrafficMirrorSourceIds") {
            self.trafficMirrorSourceIds = dict["TrafficMirrorSourceIds"] as! [String]
        }
        if dict.keys.contains("TrafficMirrorTargetId") {
            self.trafficMirrorTargetId = dict["TrafficMirrorTargetId"] as! String
        }
        if dict.keys.contains("TrafficMirrorTargetType") {
            self.trafficMirrorTargetType = dict["TrafficMirrorTargetType"] as! String
        }
        if dict.keys.contains("VirtualNetworkId") {
            self.virtualNetworkId = dict["VirtualNetworkId"] as! Int32
        }
    }
}

public class CreateTrafficMirrorSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceGroupId: String?

    public var trafficMirrorSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TrafficMirrorSessionId") {
            self.trafficMirrorSessionId = dict["TrafficMirrorSessionId"] as! String
        }
    }
}

public class CreateTrafficMirrorSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTrafficMirrorSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTrafficMirrorSessionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVSwitchRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var cidrBlock: String?

    public var clientToken: String?

    public var description_: String?

    public var ipv6CidrBlock: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateVSwitchRequest.Tag]?

    public var vSwitchName: String?

    public var vpcId: String?

    public var vpcIpv6CidrBlock: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcIpv6CidrBlock != nil {
            map["VpcIpv6CidrBlock"] = self.vpcIpv6CidrBlock!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateVSwitchRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateVSwitchRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcIpv6CidrBlock") {
            self.vpcIpv6CidrBlock = dict["VpcIpv6CidrBlock"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVSwitchCidrReservationRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateVSwitchCidrReservationRequest.Tag]?

    public var vSwitchCidrReservationCidr: String?

    public var vSwitchCidrReservationDescription: String?

    public var vSwitchCidrReservationMask: String?

    public var vSwitchCidrReservationName: String?

    public var vSwitchCidrReservationType: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchCidrReservationCidr != nil {
            map["VSwitchCidrReservationCidr"] = self.vSwitchCidrReservationCidr!
        }
        if self.vSwitchCidrReservationDescription != nil {
            map["VSwitchCidrReservationDescription"] = self.vSwitchCidrReservationDescription!
        }
        if self.vSwitchCidrReservationMask != nil {
            map["VSwitchCidrReservationMask"] = self.vSwitchCidrReservationMask!
        }
        if self.vSwitchCidrReservationName != nil {
            map["VSwitchCidrReservationName"] = self.vSwitchCidrReservationName!
        }
        if self.vSwitchCidrReservationType != nil {
            map["VSwitchCidrReservationType"] = self.vSwitchCidrReservationType!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateVSwitchCidrReservationRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateVSwitchCidrReservationRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchCidrReservationCidr") {
            self.vSwitchCidrReservationCidr = dict["VSwitchCidrReservationCidr"] as! String
        }
        if dict.keys.contains("VSwitchCidrReservationDescription") {
            self.vSwitchCidrReservationDescription = dict["VSwitchCidrReservationDescription"] as! String
        }
        if dict.keys.contains("VSwitchCidrReservationMask") {
            self.vSwitchCidrReservationMask = dict["VSwitchCidrReservationMask"] as! String
        }
        if dict.keys.contains("VSwitchCidrReservationName") {
            self.vSwitchCidrReservationName = dict["VSwitchCidrReservationName"] as! String
        }
        if dict.keys.contains("VSwitchCidrReservationType") {
            self.vSwitchCidrReservationType = dict["VSwitchCidrReservationType"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateVSwitchCidrReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchCidrReservationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchCidrReservationId != nil {
            map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchCidrReservationId") {
            self.vSwitchCidrReservationId = dict["VSwitchCidrReservationId"] as! String
        }
    }
}

public class CreateVSwitchCidrReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVSwitchCidrReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVSwitchCidrReservationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVbrHaRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerVbrId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerVbrId != nil {
            map["PeerVbrId"] = self.peerVbrId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerVbrId") {
            self.peerVbrId = dict["PeerVbrId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class CreateVbrHaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vbrHaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vbrHaId != nil {
            map["VbrHaId"] = self.vbrHaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VbrHaId") {
            self.vbrHaId = dict["VbrHaId"] as! String
        }
    }
}

public class CreateVbrHaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVbrHaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVbrHaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVcoRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnConnectionId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class CreateVcoRouteEntryResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var description_: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var requestId: String?

    public var routeDest: String?

    public var state: String?

    public var vpnConnectionId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class CreateVcoRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVcoRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVcoRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVirtualBorderRouterRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var bandwidth: Int64?

    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var enableIpv6: Bool?

    public var localGatewayIp: String?

    public var localIpv6GatewayIp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peerIpv6GatewayIp: String?

    public var peeringIpv6SubnetMask: String?

    public var peeringSubnetMask: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [CreateVirtualBorderRouterRequest.Tags]?

    public var vbrOwnerId: Int64?

    public var vlanId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.localIpv6GatewayIp != nil {
            map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peerIpv6GatewayIp != nil {
            map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
        }
        if self.peeringIpv6SubnetMask != nil {
            map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vbrOwnerId != nil {
            map["VbrOwnerId"] = self.vbrOwnerId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int64
        }
        if dict.keys.contains("CircuitCode") {
            self.circuitCode = dict["CircuitCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableIpv6") {
            self.enableIpv6 = dict["EnableIpv6"] as! Bool
        }
        if dict.keys.contains("LocalGatewayIp") {
            self.localGatewayIp = dict["LocalGatewayIp"] as! String
        }
        if dict.keys.contains("LocalIpv6GatewayIp") {
            self.localIpv6GatewayIp = dict["LocalIpv6GatewayIp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerGatewayIp") {
            self.peerGatewayIp = dict["PeerGatewayIp"] as! String
        }
        if dict.keys.contains("PeerIpv6GatewayIp") {
            self.peerIpv6GatewayIp = dict["PeerIpv6GatewayIp"] as! String
        }
        if dict.keys.contains("PeeringIpv6SubnetMask") {
            self.peeringIpv6SubnetMask = dict["PeeringIpv6SubnetMask"] as! String
        }
        if dict.keys.contains("PeeringSubnetMask") {
            self.peeringSubnetMask = dict["PeeringSubnetMask"] as! String
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateVirtualBorderRouterRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateVirtualBorderRouterRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VbrOwnerId") {
            self.vbrOwnerId = dict["VbrOwnerId"] as! Int64
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! Int32
        }
    }
}

public class CreateVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class CreateVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVirtualPhysicalConnectionRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var description_: String?

    public var dryRun: Bool?

    public var name: String?

    public var orderMode: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var spec: String?

    public var tag: [CreateVirtualPhysicalConnectionRequest.Tag]?

    public var token: String?

    public var vlanId: Int64?

    public var vpconnAliUid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderMode != nil {
            map["OrderMode"] = self.orderMode!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        if self.vpconnAliUid != nil {
            map["VpconnAliUid"] = self.vpconnAliUid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrderMode") {
            self.orderMode = dict["OrderMode"] as! String
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateVirtualPhysicalConnectionRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateVirtualPhysicalConnectionRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! Int64
        }
        if dict.keys.contains("VpconnAliUid") {
            self.vpconnAliUid = dict["VpconnAliUid"] as! Int64
        }
    }
}

public class CreateVirtualPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var virtualPhysicalConnection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.virtualPhysicalConnection != nil {
            map["VirtualPhysicalConnection"] = self.virtualPhysicalConnection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VirtualPhysicalConnection") {
            self.virtualPhysicalConnection = dict["VirtualPhysicalConnection"] as! String
        }
    }
}

public class CreateVirtualPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVirtualPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVirtualPhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpcRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var cidrBlock: String?

    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var enableDnsHostname: Bool?

    public var enableIpv6: Bool?

    public var ipv4CidrMask: Int32?

    public var ipv4IpamPoolId: String?

    public var ipv6CidrBlock: String?

    public var ipv6Isp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateVpcRequest.Tag]?

    public var userCidr: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableDnsHostname != nil {
            map["EnableDnsHostname"] = self.enableDnsHostname!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.ipv4CidrMask != nil {
            map["Ipv4CidrMask"] = self.ipv4CidrMask!
        }
        if self.ipv4IpamPoolId != nil {
            map["Ipv4IpamPoolId"] = self.ipv4IpamPoolId!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ipv6Isp != nil {
            map["Ipv6Isp"] = self.ipv6Isp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnableDnsHostname") {
            self.enableDnsHostname = dict["EnableDnsHostname"] as! Bool
        }
        if dict.keys.contains("EnableIpv6") {
            self.enableIpv6 = dict["EnableIpv6"] as! Bool
        }
        if dict.keys.contains("Ipv4CidrMask") {
            self.ipv4CidrMask = dict["Ipv4CidrMask"] as! Int32
        }
        if dict.keys.contains("Ipv4IpamPoolId") {
            self.ipv4IpamPoolId = dict["Ipv4IpamPoolId"] as! String
        }
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
        }
        if dict.keys.contains("Ipv6Isp") {
            self.ipv6Isp = dict["Ipv6Isp"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateVpcRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateVpcRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("VpcName") {
            self.vpcName = dict["VpcName"] as! String
        }
    }
}

public class CreateVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceGroupId: String?

    public var routeTableId: String?

    public var VRouterId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpcGatewayEndpointRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointDescription: String?

    public var endpointName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var policyDocument: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public var tag: [CreateVpcGatewayEndpointRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointDescription != nil {
            map["EndpointDescription"] = self.endpointDescription!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policyDocument != nil {
            map["PolicyDocument"] = self.policyDocument!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointDescription") {
            self.endpointDescription = dict["EndpointDescription"] as! String
        }
        if dict.keys.contains("EndpointName") {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PolicyDocument") {
            self.policyDocument = dict["PolicyDocument"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateVpcGatewayEndpointRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateVpcGatewayEndpointRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateVpcGatewayEndpointResponseBody : Tea.TeaModel {
    public var creationTime: String?

    public var endpointId: String?

    public var endpointName: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("EndpointId") {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("EndpointName") {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class CreateVpcGatewayEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcGatewayEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpcGatewayEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpcPrefixListRequest : Tea.TeaModel {
    public class PrefixListEntries : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cidr") {
                self.cidr = dict["Cidr"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipVersion: String?

    public var maxEntries: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListDescription: String?

    public var prefixListEntries: [CreateVpcPrefixListRequest.PrefixListEntries]?

    public var prefixListName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateVpcPrefixListRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.maxEntries != nil {
            map["MaxEntries"] = self.maxEntries!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListDescription != nil {
            map["PrefixListDescription"] = self.prefixListDescription!
        }
        if self.prefixListEntries != nil {
            var tmp : [Any] = []
            for k in self.prefixListEntries! {
                tmp.append(k.toMap())
            }
            map["PrefixListEntries"] = tmp
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("MaxEntries") {
            self.maxEntries = dict["MaxEntries"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListDescription") {
            self.prefixListDescription = dict["PrefixListDescription"] as! String
        }
        if dict.keys.contains("PrefixListEntries") {
            var tmp : [CreateVpcPrefixListRequest.PrefixListEntries] = []
            for v in dict["PrefixListEntries"] as! [Any] {
                var model = CreateVpcPrefixListRequest.PrefixListEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.prefixListEntries = tmp
        }
        if dict.keys.contains("PrefixListName") {
            self.prefixListName = dict["PrefixListName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateVpcPrefixListRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateVpcPrefixListRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateVpcPrefixListResponseBody : Tea.TeaModel {
    public var prefixListId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateVpcPrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcPrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpcPrefixListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpconnFromVbrRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var orderMode: String?

    public var regionId: String?

    public var token: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.orderMode != nil {
            map["OrderMode"] = self.orderMode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OrderMode") {
            self.orderMode = dict["OrderMode"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class CreateVpconnFromVbrResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var virtualPhysicalConnection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.virtualPhysicalConnection != nil {
            map["VirtualPhysicalConnection"] = self.virtualPhysicalConnection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VirtualPhysicalConnection") {
            self.virtualPhysicalConnection = dict["VirtualPhysicalConnection"] as! String
        }
    }
}

public class CreateVpconnFromVbrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpconnFromVbrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpconnFromVbrResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpnAttachmentRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalAsn") {
                    self.localAsn = dict["LocalAsn"] as! Int64
                }
                if dict.keys.contains("LocalBgpIp") {
                    self.localBgpIp = dict["LocalBgpIp"] as! String
                }
                if dict.keys.contains("TunnelCidr") {
                    self.tunnelCidr = dict["TunnelCidr"] as! String
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IkeAuthAlg") {
                    self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                }
                if dict.keys.contains("IkeEncAlg") {
                    self.ikeEncAlg = dict["IkeEncAlg"] as! String
                }
                if dict.keys.contains("IkeLifetime") {
                    self.ikeLifetime = dict["IkeLifetime"] as! Int64
                }
                if dict.keys.contains("IkeMode") {
                    self.ikeMode = dict["IkeMode"] as! String
                }
                if dict.keys.contains("IkePfs") {
                    self.ikePfs = dict["IkePfs"] as! String
                }
                if dict.keys.contains("IkeVersion") {
                    self.ikeVersion = dict["IkeVersion"] as! String
                }
                if dict.keys.contains("LocalId") {
                    self.localId = dict["LocalId"] as! String
                }
                if dict.keys.contains("Psk") {
                    self.psk = dict["Psk"] as! String
                }
                if dict.keys.contains("RemoteId") {
                    self.remoteId = dict["RemoteId"] as! String
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpsecAuthAlg") {
                    self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                }
                if dict.keys.contains("IpsecEncAlg") {
                    self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                }
                if dict.keys.contains("IpsecLifetime") {
                    self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
                }
                if dict.keys.contains("IpsecPfs") {
                    self.ipsecPfs = dict["IpsecPfs"] as! String
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var tunnelBgpConfig: CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelIkeConfig: CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIndex: Int32?

        public var tunnelIpsecConfig: CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIndex != nil {
                map["TunnelIndex"] = self.tunnelIndex!
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomerGatewayId") {
                self.customerGatewayId = dict["CustomerGatewayId"] as! String
            }
            if dict.keys.contains("EnableDpd") {
                self.enableDpd = dict["EnableDpd"] as! Bool
            }
            if dict.keys.contains("EnableNatTraversal") {
                self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
            }
            if dict.keys.contains("TunnelBgpConfig") {
                var model = CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
                self.tunnelBgpConfig = model
            }
            if dict.keys.contains("TunnelIkeConfig") {
                var model = CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
                self.tunnelIkeConfig = model
            }
            if dict.keys.contains("TunnelIndex") {
                self.tunnelIndex = dict["TunnelIndex"] as! Int32
            }
            if dict.keys.contains("TunnelIpsecConfig") {
                var model = CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var autoConfigRoute: Bool?

    public var bgpConfig: String?

    public var clientToken: String?

    public var customerGatewayId: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var healthCheckConfig: String?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var name: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var remoteCaCert: String?

    public var remoteSubnet: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [CreateVpnAttachmentRequest.Tags]?

    public var tunnelOptionsSpecification: [CreateVpnAttachmentRequest.TunnelOptionsSpecification]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoConfigRoute != nil {
            map["AutoConfigRoute"] = self.autoConfigRoute!
        }
        if self.bgpConfig != nil {
            map["BgpConfig"] = self.bgpConfig!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.healthCheckConfig != nil {
            map["HealthCheckConfig"] = self.healthCheckConfig!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCaCert != nil {
            map["RemoteCaCert"] = self.remoteCaCert!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoConfigRoute") {
            self.autoConfigRoute = dict["AutoConfigRoute"] as! Bool
        }
        if dict.keys.contains("BgpConfig") {
            self.bgpConfig = dict["BgpConfig"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("EffectImmediately") {
            self.effectImmediately = dict["EffectImmediately"] as! Bool
        }
        if dict.keys.contains("EnableDpd") {
            self.enableDpd = dict["EnableDpd"] as! Bool
        }
        if dict.keys.contains("EnableNatTraversal") {
            self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
        }
        if dict.keys.contains("EnableTunnelsBgp") {
            self.enableTunnelsBgp = dict["EnableTunnelsBgp"] as! Bool
        }
        if dict.keys.contains("HealthCheckConfig") {
            self.healthCheckConfig = dict["HealthCheckConfig"] as! String
        }
        if dict.keys.contains("IkeConfig") {
            self.ikeConfig = dict["IkeConfig"] as! String
        }
        if dict.keys.contains("IpsecConfig") {
            self.ipsecConfig = dict["IpsecConfig"] as! String
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteCaCert") {
            self.remoteCaCert = dict["RemoteCaCert"] as! String
        }
        if dict.keys.contains("RemoteSubnet") {
            self.remoteSubnet = dict["RemoteSubnet"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateVpnAttachmentRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateVpnAttachmentRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TunnelOptionsSpecification") {
            var tmp : [CreateVpnAttachmentRequest.TunnelOptionsSpecification] = []
            for v in dict["TunnelOptionsSpecification"] as! [Any] {
                var model = CreateVpnAttachmentRequest.TunnelOptionsSpecification()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tunnelOptionsSpecification = tmp
        }
    }
}

public class CreateVpnAttachmentResponseBody : Tea.TeaModel {
    public var code: String?

    public var createTime: Int64?

    public var message: String?

    public var name: String?

    public var requestId: String?

    public var success: Bool?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class CreateVpnAttachmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnAttachmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpnAttachmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpnConnectionRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalAsn") {
                    self.localAsn = dict["LocalAsn"] as! Int64
                }
                if dict.keys.contains("LocalBgpIp") {
                    self.localBgpIp = dict["LocalBgpIp"] as! String
                }
                if dict.keys.contains("TunnelCidr") {
                    self.tunnelCidr = dict["TunnelCidr"] as! String
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IkeAuthAlg") {
                    self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                }
                if dict.keys.contains("IkeEncAlg") {
                    self.ikeEncAlg = dict["IkeEncAlg"] as! String
                }
                if dict.keys.contains("IkeLifetime") {
                    self.ikeLifetime = dict["IkeLifetime"] as! Int64
                }
                if dict.keys.contains("IkeMode") {
                    self.ikeMode = dict["IkeMode"] as! String
                }
                if dict.keys.contains("IkePfs") {
                    self.ikePfs = dict["IkePfs"] as! String
                }
                if dict.keys.contains("IkeVersion") {
                    self.ikeVersion = dict["IkeVersion"] as! String
                }
                if dict.keys.contains("LocalId") {
                    self.localId = dict["LocalId"] as! String
                }
                if dict.keys.contains("Psk") {
                    self.psk = dict["Psk"] as! String
                }
                if dict.keys.contains("RemoteId") {
                    self.remoteId = dict["RemoteId"] as! String
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpsecAuthAlg") {
                    self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                }
                if dict.keys.contains("IpsecEncAlg") {
                    self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                }
                if dict.keys.contains("IpsecLifetime") {
                    self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
                }
                if dict.keys.contains("IpsecPfs") {
                    self.ipsecPfs = dict["IpsecPfs"] as! String
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var remoteCaCertificate: String?

        public var role: String?

        public var tunnelBgpConfig: CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelIkeConfig: CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIpsecConfig: CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.remoteCaCertificate != nil {
                map["RemoteCaCertificate"] = self.remoteCaCertificate!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomerGatewayId") {
                self.customerGatewayId = dict["CustomerGatewayId"] as! String
            }
            if dict.keys.contains("EnableDpd") {
                self.enableDpd = dict["EnableDpd"] as! Bool
            }
            if dict.keys.contains("EnableNatTraversal") {
                self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
            }
            if dict.keys.contains("RemoteCaCertificate") {
                self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("TunnelBgpConfig") {
                var model = CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
                self.tunnelBgpConfig = model
            }
            if dict.keys.contains("TunnelIkeConfig") {
                var model = CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
                self.tunnelIkeConfig = model
            }
            if dict.keys.contains("TunnelIpsecConfig") {
                var model = CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var autoConfigRoute: Bool?

    public var bgpConfig: String?

    public var clientToken: String?

    public var customerGatewayId: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var healthCheckConfig: String?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var remoteCaCertificate: String?

    public var remoteSubnet: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [CreateVpnConnectionRequest.Tags]?

    public var tunnelOptionsSpecification: [CreateVpnConnectionRequest.TunnelOptionsSpecification]?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoConfigRoute != nil {
            map["AutoConfigRoute"] = self.autoConfigRoute!
        }
        if self.bgpConfig != nil {
            map["BgpConfig"] = self.bgpConfig!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.healthCheckConfig != nil {
            map["HealthCheckConfig"] = self.healthCheckConfig!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCaCertificate != nil {
            map["RemoteCaCertificate"] = self.remoteCaCertificate!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoConfigRoute") {
            self.autoConfigRoute = dict["AutoConfigRoute"] as! Bool
        }
        if dict.keys.contains("BgpConfig") {
            self.bgpConfig = dict["BgpConfig"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("EffectImmediately") {
            self.effectImmediately = dict["EffectImmediately"] as! Bool
        }
        if dict.keys.contains("EnableDpd") {
            self.enableDpd = dict["EnableDpd"] as! Bool
        }
        if dict.keys.contains("EnableNatTraversal") {
            self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
        }
        if dict.keys.contains("EnableTunnelsBgp") {
            self.enableTunnelsBgp = dict["EnableTunnelsBgp"] as! Bool
        }
        if dict.keys.contains("HealthCheckConfig") {
            self.healthCheckConfig = dict["HealthCheckConfig"] as! String
        }
        if dict.keys.contains("IkeConfig") {
            self.ikeConfig = dict["IkeConfig"] as! String
        }
        if dict.keys.contains("IpsecConfig") {
            self.ipsecConfig = dict["IpsecConfig"] as! String
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteCaCertificate") {
            self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
        }
        if dict.keys.contains("RemoteSubnet") {
            self.remoteSubnet = dict["RemoteSubnet"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [CreateVpnConnectionRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = CreateVpnConnectionRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TunnelOptionsSpecification") {
            var tmp : [CreateVpnConnectionRequest.TunnelOptionsSpecification] = []
            for v in dict["TunnelOptionsSpecification"] as! [Any] {
                var model = CreateVpnConnectionRequest.TunnelOptionsSpecification()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tunnelOptionsSpecification = tmp
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class CreateVpnConnectionResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var name: String?

    public var requestId: String?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class CreateVpnConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpnConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpnGatewayRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var bandwidth: Int32?

    public var clientToken: String?

    public var disasterRecoveryVSwitchId: String?

    public var enableIpsec: Bool?

    public var enableSsl: Bool?

    public var instanceChargeType: String?

    public var name: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslConnections: Int32?

    public var vSwitchId: String?

    public var vpcId: String?

    public var vpnType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disasterRecoveryVSwitchId != nil {
            map["DisasterRecoveryVSwitchId"] = self.disasterRecoveryVSwitchId!
        }
        if self.enableIpsec != nil {
            map["EnableIpsec"] = self.enableIpsec!
        }
        if self.enableSsl != nil {
            map["EnableSsl"] = self.enableSsl!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslConnections != nil {
            map["SslConnections"] = self.sslConnections!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpnType != nil {
            map["VpnType"] = self.vpnType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DisasterRecoveryVSwitchId") {
            self.disasterRecoveryVSwitchId = dict["DisasterRecoveryVSwitchId"] as! String
        }
        if dict.keys.contains("EnableIpsec") {
            self.enableIpsec = dict["EnableIpsec"] as! Bool
        }
        if dict.keys.contains("EnableSsl") {
            self.enableSsl = dict["EnableSsl"] as! Bool
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslConnections") {
            self.sslConnections = dict["SslConnections"] as! Int32
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpnType") {
            self.vpnType = dict["VpnType"] as! String
        }
    }
}

public class CreateVpnGatewayResponseBody : Tea.TeaModel {
    public var name: String?

    public var orderId: Int64?

    public var requestId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class CreateVpnGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpnGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpnPbrRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var publishVpc: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.publishVpc != nil {
            map["PublishVpc"] = self.publishVpc!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("PublishVpc") {
            self.publishVpc = dict["PublishVpc"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("RouteSource") {
            self.routeSource = dict["RouteSource"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class CreateVpnPbrRouteEntryResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var description_: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var priority: Int32?

    public var requestId: String?

    public var routeDest: String?

    public var routeSource: String?

    public var state: String?

    public var vpnInstanceId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.vpnInstanceId != nil {
            map["VpnInstanceId"] = self.vpnInstanceId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("RouteSource") {
            self.routeSource = dict["RouteSource"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("VpnInstanceId") {
            self.vpnInstanceId = dict["VpnInstanceId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class CreateVpnPbrRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnPbrRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpnPbrRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpnRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publishVpc: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publishVpc != nil {
            map["PublishVpc"] = self.publishVpc!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PublishVpc") {
            self.publishVpc = dict["PublishVpc"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class CreateVpnRouteEntryResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var description_: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var requestId: String?

    public var routeDest: String?

    public var state: String?

    public var vpnInstanceId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.vpnInstanceId != nil {
            map["VpnInstanceId"] = self.vpnInstanceId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("VpnInstanceId") {
            self.vpnInstanceId = dict["VpnInstanceId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class CreateVpnRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpnRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeactivateRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class DeactivateRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeactivateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeactivateRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeactiveFlowLogRequest : Tea.TeaModel {
    public var flowLogId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowLogId") {
            self.flowLogId = dict["FlowLogId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeactiveFlowLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeactiveFlowLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactiveFlowLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeactiveFlowLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBgpGroupRequest : Tea.TeaModel {
    public var bgpGroupId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpGroupId") {
            self.bgpGroupId = dict["BgpGroupId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteBgpGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBgpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBgpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBgpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBgpNetworkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dstCidrBlock: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dstCidrBlock != nil {
            map["DstCidrBlock"] = self.dstCidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DstCidrBlock") {
            self.dstCidrBlock = dict["DstCidrBlock"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
    }
}

public class DeleteBgpNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBgpNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBgpNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBgpNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBgpPeerRequest : Tea.TeaModel {
    public var bgpPeerId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpPeerId != nil {
            map["BgpPeerId"] = self.bgpPeerId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpPeerId") {
            self.bgpPeerId = dict["BgpPeerId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteBgpPeerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBgpPeerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBgpPeerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBgpPeerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCommonBandwidthPackageRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var force: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteCommonBandwidthPackageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCommonBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCommonBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCommonBandwidthPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomerGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var customerGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteCustomerGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomerGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomerGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomerGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDhcpOptionsSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDhcpOptionsSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDhcpOptionsSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDhcpOptionsSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDhcpOptionsSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteExpressConnectTrafficQosRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DeleteExpressConnectTrafficQosResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteExpressConnectTrafficQosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExpressConnectTrafficQosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteExpressConnectTrafficQosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteExpressConnectTrafficQosQueueRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DeleteExpressConnectTrafficQosQueueResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteExpressConnectTrafficQosQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExpressConnectTrafficQosQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteExpressConnectTrafficQosQueueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteExpressConnectTrafficQosRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class DeleteExpressConnectTrafficQosRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteExpressConnectTrafficQosRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExpressConnectTrafficQosRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteExpressConnectTrafficQosRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DeleteFailoverTestJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFailoverTestJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowLogRequest : Tea.TeaModel {
    public var flowLogId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowLogId") {
            self.flowLogId = dict["FlowLogId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteFlowLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteFlowLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFlowLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteForwardEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var forwardEntryId: String?

    public var forwardTableId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardTableId") {
            self.forwardTableId = dict["ForwardTableId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFullNatEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var fullNatEntryId: String?

    public var fullNatTableId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.fullNatEntryId != nil {
            map["FullNatEntryId"] = self.fullNatEntryId!
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("FullNatEntryId") {
            self.fullNatEntryId = dict["FullNatEntryId"] as! String
        }
        if dict.keys.contains("FullNatTableId") {
            self.fullNatTableId = dict["FullNatTableId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteFullNatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFullNatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFullNatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFullNatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGlobalAccelerationInstanceRequest : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalAccelerationInstanceId") {
            self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteGlobalAccelerationInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGlobalAccelerationInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGlobalAccelerationInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGlobalAccelerationInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var haVipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIPv6TranslatorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorId") {
            self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteIPv6TranslatorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIPv6TranslatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIPv6TranslatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIPv6TranslatorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIPv6TranslatorAclListRequest : Tea.TeaModel {
    public var aclId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteIPv6TranslatorAclListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIPv6TranslatorAclListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIPv6TranslatorAclListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIPv6TranslatorAclListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIPv6TranslatorEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6TranslatorEntryId: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6TranslatorEntryId != nil {
            map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorEntryId") {
            self.ipv6TranslatorEntryId = dict["Ipv6TranslatorEntryId"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorId") {
            self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteIPv6TranslatorEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIPv6TranslatorEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIPv6TranslatorEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIPv6TranslatorEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIpsecServerRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: String?

    public var ipsecServerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! String
        }
        if dict.keys.contains("IpsecServerId") {
            self.ipsecServerId = dict["IpsecServerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteIpsecServerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIpsecServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpsecServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIpsecServerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIpv4GatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var internetMode: String?

    public var ipv4GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.internetMode != nil {
            map["InternetMode"] = self.internetMode!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InternetMode") {
            self.internetMode = dict["InternetMode"] as! String
        }
        if dict.keys.contains("Ipv4GatewayId") {
            self.ipv4GatewayId = dict["Ipv4GatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteIpv4GatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIpv4GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpv4GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIpv4GatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIpv6EgressOnlyRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6EgressOnlyRuleId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6EgressOnlyRuleId != nil {
            map["Ipv6EgressOnlyRuleId"] = self.ipv6EgressOnlyRuleId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Ipv6EgressOnlyRuleId") {
            self.ipv6EgressOnlyRuleId = dict["Ipv6EgressOnlyRuleId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteIpv6EgressOnlyRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIpv6EgressOnlyRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpv6EgressOnlyRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIpv6EgressOnlyRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIpv6GatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv6GatewayId") {
            self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteIpv6GatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIpv6GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpv6GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIpv6GatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIpv6InternetBandwidthRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6AddressId: String?

    public var ipv6InternetBandwidthId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ipv6InternetBandwidthId != nil {
            map["Ipv6InternetBandwidthId"] = self.ipv6InternetBandwidthId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv6AddressId") {
            self.ipv6AddressId = dict["Ipv6AddressId"] as! String
        }
        if dict.keys.contains("Ipv6InternetBandwidthId") {
            self.ipv6InternetBandwidthId = dict["Ipv6InternetBandwidthId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteIpv6InternetBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIpv6InternetBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpv6InternetBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIpv6InternetBandwidthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNatGatewayRequest : Tea.TeaModel {
    public var force: Bool?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteNatGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNatGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNatIpRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natIpId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natIpId != nil {
            map["NatIpId"] = self.natIpId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NatIpId") {
            self.natIpId = dict["NatIpId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteNatIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNatIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNatIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNatIpCidrRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatIpCidr") {
            self.natIpCidr = dict["NatIpCidr"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteNatIpCidrResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNatIpCidrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatIpCidrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNatIpCidrResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkAclRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeletePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePublicIpAddressPoolRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PublicIpAddressPoolId") {
            self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeletePublicIpAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePublicIpAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePublicIpAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePublicIpAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePublicIpAddressPoolCidrBlockRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PublicIpAddressPoolId") {
            self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeletePublicIpAddressPoolCidrBlockResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePublicIpAddressPoolCidrBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePublicIpAddressPoolCidrBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePublicIpAddressPoolCidrBlockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRouteEntriesRequest : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public var dstCidrBlock: String?

        public var nextHop: String?

        public var routeEntryId: String?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstCidrBlock != nil {
                map["DstCidrBlock"] = self.dstCidrBlock!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            if self.routeEntryId != nil {
                map["RouteEntryId"] = self.routeEntryId!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DstCidrBlock") {
                self.dstCidrBlock = dict["DstCidrBlock"] as! String
            }
            if dict.keys.contains("NextHop") {
                self.nextHop = dict["NextHop"] as! String
            }
            if dict.keys.contains("RouteEntryId") {
                self.routeEntryId = dict["RouteEntryId"] as! String
            }
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntries: [DeleteRouteEntriesRequest.RouteEntries]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntries") {
            var tmp : [DeleteRouteEntriesRequest.RouteEntries] = []
            for v in dict["RouteEntries"] as! [Any] {
                var model = DeleteRouteEntriesRequest.RouteEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeEntries = tmp
        }
    }
}

public class DeleteRouteEntriesResponseBody : Tea.TeaModel {
    public class FailedRouteEntries : Tea.TeaModel {
        public var dstCidrBlock: String?

        public var failedCode: String?

        public var failedMessage: String?

        public var nextHop: String?

        public var routeEntryId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstCidrBlock != nil {
                map["DstCidrBlock"] = self.dstCidrBlock!
            }
            if self.failedCode != nil {
                map["FailedCode"] = self.failedCode!
            }
            if self.failedMessage != nil {
                map["FailedMessage"] = self.failedMessage!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            if self.routeEntryId != nil {
                map["RouteEntryId"] = self.routeEntryId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DstCidrBlock") {
                self.dstCidrBlock = dict["DstCidrBlock"] as! String
            }
            if dict.keys.contains("FailedCode") {
                self.failedCode = dict["FailedCode"] as! String
            }
            if dict.keys.contains("FailedMessage") {
                self.failedMessage = dict["FailedMessage"] as! String
            }
            if dict.keys.contains("NextHop") {
                self.nextHop = dict["NextHop"] as! String
            }
            if dict.keys.contains("RouteEntryId") {
                self.routeEntryId = dict["RouteEntryId"] as! String
            }
        }
    }
    public var failedCount: Int32?

    public var failedRouteEntries: [DeleteRouteEntriesResponseBody.FailedRouteEntries]?

    public var requestId: String?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.failedRouteEntries != nil {
            var tmp : [Any] = []
            for k in self.failedRouteEntries! {
                tmp.append(k.toMap())
            }
            map["FailedRouteEntries"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedCount") {
            self.failedCount = dict["FailedCount"] as! Int32
        }
        if dict.keys.contains("FailedRouteEntries") {
            var tmp : [DeleteRouteEntriesResponseBody.FailedRouteEntries] = []
            for v in dict["FailedRouteEntries"] as! [Any] {
                var model = DeleteRouteEntriesResponseBody.FailedRouteEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.failedRouteEntries = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
    }
}

public class DeleteRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRouteEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRouteEntryRequest : Tea.TeaModel {
    public class NextHopList : Tea.TeaModel {
        public var nextHopId: String?

        public var nextHopType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextHopId") {
                self.nextHopId = dict["NextHopId"] as! String
            }
            if dict.keys.contains("NextHopType") {
                self.nextHopType = dict["NextHopType"] as! String
            }
        }
    }
    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopList: [DeleteRouteEntryRequest.NextHopList]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryId: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopList != nil {
            var tmp : [Any] = []
            for k in self.nextHopList! {
                tmp.append(k.toMap())
            }
            map["NextHopList"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("NextHopId") {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopList") {
            var tmp : [DeleteRouteEntryRequest.NextHopList] = []
            for v in dict["NextHopList"] as! [Any] {
                var model = DeleteRouteEntryRequest.NextHopList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nextHopList = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntryId") {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class DeleteRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRouteTableRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class DeleteRouteTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteRouteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRouteTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRouterInterfaceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class DeleteRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnatEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snatEntryId: String?

    public var snatTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatTableId != nil {
            map["SnatTableId"] = self.snatTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatTableId") {
            self.snatTableId = dict["SnatTableId"] as! String
        }
    }
}

public class DeleteSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSslVpnClientCertRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslVpnClientCertId") {
            self.sslVpnClientCertId = dict["SslVpnClientCertId"] as! String
        }
    }
}

public class DeleteSslVpnClientCertResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSslVpnClientCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSslVpnClientCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSslVpnClientCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSslVpnServerRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslVpnServerId") {
            self.sslVpnServerId = dict["SslVpnServerId"] as! String
        }
    }
}

public class DeleteSslVpnServerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSslVpnServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSslVpnServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSslVpnServerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTrafficMirrorFilterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrafficMirrorFilterId") {
            self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
        }
    }
}

public class DeleteTrafficMirrorFilterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTrafficMirrorFilterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficMirrorFilterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTrafficMirrorFilterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTrafficMirrorFilterRulesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorFilterRuleIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorFilterRuleIds != nil {
            map["TrafficMirrorFilterRuleIds"] = self.trafficMirrorFilterRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrafficMirrorFilterId") {
            self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
        }
        if dict.keys.contains("TrafficMirrorFilterRuleIds") {
            self.trafficMirrorFilterRuleIds = dict["TrafficMirrorFilterRuleIds"] as! [String]
        }
    }
}

public class DeleteTrafficMirrorFilterRulesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTrafficMirrorFilterRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficMirrorFilterRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTrafficMirrorFilterRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTrafficMirrorSessionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrafficMirrorSessionId") {
            self.trafficMirrorSessionId = dict["TrafficMirrorSessionId"] as! String
        }
    }
}

public class DeleteTrafficMirrorSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTrafficMirrorSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficMirrorSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTrafficMirrorSessionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVSwitchRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DeleteVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVSwitchCidrReservationRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchCidrReservationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchCidrReservationId != nil {
            map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchCidrReservationId") {
            self.vSwitchCidrReservationId = dict["VSwitchCidrReservationId"] as! String
        }
    }
}

public class DeleteVSwitchCidrReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVSwitchCidrReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVSwitchCidrReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVSwitchCidrReservationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVbrHaRequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteVbrHaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVbrHaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVbrHaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVbrHaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVcoRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnConnectionId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class DeleteVcoRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVcoRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVcoRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVcoRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class DeleteVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpcRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var forceDelete: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceDelete != nil {
            map["ForceDelete"] = self.forceDelete!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ForceDelete") {
            self.forceDelete = dict["ForceDelete"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DeleteVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpcGatewayEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointId") {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteVpcGatewayEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVpcGatewayEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcGatewayEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpcGatewayEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpcPrefixListRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteVpcPrefixListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVpcPrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcPrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpcPrefixListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpnAttachmentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class DeleteVpnAttachmentResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteVpnAttachmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnAttachmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpnAttachmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpnConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class DeleteVpnConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVpnConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpnConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpnGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DeleteVpnGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVpnGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpnGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpnPbrRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("RouteSource") {
            self.routeSource = dict["RouteSource"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class DeleteVpnPbrRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVpnPbrRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnPbrRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpnPbrRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpnRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class DeleteVpnRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVpnRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpnRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletionProtectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var ownerId: Int64?

    public var protectionEnable: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.protectionEnable != nil {
            map["ProtectionEnable"] = self.protectionEnable!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProtectionEnable") {
            self.protectionEnable = dict["ProtectionEnable"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DeletionProtectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletionProtectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletionProtectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletionProtectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class Describe95TrafficRequest : Tea.TeaModel {
    public var day: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.day != nil {
            map["Day"] = self.day!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Day") {
            self.day = dict["Day"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class Describe95TrafficResponseBody : Tea.TeaModel {
    public class Traffic95Summary : Tea.TeaModel {
        public class Traffic95DetailList : Tea.TeaModel {
            public class Traffic95Detail : Tea.TeaModel {
                public var billBandwidth: String?

                public var inBandwidth: String?

                public var outBandwidth: String?

                public var time: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.billBandwidth != nil {
                        map["BillBandwidth"] = self.billBandwidth!
                    }
                    if self.inBandwidth != nil {
                        map["InBandwidth"] = self.inBandwidth!
                    }
                    if self.outBandwidth != nil {
                        map["OutBandwidth"] = self.outBandwidth!
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BillBandwidth") {
                        self.billBandwidth = dict["BillBandwidth"] as! String
                    }
                    if dict.keys.contains("InBandwidth") {
                        self.inBandwidth = dict["InBandwidth"] as! String
                    }
                    if dict.keys.contains("OutBandwidth") {
                        self.outBandwidth = dict["OutBandwidth"] as! String
                    }
                    if dict.keys.contains("Time") {
                        self.time = dict["Time"] as! String
                    }
                }
            }
            public var traffic95Detail: [Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList.Traffic95Detail]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.traffic95Detail != nil {
                    var tmp : [Any] = []
                    for k in self.traffic95Detail! {
                        tmp.append(k.toMap())
                    }
                    map["Traffic95Detail"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Traffic95Detail") {
                    var tmp : [Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList.Traffic95Detail] = []
                    for v in dict["Traffic95Detail"] as! [Any] {
                        var model = Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList.Traffic95Detail()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.traffic95Detail = tmp
                }
            }
        }
        public var bandwidth: Int64?

        public var fifthPeakBandwidth: String?

        public var instanceId: String?

        public var internetChargeType: String?

        public var minimumConsumeBandwidth: String?

        public var traffic95DetailList: Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.traffic95DetailList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.fifthPeakBandwidth != nil {
                map["FifthPeakBandwidth"] = self.fifthPeakBandwidth!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.minimumConsumeBandwidth != nil {
                map["MinimumConsumeBandwidth"] = self.minimumConsumeBandwidth!
            }
            if self.traffic95DetailList != nil {
                map["Traffic95DetailList"] = self.traffic95DetailList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") {
                self.bandwidth = dict["Bandwidth"] as! Int64
            }
            if dict.keys.contains("FifthPeakBandwidth") {
                self.fifthPeakBandwidth = dict["FifthPeakBandwidth"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InternetChargeType") {
                self.internetChargeType = dict["InternetChargeType"] as! String
            }
            if dict.keys.contains("MinimumConsumeBandwidth") {
                self.minimumConsumeBandwidth = dict["MinimumConsumeBandwidth"] as! String
            }
            if dict.keys.contains("Traffic95DetailList") {
                var model = Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList()
                model.fromMap(dict["Traffic95DetailList"] as! [String: Any])
                self.traffic95DetailList = model
            }
        }
    }
    public var requestId: String?

    public var traffic95Summary: Describe95TrafficResponseBody.Traffic95Summary?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.traffic95Summary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traffic95Summary != nil {
            map["Traffic95Summary"] = self.traffic95Summary?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Traffic95Summary") {
            var model = Describe95TrafficResponseBody.Traffic95Summary()
            model.fromMap(dict["Traffic95Summary"] as! [String: Any])
            self.traffic95Summary = model
        }
    }
}

public class Describe95TrafficResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: Describe95TrafficResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = Describe95TrafficResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccessPointsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeAccessPointsResponseBody : Tea.TeaModel {
    public class AccessPointSet : Tea.TeaModel {
        public class AccessPointType : Tea.TeaModel {
            public class AccessPointFeatureModels : Tea.TeaModel {
                public class AccessPointFeatureModel : Tea.TeaModel {
                    public var featureKey: String?

                    public var featureValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.featureKey != nil {
                            map["FeatureKey"] = self.featureKey!
                        }
                        if self.featureValue != nil {
                            map["FeatureValue"] = self.featureValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FeatureKey") {
                            self.featureKey = dict["FeatureKey"] as! String
                        }
                        if dict.keys.contains("FeatureValue") {
                            self.featureValue = dict["FeatureValue"] as! String
                        }
                    }
                }
                public var accessPointFeatureModel: [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels.AccessPointFeatureModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessPointFeatureModel != nil {
                        var tmp : [Any] = []
                        for k in self.accessPointFeatureModel! {
                            tmp.append(k.toMap())
                        }
                        map["AccessPointFeatureModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AccessPointFeatureModel") {
                        var tmp : [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels.AccessPointFeatureModel] = []
                        for v in dict["AccessPointFeatureModel"] as! [Any] {
                            var model = DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels.AccessPointFeatureModel()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.accessPointFeatureModel = tmp
                    }
                }
            }
            public var accessPointFeatureModels: DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels?

            public var accessPointId: String?

            public var attachedRegionNo: String?

            public var description_: String?

            public var hostOperator: String?

            public var location: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.accessPointFeatureModels?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointFeatureModels != nil {
                    map["AccessPointFeatureModels"] = self.accessPointFeatureModels?.toMap()
                }
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.attachedRegionNo != nil {
                    map["AttachedRegionNo"] = self.attachedRegionNo!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hostOperator != nil {
                    map["HostOperator"] = self.hostOperator!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessPointFeatureModels") {
                    var model = DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels()
                    model.fromMap(dict["AccessPointFeatureModels"] as! [String: Any])
                    self.accessPointFeatureModels = model
                }
                if dict.keys.contains("AccessPointId") {
                    self.accessPointId = dict["AccessPointId"] as! String
                }
                if dict.keys.contains("AttachedRegionNo") {
                    self.attachedRegionNo = dict["AttachedRegionNo"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HostOperator") {
                    self.hostOperator = dict["HostOperator"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var accessPointType: [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointType != nil {
                var tmp : [Any] = []
                for k in self.accessPointType! {
                    tmp.append(k.toMap())
                }
                map["AccessPointType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessPointType") {
                var tmp : [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType] = []
                for v in dict["AccessPointType"] as! [Any] {
                    var model = DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.accessPointType = tmp
            }
        }
    }
    public var accessPointSet: DescribeAccessPointsResponseBody.AccessPointSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessPointSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointSet != nil {
            map["AccessPointSet"] = self.accessPointSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPointSet") {
            var model = DescribeAccessPointsResponseBody.AccessPointSet()
            model.fromMap(dict["AccessPointSet"] as! [String: Any])
            self.accessPointSet = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAccessPointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccessPointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAccessPointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBgpGroupsRequest : Tea.TeaModel {
    public var bgpGroupId: String?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpGroupId") {
            self.bgpGroupId = dict["BgpGroupId"] as! String
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
    }
}

public class DescribeBgpGroupsResponseBody : Tea.TeaModel {
    public class BgpGroups : Tea.TeaModel {
        public class BgpGroup : Tea.TeaModel {
            public var authKey: String?

            public var bgpGroupId: String?

            public var description_: String?

            public var hold: String?

            public var ipVersion: String?

            public var isFake: String?

            public var keepalive: String?

            public var localAsn: String?

            public var name: String?

            public var peerAsn: String?

            public var regionId: String?

            public var routeLimit: String?

            public var routerId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authKey != nil {
                    map["AuthKey"] = self.authKey!
                }
                if self.bgpGroupId != nil {
                    map["BgpGroupId"] = self.bgpGroupId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hold != nil {
                    map["Hold"] = self.hold!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.isFake != nil {
                    map["IsFake"] = self.isFake!
                }
                if self.keepalive != nil {
                    map["Keepalive"] = self.keepalive!
                }
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.peerAsn != nil {
                    map["PeerAsn"] = self.peerAsn!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.routeLimit != nil {
                    map["RouteLimit"] = self.routeLimit!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthKey") {
                    self.authKey = dict["AuthKey"] as! String
                }
                if dict.keys.contains("BgpGroupId") {
                    self.bgpGroupId = dict["BgpGroupId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Hold") {
                    self.hold = dict["Hold"] as! String
                }
                if dict.keys.contains("IpVersion") {
                    self.ipVersion = dict["IpVersion"] as! String
                }
                if dict.keys.contains("IsFake") {
                    self.isFake = dict["IsFake"] as! String
                }
                if dict.keys.contains("Keepalive") {
                    self.keepalive = dict["Keepalive"] as! String
                }
                if dict.keys.contains("LocalAsn") {
                    self.localAsn = dict["LocalAsn"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PeerAsn") {
                    self.peerAsn = dict["PeerAsn"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RouteLimit") {
                    self.routeLimit = dict["RouteLimit"] as! String
                }
                if dict.keys.contains("RouterId") {
                    self.routerId = dict["RouterId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var bgpGroup: [DescribeBgpGroupsResponseBody.BgpGroups.BgpGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bgpGroup != nil {
                var tmp : [Any] = []
                for k in self.bgpGroup! {
                    tmp.append(k.toMap())
                }
                map["BgpGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BgpGroup") {
                var tmp : [DescribeBgpGroupsResponseBody.BgpGroups.BgpGroup] = []
                for v in dict["BgpGroup"] as! [Any] {
                    var model = DescribeBgpGroupsResponseBody.BgpGroups.BgpGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bgpGroup = tmp
            }
        }
    }
    public var bgpGroups: DescribeBgpGroupsResponseBody.BgpGroups?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bgpGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroups != nil {
            map["BgpGroups"] = self.bgpGroups?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpGroups") {
            var model = DescribeBgpGroupsResponseBody.BgpGroups()
            model.fromMap(dict["BgpGroups"] as! [String: Any])
            self.bgpGroups = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeBgpGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBgpGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBgpGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBgpNetworksRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
    }
}

public class DescribeBgpNetworksResponseBody : Tea.TeaModel {
    public class BgpNetworks : Tea.TeaModel {
        public class BgpNetwork : Tea.TeaModel {
            public var dstCidrBlock: String?

            public var routerId: String?

            public var status: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dstCidrBlock != nil {
                    map["DstCidrBlock"] = self.dstCidrBlock!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DstCidrBlock") {
                    self.dstCidrBlock = dict["DstCidrBlock"] as! String
                }
                if dict.keys.contains("RouterId") {
                    self.routerId = dict["RouterId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var bgpNetwork: [DescribeBgpNetworksResponseBody.BgpNetworks.BgpNetwork]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bgpNetwork != nil {
                var tmp : [Any] = []
                for k in self.bgpNetwork! {
                    tmp.append(k.toMap())
                }
                map["BgpNetwork"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BgpNetwork") {
                var tmp : [DescribeBgpNetworksResponseBody.BgpNetworks.BgpNetwork] = []
                for v in dict["BgpNetwork"] as! [Any] {
                    var model = DescribeBgpNetworksResponseBody.BgpNetworks.BgpNetwork()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bgpNetwork = tmp
            }
        }
    }
    public var bgpNetworks: DescribeBgpNetworksResponseBody.BgpNetworks?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bgpNetworks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpNetworks != nil {
            map["BgpNetworks"] = self.bgpNetworks?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpNetworks") {
            var model = DescribeBgpNetworksResponseBody.BgpNetworks()
            model.fromMap(dict["BgpNetworks"] as! [String: Any])
            self.bgpNetworks = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeBgpNetworksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBgpNetworksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBgpNetworksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBgpPeersRequest : Tea.TeaModel {
    public var bgpGroupId: String?

    public var bgpPeerId: String?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.bgpPeerId != nil {
            map["BgpPeerId"] = self.bgpPeerId!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpGroupId") {
            self.bgpGroupId = dict["BgpGroupId"] as! String
        }
        if dict.keys.contains("BgpPeerId") {
            self.bgpPeerId = dict["BgpPeerId"] as! String
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
    }
}

public class DescribeBgpPeersResponseBody : Tea.TeaModel {
    public class BgpPeers : Tea.TeaModel {
        public class BgpPeer : Tea.TeaModel {
            public var advertisedRouteCount: Int32?

            public var authKey: String?

            public var bfdMultiHop: Int32?

            public var bgpGroupId: String?

            public var bgpPeerId: String?

            public var bgpStatus: String?

            public var description_: String?

            public var enableBfd: Bool?

            public var gmtModified: String?

            public var hold: String?

            public var ipVersion: String?

            public var isFake: Bool?

            public var keepalive: String?

            public var localAsn: String?

            public var name: String?

            public var peerAsn: String?

            public var peerIpAddress: String?

            public var receivedRouteCount: Int32?

            public var regionId: String?

            public var routeLimit: String?

            public var routerId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.advertisedRouteCount != nil {
                    map["AdvertisedRouteCount"] = self.advertisedRouteCount!
                }
                if self.authKey != nil {
                    map["AuthKey"] = self.authKey!
                }
                if self.bfdMultiHop != nil {
                    map["BfdMultiHop"] = self.bfdMultiHop!
                }
                if self.bgpGroupId != nil {
                    map["BgpGroupId"] = self.bgpGroupId!
                }
                if self.bgpPeerId != nil {
                    map["BgpPeerId"] = self.bgpPeerId!
                }
                if self.bgpStatus != nil {
                    map["BgpStatus"] = self.bgpStatus!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enableBfd != nil {
                    map["EnableBfd"] = self.enableBfd!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.hold != nil {
                    map["Hold"] = self.hold!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.isFake != nil {
                    map["IsFake"] = self.isFake!
                }
                if self.keepalive != nil {
                    map["Keepalive"] = self.keepalive!
                }
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.peerAsn != nil {
                    map["PeerAsn"] = self.peerAsn!
                }
                if self.peerIpAddress != nil {
                    map["PeerIpAddress"] = self.peerIpAddress!
                }
                if self.receivedRouteCount != nil {
                    map["ReceivedRouteCount"] = self.receivedRouteCount!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.routeLimit != nil {
                    map["RouteLimit"] = self.routeLimit!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdvertisedRouteCount") {
                    self.advertisedRouteCount = dict["AdvertisedRouteCount"] as! Int32
                }
                if dict.keys.contains("AuthKey") {
                    self.authKey = dict["AuthKey"] as! String
                }
                if dict.keys.contains("BfdMultiHop") {
                    self.bfdMultiHop = dict["BfdMultiHop"] as! Int32
                }
                if dict.keys.contains("BgpGroupId") {
                    self.bgpGroupId = dict["BgpGroupId"] as! String
                }
                if dict.keys.contains("BgpPeerId") {
                    self.bgpPeerId = dict["BgpPeerId"] as! String
                }
                if dict.keys.contains("BgpStatus") {
                    self.bgpStatus = dict["BgpStatus"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnableBfd") {
                    self.enableBfd = dict["EnableBfd"] as! Bool
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Hold") {
                    self.hold = dict["Hold"] as! String
                }
                if dict.keys.contains("IpVersion") {
                    self.ipVersion = dict["IpVersion"] as! String
                }
                if dict.keys.contains("IsFake") {
                    self.isFake = dict["IsFake"] as! Bool
                }
                if dict.keys.contains("Keepalive") {
                    self.keepalive = dict["Keepalive"] as! String
                }
                if dict.keys.contains("LocalAsn") {
                    self.localAsn = dict["LocalAsn"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PeerAsn") {
                    self.peerAsn = dict["PeerAsn"] as! String
                }
                if dict.keys.contains("PeerIpAddress") {
                    self.peerIpAddress = dict["PeerIpAddress"] as! String
                }
                if dict.keys.contains("ReceivedRouteCount") {
                    self.receivedRouteCount = dict["ReceivedRouteCount"] as! Int32
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RouteLimit") {
                    self.routeLimit = dict["RouteLimit"] as! String
                }
                if dict.keys.contains("RouterId") {
                    self.routerId = dict["RouterId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var bgpPeer: [DescribeBgpPeersResponseBody.BgpPeers.BgpPeer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bgpPeer != nil {
                var tmp : [Any] = []
                for k in self.bgpPeer! {
                    tmp.append(k.toMap())
                }
                map["BgpPeer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BgpPeer") {
                var tmp : [DescribeBgpPeersResponseBody.BgpPeers.BgpPeer] = []
                for v in dict["BgpPeer"] as! [Any] {
                    var model = DescribeBgpPeersResponseBody.BgpPeers.BgpPeer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bgpPeer = tmp
            }
        }
    }
    public var bgpPeers: DescribeBgpPeersResponseBody.BgpPeers?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bgpPeers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpPeers != nil {
            map["BgpPeers"] = self.bgpPeers?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpPeers") {
            var model = DescribeBgpPeersResponseBody.BgpPeers()
            model.fromMap(dict["BgpPeers"] as! [String: Any])
            self.bgpPeers = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeBgpPeersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBgpPeersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBgpPeersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCommonBandwidthPackagesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var bandwidthPackageId: String?

    public var dryRun: Bool?

    public var includeReservationData: Bool?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var tag: [DescribeCommonBandwidthPackagesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("IncludeReservationData") {
            self.includeReservationData = dict["IncludeReservationData"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityProtectionEnabled") {
            self.securityProtectionEnabled = dict["SecurityProtectionEnabled"] as! Bool
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeCommonBandwidthPackagesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeCommonBandwidthPackagesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeCommonBandwidthPackagesResponseBody : Tea.TeaModel {
    public class CommonBandwidthPackages : Tea.TeaModel {
        public class CommonBandwidthPackage : Tea.TeaModel {
            public class PublicIpAddresses : Tea.TeaModel {
                public class PublicIpAddresse : Tea.TeaModel {
                    public var allocationId: String?

                    public var bandwidthPackageIpRelationStatus: String?

                    public var ipAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allocationId != nil {
                            map["AllocationId"] = self.allocationId!
                        }
                        if self.bandwidthPackageIpRelationStatus != nil {
                            map["BandwidthPackageIpRelationStatus"] = self.bandwidthPackageIpRelationStatus!
                        }
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllocationId") {
                            self.allocationId = dict["AllocationId"] as! String
                        }
                        if dict.keys.contains("BandwidthPackageIpRelationStatus") {
                            self.bandwidthPackageIpRelationStatus = dict["BandwidthPackageIpRelationStatus"] as! String
                        }
                        if dict.keys.contains("IpAddress") {
                            self.ipAddress = dict["IpAddress"] as! String
                        }
                    }
                }
                public var publicIpAddresse: [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses.PublicIpAddresse]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.publicIpAddresse != nil {
                        var tmp : [Any] = []
                        for k in self.publicIpAddresse! {
                            tmp.append(k.toMap())
                        }
                        map["PublicIpAddresse"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PublicIpAddresse") {
                        var tmp : [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses.PublicIpAddresse] = []
                        for v in dict["PublicIpAddresse"] as! [Any] {
                            var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses.PublicIpAddresse()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.publicIpAddresse = tmp
                    }
                }
            }
            public class SecurityProtectionTypes : Tea.TeaModel {
                public var securityProtectionType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityProtectionType != nil {
                        map["SecurityProtectionType"] = self.securityProtectionType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityProtectionType") {
                        self.securityProtectionType = dict["SecurityProtectionType"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var bandwidth: String?

            public var bandwidthPackageId: String?

            public var bizType: String?

            public var businessStatus: String?

            public var creationTime: String?

            public var deletionProtection: Bool?

            public var description_: String?

            public var expiredTime: String?

            public var hasReservationData: String?

            public var ISP: String?

            public var instanceChargeType: String?

            public var internetChargeType: String?

            public var name: String?

            public var publicIpAddresses: DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses?

            public var ratio: Int32?

            public var regionId: String?

            public var reservationActiveTime: String?

            public var reservationBandwidth: String?

            public var reservationInternetChargeType: String?

            public var reservationOrderType: String?

            public var resourceGroupId: String?

            public var securityProtectionTypes: DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.SecurityProtectionTypes?

            public var serviceManaged: Int32?

            public var status: String?

            public var tags: DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.publicIpAddresses?.validate()
                try self.securityProtectionTypes?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthPackageId != nil {
                    map["BandwidthPackageId"] = self.bandwidthPackageId!
                }
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.hasReservationData != nil {
                    map["HasReservationData"] = self.hasReservationData!
                }
                if self.ISP != nil {
                    map["ISP"] = self.ISP!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.publicIpAddresses != nil {
                    map["PublicIpAddresses"] = self.publicIpAddresses?.toMap()
                }
                if self.ratio != nil {
                    map["Ratio"] = self.ratio!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservationActiveTime != nil {
                    map["ReservationActiveTime"] = self.reservationActiveTime!
                }
                if self.reservationBandwidth != nil {
                    map["ReservationBandwidth"] = self.reservationBandwidth!
                }
                if self.reservationInternetChargeType != nil {
                    map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                }
                if self.reservationOrderType != nil {
                    map["ReservationOrderType"] = self.reservationOrderType!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityProtectionTypes != nil {
                    map["SecurityProtectionTypes"] = self.securityProtectionTypes?.toMap()
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! String
                }
                if dict.keys.contains("BandwidthPackageId") {
                    self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
                }
                if dict.keys.contains("BizType") {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DeletionProtection") {
                    self.deletionProtection = dict["DeletionProtection"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("HasReservationData") {
                    self.hasReservationData = dict["HasReservationData"] as! String
                }
                if dict.keys.contains("ISP") {
                    self.ISP = dict["ISP"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InternetChargeType") {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PublicIpAddresses") {
                    var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses()
                    model.fromMap(dict["PublicIpAddresses"] as! [String: Any])
                    self.publicIpAddresses = model
                }
                if dict.keys.contains("Ratio") {
                    self.ratio = dict["Ratio"] as! Int32
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReservationActiveTime") {
                    self.reservationActiveTime = dict["ReservationActiveTime"] as! String
                }
                if dict.keys.contains("ReservationBandwidth") {
                    self.reservationBandwidth = dict["ReservationBandwidth"] as! String
                }
                if dict.keys.contains("ReservationInternetChargeType") {
                    self.reservationInternetChargeType = dict["ReservationInternetChargeType"] as! String
                }
                if dict.keys.contains("ReservationOrderType") {
                    self.reservationOrderType = dict["ReservationOrderType"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SecurityProtectionTypes") {
                    var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.SecurityProtectionTypes()
                    model.fromMap(dict["SecurityProtectionTypes"] as! [String: Any])
                    self.securityProtectionTypes = model
                }
                if dict.keys.contains("ServiceManaged") {
                    self.serviceManaged = dict["ServiceManaged"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Zone") {
                    self.zone = dict["Zone"] as! String
                }
            }
        }
        public var commonBandwidthPackage: [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commonBandwidthPackage != nil {
                var tmp : [Any] = []
                for k in self.commonBandwidthPackage! {
                    tmp.append(k.toMap())
                }
                map["CommonBandwidthPackage"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommonBandwidthPackage") {
                var tmp : [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage] = []
                for v in dict["CommonBandwidthPackage"] as! [Any] {
                    var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.commonBandwidthPackage = tmp
            }
        }
    }
    public var commonBandwidthPackages: DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonBandwidthPackages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonBandwidthPackages != nil {
            map["CommonBandwidthPackages"] = self.commonBandwidthPackages?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommonBandwidthPackages") {
            var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages()
            model.fromMap(dict["CommonBandwidthPackages"] as! [String: Any])
            self.commonBandwidthPackages = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeCommonBandwidthPackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommonBandwidthPackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCommonBandwidthPackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomerGatewayRequest : Tea.TeaModel {
    public var customerGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeCustomerGatewayResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var tag: [DescribeCustomerGatewayResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") {
                var tmp : [DescribeCustomerGatewayResponseBody.Tags.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = DescribeCustomerGatewayResponseBody.Tags.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public var asn: Int64?

    public var authKey: String?

    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var tags: DescribeCustomerGatewayResponseBody.Tags?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asn != nil {
            map["Asn"] = self.asn!
        }
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asn") {
            self.asn = dict["Asn"] as! Int64
        }
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var model = DescribeCustomerGatewayResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
    }
}

public class DescribeCustomerGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomerGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustomerGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomerGatewaysRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var customerGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeCustomerGatewaysRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeCustomerGatewaysRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeCustomerGatewaysRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeCustomerGatewaysResponseBody : Tea.TeaModel {
    public class CustomerGateways : Tea.TeaModel {
        public class CustomerGateway : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var asn: Int64?

            public var authKey: String?

            public var createTime: Int64?

            public var customerGatewayId: String?

            public var description_: String?

            public var ipAddress: String?

            public var name: String?

            public var resourceGroupId: String?

            public var tags: DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.asn != nil {
                    map["Asn"] = self.asn!
                }
                if self.authKey != nil {
                    map["AuthKey"] = self.authKey!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.customerGatewayId != nil {
                    map["CustomerGatewayId"] = self.customerGatewayId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Asn") {
                    self.asn = dict["Asn"] as! Int64
                }
                if dict.keys.contains("AuthKey") {
                    self.authKey = dict["AuthKey"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CustomerGatewayId") {
                    self.customerGatewayId = dict["CustomerGatewayId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var customerGateway: [DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGateway != nil {
                var tmp : [Any] = []
                for k in self.customerGateway! {
                    tmp.append(k.toMap())
                }
                map["CustomerGateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomerGateway") {
                var tmp : [DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway] = []
                for v in dict["CustomerGateway"] as! [Any] {
                    var model = DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customerGateway = tmp
            }
        }
    }
    public var customerGateways: DescribeCustomerGatewaysResponseBody.CustomerGateways?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customerGateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGateways != nil {
            map["CustomerGateways"] = self.customerGateways?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomerGateways") {
            var model = DescribeCustomerGatewaysResponseBody.CustomerGateways()
            model.fromMap(dict["CustomerGateways"] as! [String: Any])
            self.customerGateways = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeCustomerGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomerGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustomerGatewaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEcGrantRelationRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("VbrRegionNo") {
            self.vbrRegionNo = dict["VbrRegionNo"] as! String
        }
    }
}

public class DescribeEcGrantRelationResponseBody : Tea.TeaModel {
    public class EcGrantRelations : Tea.TeaModel {
        public var aliUid: Int64?

        public var gmtCreate: String?

        public var grantType: String?

        public var instanceId: String?

        public var instanceName: String?

        public var instanceRouterId: String?

        public var regionNo: String?

        public var status: String?

        public var vbrInstanceId: String?

        public var vbrOwnerUid: Int64?

        public var vbrRegionNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.grantType != nil {
                map["GrantType"] = self.grantType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceRouterId != nil {
                map["InstanceRouterId"] = self.instanceRouterId!
            }
            if self.regionNo != nil {
                map["RegionNo"] = self.regionNo!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vbrInstanceId != nil {
                map["VbrInstanceId"] = self.vbrInstanceId!
            }
            if self.vbrOwnerUid != nil {
                map["VbrOwnerUid"] = self.vbrOwnerUid!
            }
            if self.vbrRegionNo != nil {
                map["VbrRegionNo"] = self.vbrRegionNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliUid") {
                self.aliUid = dict["AliUid"] as! Int64
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GrantType") {
                self.grantType = dict["GrantType"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InstanceRouterId") {
                self.instanceRouterId = dict["InstanceRouterId"] as! String
            }
            if dict.keys.contains("RegionNo") {
                self.regionNo = dict["RegionNo"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VbrInstanceId") {
                self.vbrInstanceId = dict["VbrInstanceId"] as! String
            }
            if dict.keys.contains("VbrOwnerUid") {
                self.vbrOwnerUid = dict["VbrOwnerUid"] as! Int64
            }
            if dict.keys.contains("VbrRegionNo") {
                self.vbrRegionNo = dict["VbrRegionNo"] as! String
            }
        }
    }
    public var count: Int32?

    public var ecGrantRelations: [DescribeEcGrantRelationResponseBody.EcGrantRelations]?

    public var page: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.ecGrantRelations != nil {
            var tmp : [Any] = []
            for k in self.ecGrantRelations! {
                tmp.append(k.toMap())
            }
            map["EcGrantRelations"] = tmp
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("EcGrantRelations") {
            var tmp : [DescribeEcGrantRelationResponseBody.EcGrantRelations] = []
            for v in dict["EcGrantRelations"] as! [Any] {
                var model = DescribeEcGrantRelationResponseBody.EcGrantRelations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ecGrantRelations = tmp
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEcGrantRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEcGrantRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEcGrantRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEipAddressesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var filter: [DescribeEipAddressesRequest.Filter]?

    public var allocationId: String?

    public var associatedInstanceId: String?

    public var associatedInstanceType: String?

    public var chargeType: String?

    public var dryRun: Bool?

    public var eipAddress: String?

    public var eipName: String?

    public var ISP: String?

    public var includeReservationData: Bool?

    public var lockReason: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var segmentInstanceId: String?

    public var serviceManaged: Bool?

    public var status: String?

    public var tag: [DescribeEipAddressesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.associatedInstanceId != nil {
            map["AssociatedInstanceId"] = self.associatedInstanceId!
        }
        if self.associatedInstanceType != nil {
            map["AssociatedInstanceType"] = self.associatedInstanceType!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.eipName != nil {
            map["EipName"] = self.eipName!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.segmentInstanceId != nil {
            map["SegmentInstanceId"] = self.segmentInstanceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeEipAddressesRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeEipAddressesRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("AssociatedInstanceId") {
            self.associatedInstanceId = dict["AssociatedInstanceId"] as! String
        }
        if dict.keys.contains("AssociatedInstanceType") {
            self.associatedInstanceType = dict["AssociatedInstanceType"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EipAddress") {
            self.eipAddress = dict["EipAddress"] as! String
        }
        if dict.keys.contains("EipName") {
            self.eipName = dict["EipName"] as! String
        }
        if dict.keys.contains("ISP") {
            self.ISP = dict["ISP"] as! String
        }
        if dict.keys.contains("IncludeReservationData") {
            self.includeReservationData = dict["IncludeReservationData"] as! Bool
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PublicIpAddressPoolId") {
            self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityProtectionEnabled") {
            self.securityProtectionEnabled = dict["SecurityProtectionEnabled"] as! Bool
        }
        if dict.keys.contains("SegmentInstanceId") {
            self.segmentInstanceId = dict["SegmentInstanceId"] as! String
        }
        if dict.keys.contains("ServiceManaged") {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeEipAddressesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeEipAddressesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeEipAddressesResponseBody : Tea.TeaModel {
    public class EipAddresses : Tea.TeaModel {
        public class EipAddress : Tea.TeaModel {
            public class OperationLocks : Tea.TeaModel {
                public class LockReason : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LockReason") {
                            self.lockReason = dict["LockReason"] as! String
                        }
                    }
                }
                public var lockReason: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lockReason != nil {
                        var tmp : [Any] = []
                        for k in self.lockReason! {
                            tmp.append(k.toMap())
                        }
                        map["LockReason"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LockReason") {
                        var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason] = []
                        for v in dict["LockReason"] as! [Any] {
                            var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.lockReason = tmp
                    }
                }
            }
            public class SecurityProtectionTypes : Tea.TeaModel {
                public var securityProtectionType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityProtectionType != nil {
                        map["SecurityProtectionType"] = self.securityProtectionType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityProtectionType") {
                        self.securityProtectionType = dict["SecurityProtectionType"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocationId: String?

            public var allocationTime: String?

            public var bandwidth: String?

            public var bandwidthPackageBandwidth: String?

            public var bandwidthPackageId: String?

            public var bandwidthPackageType: String?

            public var bizType: String?

            public var businessStatus: String?

            public var chargeType: String?

            public var deletionProtection: Bool?

            public var description_: String?

            public var eipBandwidth: String?

            public var expiredTime: String?

            public var HDMonitorStatus: String?

            public var hasReservationData: String?

            public var ISP: String?

            public var instanceId: String?

            public var instanceRegionId: String?

            public var instanceType: String?

            public var internetChargeType: String?

            public var ipAddress: String?

            public var mode: String?

            public var name: String?

            public var netmode: String?

            public var operationLocks: DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks?

            public var privateIpAddress: String?

            public var publicIpAddressPoolId: String?

            public var regionId: String?

            public var reservationActiveTime: String?

            public var reservationBandwidth: String?

            public var reservationInternetChargeType: String?

            public var reservationOrderType: String?

            public var resourceGroupId: String?

            public var secondLimited: Bool?

            public var securityProtectionTypes: DescribeEipAddressesResponseBody.EipAddresses.EipAddress.SecurityProtectionTypes?

            public var segmentInstanceId: String?

            public var serviceManaged: Int32?

            public var status: String?

            public var tags: DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags?

            public var vpcId: String?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.operationLocks?.validate()
                try self.securityProtectionTypes?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationId != nil {
                    map["AllocationId"] = self.allocationId!
                }
                if self.allocationTime != nil {
                    map["AllocationTime"] = self.allocationTime!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthPackageBandwidth != nil {
                    map["BandwidthPackageBandwidth"] = self.bandwidthPackageBandwidth!
                }
                if self.bandwidthPackageId != nil {
                    map["BandwidthPackageId"] = self.bandwidthPackageId!
                }
                if self.bandwidthPackageType != nil {
                    map["BandwidthPackageType"] = self.bandwidthPackageType!
                }
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.HDMonitorStatus != nil {
                    map["HDMonitorStatus"] = self.HDMonitorStatus!
                }
                if self.hasReservationData != nil {
                    map["HasReservationData"] = self.hasReservationData!
                }
                if self.ISP != nil {
                    map["ISP"] = self.ISP!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceRegionId != nil {
                    map["InstanceRegionId"] = self.instanceRegionId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.netmode != nil {
                    map["Netmode"] = self.netmode!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                if self.publicIpAddressPoolId != nil {
                    map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservationActiveTime != nil {
                    map["ReservationActiveTime"] = self.reservationActiveTime!
                }
                if self.reservationBandwidth != nil {
                    map["ReservationBandwidth"] = self.reservationBandwidth!
                }
                if self.reservationInternetChargeType != nil {
                    map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                }
                if self.reservationOrderType != nil {
                    map["ReservationOrderType"] = self.reservationOrderType!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.secondLimited != nil {
                    map["SecondLimited"] = self.secondLimited!
                }
                if self.securityProtectionTypes != nil {
                    map["SecurityProtectionTypes"] = self.securityProtectionTypes?.toMap()
                }
                if self.segmentInstanceId != nil {
                    map["SegmentInstanceId"] = self.segmentInstanceId!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocationId") {
                    self.allocationId = dict["AllocationId"] as! String
                }
                if dict.keys.contains("AllocationTime") {
                    self.allocationTime = dict["AllocationTime"] as! String
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! String
                }
                if dict.keys.contains("BandwidthPackageBandwidth") {
                    self.bandwidthPackageBandwidth = dict["BandwidthPackageBandwidth"] as! String
                }
                if dict.keys.contains("BandwidthPackageId") {
                    self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
                }
                if dict.keys.contains("BandwidthPackageType") {
                    self.bandwidthPackageType = dict["BandwidthPackageType"] as! String
                }
                if dict.keys.contains("BizType") {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("DeletionProtection") {
                    self.deletionProtection = dict["DeletionProtection"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EipBandwidth") {
                    self.eipBandwidth = dict["EipBandwidth"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("HDMonitorStatus") {
                    self.HDMonitorStatus = dict["HDMonitorStatus"] as! String
                }
                if dict.keys.contains("HasReservationData") {
                    self.hasReservationData = dict["HasReservationData"] as! String
                }
                if dict.keys.contains("ISP") {
                    self.ISP = dict["ISP"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceRegionId") {
                    self.instanceRegionId = dict["InstanceRegionId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InternetChargeType") {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Netmode") {
                    self.netmode = dict["Netmode"] as! String
                }
                if dict.keys.contains("OperationLocks") {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks()
                    model.fromMap(dict["OperationLocks"] as! [String: Any])
                    self.operationLocks = model
                }
                if dict.keys.contains("PrivateIpAddress") {
                    self.privateIpAddress = dict["PrivateIpAddress"] as! String
                }
                if dict.keys.contains("PublicIpAddressPoolId") {
                    self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReservationActiveTime") {
                    self.reservationActiveTime = dict["ReservationActiveTime"] as! String
                }
                if dict.keys.contains("ReservationBandwidth") {
                    self.reservationBandwidth = dict["ReservationBandwidth"] as! String
                }
                if dict.keys.contains("ReservationInternetChargeType") {
                    self.reservationInternetChargeType = dict["ReservationInternetChargeType"] as! String
                }
                if dict.keys.contains("ReservationOrderType") {
                    self.reservationOrderType = dict["ReservationOrderType"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SecondLimited") {
                    self.secondLimited = dict["SecondLimited"] as! Bool
                }
                if dict.keys.contains("SecurityProtectionTypes") {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.SecurityProtectionTypes()
                    model.fromMap(dict["SecurityProtectionTypes"] as! [String: Any])
                    self.securityProtectionTypes = model
                }
                if dict.keys.contains("SegmentInstanceId") {
                    self.segmentInstanceId = dict["SegmentInstanceId"] as! String
                }
                if dict.keys.contains("ServiceManaged") {
                    self.serviceManaged = dict["ServiceManaged"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("Zone") {
                    self.zone = dict["Zone"] as! String
                }
            }
        }
        public var eipAddress: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipAddress != nil {
                var tmp : [Any] = []
                for k in self.eipAddress! {
                    tmp.append(k.toMap())
                }
                map["EipAddress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipAddress") {
                var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress] = []
                for v in dict["EipAddress"] as! [Any] {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipAddress = tmp
            }
        }
    }
    public var eipAddresses: DescribeEipAddressesResponseBody.EipAddresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipAddresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipAddresses != nil {
            map["EipAddresses"] = self.eipAddresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipAddresses") {
            var model = DescribeEipAddressesResponseBody.EipAddresses()
            model.fromMap(dict["EipAddresses"] as! [String: Any])
            self.eipAddresses = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEipAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEipAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEipGatewayInfoRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeEipGatewayInfoResponseBody : Tea.TeaModel {
    public class EipInfos : Tea.TeaModel {
        public class EipInfo : Tea.TeaModel {
            public var ip: String?

            public var ipGw: String?

            public var ipMask: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.ipGw != nil {
                    map["IpGw"] = self.ipGw!
                }
                if self.ipMask != nil {
                    map["IpMask"] = self.ipMask!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("IpGw") {
                    self.ipGw = dict["IpGw"] as! String
                }
                if dict.keys.contains("IpMask") {
                    self.ipMask = dict["IpMask"] as! String
                }
            }
        }
        public var eipInfo: [DescribeEipGatewayInfoResponseBody.EipInfos.EipInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipInfo != nil {
                var tmp : [Any] = []
                for k in self.eipInfo! {
                    tmp.append(k.toMap())
                }
                map["EipInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipInfo") {
                var tmp : [DescribeEipGatewayInfoResponseBody.EipInfos.EipInfo] = []
                for v in dict["EipInfo"] as! [Any] {
                    var model = DescribeEipGatewayInfoResponseBody.EipInfos.EipInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipInfo = tmp
            }
        }
    }
    public var code: String?

    public var eipInfos: DescribeEipGatewayInfoResponseBody.EipInfos?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.eipInfos != nil {
            map["EipInfos"] = self.eipInfos?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("EipInfos") {
            var model = DescribeEipGatewayInfoResponseBody.EipInfos()
            model.fromMap(dict["EipInfos"] as! [String: Any])
            self.eipInfos = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEipGatewayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipGatewayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEipGatewayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEipMonitorDataRequest : Tea.TeaModel {
    public var allocationId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeEipMonitorDataResponseBody : Tea.TeaModel {
    public class EipMonitorDatas : Tea.TeaModel {
        public class EipMonitorData : Tea.TeaModel {
            public var eipBandwidth: Int32?

            public var eipFlow: Int64?

            public var eipPackets: Int32?

            public var eipRX: Int64?

            public var eipTX: Int64?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.eipFlow != nil {
                    map["EipFlow"] = self.eipFlow!
                }
                if self.eipPackets != nil {
                    map["EipPackets"] = self.eipPackets!
                }
                if self.eipRX != nil {
                    map["EipRX"] = self.eipRX!
                }
                if self.eipTX != nil {
                    map["EipTX"] = self.eipTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EipBandwidth") {
                    self.eipBandwidth = dict["EipBandwidth"] as! Int32
                }
                if dict.keys.contains("EipFlow") {
                    self.eipFlow = dict["EipFlow"] as! Int64
                }
                if dict.keys.contains("EipPackets") {
                    self.eipPackets = dict["EipPackets"] as! Int32
                }
                if dict.keys.contains("EipRX") {
                    self.eipRX = dict["EipRX"] as! Int64
                }
                if dict.keys.contains("EipTX") {
                    self.eipTX = dict["EipTX"] as! Int64
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var eipMonitorData: [DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipMonitorData != nil {
                var tmp : [Any] = []
                for k in self.eipMonitorData! {
                    tmp.append(k.toMap())
                }
                map["EipMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipMonitorData") {
                var tmp : [DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData] = []
                for v in dict["EipMonitorData"] as! [Any] {
                    var model = DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipMonitorData = tmp
            }
        }
    }
    public var eipMonitorDatas: DescribeEipMonitorDataResponseBody.EipMonitorDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipMonitorDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipMonitorDatas != nil {
            map["EipMonitorDatas"] = self.eipMonitorDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipMonitorDatas") {
            var model = DescribeEipMonitorDataResponseBody.EipMonitorDatas()
            model.fromMap(dict["EipMonitorDatas"] as! [String: Any])
            self.eipMonitorDatas = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEipMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEipMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEipSegmentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var segmentInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.segmentInstanceId != nil {
            map["SegmentInstanceId"] = self.segmentInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SegmentInstanceId") {
            self.segmentInstanceId = dict["SegmentInstanceId"] as! String
        }
    }
}

public class DescribeEipSegmentResponseBody : Tea.TeaModel {
    public class EipSegments : Tea.TeaModel {
        public class EipSegment : Tea.TeaModel {
            public var creationTime: String?

            public var descritpion: String?

            public var instanceId: String?

            public var ipCount: String?

            public var name: String?

            public var regionId: String?

            public var segment: String?

            public var status: String?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.descritpion != nil {
                    map["Descritpion"] = self.descritpion!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipCount != nil {
                    map["IpCount"] = self.ipCount!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.segment != nil {
                    map["Segment"] = self.segment!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Descritpion") {
                    self.descritpion = dict["Descritpion"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IpCount") {
                    self.ipCount = dict["IpCount"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Segment") {
                    self.segment = dict["Segment"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Zone") {
                    self.zone = dict["Zone"] as! String
                }
            }
        }
        public var eipSegment: [DescribeEipSegmentResponseBody.EipSegments.EipSegment]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipSegment != nil {
                var tmp : [Any] = []
                for k in self.eipSegment! {
                    tmp.append(k.toMap())
                }
                map["EipSegment"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipSegment") {
                var tmp : [DescribeEipSegmentResponseBody.EipSegments.EipSegment] = []
                for v in dict["EipSegment"] as! [Any] {
                    var model = DescribeEipSegmentResponseBody.EipSegments.EipSegment()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipSegment = tmp
            }
        }
    }
    public var eipSegments: DescribeEipSegmentResponseBody.EipSegments?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipSegments?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipSegments != nil {
            map["EipSegments"] = self.eipSegments?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipSegments") {
            var model = DescribeEipSegmentResponseBody.EipSegments()
            model.fromMap(dict["EipSegments"] as! [String: Any])
            self.eipSegments = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEipSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEipSegmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExpressConnectTrafficQosRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosIdList: [String]?

    public var qosNameList: [String]?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var tags: [DescribeExpressConnectTrafficQosRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosIdList != nil {
            map["QosIdList"] = self.qosIdList!
        }
        if self.qosNameList != nil {
            map["QosNameList"] = self.qosNameList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosIdList") {
            self.qosIdList = dict["QosIdList"] as! [String]
        }
        if dict.keys.contains("QosNameList") {
            self.qosNameList = dict["QosNameList"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeExpressConnectTrafficQosRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeExpressConnectTrafficQosRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class DescribeExpressConnectTrafficQosResponseBody : Tea.TeaModel {
    public class QosList : Tea.TeaModel {
        public class AssociatedInstanceList : Tea.TeaModel {
            public var instanceId: String?

            public var instanceProgressing: Int32?

            public var instanceStatus: String?

            public var instanceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceProgressing != nil {
                    map["InstanceProgressing"] = self.instanceProgressing!
                }
                if self.instanceStatus != nil {
                    map["InstanceStatus"] = self.instanceStatus!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceProgressing") {
                    self.instanceProgressing = dict["InstanceProgressing"] as! Int32
                }
                if dict.keys.contains("InstanceStatus") {
                    self.instanceStatus = dict["InstanceStatus"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
            }
        }
        public class QueueList : Tea.TeaModel {
            public var bandwidthPercent: String?

            public var qosId: String?

            public var queueDescription: String?

            public var queueId: String?

            public var queueName: String?

            public var queueType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidthPercent != nil {
                    map["BandwidthPercent"] = self.bandwidthPercent!
                }
                if self.qosId != nil {
                    map["QosId"] = self.qosId!
                }
                if self.queueDescription != nil {
                    map["QueueDescription"] = self.queueDescription!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.queueType != nil {
                    map["QueueType"] = self.queueType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandwidthPercent") {
                    self.bandwidthPercent = dict["BandwidthPercent"] as! String
                }
                if dict.keys.contains("QosId") {
                    self.qosId = dict["QosId"] as! String
                }
                if dict.keys.contains("QueueDescription") {
                    self.queueDescription = dict["QueueDescription"] as! String
                }
                if dict.keys.contains("QueueId") {
                    self.queueId = dict["QueueId"] as! String
                }
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("QueueType") {
                    self.queueType = dict["QueueType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var associatedInstanceList: [DescribeExpressConnectTrafficQosResponseBody.QosList.AssociatedInstanceList]?

        public var progressing: Int32?

        public var qosDescription: String?

        public var qosId: String?

        public var qosName: String?

        public var queueList: [DescribeExpressConnectTrafficQosResponseBody.QosList.QueueList]?

        public var resourceGroupId: String?

        public var status: String?

        public var tags: [DescribeExpressConnectTrafficQosResponseBody.QosList.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associatedInstanceList != nil {
                var tmp : [Any] = []
                for k in self.associatedInstanceList! {
                    tmp.append(k.toMap())
                }
                map["AssociatedInstanceList"] = tmp
            }
            if self.progressing != nil {
                map["Progressing"] = self.progressing!
            }
            if self.qosDescription != nil {
                map["QosDescription"] = self.qosDescription!
            }
            if self.qosId != nil {
                map["QosId"] = self.qosId!
            }
            if self.qosName != nil {
                map["QosName"] = self.qosName!
            }
            if self.queueList != nil {
                var tmp : [Any] = []
                for k in self.queueList! {
                    tmp.append(k.toMap())
                }
                map["QueueList"] = tmp
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociatedInstanceList") {
                var tmp : [DescribeExpressConnectTrafficQosResponseBody.QosList.AssociatedInstanceList] = []
                for v in dict["AssociatedInstanceList"] as! [Any] {
                    var model = DescribeExpressConnectTrafficQosResponseBody.QosList.AssociatedInstanceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.associatedInstanceList = tmp
            }
            if dict.keys.contains("Progressing") {
                self.progressing = dict["Progressing"] as! Int32
            }
            if dict.keys.contains("QosDescription") {
                self.qosDescription = dict["QosDescription"] as! String
            }
            if dict.keys.contains("QosId") {
                self.qosId = dict["QosId"] as! String
            }
            if dict.keys.contains("QosName") {
                self.qosName = dict["QosName"] as! String
            }
            if dict.keys.contains("QueueList") {
                var tmp : [DescribeExpressConnectTrafficQosResponseBody.QosList.QueueList] = []
                for v in dict["QueueList"] as! [Any] {
                    var model = DescribeExpressConnectTrafficQosResponseBody.QosList.QueueList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.queueList = tmp
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeExpressConnectTrafficQosResponseBody.QosList.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeExpressConnectTrafficQosResponseBody.QosList.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var count: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var qosList: [DescribeExpressConnectTrafficQosResponseBody.QosList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.qosList != nil {
            var tmp : [Any] = []
            for k in self.qosList! {
                tmp.append(k.toMap())
            }
            map["QosList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("QosList") {
            var tmp : [DescribeExpressConnectTrafficQosResponseBody.QosList] = []
            for v in dict["QosList"] as! [Any] {
                var model = DescribeExpressConnectTrafficQosResponseBody.QosList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.qosList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeExpressConnectTrafficQosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExpressConnectTrafficQosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExpressConnectTrafficQosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExpressConnectTrafficQosQueueRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueIdList: [String]?

    public var queueNameList: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueIdList != nil {
            map["QueueIdList"] = self.queueIdList!
        }
        if self.queueNameList != nil {
            map["QueueNameList"] = self.queueNameList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueIdList") {
            self.queueIdList = dict["QueueIdList"] as! [String]
        }
        if dict.keys.contains("QueueNameList") {
            self.queueNameList = dict["QueueNameList"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DescribeExpressConnectTrafficQosQueueResponseBody : Tea.TeaModel {
    public class QueueList : Tea.TeaModel {
        public class RuleList : Tea.TeaModel {
            public var dstCidr: String?

            public var dstIPv6Cidr: String?

            public var dstPortRange: String?

            public var matchDscp: Int32?

            public var priority: Int32?

            public var protocol_: String?

            public var qosId: String?

            public var queueId: String?

            public var remarkingDscp: Int32?

            public var ruleDescription: String?

            public var ruleId: String?

            public var ruleName: String?

            public var srcCidr: String?

            public var srcIPv6Cidr: String?

            public var srcPortRange: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dstCidr != nil {
                    map["DstCidr"] = self.dstCidr!
                }
                if self.dstIPv6Cidr != nil {
                    map["DstIPv6Cidr"] = self.dstIPv6Cidr!
                }
                if self.dstPortRange != nil {
                    map["DstPortRange"] = self.dstPortRange!
                }
                if self.matchDscp != nil {
                    map["MatchDscp"] = self.matchDscp!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.qosId != nil {
                    map["QosId"] = self.qosId!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                if self.remarkingDscp != nil {
                    map["RemarkingDscp"] = self.remarkingDscp!
                }
                if self.ruleDescription != nil {
                    map["RuleDescription"] = self.ruleDescription!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.srcCidr != nil {
                    map["SrcCidr"] = self.srcCidr!
                }
                if self.srcIPv6Cidr != nil {
                    map["SrcIPv6Cidr"] = self.srcIPv6Cidr!
                }
                if self.srcPortRange != nil {
                    map["SrcPortRange"] = self.srcPortRange!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DstCidr") {
                    self.dstCidr = dict["DstCidr"] as! String
                }
                if dict.keys.contains("DstIPv6Cidr") {
                    self.dstIPv6Cidr = dict["DstIPv6Cidr"] as! String
                }
                if dict.keys.contains("DstPortRange") {
                    self.dstPortRange = dict["DstPortRange"] as! String
                }
                if dict.keys.contains("MatchDscp") {
                    self.matchDscp = dict["MatchDscp"] as! Int32
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("QosId") {
                    self.qosId = dict["QosId"] as! String
                }
                if dict.keys.contains("QueueId") {
                    self.queueId = dict["QueueId"] as! String
                }
                if dict.keys.contains("RemarkingDscp") {
                    self.remarkingDscp = dict["RemarkingDscp"] as! Int32
                }
                if dict.keys.contains("RuleDescription") {
                    self.ruleDescription = dict["RuleDescription"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("SrcCidr") {
                    self.srcCidr = dict["SrcCidr"] as! String
                }
                if dict.keys.contains("SrcIPv6Cidr") {
                    self.srcIPv6Cidr = dict["SrcIPv6Cidr"] as! String
                }
                if dict.keys.contains("SrcPortRange") {
                    self.srcPortRange = dict["SrcPortRange"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var bandwidthPercent: String?

        public var qosId: String?

        public var queueDescription: String?

        public var queueId: String?

        public var queueName: String?

        public var queueType: String?

        public var ruleList: [DescribeExpressConnectTrafficQosQueueResponseBody.QueueList.RuleList]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidthPercent != nil {
                map["BandwidthPercent"] = self.bandwidthPercent!
            }
            if self.qosId != nil {
                map["QosId"] = self.qosId!
            }
            if self.queueDescription != nil {
                map["QueueDescription"] = self.queueDescription!
            }
            if self.queueId != nil {
                map["QueueId"] = self.queueId!
            }
            if self.queueName != nil {
                map["QueueName"] = self.queueName!
            }
            if self.queueType != nil {
                map["QueueType"] = self.queueType!
            }
            if self.ruleList != nil {
                var tmp : [Any] = []
                for k in self.ruleList! {
                    tmp.append(k.toMap())
                }
                map["RuleList"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BandwidthPercent") {
                self.bandwidthPercent = dict["BandwidthPercent"] as! String
            }
            if dict.keys.contains("QosId") {
                self.qosId = dict["QosId"] as! String
            }
            if dict.keys.contains("QueueDescription") {
                self.queueDescription = dict["QueueDescription"] as! String
            }
            if dict.keys.contains("QueueId") {
                self.queueId = dict["QueueId"] as! String
            }
            if dict.keys.contains("QueueName") {
                self.queueName = dict["QueueName"] as! String
            }
            if dict.keys.contains("QueueType") {
                self.queueType = dict["QueueType"] as! String
            }
            if dict.keys.contains("RuleList") {
                var tmp : [DescribeExpressConnectTrafficQosQueueResponseBody.QueueList.RuleList] = []
                for v in dict["RuleList"] as! [Any] {
                    var model = DescribeExpressConnectTrafficQosQueueResponseBody.QueueList.RuleList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleList = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var queueList: [DescribeExpressConnectTrafficQosQueueResponseBody.QueueList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.queueList != nil {
            var tmp : [Any] = []
            for k in self.queueList! {
                tmp.append(k.toMap())
            }
            map["QueueList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QueueList") {
            var tmp : [DescribeExpressConnectTrafficQosQueueResponseBody.QueueList] = []
            for v in dict["QueueList"] as! [Any] {
                var model = DescribeExpressConnectTrafficQosQueueResponseBody.QueueList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.queueList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeExpressConnectTrafficQosQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExpressConnectTrafficQosQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExpressConnectTrafficQosQueueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExpressConnectTrafficQosRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var ruleIdList: [String]?

    public var ruleNameList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.ruleIdList != nil {
            map["RuleIdList"] = self.ruleIdList!
        }
        if self.ruleNameList != nil {
            map["RuleNameList"] = self.ruleNameList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("RuleIdList") {
            self.ruleIdList = dict["RuleIdList"] as! [String]
        }
        if dict.keys.contains("RuleNameList") {
            self.ruleNameList = dict["RuleNameList"] as! [String]
        }
    }
}

public class DescribeExpressConnectTrafficQosRuleResponseBody : Tea.TeaModel {
    public class RuleList : Tea.TeaModel {
        public var dstCidr: String?

        public var dstIPv6Cidr: String?

        public var dstPortRange: String?

        public var matchDscp: Int32?

        public var priority: Int32?

        public var protocol_: String?

        public var qosId: String?

        public var queueId: String?

        public var remarkingDscp: Int32?

        public var ruleDescription: String?

        public var ruleId: String?

        public var ruleName: String?

        public var srcCidr: String?

        public var srcIPv6Cidr: String?

        public var srcPortRange: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstCidr != nil {
                map["DstCidr"] = self.dstCidr!
            }
            if self.dstIPv6Cidr != nil {
                map["DstIPv6Cidr"] = self.dstIPv6Cidr!
            }
            if self.dstPortRange != nil {
                map["DstPortRange"] = self.dstPortRange!
            }
            if self.matchDscp != nil {
                map["MatchDscp"] = self.matchDscp!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.qosId != nil {
                map["QosId"] = self.qosId!
            }
            if self.queueId != nil {
                map["QueueId"] = self.queueId!
            }
            if self.remarkingDscp != nil {
                map["RemarkingDscp"] = self.remarkingDscp!
            }
            if self.ruleDescription != nil {
                map["RuleDescription"] = self.ruleDescription!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.srcCidr != nil {
                map["SrcCidr"] = self.srcCidr!
            }
            if self.srcIPv6Cidr != nil {
                map["SrcIPv6Cidr"] = self.srcIPv6Cidr!
            }
            if self.srcPortRange != nil {
                map["SrcPortRange"] = self.srcPortRange!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DstCidr") {
                self.dstCidr = dict["DstCidr"] as! String
            }
            if dict.keys.contains("DstIPv6Cidr") {
                self.dstIPv6Cidr = dict["DstIPv6Cidr"] as! String
            }
            if dict.keys.contains("DstPortRange") {
                self.dstPortRange = dict["DstPortRange"] as! String
            }
            if dict.keys.contains("MatchDscp") {
                self.matchDscp = dict["MatchDscp"] as! Int32
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("QosId") {
                self.qosId = dict["QosId"] as! String
            }
            if dict.keys.contains("QueueId") {
                self.queueId = dict["QueueId"] as! String
            }
            if dict.keys.contains("RemarkingDscp") {
                self.remarkingDscp = dict["RemarkingDscp"] as! Int32
            }
            if dict.keys.contains("RuleDescription") {
                self.ruleDescription = dict["RuleDescription"] as! String
            }
            if dict.keys.contains("RuleId") {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("SrcCidr") {
                self.srcCidr = dict["SrcCidr"] as! String
            }
            if dict.keys.contains("SrcIPv6Cidr") {
                self.srcIPv6Cidr = dict["SrcIPv6Cidr"] as! String
            }
            if dict.keys.contains("SrcPortRange") {
                self.srcPortRange = dict["SrcPortRange"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var requestId: String?

    public var ruleList: [DescribeExpressConnectTrafficQosRuleResponseBody.RuleList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleList != nil {
            var tmp : [Any] = []
            for k in self.ruleList! {
                tmp.append(k.toMap())
            }
            map["RuleList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleList") {
            var tmp : [DescribeExpressConnectTrafficQosRuleResponseBody.RuleList] = []
            for v in dict["RuleList"] as! [Any] {
                var model = DescribeExpressConnectTrafficQosRuleResponseBody.RuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ruleList = tmp
        }
    }
}

public class DescribeExpressConnectTrafficQosRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExpressConnectTrafficQosRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExpressConnectTrafficQosRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DescribeFailoverTestJobResponseBody : Tea.TeaModel {
    public class FailoverTestJobModel : Tea.TeaModel {
        public var description_: String?

        public var jobDuration: String?

        public var jobId: String?

        public var jobType: String?

        public var name: String?

        public var resourceId: [String]?

        public var resourceType: String?

        public var startTime: String?

        public var status: String?

        public var stopTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.jobDuration != nil {
                map["JobDuration"] = self.jobDuration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopTime != nil {
                map["StopTime"] = self.stopTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("JobDuration") {
                self.jobDuration = dict["JobDuration"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! [String]
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StopTime") {
                self.stopTime = dict["StopTime"] as! String
            }
        }
    }
    public var failoverTestJobModel: DescribeFailoverTestJobResponseBody.FailoverTestJobModel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failoverTestJobModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failoverTestJobModel != nil {
            map["FailoverTestJobModel"] = self.failoverTestJobModel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailoverTestJobModel") {
            var model = DescribeFailoverTestJobResponseBody.FailoverTestJobModel()
            model.fromMap(dict["FailoverTestJobModel"] as! [String: Any])
            self.failoverTestJobModel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFailoverTestJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFailoverTestJobsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var clientToken: String?

    public var filter: [DescribeFailoverTestJobsRequest.Filter]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Filter") {
            var tmp : [DescribeFailoverTestJobsRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeFailoverTestJobsRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DescribeFailoverTestJobsResponseBody : Tea.TeaModel {
    public class FailoverTestJobList : Tea.TeaModel {
        public var description_: String?

        public var jobDuration: String?

        public var jobId: String?

        public var jobType: String?

        public var name: String?

        public var resourceId: [String]?

        public var resourceType: String?

        public var startTime: String?

        public var status: String?

        public var stopTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.jobDuration != nil {
                map["JobDuration"] = self.jobDuration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopTime != nil {
                map["StopTime"] = self.stopTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("JobDuration") {
                self.jobDuration = dict["JobDuration"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! [String]
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StopTime") {
                self.stopTime = dict["StopTime"] as! String
            }
        }
    }
    public var count: Int32?

    public var failoverTestJobList: [DescribeFailoverTestJobsResponseBody.FailoverTestJobList]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.failoverTestJobList != nil {
            var tmp : [Any] = []
            for k in self.failoverTestJobList! {
                tmp.append(k.toMap())
            }
            map["FailoverTestJobList"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("FailoverTestJobList") {
            var tmp : [DescribeFailoverTestJobsResponseBody.FailoverTestJobList] = []
            for v in dict["FailoverTestJobList"] as! [Any] {
                var model = DescribeFailoverTestJobsResponseBody.FailoverTestJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.failoverTestJobList = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeFailoverTestJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFailoverTestJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFailoverTestJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowLogsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var description_: String?

    public var flowLogId: String?

    public var flowLogName: String?

    public var logStoreName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var status: String?

    public var tags: [DescribeFlowLogsRequest.Tags]?

    public var trafficType: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.flowLogName != nil {
            map["FlowLogName"] = self.flowLogName!
        }
        if self.logStoreName != nil {
            map["LogStoreName"] = self.logStoreName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.trafficType != nil {
            map["TrafficType"] = self.trafficType!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FlowLogId") {
            self.flowLogId = dict["FlowLogId"] as! String
        }
        if dict.keys.contains("FlowLogName") {
            self.flowLogName = dict["FlowLogName"] as! String
        }
        if dict.keys.contains("LogStoreName") {
            self.logStoreName = dict["LogStoreName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeFlowLogsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeFlowLogsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TrafficType") {
            self.trafficType = dict["TrafficType"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeFlowLogsResponseBody : Tea.TeaModel {
    public class FlowLogs : Tea.TeaModel {
        public class FlowLog : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public class TrafficPath : Tea.TeaModel {
                public var trafficPathList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.trafficPathList != nil {
                        map["TrafficPathList"] = self.trafficPathList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TrafficPathList") {
                        self.trafficPathList = dict["TrafficPathList"] as! [String]
                    }
                }
            }
            public var aggregationInterval: Int32?

            public var businessStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var flowLogDeliverErrorMessage: String?

            public var flowLogDeliverStatus: String?

            public var flowLogId: String?

            public var flowLogName: String?

            public var ipVersion: String?

            public var logStoreName: String?

            public var projectName: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var resourceId: String?

            public var resourceType: String?

            public var serviceType: String?

            public var status: String?

            public var tags: DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags?

            public var trafficPath: DescribeFlowLogsResponseBody.FlowLogs.FlowLog.TrafficPath?

            public var trafficType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
                try self.trafficPath?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aggregationInterval != nil {
                    map["AggregationInterval"] = self.aggregationInterval!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.flowLogDeliverErrorMessage != nil {
                    map["FlowLogDeliverErrorMessage"] = self.flowLogDeliverErrorMessage!
                }
                if self.flowLogDeliverStatus != nil {
                    map["FlowLogDeliverStatus"] = self.flowLogDeliverStatus!
                }
                if self.flowLogId != nil {
                    map["FlowLogId"] = self.flowLogId!
                }
                if self.flowLogName != nil {
                    map["FlowLogName"] = self.flowLogName!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.logStoreName != nil {
                    map["LogStoreName"] = self.logStoreName!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.serviceType != nil {
                    map["ServiceType"] = self.serviceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.trafficPath != nil {
                    map["TrafficPath"] = self.trafficPath?.toMap()
                }
                if self.trafficType != nil {
                    map["TrafficType"] = self.trafficType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AggregationInterval") {
                    self.aggregationInterval = dict["AggregationInterval"] as! Int32
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FlowLogDeliverErrorMessage") {
                    self.flowLogDeliverErrorMessage = dict["FlowLogDeliverErrorMessage"] as! String
                }
                if dict.keys.contains("FlowLogDeliverStatus") {
                    self.flowLogDeliverStatus = dict["FlowLogDeliverStatus"] as! String
                }
                if dict.keys.contains("FlowLogId") {
                    self.flowLogId = dict["FlowLogId"] as! String
                }
                if dict.keys.contains("FlowLogName") {
                    self.flowLogName = dict["FlowLogName"] as! String
                }
                if dict.keys.contains("IpVersion") {
                    self.ipVersion = dict["IpVersion"] as! String
                }
                if dict.keys.contains("LogStoreName") {
                    self.logStoreName = dict["LogStoreName"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("ServiceType") {
                    self.serviceType = dict["ServiceType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TrafficPath") {
                    var model = DescribeFlowLogsResponseBody.FlowLogs.FlowLog.TrafficPath()
                    model.fromMap(dict["TrafficPath"] as! [String: Any])
                    self.trafficPath = model
                }
                if dict.keys.contains("TrafficType") {
                    self.trafficType = dict["TrafficType"] as! String
                }
            }
        }
        public var flowLog: [DescribeFlowLogsResponseBody.FlowLogs.FlowLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flowLog != nil {
                var tmp : [Any] = []
                for k in self.flowLog! {
                    tmp.append(k.toMap())
                }
                map["FlowLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FlowLog") {
                var tmp : [DescribeFlowLogsResponseBody.FlowLogs.FlowLog] = []
                for v in dict["FlowLog"] as! [Any] {
                    var model = DescribeFlowLogsResponseBody.FlowLogs.FlowLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.flowLog = tmp
            }
        }
    }
    public var flowLogs: DescribeFlowLogsResponseBody.FlowLogs?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var success: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.flowLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogs != nil {
            map["FlowLogs"] = self.flowLogs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowLogs") {
            var model = DescribeFlowLogsResponseBody.FlowLogs()
            model.fromMap(dict["FlowLogs"] as! [String: Any])
            self.flowLogs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeFlowLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFlowLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeForwardTableEntriesRequest : Tea.TeaModel {
    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryId: String?

    public var forwardEntryName: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExternalIp") {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ExternalPort") {
            self.externalPort = dict["ExternalPort"] as! String
        }
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardEntryName") {
            self.forwardEntryName = dict["ForwardEntryName"] as! String
        }
        if dict.keys.contains("ForwardTableId") {
            self.forwardTableId = dict["ForwardTableId"] as! String
        }
        if dict.keys.contains("InternalIp") {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("InternalPort") {
            self.internalPort = dict["InternalPort"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeForwardTableEntriesResponseBody : Tea.TeaModel {
    public class ForwardTableEntries : Tea.TeaModel {
        public class ForwardTableEntry : Tea.TeaModel {
            public var externalIp: String?

            public var externalPort: String?

            public var forwardEntryId: String?

            public var forwardEntryName: String?

            public var forwardTableId: String?

            public var internalIp: String?

            public var internalPort: String?

            public var ipProtocol: String?

            public var natGatewayId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externalIp != nil {
                    map["ExternalIp"] = self.externalIp!
                }
                if self.externalPort != nil {
                    map["ExternalPort"] = self.externalPort!
                }
                if self.forwardEntryId != nil {
                    map["ForwardEntryId"] = self.forwardEntryId!
                }
                if self.forwardEntryName != nil {
                    map["ForwardEntryName"] = self.forwardEntryName!
                }
                if self.forwardTableId != nil {
                    map["ForwardTableId"] = self.forwardTableId!
                }
                if self.internalIp != nil {
                    map["InternalIp"] = self.internalIp!
                }
                if self.internalPort != nil {
                    map["InternalPort"] = self.internalPort!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExternalIp") {
                    self.externalIp = dict["ExternalIp"] as! String
                }
                if dict.keys.contains("ExternalPort") {
                    self.externalPort = dict["ExternalPort"] as! String
                }
                if dict.keys.contains("ForwardEntryId") {
                    self.forwardEntryId = dict["ForwardEntryId"] as! String
                }
                if dict.keys.contains("ForwardEntryName") {
                    self.forwardEntryName = dict["ForwardEntryName"] as! String
                }
                if dict.keys.contains("ForwardTableId") {
                    self.forwardTableId = dict["ForwardTableId"] as! String
                }
                if dict.keys.contains("InternalIp") {
                    self.internalIp = dict["InternalIp"] as! String
                }
                if dict.keys.contains("InternalPort") {
                    self.internalPort = dict["InternalPort"] as! String
                }
                if dict.keys.contains("IpProtocol") {
                    self.ipProtocol = dict["IpProtocol"] as! String
                }
                if dict.keys.contains("NatGatewayId") {
                    self.natGatewayId = dict["NatGatewayId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var forwardTableEntry: [DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardTableEntry != nil {
                var tmp : [Any] = []
                for k in self.forwardTableEntry! {
                    tmp.append(k.toMap())
                }
                map["ForwardTableEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardTableEntry") {
                var tmp : [DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry] = []
                for v in dict["ForwardTableEntry"] as! [Any] {
                    var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.forwardTableEntry = tmp
            }
        }
    }
    public var forwardTableEntries: DescribeForwardTableEntriesResponseBody.ForwardTableEntries?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forwardTableEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardTableEntries != nil {
            map["ForwardTableEntries"] = self.forwardTableEntries?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardTableEntries") {
            var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries()
            model.fromMap(dict["ForwardTableEntries"] as! [String: Any])
            self.forwardTableEntries = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeForwardTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeForwardTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeForwardTableEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGlobalAccelerationInstancesRequest : Tea.TeaModel {
    public var bandwidthType: String?

    public var globalAccelerationInstanceId: String?

    public var includeReservationData: Bool?

    public var ipAddress: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serverId: String?

    public var serviceLocation: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthType != nil {
            map["BandwidthType"] = self.bandwidthType!
        }
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        if self.serviceLocation != nil {
            map["ServiceLocation"] = self.serviceLocation!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthType") {
            self.bandwidthType = dict["BandwidthType"] as! String
        }
        if dict.keys.contains("GlobalAccelerationInstanceId") {
            self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
        }
        if dict.keys.contains("IncludeReservationData") {
            self.includeReservationData = dict["IncludeReservationData"] as! Bool
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
        if dict.keys.contains("ServiceLocation") {
            self.serviceLocation = dict["ServiceLocation"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeGlobalAccelerationInstancesResponseBody : Tea.TeaModel {
    public class GlobalAccelerationInstances : Tea.TeaModel {
        public class GlobalAccelerationInstance : Tea.TeaModel {
            public class BackendServers : Tea.TeaModel {
                public class BackendServer : Tea.TeaModel {
                    public var regionId: String?

                    public var serverId: String?

                    public var serverIpAddress: String?

                    public var serverType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.serverId != nil {
                            map["ServerId"] = self.serverId!
                        }
                        if self.serverIpAddress != nil {
                            map["ServerIpAddress"] = self.serverIpAddress!
                        }
                        if self.serverType != nil {
                            map["ServerType"] = self.serverType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("RegionId") {
                            self.regionId = dict["RegionId"] as! String
                        }
                        if dict.keys.contains("ServerId") {
                            self.serverId = dict["ServerId"] as! String
                        }
                        if dict.keys.contains("ServerIpAddress") {
                            self.serverIpAddress = dict["ServerIpAddress"] as! String
                        }
                        if dict.keys.contains("ServerType") {
                            self.serverType = dict["ServerType"] as! String
                        }
                    }
                }
                public var backendServer: [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers.BackendServer]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.backendServer != nil {
                        var tmp : [Any] = []
                        for k in self.backendServer! {
                            tmp.append(k.toMap())
                        }
                        map["BackendServer"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BackendServer") {
                        var tmp : [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers.BackendServer] = []
                        for v in dict["BackendServer"] as! [Any] {
                            var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers.BackendServer()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.backendServer = tmp
                    }
                }
            }
            public class PublicIpAddresses : Tea.TeaModel {
                public class PublicIpAddress : Tea.TeaModel {
                    public var allocationId: String?

                    public var ipAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allocationId != nil {
                            map["AllocationId"] = self.allocationId!
                        }
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllocationId") {
                            self.allocationId = dict["AllocationId"] as! String
                        }
                        if dict.keys.contains("IpAddress") {
                            self.ipAddress = dict["IpAddress"] as! String
                        }
                    }
                }
                public var publicIpAddress: [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses.PublicIpAddress]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.publicIpAddress != nil {
                        var tmp : [Any] = []
                        for k in self.publicIpAddress! {
                            tmp.append(k.toMap())
                        }
                        map["PublicIpAddress"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PublicIpAddress") {
                        var tmp : [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses.PublicIpAddress] = []
                        for v in dict["PublicIpAddress"] as! [Any] {
                            var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses.PublicIpAddress()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.publicIpAddress = tmp
                    }
                }
            }
            public var accelerationLocation: String?

            public var backendServers: DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers?

            public var bandwidth: String?

            public var bandwidthType: String?

            public var chargeType: String?

            public var creationTime: String?

            public var description_: String?

            public var expiredTime: String?

            public var globalAccelerationInstanceId: String?

            public var internetChargeType: String?

            public var ipAddress: String?

            public var name: String?

            public var publicIpAddresses: DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses?

            public var regionId: String?

            public var serviceLocation: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.backendServers?.validate()
                try self.publicIpAddresses?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accelerationLocation != nil {
                    map["AccelerationLocation"] = self.accelerationLocation!
                }
                if self.backendServers != nil {
                    map["BackendServers"] = self.backendServers?.toMap()
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthType != nil {
                    map["BandwidthType"] = self.bandwidthType!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.globalAccelerationInstanceId != nil {
                    map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.publicIpAddresses != nil {
                    map["PublicIpAddresses"] = self.publicIpAddresses?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.serviceLocation != nil {
                    map["ServiceLocation"] = self.serviceLocation!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccelerationLocation") {
                    self.accelerationLocation = dict["AccelerationLocation"] as! String
                }
                if dict.keys.contains("BackendServers") {
                    var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers()
                    model.fromMap(dict["BackendServers"] as! [String: Any])
                    self.backendServers = model
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! String
                }
                if dict.keys.contains("BandwidthType") {
                    self.bandwidthType = dict["BandwidthType"] as! String
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("GlobalAccelerationInstanceId") {
                    self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
                }
                if dict.keys.contains("InternetChargeType") {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PublicIpAddresses") {
                    var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses()
                    model.fromMap(dict["PublicIpAddresses"] as! [String: Any])
                    self.publicIpAddresses = model
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ServiceLocation") {
                    self.serviceLocation = dict["ServiceLocation"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var globalAccelerationInstance: [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.globalAccelerationInstance != nil {
                var tmp : [Any] = []
                for k in self.globalAccelerationInstance! {
                    tmp.append(k.toMap())
                }
                map["GlobalAccelerationInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GlobalAccelerationInstance") {
                var tmp : [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance] = []
                for v in dict["GlobalAccelerationInstance"] as! [Any] {
                    var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.globalAccelerationInstance = tmp
            }
        }
    }
    public var globalAccelerationInstances: DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.globalAccelerationInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstances != nil {
            map["GlobalAccelerationInstances"] = self.globalAccelerationInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalAccelerationInstances") {
            var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances()
            model.fromMap(dict["GlobalAccelerationInstances"] as! [String: Any])
            self.globalAccelerationInstances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeGlobalAccelerationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGlobalAccelerationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGlobalAccelerationInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGrantRulesToCenRequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeGrantRulesToCenResponseBody : Tea.TeaModel {
    public class CenGrantRules : Tea.TeaModel {
        public class CbnGrantRule : Tea.TeaModel {
            public var cenInstanceId: String?

            public var cenOwnerId: Int64?

            public var creationTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cenInstanceId != nil {
                    map["CenInstanceId"] = self.cenInstanceId!
                }
                if self.cenOwnerId != nil {
                    map["CenOwnerId"] = self.cenOwnerId!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CenInstanceId") {
                    self.cenInstanceId = dict["CenInstanceId"] as! String
                }
                if dict.keys.contains("CenOwnerId") {
                    self.cenOwnerId = dict["CenOwnerId"] as! Int64
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
            }
        }
        public var cbnGrantRule: [DescribeGrantRulesToCenResponseBody.CenGrantRules.CbnGrantRule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cbnGrantRule != nil {
                var tmp : [Any] = []
                for k in self.cbnGrantRule! {
                    tmp.append(k.toMap())
                }
                map["CbnGrantRule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CbnGrantRule") {
                var tmp : [DescribeGrantRulesToCenResponseBody.CenGrantRules.CbnGrantRule] = []
                for v in dict["CbnGrantRule"] as! [Any] {
                    var model = DescribeGrantRulesToCenResponseBody.CenGrantRules.CbnGrantRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cbnGrantRule = tmp
            }
        }
    }
    public var cenGrantRules: DescribeGrantRulesToCenResponseBody.CenGrantRules?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cenGrantRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cenGrantRules != nil {
            map["CenGrantRules"] = self.cenGrantRules?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CenGrantRules") {
            var model = DescribeGrantRulesToCenResponseBody.CenGrantRules()
            model.fromMap(dict["CenGrantRules"] as! [String: Any])
            self.cenGrantRules = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeGrantRulesToCenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGrantRulesToCenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGrantRulesToCenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHaVipsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var filter: [DescribeHaVipsRequest.Filter]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribeHaVipsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeHaVipsRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeHaVipsRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeHaVipsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeHaVipsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class DescribeHaVipsResponseBody : Tea.TeaModel {
    public class HaVips : Tea.TeaModel {
        public class HaVip : Tea.TeaModel {
            public class AssociatedEipAddresses : Tea.TeaModel {
                public var associatedEipAddresse: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedEipAddresse != nil {
                        map["associatedEipAddresse"] = self.associatedEipAddresse!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("associatedEipAddresse") {
                        self.associatedEipAddresse = dict["associatedEipAddresse"] as! [String]
                    }
                }
            }
            public class AssociatedInstances : Tea.TeaModel {
                public var associatedInstance: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedInstance != nil {
                        map["associatedInstance"] = self.associatedInstance!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("associatedInstance") {
                        self.associatedInstance = dict["associatedInstance"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeHaVipsResponseBody.HaVips.HaVip.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeHaVipsResponseBody.HaVips.HaVip.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeHaVipsResponseBody.HaVips.HaVip.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var associatedEipAddresses: DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedEipAddresses?

            public var associatedInstanceType: String?

            public var associatedInstances: DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedInstances?

            public var chargeType: String?

            public var createTime: String?

            public var description_: String?

            public var haVipId: String?

            public var ipAddress: String?

            public var masterInstanceId: String?

            public var name: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var status: String?

            public var tags: DescribeHaVipsResponseBody.HaVips.HaVip.Tags?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedEipAddresses?.validate()
                try self.associatedInstances?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedEipAddresses != nil {
                    map["AssociatedEipAddresses"] = self.associatedEipAddresses?.toMap()
                }
                if self.associatedInstanceType != nil {
                    map["AssociatedInstanceType"] = self.associatedInstanceType!
                }
                if self.associatedInstances != nil {
                    map["AssociatedInstances"] = self.associatedInstances?.toMap()
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.haVipId != nil {
                    map["HaVipId"] = self.haVipId!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.masterInstanceId != nil {
                    map["MasterInstanceId"] = self.masterInstanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssociatedEipAddresses") {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedEipAddresses()
                    model.fromMap(dict["AssociatedEipAddresses"] as! [String: Any])
                    self.associatedEipAddresses = model
                }
                if dict.keys.contains("AssociatedInstanceType") {
                    self.associatedInstanceType = dict["AssociatedInstanceType"] as! String
                }
                if dict.keys.contains("AssociatedInstances") {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedInstances()
                    model.fromMap(dict["AssociatedInstances"] as! [String: Any])
                    self.associatedInstances = model
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HaVipId") {
                    self.haVipId = dict["HaVipId"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("MasterInstanceId") {
                    self.masterInstanceId = dict["MasterInstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var haVip: [DescribeHaVipsResponseBody.HaVips.HaVip]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.haVip != nil {
                var tmp : [Any] = []
                for k in self.haVip! {
                    tmp.append(k.toMap())
                }
                map["HaVip"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HaVip") {
                var tmp : [DescribeHaVipsResponseBody.HaVips.HaVip] = []
                for v in dict["HaVip"] as! [Any] {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.haVip = tmp
            }
        }
    }
    public var haVips: DescribeHaVipsResponseBody.HaVips?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.haVips?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVips != nil {
            map["HaVips"] = self.haVips?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVips") {
            var model = DescribeHaVipsResponseBody.HaVips()
            model.fromMap(dict["HaVips"] as! [String: Any])
            self.haVips = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeHaVipsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHaVipsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHaVipsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHighDefinitionMonitorLogAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeHighDefinitionMonitorLogAttributeResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var logProject: String?

    public var logStore: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.logProject != nil {
            map["LogProject"] = self.logProject!
        }
        if self.logStore != nil {
            map["LogStore"] = self.logStore!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("LogProject") {
            self.logProject = dict["LogProject"] as! String
        }
        if dict.keys.contains("LogStore") {
            self.logStore = dict["LogStore"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeHighDefinitionMonitorLogAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHighDefinitionMonitorLogAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHighDefinitionMonitorLogAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIPv6TranslatorAclListAttributesRequest : Tea.TeaModel {
    public var aclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeIPv6TranslatorAclListAttributesResponseBody : Tea.TeaModel {
    public class AclEntries : Tea.TeaModel {
        public class AclEntry : Tea.TeaModel {
            public var aclEntryComment: String?

            public var aclEntryId: String?

            public var aclEntryIp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclEntryComment != nil {
                    map["AclEntryComment"] = self.aclEntryComment!
                }
                if self.aclEntryId != nil {
                    map["AclEntryId"] = self.aclEntryId!
                }
                if self.aclEntryIp != nil {
                    map["AclEntryIp"] = self.aclEntryIp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AclEntryComment") {
                    self.aclEntryComment = dict["AclEntryComment"] as! String
                }
                if dict.keys.contains("AclEntryId") {
                    self.aclEntryId = dict["AclEntryId"] as! String
                }
                if dict.keys.contains("AclEntryIp") {
                    self.aclEntryIp = dict["AclEntryIp"] as! String
                }
            }
        }
        public var aclEntry: [DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries.AclEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclEntry != nil {
                var tmp : [Any] = []
                for k in self.aclEntry! {
                    tmp.append(k.toMap())
                }
                map["AclEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclEntry") {
                var tmp : [DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries.AclEntry] = []
                for v in dict["AclEntry"] as! [Any] {
                    var model = DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries.AclEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.aclEntry = tmp
            }
        }
    }
    public var aclEntries: DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries?

    public var aclId: String?

    public var aclName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aclEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntries != nil {
            map["AclEntries"] = self.aclEntries?.toMap()
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntries") {
            var model = DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries()
            model.fromMap(dict["AclEntries"] as! [String: Any])
            self.aclEntries = model
        }
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclName") {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIPv6TranslatorAclListAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIPv6TranslatorAclListAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIPv6TranslatorAclListAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIPv6TranslatorAclListsRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclName") {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeIPv6TranslatorAclListsResponseBody : Tea.TeaModel {
    public class Ipv6TranslatorAcls : Tea.TeaModel {
        public class IPv6TranslatorAcl : Tea.TeaModel {
            public var aclId: String?

            public var aclName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclId != nil {
                    map["AclId"] = self.aclId!
                }
                if self.aclName != nil {
                    map["AclName"] = self.aclName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AclId") {
                    self.aclId = dict["AclId"] as! String
                }
                if dict.keys.contains("AclName") {
                    self.aclName = dict["AclName"] as! String
                }
            }
        }
        public var IPv6TranslatorAcl: [DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls.IPv6TranslatorAcl]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IPv6TranslatorAcl != nil {
                var tmp : [Any] = []
                for k in self.IPv6TranslatorAcl! {
                    tmp.append(k.toMap())
                }
                map["IPv6TranslatorAcl"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IPv6TranslatorAcl") {
                var tmp : [DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls.IPv6TranslatorAcl] = []
                for v in dict["IPv6TranslatorAcl"] as! [Any] {
                    var model = DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls.IPv6TranslatorAcl()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.IPv6TranslatorAcl = tmp
            }
        }
    }
    public var ipv6TranslatorAcls: DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6TranslatorAcls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6TranslatorAcls != nil {
            map["Ipv6TranslatorAcls"] = self.ipv6TranslatorAcls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6TranslatorAcls") {
            var model = DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls()
            model.fromMap(dict["Ipv6TranslatorAcls"] as! [String: Any])
            self.ipv6TranslatorAcls = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIPv6TranslatorAclListsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIPv6TranslatorAclListsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIPv6TranslatorAclListsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIPv6TranslatorEntriesRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclStatus: String?

    public var aclType: String?

    public var allocateIpv6Addr: String?

    public var allocateIpv6Port: Int32?

    public var backendIpv4Addr: String?

    public var backendIpv4Port: Int32?

    public var clientToken: String?

    public var entryName: String?

    public var ipv6TranslatorEntryId: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var transProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclStatus != nil {
            map["AclStatus"] = self.aclStatus!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.allocateIpv6Addr != nil {
            map["AllocateIpv6Addr"] = self.allocateIpv6Addr!
        }
        if self.allocateIpv6Port != nil {
            map["AllocateIpv6Port"] = self.allocateIpv6Port!
        }
        if self.backendIpv4Addr != nil {
            map["BackendIpv4Addr"] = self.backendIpv4Addr!
        }
        if self.backendIpv4Port != nil {
            map["BackendIpv4Port"] = self.backendIpv4Port!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.entryName != nil {
            map["EntryName"] = self.entryName!
        }
        if self.ipv6TranslatorEntryId != nil {
            map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.transProtocol != nil {
            map["TransProtocol"] = self.transProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclStatus") {
            self.aclStatus = dict["AclStatus"] as! String
        }
        if dict.keys.contains("AclType") {
            self.aclType = dict["AclType"] as! String
        }
        if dict.keys.contains("AllocateIpv6Addr") {
            self.allocateIpv6Addr = dict["AllocateIpv6Addr"] as! String
        }
        if dict.keys.contains("AllocateIpv6Port") {
            self.allocateIpv6Port = dict["AllocateIpv6Port"] as! Int32
        }
        if dict.keys.contains("BackendIpv4Addr") {
            self.backendIpv4Addr = dict["BackendIpv4Addr"] as! String
        }
        if dict.keys.contains("BackendIpv4Port") {
            self.backendIpv4Port = dict["BackendIpv4Port"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EntryName") {
            self.entryName = dict["EntryName"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorEntryId") {
            self.ipv6TranslatorEntryId = dict["Ipv6TranslatorEntryId"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorId") {
            self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TransProtocol") {
            self.transProtocol = dict["TransProtocol"] as! String
        }
    }
}

public class DescribeIPv6TranslatorEntriesResponseBody : Tea.TeaModel {
    public class Ipv6TranslatorEntries : Tea.TeaModel {
        public class Ipv6TranslatorEntry : Tea.TeaModel {
            public var aclId: String?

            public var aclStatus: String?

            public var aclType: String?

            public var allocateIpv6Addr: String?

            public var allocateIpv6Port: Int32?

            public var backendIpv4Addr: String?

            public var backendIpv4Port: String?

            public var entryBandwidth: String?

            public var entryDescription: String?

            public var entryName: String?

            public var entryStatus: String?

            public var ipv6TranslatorEntryId: String?

            public var ipv6TranslatorId: String?

            public var regionId: String?

            public var transProtocol: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclId != nil {
                    map["AclId"] = self.aclId!
                }
                if self.aclStatus != nil {
                    map["AclStatus"] = self.aclStatus!
                }
                if self.aclType != nil {
                    map["AclType"] = self.aclType!
                }
                if self.allocateIpv6Addr != nil {
                    map["AllocateIpv6Addr"] = self.allocateIpv6Addr!
                }
                if self.allocateIpv6Port != nil {
                    map["AllocateIpv6Port"] = self.allocateIpv6Port!
                }
                if self.backendIpv4Addr != nil {
                    map["BackendIpv4Addr"] = self.backendIpv4Addr!
                }
                if self.backendIpv4Port != nil {
                    map["BackendIpv4Port"] = self.backendIpv4Port!
                }
                if self.entryBandwidth != nil {
                    map["EntryBandwidth"] = self.entryBandwidth!
                }
                if self.entryDescription != nil {
                    map["EntryDescription"] = self.entryDescription!
                }
                if self.entryName != nil {
                    map["EntryName"] = self.entryName!
                }
                if self.entryStatus != nil {
                    map["EntryStatus"] = self.entryStatus!
                }
                if self.ipv6TranslatorEntryId != nil {
                    map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
                }
                if self.ipv6TranslatorId != nil {
                    map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.transProtocol != nil {
                    map["TransProtocol"] = self.transProtocol!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AclId") {
                    self.aclId = dict["AclId"] as! String
                }
                if dict.keys.contains("AclStatus") {
                    self.aclStatus = dict["AclStatus"] as! String
                }
                if dict.keys.contains("AclType") {
                    self.aclType = dict["AclType"] as! String
                }
                if dict.keys.contains("AllocateIpv6Addr") {
                    self.allocateIpv6Addr = dict["AllocateIpv6Addr"] as! String
                }
                if dict.keys.contains("AllocateIpv6Port") {
                    self.allocateIpv6Port = dict["AllocateIpv6Port"] as! Int32
                }
                if dict.keys.contains("BackendIpv4Addr") {
                    self.backendIpv4Addr = dict["BackendIpv4Addr"] as! String
                }
                if dict.keys.contains("BackendIpv4Port") {
                    self.backendIpv4Port = dict["BackendIpv4Port"] as! String
                }
                if dict.keys.contains("EntryBandwidth") {
                    self.entryBandwidth = dict["EntryBandwidth"] as! String
                }
                if dict.keys.contains("EntryDescription") {
                    self.entryDescription = dict["EntryDescription"] as! String
                }
                if dict.keys.contains("EntryName") {
                    self.entryName = dict["EntryName"] as! String
                }
                if dict.keys.contains("EntryStatus") {
                    self.entryStatus = dict["EntryStatus"] as! String
                }
                if dict.keys.contains("Ipv6TranslatorEntryId") {
                    self.ipv6TranslatorEntryId = dict["Ipv6TranslatorEntryId"] as! String
                }
                if dict.keys.contains("Ipv6TranslatorId") {
                    self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("TransProtocol") {
                    self.transProtocol = dict["TransProtocol"] as! String
                }
            }
        }
        public var ipv6TranslatorEntry: [DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries.Ipv6TranslatorEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6TranslatorEntry != nil {
                var tmp : [Any] = []
                for k in self.ipv6TranslatorEntry! {
                    tmp.append(k.toMap())
                }
                map["Ipv6TranslatorEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6TranslatorEntry") {
                var tmp : [DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries.Ipv6TranslatorEntry] = []
                for v in dict["Ipv6TranslatorEntry"] as! [Any] {
                    var model = DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries.Ipv6TranslatorEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6TranslatorEntry = tmp
            }
        }
    }
    public var ipv6TranslatorEntries: DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6TranslatorEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6TranslatorEntries != nil {
            map["Ipv6TranslatorEntries"] = self.ipv6TranslatorEntries?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6TranslatorEntries") {
            var model = DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries()
            model.fromMap(dict["Ipv6TranslatorEntries"] as! [String: Any])
            self.ipv6TranslatorEntries = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIPv6TranslatorEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIPv6TranslatorEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIPv6TranslatorEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIPv6TranslatorsRequest : Tea.TeaModel {
    public var allocateIpv4Addr: String?

    public var allocateIpv6Addr: String?

    public var businessStatus: String?

    public var ipv6TranslatorId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var payType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocateIpv4Addr != nil {
            map["AllocateIpv4Addr"] = self.allocateIpv4Addr!
        }
        if self.allocateIpv6Addr != nil {
            map["AllocateIpv6Addr"] = self.allocateIpv6Addr!
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocateIpv4Addr") {
            self.allocateIpv4Addr = dict["AllocateIpv4Addr"] as! String
        }
        if dict.keys.contains("AllocateIpv6Addr") {
            self.allocateIpv6Addr = dict["AllocateIpv6Addr"] as! String
        }
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorId") {
            self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeIPv6TranslatorsResponseBody : Tea.TeaModel {
    public class Ipv6Translators : Tea.TeaModel {
        public class Ipv6Translator : Tea.TeaModel {
            public class Ipv6TranslatorEntryIds : Tea.TeaModel {
                public var ipv6TranslatorEntryId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6TranslatorEntryId != nil {
                        map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ipv6TranslatorEntryId") {
                        self.ipv6TranslatorEntryId = dict["Ipv6TranslatorEntryId"] as! [String]
                    }
                }
            }
            public var allocateIpv4Addr: String?

            public var allocateIpv6Addr: String?

            public var availableBandwidth: String?

            public var bandwidth: Int32?

            public var businessStatus: String?

            public var createTime: Int64?

            public var description_: String?

            public var endTime: Int64?

            public var ipv6TranslatorEntryIds: DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator.Ipv6TranslatorEntryIds?

            public var ipv6TranslatorId: String?

            public var name: String?

            public var payType: String?

            public var regionId: String?

            public var spec: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ipv6TranslatorEntryIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocateIpv4Addr != nil {
                    map["AllocateIpv4Addr"] = self.allocateIpv4Addr!
                }
                if self.allocateIpv6Addr != nil {
                    map["AllocateIpv6Addr"] = self.allocateIpv6Addr!
                }
                if self.availableBandwidth != nil {
                    map["AvailableBandwidth"] = self.availableBandwidth!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.ipv6TranslatorEntryIds != nil {
                    map["Ipv6TranslatorEntryIds"] = self.ipv6TranslatorEntryIds?.toMap()
                }
                if self.ipv6TranslatorId != nil {
                    map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocateIpv4Addr") {
                    self.allocateIpv4Addr = dict["AllocateIpv4Addr"] as! String
                }
                if dict.keys.contains("AllocateIpv6Addr") {
                    self.allocateIpv6Addr = dict["AllocateIpv6Addr"] as! String
                }
                if dict.keys.contains("AvailableBandwidth") {
                    self.availableBandwidth = dict["AvailableBandwidth"] as! String
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("Ipv6TranslatorEntryIds") {
                    var model = DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator.Ipv6TranslatorEntryIds()
                    model.fromMap(dict["Ipv6TranslatorEntryIds"] as! [String: Any])
                    self.ipv6TranslatorEntryIds = model
                }
                if dict.keys.contains("Ipv6TranslatorId") {
                    self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PayType") {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var ipv6Translator: [DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Translator != nil {
                var tmp : [Any] = []
                for k in self.ipv6Translator! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Translator"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6Translator") {
                var tmp : [DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator] = []
                for v in dict["Ipv6Translator"] as! [Any] {
                    var model = DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6Translator = tmp
            }
        }
    }
    public var ipv6Translators: DescribeIPv6TranslatorsResponseBody.Ipv6Translators?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6Translators?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Translators != nil {
            map["Ipv6Translators"] = self.ipv6Translators?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6Translators") {
            var model = DescribeIPv6TranslatorsResponseBody.Ipv6Translators()
            model.fromMap(dict["Ipv6Translators"] as! [String: Any])
            self.ipv6Translators = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIPv6TranslatorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIPv6TranslatorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIPv6TranslatorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpv6AddressesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var addressType: String?

    public var associatedInstanceId: String?

    public var associatedInstanceType: String?

    public var includeReservationData: Bool?

    public var ipv6Address: String?

    public var ipv6AddressId: String?

    public var ipv6InternetBandwidthId: String?

    public var name: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceManaged: Bool?

    public var tag: [DescribeIpv6AddressesRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressType != nil {
            map["AddressType"] = self.addressType!
        }
        if self.associatedInstanceId != nil {
            map["AssociatedInstanceId"] = self.associatedInstanceId!
        }
        if self.associatedInstanceType != nil {
            map["AssociatedInstanceType"] = self.associatedInstanceType!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ipv6InternetBandwidthId != nil {
            map["Ipv6InternetBandwidthId"] = self.ipv6InternetBandwidthId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressType") {
            self.addressType = dict["AddressType"] as! String
        }
        if dict.keys.contains("AssociatedInstanceId") {
            self.associatedInstanceId = dict["AssociatedInstanceId"] as! String
        }
        if dict.keys.contains("AssociatedInstanceType") {
            self.associatedInstanceType = dict["AssociatedInstanceType"] as! String
        }
        if dict.keys.contains("IncludeReservationData") {
            self.includeReservationData = dict["IncludeReservationData"] as! Bool
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! String
        }
        if dict.keys.contains("Ipv6AddressId") {
            self.ipv6AddressId = dict["Ipv6AddressId"] as! String
        }
        if dict.keys.contains("Ipv6InternetBandwidthId") {
            self.ipv6InternetBandwidthId = dict["Ipv6InternetBandwidthId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceManaged") {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeIpv6AddressesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeIpv6AddressesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeIpv6AddressesResponseBody : Tea.TeaModel {
    public class Ipv6Addresses : Tea.TeaModel {
        public class Ipv6Address : Tea.TeaModel {
            public class Ipv6InternetBandwidth : Tea.TeaModel {
                public var bandwidth: Int32?

                public var businessStatus: String?

                public var hasReservationData: Bool?

                public var instanceChargeType: String?

                public var internetChargeType: String?

                public var ipv6InternetBandwidthId: String?

                public var reservationActiveTime: String?

                public var reservationBandwidth: Int64?

                public var reservationInternetChargeType: String?

                public var reservationOrderType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandwidth != nil {
                        map["Bandwidth"] = self.bandwidth!
                    }
                    if self.businessStatus != nil {
                        map["BusinessStatus"] = self.businessStatus!
                    }
                    if self.hasReservationData != nil {
                        map["HasReservationData"] = self.hasReservationData!
                    }
                    if self.instanceChargeType != nil {
                        map["InstanceChargeType"] = self.instanceChargeType!
                    }
                    if self.internetChargeType != nil {
                        map["InternetChargeType"] = self.internetChargeType!
                    }
                    if self.ipv6InternetBandwidthId != nil {
                        map["Ipv6InternetBandwidthId"] = self.ipv6InternetBandwidthId!
                    }
                    if self.reservationActiveTime != nil {
                        map["ReservationActiveTime"] = self.reservationActiveTime!
                    }
                    if self.reservationBandwidth != nil {
                        map["ReservationBandwidth"] = self.reservationBandwidth!
                    }
                    if self.reservationInternetChargeType != nil {
                        map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                    }
                    if self.reservationOrderType != nil {
                        map["ReservationOrderType"] = self.reservationOrderType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bandwidth") {
                        self.bandwidth = dict["Bandwidth"] as! Int32
                    }
                    if dict.keys.contains("BusinessStatus") {
                        self.businessStatus = dict["BusinessStatus"] as! String
                    }
                    if dict.keys.contains("HasReservationData") {
                        self.hasReservationData = dict["HasReservationData"] as! Bool
                    }
                    if dict.keys.contains("InstanceChargeType") {
                        self.instanceChargeType = dict["InstanceChargeType"] as! String
                    }
                    if dict.keys.contains("InternetChargeType") {
                        self.internetChargeType = dict["InternetChargeType"] as! String
                    }
                    if dict.keys.contains("Ipv6InternetBandwidthId") {
                        self.ipv6InternetBandwidthId = dict["Ipv6InternetBandwidthId"] as! String
                    }
                    if dict.keys.contains("ReservationActiveTime") {
                        self.reservationActiveTime = dict["ReservationActiveTime"] as! String
                    }
                    if dict.keys.contains("ReservationBandwidth") {
                        self.reservationBandwidth = dict["ReservationBandwidth"] as! Int64
                    }
                    if dict.keys.contains("ReservationInternetChargeType") {
                        self.reservationInternetChargeType = dict["ReservationInternetChargeType"] as! String
                    }
                    if dict.keys.contains("ReservationOrderType") {
                        self.reservationOrderType = dict["ReservationOrderType"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var addressType: String?

            public var allocationTime: String?

            public var associatedInstanceId: String?

            public var associatedInstanceType: String?

            public var ipv6Address: String?

            public var ipv6AddressDescription: String?

            public var ipv6AddressId: String?

            public var ipv6AddressName: String?

            public var ipv6GatewayId: String?

            public var ipv6InternetBandwidth: DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Ipv6InternetBandwidth?

            public var ipv6Isp: String?

            public var networkType: String?

            public var realBandwidth: Int32?

            public var resourceGroupId: String?

            public var serviceManaged: Int32?

            public var status: String?

            public var tags: DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ipv6InternetBandwidth?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressType != nil {
                    map["AddressType"] = self.addressType!
                }
                if self.allocationTime != nil {
                    map["AllocationTime"] = self.allocationTime!
                }
                if self.associatedInstanceId != nil {
                    map["AssociatedInstanceId"] = self.associatedInstanceId!
                }
                if self.associatedInstanceType != nil {
                    map["AssociatedInstanceType"] = self.associatedInstanceType!
                }
                if self.ipv6Address != nil {
                    map["Ipv6Address"] = self.ipv6Address!
                }
                if self.ipv6AddressDescription != nil {
                    map["Ipv6AddressDescription"] = self.ipv6AddressDescription!
                }
                if self.ipv6AddressId != nil {
                    map["Ipv6AddressId"] = self.ipv6AddressId!
                }
                if self.ipv6AddressName != nil {
                    map["Ipv6AddressName"] = self.ipv6AddressName!
                }
                if self.ipv6GatewayId != nil {
                    map["Ipv6GatewayId"] = self.ipv6GatewayId!
                }
                if self.ipv6InternetBandwidth != nil {
                    map["Ipv6InternetBandwidth"] = self.ipv6InternetBandwidth?.toMap()
                }
                if self.ipv6Isp != nil {
                    map["Ipv6Isp"] = self.ipv6Isp!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.realBandwidth != nil {
                    map["RealBandwidth"] = self.realBandwidth!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressType") {
                    self.addressType = dict["AddressType"] as! String
                }
                if dict.keys.contains("AllocationTime") {
                    self.allocationTime = dict["AllocationTime"] as! String
                }
                if dict.keys.contains("AssociatedInstanceId") {
                    self.associatedInstanceId = dict["AssociatedInstanceId"] as! String
                }
                if dict.keys.contains("AssociatedInstanceType") {
                    self.associatedInstanceType = dict["AssociatedInstanceType"] as! String
                }
                if dict.keys.contains("Ipv6Address") {
                    self.ipv6Address = dict["Ipv6Address"] as! String
                }
                if dict.keys.contains("Ipv6AddressDescription") {
                    self.ipv6AddressDescription = dict["Ipv6AddressDescription"] as! String
                }
                if dict.keys.contains("Ipv6AddressId") {
                    self.ipv6AddressId = dict["Ipv6AddressId"] as! String
                }
                if dict.keys.contains("Ipv6AddressName") {
                    self.ipv6AddressName = dict["Ipv6AddressName"] as! String
                }
                if dict.keys.contains("Ipv6GatewayId") {
                    self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
                }
                if dict.keys.contains("Ipv6InternetBandwidth") {
                    var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Ipv6InternetBandwidth()
                    model.fromMap(dict["Ipv6InternetBandwidth"] as! [String: Any])
                    self.ipv6InternetBandwidth = model
                }
                if dict.keys.contains("Ipv6Isp") {
                    self.ipv6Isp = dict["Ipv6Isp"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("RealBandwidth") {
                    self.realBandwidth = dict["RealBandwidth"] as! Int32
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("ServiceManaged") {
                    self.serviceManaged = dict["ServiceManaged"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var ipv6Address: [DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Address != nil {
                var tmp : [Any] = []
                for k in self.ipv6Address! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Address"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6Address") {
                var tmp : [DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address] = []
                for v in dict["Ipv6Address"] as! [Any] {
                    var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6Address = tmp
            }
        }
    }
    public var ipv6Addresses: DescribeIpv6AddressesResponseBody.Ipv6Addresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6Addresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Addresses != nil {
            map["Ipv6Addresses"] = self.ipv6Addresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6Addresses") {
            var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses()
            model.fromMap(dict["Ipv6Addresses"] as! [String: Any])
            self.ipv6Addresses = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIpv6AddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpv6AddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIpv6AddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpv6EgressOnlyRulesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var ipv6EgressOnlyRuleId: String?

    public var ipv6GatewayId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ipv6EgressOnlyRuleId != nil {
            map["Ipv6EgressOnlyRuleId"] = self.ipv6EgressOnlyRuleId!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Ipv6EgressOnlyRuleId") {
            self.ipv6EgressOnlyRuleId = dict["Ipv6EgressOnlyRuleId"] as! String
        }
        if dict.keys.contains("Ipv6GatewayId") {
            self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeIpv6EgressOnlyRulesResponseBody : Tea.TeaModel {
    public class Ipv6EgressOnlyRules : Tea.TeaModel {
        public class Ipv6EgressOnlyRule : Tea.TeaModel {
            public var description_: String?

            public var instanceId: String?

            public var instanceType: String?

            public var ipv6EgressOnlyRuleId: String?

            public var name: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ipv6EgressOnlyRuleId != nil {
                    map["Ipv6EgressOnlyRuleId"] = self.ipv6EgressOnlyRuleId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ipv6EgressOnlyRuleId") {
                    self.ipv6EgressOnlyRuleId = dict["Ipv6EgressOnlyRuleId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var ipv6EgressOnlyRule: [DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules.Ipv6EgressOnlyRule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6EgressOnlyRule != nil {
                var tmp : [Any] = []
                for k in self.ipv6EgressOnlyRule! {
                    tmp.append(k.toMap())
                }
                map["Ipv6EgressOnlyRule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6EgressOnlyRule") {
                var tmp : [DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules.Ipv6EgressOnlyRule] = []
                for v in dict["Ipv6EgressOnlyRule"] as! [Any] {
                    var model = DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules.Ipv6EgressOnlyRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6EgressOnlyRule = tmp
            }
        }
    }
    public var ipv6EgressOnlyRules: DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6EgressOnlyRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6EgressOnlyRules != nil {
            map["Ipv6EgressOnlyRules"] = self.ipv6EgressOnlyRules?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6EgressOnlyRules") {
            var model = DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules()
            model.fromMap(dict["Ipv6EgressOnlyRules"] as! [String: Any])
            self.ipv6EgressOnlyRules = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIpv6EgressOnlyRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpv6EgressOnlyRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIpv6EgressOnlyRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpv6GatewayAttributeRequest : Tea.TeaModel {
    public var ipv6GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6GatewayId") {
            self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeIpv6GatewayAttributeResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var tag: [DescribeIpv6GatewayAttributeResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") {
                var tmp : [DescribeIpv6GatewayAttributeResponseBody.Tags.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = DescribeIpv6GatewayAttributeResponseBody.Tags.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public var businessStatus: String?

    public var creationTime: String?

    public var description_: String?

    public var expiredTime: String?

    public var gatewayRouteTableId: String?

    public var instanceChargeType: String?

    public var ipv6GatewayId: String?

    public var name: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var status: String?

    public var tags: DescribeIpv6GatewayAttributeResponseBody.Tags?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.gatewayRouteTableId != nil {
            map["GatewayRouteTableId"] = self.gatewayRouteTableId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("GatewayRouteTableId") {
            self.gatewayRouteTableId = dict["GatewayRouteTableId"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("Ipv6GatewayId") {
            self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var model = DescribeIpv6GatewayAttributeResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeIpv6GatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpv6GatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIpv6GatewayAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpv6GatewaysRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ipv6GatewayId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribeIpv6GatewaysRequest.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6GatewayId") {
            self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeIpv6GatewaysRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeIpv6GatewaysRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeIpv6GatewaysResponseBody : Tea.TeaModel {
    public class Ipv6Gateways : Tea.TeaModel {
        public class Ipv6Gateway : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var businessStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var expiredTime: String?

            public var instanceChargeType: String?

            public var ipv6GatewayId: String?

            public var name: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var status: String?

            public var tags: DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.ipv6GatewayId != nil {
                    map["Ipv6GatewayId"] = self.ipv6GatewayId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("Ipv6GatewayId") {
                    self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var ipv6Gateway: [DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Gateway != nil {
                var tmp : [Any] = []
                for k in self.ipv6Gateway! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Gateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6Gateway") {
                var tmp : [DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway] = []
                for v in dict["Ipv6Gateway"] as! [Any] {
                    var model = DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6Gateway = tmp
            }
        }
    }
    public var ipv6Gateways: DescribeIpv6GatewaysResponseBody.Ipv6Gateways?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6Gateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Gateways != nil {
            map["Ipv6Gateways"] = self.ipv6Gateways?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6Gateways") {
            var model = DescribeIpv6GatewaysResponseBody.Ipv6Gateways()
            model.fromMap(dict["Ipv6Gateways"] as! [String: Any])
            self.ipv6Gateways = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIpv6GatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpv6GatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIpv6GatewaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNatGatewayAssociateNetworkInterfacesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var filter: [DescribeNatGatewayAssociateNetworkInterfacesRequest.Filter]?

    public var maxResults: Int32?

    public var natGatewayId: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeNatGatewayAssociateNetworkInterfacesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Filter") {
            var tmp : [DescribeNatGatewayAssociateNetworkInterfacesRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeNatGatewayAssociateNetworkInterfacesRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeNatGatewayAssociateNetworkInterfacesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeNatGatewayAssociateNetworkInterfacesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeNatGatewayAssociateNetworkInterfacesResponseBody : Tea.TeaModel {
    public class AssociateNetworkInterfaces : Tea.TeaModel {
        public class AssociateNetworkInterface : Tea.TeaModel {
            public class IPv4Sets : Tea.TeaModel {
                public class IPv4Set : Tea.TeaModel {
                    public var IPv4Address: String?

                    public var primary: Bool?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.IPv4Address != nil {
                            map["IPv4Address"] = self.IPv4Address!
                        }
                        if self.primary != nil {
                            map["Primary"] = self.primary!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IPv4Address") {
                            self.IPv4Address = dict["IPv4Address"] as! String
                        }
                        if dict.keys.contains("Primary") {
                            self.primary = dict["Primary"] as! Bool
                        }
                    }
                }
                public var IPv4Set: [DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets.IPv4Set]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.IPv4Set != nil {
                        var tmp : [Any] = []
                        for k in self.IPv4Set! {
                            tmp.append(k.toMap())
                        }
                        map["IPv4Set"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IPv4Set") {
                        var tmp : [DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets.IPv4Set] = []
                        for v in dict["IPv4Set"] as! [Any] {
                            var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets.IPv4Set()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.IPv4Set = tmp
                    }
                }
            }
            public var IPv4Sets: DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets?

            public var networkInterfaceId: String?

            public var resourceId: String?

            public var resourceOwnerId: String?

            public var resourceType: String?

            public var tunnelIndex: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.IPv4Sets?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.IPv4Sets != nil {
                    map["IPv4Sets"] = self.IPv4Sets?.toMap()
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceOwnerId != nil {
                    map["ResourceOwnerId"] = self.resourceOwnerId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tunnelIndex != nil {
                    map["TunnelIndex"] = self.tunnelIndex!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IPv4Sets") {
                    var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets()
                    model.fromMap(dict["IPv4Sets"] as! [String: Any])
                    self.IPv4Sets = model
                }
                if dict.keys.contains("NetworkInterfaceId") {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceOwnerId") {
                    self.resourceOwnerId = dict["ResourceOwnerId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TunnelIndex") {
                    self.tunnelIndex = dict["TunnelIndex"] as! String
                }
            }
        }
        public var associateNetworkInterface: [DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associateNetworkInterface != nil {
                var tmp : [Any] = []
                for k in self.associateNetworkInterface! {
                    tmp.append(k.toMap())
                }
                map["AssociateNetworkInterface"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociateNetworkInterface") {
                var tmp : [DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface] = []
                for v in dict["AssociateNetworkInterface"] as! [Any] {
                    var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.associateNetworkInterface = tmp
            }
        }
    }
    public var associateNetworkInterfaces: DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces?

    public var maxResults: Int32?

    public var natGatewayId: String?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.associateNetworkInterfaces?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associateNetworkInterfaces != nil {
            map["AssociateNetworkInterfaces"] = self.associateNetworkInterfaces?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssociateNetworkInterfaces") {
            var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces()
            model.fromMap(dict["AssociateNetworkInterfaces"] as! [String: Any])
            self.associateNetworkInterfaces = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNatGatewayAssociateNetworkInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNatGatewayAssociateNetworkInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNatGatewaysRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dryRun: Bool?

    public var instanceChargeType: String?

    public var name: String?

    public var natGatewayId: String?

    public var natType: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public var status: String?

    public var tag: [DescribeNatGatewaysRequest.Tag]?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatType") {
            self.natType = dict["NatType"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeNatGatewaysRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeNatGatewaysRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeNatGatewaysResponseBody : Tea.TeaModel {
    public class NatGateways : Tea.TeaModel {
        public class NatGateway : Tea.TeaModel {
            public class AccessMode : Tea.TeaModel {
                public var modeValue: String?

                public var tunnelType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.modeValue != nil {
                        map["ModeValue"] = self.modeValue!
                    }
                    if self.tunnelType != nil {
                        map["TunnelType"] = self.tunnelType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ModeValue") {
                        self.modeValue = dict["ModeValue"] as! String
                    }
                    if dict.keys.contains("TunnelType") {
                        self.tunnelType = dict["TunnelType"] as! String
                    }
                }
            }
            public class ForwardTableIds : Tea.TeaModel {
                public var forwardTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.forwardTableId != nil {
                        map["ForwardTableId"] = self.forwardTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ForwardTableId") {
                        self.forwardTableId = dict["ForwardTableId"] as! [String]
                    }
                }
            }
            public class FullNatTableIds : Tea.TeaModel {
                public var fullNatTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fullNatTableId != nil {
                        map["FullNatTableId"] = self.fullNatTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FullNatTableId") {
                        self.fullNatTableId = dict["FullNatTableId"] as! [String]
                    }
                }
            }
            public class IpLists : Tea.TeaModel {
                public class IpList : Tea.TeaModel {
                    public var allocationId: String?

                    public var ipAddress: String?

                    public var privateIpAddress: String?

                    public var snatEntryEnabled: Bool?

                    public var usingStatus: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allocationId != nil {
                            map["AllocationId"] = self.allocationId!
                        }
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        if self.privateIpAddress != nil {
                            map["PrivateIpAddress"] = self.privateIpAddress!
                        }
                        if self.snatEntryEnabled != nil {
                            map["SnatEntryEnabled"] = self.snatEntryEnabled!
                        }
                        if self.usingStatus != nil {
                            map["UsingStatus"] = self.usingStatus!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllocationId") {
                            self.allocationId = dict["AllocationId"] as! String
                        }
                        if dict.keys.contains("IpAddress") {
                            self.ipAddress = dict["IpAddress"] as! String
                        }
                        if dict.keys.contains("PrivateIpAddress") {
                            self.privateIpAddress = dict["PrivateIpAddress"] as! String
                        }
                        if dict.keys.contains("SnatEntryEnabled") {
                            self.snatEntryEnabled = dict["SnatEntryEnabled"] as! Bool
                        }
                        if dict.keys.contains("UsingStatus") {
                            self.usingStatus = dict["UsingStatus"] as! String
                        }
                    }
                }
                public var ipList: [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists.IpList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipList != nil {
                        var tmp : [Any] = []
                        for k in self.ipList! {
                            tmp.append(k.toMap())
                        }
                        map["IpList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpList") {
                        var tmp : [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists.IpList] = []
                        for v in dict["IpList"] as! [Any] {
                            var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists.IpList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ipList = tmp
                    }
                }
            }
            public class NatGatewayPrivateInfo : Tea.TeaModel {
                public var eniInstanceId: String?

                public var eniType: String?

                public var izNo: String?

                public var maxBandwidth: Int32?

                public var maxSessionEstablishRate: Int32?

                public var maxSessionQuota: Int32?

                public var privateIpAddress: String?

                public var vswitchId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eniInstanceId != nil {
                        map["EniInstanceId"] = self.eniInstanceId!
                    }
                    if self.eniType != nil {
                        map["EniType"] = self.eniType!
                    }
                    if self.izNo != nil {
                        map["IzNo"] = self.izNo!
                    }
                    if self.maxBandwidth != nil {
                        map["MaxBandwidth"] = self.maxBandwidth!
                    }
                    if self.maxSessionEstablishRate != nil {
                        map["MaxSessionEstablishRate"] = self.maxSessionEstablishRate!
                    }
                    if self.maxSessionQuota != nil {
                        map["MaxSessionQuota"] = self.maxSessionQuota!
                    }
                    if self.privateIpAddress != nil {
                        map["PrivateIpAddress"] = self.privateIpAddress!
                    }
                    if self.vswitchId != nil {
                        map["VswitchId"] = self.vswitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EniInstanceId") {
                        self.eniInstanceId = dict["EniInstanceId"] as! String
                    }
                    if dict.keys.contains("EniType") {
                        self.eniType = dict["EniType"] as! String
                    }
                    if dict.keys.contains("IzNo") {
                        self.izNo = dict["IzNo"] as! String
                    }
                    if dict.keys.contains("MaxBandwidth") {
                        self.maxBandwidth = dict["MaxBandwidth"] as! Int32
                    }
                    if dict.keys.contains("MaxSessionEstablishRate") {
                        self.maxSessionEstablishRate = dict["MaxSessionEstablishRate"] as! Int32
                    }
                    if dict.keys.contains("MaxSessionQuota") {
                        self.maxSessionQuota = dict["MaxSessionQuota"] as! Int32
                    }
                    if dict.keys.contains("PrivateIpAddress") {
                        self.privateIpAddress = dict["PrivateIpAddress"] as! String
                    }
                    if dict.keys.contains("VswitchId") {
                        self.vswitchId = dict["VswitchId"] as! String
                    }
                }
            }
            public class SnatTableIds : Tea.TeaModel {
                public var snatTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snatTableId != nil {
                        map["SnatTableId"] = self.snatTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SnatTableId") {
                        self.snatTableId = dict["SnatTableId"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var accessMode: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.AccessMode?

            public var autoPay: Bool?

            public var businessStatus: String?

            public var creationTime: String?

            public var deletionProtection: Bool?

            public var description_: String?

            public var ecsMetricEnabled: Bool?

            public var eipBindMode: String?

            public var enableSessionLog: String?

            public var expiredTime: String?

            public var forwardTableIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.ForwardTableIds?

            public var fullNatTableIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.FullNatTableIds?

            public var icmpReplyEnabled: Bool?

            public var instanceChargeType: String?

            public var internetChargeType: String?

            public var ipLists: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists?

            public var name: String?

            public var natGatewayId: String?

            public var natGatewayPrivateInfo: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.NatGatewayPrivateInfo?

            public var natType: String?

            public var networkType: String?

            public var privateLinkEnabled: Bool?

            public var privateLinkMode: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var securityProtectionEnabled: Bool?

            public var snatTableIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.SnatTableIds?

            public var spec: String?

            public var status: String?

            public var tags: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.accessMode?.validate()
                try self.forwardTableIds?.validate()
                try self.fullNatTableIds?.validate()
                try self.ipLists?.validate()
                try self.natGatewayPrivateInfo?.validate()
                try self.snatTableIds?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessMode != nil {
                    map["AccessMode"] = self.accessMode?.toMap()
                }
                if self.autoPay != nil {
                    map["AutoPay"] = self.autoPay!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ecsMetricEnabled != nil {
                    map["EcsMetricEnabled"] = self.ecsMetricEnabled!
                }
                if self.eipBindMode != nil {
                    map["EipBindMode"] = self.eipBindMode!
                }
                if self.enableSessionLog != nil {
                    map["EnableSessionLog"] = self.enableSessionLog!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.forwardTableIds != nil {
                    map["ForwardTableIds"] = self.forwardTableIds?.toMap()
                }
                if self.fullNatTableIds != nil {
                    map["FullNatTableIds"] = self.fullNatTableIds?.toMap()
                }
                if self.icmpReplyEnabled != nil {
                    map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipLists != nil {
                    map["IpLists"] = self.ipLists?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.natGatewayPrivateInfo != nil {
                    map["NatGatewayPrivateInfo"] = self.natGatewayPrivateInfo?.toMap()
                }
                if self.natType != nil {
                    map["NatType"] = self.natType!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.privateLinkEnabled != nil {
                    map["PrivateLinkEnabled"] = self.privateLinkEnabled!
                }
                if self.privateLinkMode != nil {
                    map["PrivateLinkMode"] = self.privateLinkMode!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityProtectionEnabled != nil {
                    map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
                }
                if self.snatTableIds != nil {
                    map["SnatTableIds"] = self.snatTableIds?.toMap()
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessMode") {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.AccessMode()
                    model.fromMap(dict["AccessMode"] as! [String: Any])
                    self.accessMode = model
                }
                if dict.keys.contains("AutoPay") {
                    self.autoPay = dict["AutoPay"] as! Bool
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DeletionProtection") {
                    self.deletionProtection = dict["DeletionProtection"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EcsMetricEnabled") {
                    self.ecsMetricEnabled = dict["EcsMetricEnabled"] as! Bool
                }
                if dict.keys.contains("EipBindMode") {
                    self.eipBindMode = dict["EipBindMode"] as! String
                }
                if dict.keys.contains("EnableSessionLog") {
                    self.enableSessionLog = dict["EnableSessionLog"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("ForwardTableIds") {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.ForwardTableIds()
                    model.fromMap(dict["ForwardTableIds"] as! [String: Any])
                    self.forwardTableIds = model
                }
                if dict.keys.contains("FullNatTableIds") {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.FullNatTableIds()
                    model.fromMap(dict["FullNatTableIds"] as! [String: Any])
                    self.fullNatTableIds = model
                }
                if dict.keys.contains("IcmpReplyEnabled") {
                    self.icmpReplyEnabled = dict["IcmpReplyEnabled"] as! Bool
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InternetChargeType") {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("IpLists") {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists()
                    model.fromMap(dict["IpLists"] as! [String: Any])
                    self.ipLists = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NatGatewayId") {
                    self.natGatewayId = dict["NatGatewayId"] as! String
                }
                if dict.keys.contains("NatGatewayPrivateInfo") {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.NatGatewayPrivateInfo()
                    model.fromMap(dict["NatGatewayPrivateInfo"] as! [String: Any])
                    self.natGatewayPrivateInfo = model
                }
                if dict.keys.contains("NatType") {
                    self.natType = dict["NatType"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("PrivateLinkEnabled") {
                    self.privateLinkEnabled = dict["PrivateLinkEnabled"] as! Bool
                }
                if dict.keys.contains("PrivateLinkMode") {
                    self.privateLinkMode = dict["PrivateLinkMode"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SecurityProtectionEnabled") {
                    self.securityProtectionEnabled = dict["SecurityProtectionEnabled"] as! Bool
                }
                if dict.keys.contains("SnatTableIds") {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.SnatTableIds()
                    model.fromMap(dict["SnatTableIds"] as! [String: Any])
                    self.snatTableIds = model
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var natGateway: [DescribeNatGatewaysResponseBody.NatGateways.NatGateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natGateway != nil {
                var tmp : [Any] = []
                for k in self.natGateway! {
                    tmp.append(k.toMap())
                }
                map["NatGateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NatGateway") {
                var tmp : [DescribeNatGatewaysResponseBody.NatGateways.NatGateway] = []
                for v in dict["NatGateway"] as! [Any] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.natGateway = tmp
            }
        }
    }
    public var natGateways: DescribeNatGatewaysResponseBody.NatGateways?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.natGateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGateways != nil {
            map["NatGateways"] = self.natGateways?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGateways") {
            var model = DescribeNatGatewaysResponseBody.NatGateways()
            model.fromMap(dict["NatGateways"] as! [String: Any])
            self.natGateways = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNatGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNatGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNatGatewaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkAclAttributesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeNetworkAclAttributesResponseBody : Tea.TeaModel {
    public class NetworkAclAttribute : Tea.TeaModel {
        public class EgressAclEntries : Tea.TeaModel {
            public class EgressAclEntry : Tea.TeaModel {
                public var description_: String?

                public var destinationCidrIp: String?

                public var entryType: String?

                public var ipVersion: String?

                public var networkAclEntryId: String?

                public var networkAclEntryName: String?

                public var policy: String?

                public var port: String?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.destinationCidrIp != nil {
                        map["DestinationCidrIp"] = self.destinationCidrIp!
                    }
                    if self.entryType != nil {
                        map["EntryType"] = self.entryType!
                    }
                    if self.ipVersion != nil {
                        map["IpVersion"] = self.ipVersion!
                    }
                    if self.networkAclEntryId != nil {
                        map["NetworkAclEntryId"] = self.networkAclEntryId!
                    }
                    if self.networkAclEntryName != nil {
                        map["NetworkAclEntryName"] = self.networkAclEntryName!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DestinationCidrIp") {
                        self.destinationCidrIp = dict["DestinationCidrIp"] as! String
                    }
                    if dict.keys.contains("EntryType") {
                        self.entryType = dict["EntryType"] as! String
                    }
                    if dict.keys.contains("IpVersion") {
                        self.ipVersion = dict["IpVersion"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryId") {
                        self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryName") {
                        self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public var egressAclEntry: [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.egressAclEntry != nil {
                    var tmp : [Any] = []
                    for k in self.egressAclEntry! {
                        tmp.append(k.toMap())
                    }
                    map["EgressAclEntry"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EgressAclEntry") {
                    var tmp : [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry] = []
                    for v in dict["EgressAclEntry"] as! [Any] {
                        var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.egressAclEntry = tmp
                }
            }
        }
        public class IngressAclEntries : Tea.TeaModel {
            public class IngressAclEntry : Tea.TeaModel {
                public var description_: String?

                public var entryType: String?

                public var ipVersion: String?

                public var networkAclEntryId: String?

                public var networkAclEntryName: String?

                public var policy: String?

                public var port: String?

                public var protocol_: String?

                public var sourceCidrIp: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.entryType != nil {
                        map["EntryType"] = self.entryType!
                    }
                    if self.ipVersion != nil {
                        map["IpVersion"] = self.ipVersion!
                    }
                    if self.networkAclEntryId != nil {
                        map["NetworkAclEntryId"] = self.networkAclEntryId!
                    }
                    if self.networkAclEntryName != nil {
                        map["NetworkAclEntryName"] = self.networkAclEntryName!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    if self.sourceCidrIp != nil {
                        map["SourceCidrIp"] = self.sourceCidrIp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("EntryType") {
                        self.entryType = dict["EntryType"] as! String
                    }
                    if dict.keys.contains("IpVersion") {
                        self.ipVersion = dict["IpVersion"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryId") {
                        self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryName") {
                        self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                    if dict.keys.contains("SourceCidrIp") {
                        self.sourceCidrIp = dict["SourceCidrIp"] as! String
                    }
                }
            }
            public var ingressAclEntry: [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ingressAclEntry != nil {
                    var tmp : [Any] = []
                    for k in self.ingressAclEntry! {
                        tmp.append(k.toMap())
                    }
                    map["IngressAclEntry"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IngressAclEntry") {
                    var tmp : [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry] = []
                    for v in dict["IngressAclEntry"] as! [Any] {
                        var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ingressAclEntry = tmp
                }
            }
        }
        public class Resources : Tea.TeaModel {
            public class Resource : Tea.TeaModel {
                public var resourceId: String?

                public var resourceType: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceId != nil {
                        map["ResourceId"] = self.resourceId!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceId") {
                        self.resourceId = dict["ResourceId"] as! String
                    }
                    if dict.keys.contains("ResourceType") {
                        self.resourceType = dict["ResourceType"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var resource: [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources.Resource]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resource != nil {
                    var tmp : [Any] = []
                    for k in self.resource! {
                        tmp.append(k.toMap())
                    }
                    map["Resource"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Resource") {
                    var tmp : [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources.Resource] = []
                    for v in dict["Resource"] as! [Any] {
                        var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources.Resource()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.resource = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public class Tag : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var tag: [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags.Tag]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    var tmp : [Any] = []
                    for k in self.tag! {
                        tmp.append(k.toMap())
                    }
                    map["Tag"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    var tmp : [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags.Tag] = []
                    for v in dict["Tag"] as! [Any] {
                        var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tag = tmp
                }
            }
        }
        public var creationTime: String?

        public var description_: String?

        public var egressAclEntries: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries?

        public var ingressAclEntries: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries?

        public var networkAclId: String?

        public var networkAclName: String?

        public var ownerId: Int64?

        public var regionId: String?

        public var resources: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources?

        public var status: String?

        public var tags: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.egressAclEntries?.validate()
            try self.ingressAclEntries?.validate()
            try self.resources?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.egressAclEntries != nil {
                map["EgressAclEntries"] = self.egressAclEntries?.toMap()
            }
            if self.ingressAclEntries != nil {
                map["IngressAclEntries"] = self.ingressAclEntries?.toMap()
            }
            if self.networkAclId != nil {
                map["NetworkAclId"] = self.networkAclId!
            }
            if self.networkAclName != nil {
                map["NetworkAclName"] = self.networkAclName!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resources != nil {
                map["Resources"] = self.resources?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EgressAclEntries") {
                var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries()
                model.fromMap(dict["EgressAclEntries"] as! [String: Any])
                self.egressAclEntries = model
            }
            if dict.keys.contains("IngressAclEntries") {
                var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries()
                model.fromMap(dict["IngressAclEntries"] as! [String: Any])
                self.ingressAclEntries = model
            }
            if dict.keys.contains("NetworkAclId") {
                self.networkAclId = dict["NetworkAclId"] as! String
            }
            if dict.keys.contains("NetworkAclName") {
                self.networkAclName = dict["NetworkAclName"] as! String
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! Int64
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Resources") {
                var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources()
                model.fromMap(dict["Resources"] as! [String: Any])
                self.resources = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var networkAclAttribute: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAclAttribute?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclAttribute != nil {
            map["NetworkAclAttribute"] = self.networkAclAttribute?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclAttribute") {
            var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute()
            model.fromMap(dict["NetworkAclAttribute"] as! [String: Any])
            self.networkAclAttribute = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNetworkAclAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkAclAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkAclAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkAclsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var networkAclId: String?

    public var networkAclName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tags: [DescribeNetworkAclsRequest.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("NetworkAclName") {
            self.networkAclName = dict["NetworkAclName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeNetworkAclsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeNetworkAclsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeNetworkAclsResponseBody : Tea.TeaModel {
    public class NetworkAcls : Tea.TeaModel {
        public class NetworkAcl : Tea.TeaModel {
            public class EgressAclEntries : Tea.TeaModel {
                public class EgressAclEntry : Tea.TeaModel {
                    public var description_: String?

                    public var destinationCidrIp: String?

                    public var entryType: String?

                    public var ipVersion: String?

                    public var networkAclEntryId: String?

                    public var networkAclEntryName: String?

                    public var policy: String?

                    public var port: String?

                    public var protocol_: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.destinationCidrIp != nil {
                            map["DestinationCidrIp"] = self.destinationCidrIp!
                        }
                        if self.entryType != nil {
                            map["EntryType"] = self.entryType!
                        }
                        if self.ipVersion != nil {
                            map["IpVersion"] = self.ipVersion!
                        }
                        if self.networkAclEntryId != nil {
                            map["NetworkAclEntryId"] = self.networkAclEntryId!
                        }
                        if self.networkAclEntryName != nil {
                            map["NetworkAclEntryName"] = self.networkAclEntryName!
                        }
                        if self.policy != nil {
                            map["Policy"] = self.policy!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.protocol_ != nil {
                            map["Protocol"] = self.protocol_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("DestinationCidrIp") {
                            self.destinationCidrIp = dict["DestinationCidrIp"] as! String
                        }
                        if dict.keys.contains("EntryType") {
                            self.entryType = dict["EntryType"] as! String
                        }
                        if dict.keys.contains("IpVersion") {
                            self.ipVersion = dict["IpVersion"] as! String
                        }
                        if dict.keys.contains("NetworkAclEntryId") {
                            self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                        }
                        if dict.keys.contains("NetworkAclEntryName") {
                            self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                        }
                        if dict.keys.contains("Policy") {
                            self.policy = dict["Policy"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! String
                        }
                        if dict.keys.contains("Protocol") {
                            self.protocol_ = dict["Protocol"] as! String
                        }
                    }
                }
                public var egressAclEntry: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries.EgressAclEntry]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.egressAclEntry != nil {
                        var tmp : [Any] = []
                        for k in self.egressAclEntry! {
                            tmp.append(k.toMap())
                        }
                        map["EgressAclEntry"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EgressAclEntry") {
                        var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries.EgressAclEntry] = []
                        for v in dict["EgressAclEntry"] as! [Any] {
                            var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries.EgressAclEntry()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.egressAclEntry = tmp
                    }
                }
            }
            public class IngressAclEntries : Tea.TeaModel {
                public class IngressAclEntry : Tea.TeaModel {
                    public var description_: String?

                    public var entryType: String?

                    public var ipVersion: String?

                    public var networkAclEntryId: String?

                    public var networkAclEntryName: String?

                    public var policy: String?

                    public var port: String?

                    public var protocol_: String?

                    public var sourceCidrIp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.entryType != nil {
                            map["EntryType"] = self.entryType!
                        }
                        if self.ipVersion != nil {
                            map["IpVersion"] = self.ipVersion!
                        }
                        if self.networkAclEntryId != nil {
                            map["NetworkAclEntryId"] = self.networkAclEntryId!
                        }
                        if self.networkAclEntryName != nil {
                            map["NetworkAclEntryName"] = self.networkAclEntryName!
                        }
                        if self.policy != nil {
                            map["Policy"] = self.policy!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.protocol_ != nil {
                            map["Protocol"] = self.protocol_!
                        }
                        if self.sourceCidrIp != nil {
                            map["SourceCidrIp"] = self.sourceCidrIp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("EntryType") {
                            self.entryType = dict["EntryType"] as! String
                        }
                        if dict.keys.contains("IpVersion") {
                            self.ipVersion = dict["IpVersion"] as! String
                        }
                        if dict.keys.contains("NetworkAclEntryId") {
                            self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                        }
                        if dict.keys.contains("NetworkAclEntryName") {
                            self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                        }
                        if dict.keys.contains("Policy") {
                            self.policy = dict["Policy"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! String
                        }
                        if dict.keys.contains("Protocol") {
                            self.protocol_ = dict["Protocol"] as! String
                        }
                        if dict.keys.contains("SourceCidrIp") {
                            self.sourceCidrIp = dict["SourceCidrIp"] as! String
                        }
                    }
                }
                public var ingressAclEntry: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries.IngressAclEntry]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ingressAclEntry != nil {
                        var tmp : [Any] = []
                        for k in self.ingressAclEntry! {
                            tmp.append(k.toMap())
                        }
                        map["IngressAclEntry"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IngressAclEntry") {
                        var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries.IngressAclEntry] = []
                        for v in dict["IngressAclEntry"] as! [Any] {
                            var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries.IngressAclEntry()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ingressAclEntry = tmp
                    }
                }
            }
            public class Resources : Tea.TeaModel {
                public class Resource : Tea.TeaModel {
                    public var resourceId: String?

                    public var resourceType: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.resourceId != nil {
                            map["ResourceId"] = self.resourceId!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ResourceId") {
                            self.resourceId = dict["ResourceId"] as! String
                        }
                        if dict.keys.contains("ResourceType") {
                            self.resourceType = dict["ResourceType"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var resource: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources.Resource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resource != nil {
                        var tmp : [Any] = []
                        for k in self.resource! {
                            tmp.append(k.toMap())
                        }
                        map["Resource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Resource") {
                        var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources.Resource] = []
                        for v in dict["Resource"] as! [Any] {
                            var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources.Resource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.resource = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var egressAclEntries: DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries?

            public var ingressAclEntries: DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries?

            public var networkAclId: String?

            public var networkAclName: String?

            public var ownerId: Int64?

            public var regionId: String?

            public var resources: DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources?

            public var status: String?

            public var tags: DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.egressAclEntries?.validate()
                try self.ingressAclEntries?.validate()
                try self.resources?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.egressAclEntries != nil {
                    map["EgressAclEntries"] = self.egressAclEntries?.toMap()
                }
                if self.ingressAclEntries != nil {
                    map["IngressAclEntries"] = self.ingressAclEntries?.toMap()
                }
                if self.networkAclId != nil {
                    map["NetworkAclId"] = self.networkAclId!
                }
                if self.networkAclName != nil {
                    map["NetworkAclName"] = self.networkAclName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resources != nil {
                    map["Resources"] = self.resources?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EgressAclEntries") {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries()
                    model.fromMap(dict["EgressAclEntries"] as! [String: Any])
                    self.egressAclEntries = model
                }
                if dict.keys.contains("IngressAclEntries") {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries()
                    model.fromMap(dict["IngressAclEntries"] as! [String: Any])
                    self.ingressAclEntries = model
                }
                if dict.keys.contains("NetworkAclId") {
                    self.networkAclId = dict["NetworkAclId"] as! String
                }
                if dict.keys.contains("NetworkAclName") {
                    self.networkAclName = dict["NetworkAclName"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! Int64
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Resources") {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources()
                    model.fromMap(dict["Resources"] as! [String: Any])
                    self.resources = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var networkAcl: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkAcl != nil {
                var tmp : [Any] = []
                for k in self.networkAcl! {
                    tmp.append(k.toMap())
                }
                map["NetworkAcl"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkAcl") {
                var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl] = []
                for v in dict["NetworkAcl"] as! [Any] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.networkAcl = tmp
            }
        }
    }
    public var networkAcls: DescribeNetworkAclsResponseBody.NetworkAcls?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAcls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAcls != nil {
            map["NetworkAcls"] = self.networkAcls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAcls") {
            var model = DescribeNetworkAclsResponseBody.NetworkAcls()
            model.fromMap(dict["NetworkAcls"] as! [String: Any])
            self.networkAcls = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeNetworkAclsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkAclsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkAclsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePhysicalConnectionLOARequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribePhysicalConnectionLOAResponseBody : Tea.TeaModel {
    public class PhysicalConnectionLOAType : Tea.TeaModel {
        public class PMInfo : Tea.TeaModel {
            public class PMInfo : Tea.TeaModel {
                public var PMCertificateNo: String?

                public var PMCertificateType: String?

                public var PMContactInfo: String?

                public var PMGender: String?

                public var PMName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.PMCertificateNo != nil {
                        map["PMCertificateNo"] = self.PMCertificateNo!
                    }
                    if self.PMCertificateType != nil {
                        map["PMCertificateType"] = self.PMCertificateType!
                    }
                    if self.PMContactInfo != nil {
                        map["PMContactInfo"] = self.PMContactInfo!
                    }
                    if self.PMGender != nil {
                        map["PMGender"] = self.PMGender!
                    }
                    if self.PMName != nil {
                        map["PMName"] = self.PMName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PMCertificateNo") {
                        self.PMCertificateNo = dict["PMCertificateNo"] as! String
                    }
                    if dict.keys.contains("PMCertificateType") {
                        self.PMCertificateType = dict["PMCertificateType"] as! String
                    }
                    if dict.keys.contains("PMContactInfo") {
                        self.PMContactInfo = dict["PMContactInfo"] as! String
                    }
                    if dict.keys.contains("PMGender") {
                        self.PMGender = dict["PMGender"] as! String
                    }
                    if dict.keys.contains("PMName") {
                        self.PMName = dict["PMName"] as! String
                    }
                }
            }
            public var PMInfo: [DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo.PMInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.PMInfo != nil {
                    var tmp : [Any] = []
                    for k in self.PMInfo! {
                        tmp.append(k.toMap())
                    }
                    map["PMInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PMInfo") {
                    var tmp : [DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo.PMInfo] = []
                    for v in dict["PMInfo"] as! [Any] {
                        var model = DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo.PMInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.PMInfo = tmp
                }
            }
        }
        public var companyLocalizedName: String?

        public var companyName: String?

        public var constructionTime: String?

        public var instanceId: String?

        public var lineCode: String?

        public var lineLabel: String?

        public var lineSPContactInfo: String?

        public var lineServiceProvider: String?

        public var lineType: String?

        public var loaUrl: String?

        public var PMInfo: DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo?

        public var SI: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.PMInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.companyLocalizedName != nil {
                map["CompanyLocalizedName"] = self.companyLocalizedName!
            }
            if self.companyName != nil {
                map["CompanyName"] = self.companyName!
            }
            if self.constructionTime != nil {
                map["ConstructionTime"] = self.constructionTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lineCode != nil {
                map["LineCode"] = self.lineCode!
            }
            if self.lineLabel != nil {
                map["LineLabel"] = self.lineLabel!
            }
            if self.lineSPContactInfo != nil {
                map["LineSPContactInfo"] = self.lineSPContactInfo!
            }
            if self.lineServiceProvider != nil {
                map["LineServiceProvider"] = self.lineServiceProvider!
            }
            if self.lineType != nil {
                map["LineType"] = self.lineType!
            }
            if self.loaUrl != nil {
                map["LoaUrl"] = self.loaUrl!
            }
            if self.PMInfo != nil {
                map["PMInfo"] = self.PMInfo?.toMap()
            }
            if self.SI != nil {
                map["SI"] = self.SI!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompanyLocalizedName") {
                self.companyLocalizedName = dict["CompanyLocalizedName"] as! String
            }
            if dict.keys.contains("CompanyName") {
                self.companyName = dict["CompanyName"] as! String
            }
            if dict.keys.contains("ConstructionTime") {
                self.constructionTime = dict["ConstructionTime"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LineCode") {
                self.lineCode = dict["LineCode"] as! String
            }
            if dict.keys.contains("LineLabel") {
                self.lineLabel = dict["LineLabel"] as! String
            }
            if dict.keys.contains("LineSPContactInfo") {
                self.lineSPContactInfo = dict["LineSPContactInfo"] as! String
            }
            if dict.keys.contains("LineServiceProvider") {
                self.lineServiceProvider = dict["LineServiceProvider"] as! String
            }
            if dict.keys.contains("LineType") {
                self.lineType = dict["LineType"] as! String
            }
            if dict.keys.contains("LoaUrl") {
                self.loaUrl = dict["LoaUrl"] as! String
            }
            if dict.keys.contains("PMInfo") {
                var model = DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo()
                model.fromMap(dict["PMInfo"] as! [String: Any])
                self.PMInfo = model
            }
            if dict.keys.contains("SI") {
                self.SI = dict["SI"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var physicalConnectionLOAType: DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.physicalConnectionLOAType?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.physicalConnectionLOAType != nil {
            map["PhysicalConnectionLOAType"] = self.physicalConnectionLOAType?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PhysicalConnectionLOAType") {
            var model = DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType()
            model.fromMap(dict["PhysicalConnectionLOAType"] as! [String: Any])
            self.physicalConnectionLOAType = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePhysicalConnectionLOAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePhysicalConnectionLOAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePhysicalConnectionLOAResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePhysicalConnectionsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var filter: [DescribePhysicalConnectionsRequest.Filter]?

    public var includeReservationData: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribePhysicalConnectionsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Filter") {
            var tmp : [DescribePhysicalConnectionsRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribePhysicalConnectionsRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("IncludeReservationData") {
            self.includeReservationData = dict["IncludeReservationData"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribePhysicalConnectionsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribePhysicalConnectionsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class DescribePhysicalConnectionsResponseBody : Tea.TeaModel {
    public class PhysicalConnectionSet : Tea.TeaModel {
        public class PhysicalConnectionType : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tags: [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags.Tags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tags != nil {
                        var tmp : [Any] = []
                        for k in self.tags! {
                            tmp.append(k.toMap())
                        }
                        map["tags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("tags") {
                        var tmp : [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags.Tags] = []
                        for v in dict["tags"] as! [Any] {
                            var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags.Tags()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tags = tmp
                    }
                }
            }
            public var accessPointId: String?

            public var accessPointType: String?

            public var adDetailLocation: String?

            public var adLocation: String?

            public var bandwidth: Int64?

            public var businessStatus: String?

            public var chargeType: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var description_: String?

            public var enabledTime: String?

            public var endTime: String?

            public var expectSpec: String?

            public var hasReservationData: String?

            public var lineOperator: String?

            public var loaStatus: String?

            public var name: String?

            public var orderMode: String?

            public var parentPhysicalConnectionAliUid: Int64?

            public var parentPhysicalConnectionId: String?

            public var peerLocation: String?

            public var physicalConnectionId: String?

            public var portNumber: String?

            public var portType: String?

            public var productType: String?

            public var qosId: String?

            public var redundantPhysicalConnectionId: String?

            public var reservationActiveTime: String?

            public var reservationInternetChargeType: String?

            public var reservationOrderType: String?

            public var resourceGroupId: String?

            public var spec: String?

            public var status: String?

            public var tags: DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags?

            public var type: String?

            public var virtualPhysicalConnectionCount: Int32?

            public var vlanId: String?

            public var vpconnStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.accessPointType != nil {
                    map["AccessPointType"] = self.accessPointType!
                }
                if self.adDetailLocation != nil {
                    map["AdDetailLocation"] = self.adDetailLocation!
                }
                if self.adLocation != nil {
                    map["AdLocation"] = self.adLocation!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabledTime != nil {
                    map["EnabledTime"] = self.enabledTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.expectSpec != nil {
                    map["ExpectSpec"] = self.expectSpec!
                }
                if self.hasReservationData != nil {
                    map["HasReservationData"] = self.hasReservationData!
                }
                if self.lineOperator != nil {
                    map["LineOperator"] = self.lineOperator!
                }
                if self.loaStatus != nil {
                    map["LoaStatus"] = self.loaStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.orderMode != nil {
                    map["OrderMode"] = self.orderMode!
                }
                if self.parentPhysicalConnectionAliUid != nil {
                    map["ParentPhysicalConnectionAliUid"] = self.parentPhysicalConnectionAliUid!
                }
                if self.parentPhysicalConnectionId != nil {
                    map["ParentPhysicalConnectionId"] = self.parentPhysicalConnectionId!
                }
                if self.peerLocation != nil {
                    map["PeerLocation"] = self.peerLocation!
                }
                if self.physicalConnectionId != nil {
                    map["PhysicalConnectionId"] = self.physicalConnectionId!
                }
                if self.portNumber != nil {
                    map["PortNumber"] = self.portNumber!
                }
                if self.portType != nil {
                    map["PortType"] = self.portType!
                }
                if self.productType != nil {
                    map["ProductType"] = self.productType!
                }
                if self.qosId != nil {
                    map["QosId"] = self.qosId!
                }
                if self.redundantPhysicalConnectionId != nil {
                    map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
                }
                if self.reservationActiveTime != nil {
                    map["ReservationActiveTime"] = self.reservationActiveTime!
                }
                if self.reservationInternetChargeType != nil {
                    map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                }
                if self.reservationOrderType != nil {
                    map["ReservationOrderType"] = self.reservationOrderType!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.virtualPhysicalConnectionCount != nil {
                    map["VirtualPhysicalConnectionCount"] = self.virtualPhysicalConnectionCount!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                if self.vpconnStatus != nil {
                    map["VpconnStatus"] = self.vpconnStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessPointId") {
                    self.accessPointId = dict["AccessPointId"] as! String
                }
                if dict.keys.contains("AccessPointType") {
                    self.accessPointType = dict["AccessPointType"] as! String
                }
                if dict.keys.contains("AdDetailLocation") {
                    self.adDetailLocation = dict["AdDetailLocation"] as! String
                }
                if dict.keys.contains("AdLocation") {
                    self.adLocation = dict["AdLocation"] as! String
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! Int64
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CircuitCode") {
                    self.circuitCode = dict["CircuitCode"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnabledTime") {
                    self.enabledTime = dict["EnabledTime"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("ExpectSpec") {
                    self.expectSpec = dict["ExpectSpec"] as! String
                }
                if dict.keys.contains("HasReservationData") {
                    self.hasReservationData = dict["HasReservationData"] as! String
                }
                if dict.keys.contains("LineOperator") {
                    self.lineOperator = dict["LineOperator"] as! String
                }
                if dict.keys.contains("LoaStatus") {
                    self.loaStatus = dict["LoaStatus"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OrderMode") {
                    self.orderMode = dict["OrderMode"] as! String
                }
                if dict.keys.contains("ParentPhysicalConnectionAliUid") {
                    self.parentPhysicalConnectionAliUid = dict["ParentPhysicalConnectionAliUid"] as! Int64
                }
                if dict.keys.contains("ParentPhysicalConnectionId") {
                    self.parentPhysicalConnectionId = dict["ParentPhysicalConnectionId"] as! String
                }
                if dict.keys.contains("PeerLocation") {
                    self.peerLocation = dict["PeerLocation"] as! String
                }
                if dict.keys.contains("PhysicalConnectionId") {
                    self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
                }
                if dict.keys.contains("PortNumber") {
                    self.portNumber = dict["PortNumber"] as! String
                }
                if dict.keys.contains("PortType") {
                    self.portType = dict["PortType"] as! String
                }
                if dict.keys.contains("ProductType") {
                    self.productType = dict["ProductType"] as! String
                }
                if dict.keys.contains("QosId") {
                    self.qosId = dict["QosId"] as! String
                }
                if dict.keys.contains("RedundantPhysicalConnectionId") {
                    self.redundantPhysicalConnectionId = dict["RedundantPhysicalConnectionId"] as! String
                }
                if dict.keys.contains("ReservationActiveTime") {
                    self.reservationActiveTime = dict["ReservationActiveTime"] as! String
                }
                if dict.keys.contains("ReservationInternetChargeType") {
                    self.reservationInternetChargeType = dict["ReservationInternetChargeType"] as! String
                }
                if dict.keys.contains("ReservationOrderType") {
                    self.reservationOrderType = dict["ReservationOrderType"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VirtualPhysicalConnectionCount") {
                    self.virtualPhysicalConnectionCount = dict["VirtualPhysicalConnectionCount"] as! Int32
                }
                if dict.keys.contains("VlanId") {
                    self.vlanId = dict["VlanId"] as! String
                }
                if dict.keys.contains("VpconnStatus") {
                    self.vpconnStatus = dict["VpconnStatus"] as! String
                }
            }
        }
        public var physicalConnectionType: [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.physicalConnectionType != nil {
                var tmp : [Any] = []
                for k in self.physicalConnectionType! {
                    tmp.append(k.toMap())
                }
                map["PhysicalConnectionType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PhysicalConnectionType") {
                var tmp : [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType] = []
                for v in dict["PhysicalConnectionType"] as! [Any] {
                    var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.physicalConnectionType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var physicalConnectionSet: DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.physicalConnectionSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.physicalConnectionSet != nil {
            map["PhysicalConnectionSet"] = self.physicalConnectionSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PhysicalConnectionSet") {
            var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet()
            model.fromMap(dict["PhysicalConnectionSet"] as! [String: Any])
            self.physicalConnectionSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePhysicalConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePhysicalConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePhysicalConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePublicIpAddressRequest : Tea.TeaModel {
    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribePublicIpAddressResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var publicIpAddress: [String]?

    public var regionId: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.publicIpAddress != nil {
            map["PublicIpAddress"] = self.publicIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PublicIpAddress") {
            self.publicIpAddress = dict["PublicIpAddress"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePublicIpAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePublicIpAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePublicIpAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var productType: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProductType") {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class Region : Tea.TeaModel {
            public var localName: String?

            public var regionEndpoint: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("RegionEndpoint") {
                    self.regionEndpoint = dict["RegionEndpoint"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var region: [DescribeRegionsResponseBody.Regions.Region]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                var tmp : [Any] = []
                for k in self.region! {
                    tmp.append(k.toMap())
                }
                map["Region"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Region") {
                var tmp : [DescribeRegionsResponseBody.Regions.Region] = []
                for v in dict["Region"] as! [Any] {
                    var model = DescribeRegionsResponseBody.Regions.Region()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.region = tmp
            }
        }
    }
    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(dict["Regions"] as! [String: Any])
            self.regions = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRouteEntryListRequest : Tea.TeaModel {
    public var destCidrBlockList: [String]?

    public var destinationCidrBlock: String?

    public var ipVersion: String?

    public var maxResult: Int32?

    public var nextHopId: String?

    public var nextHopType: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryId: String?

    public var routeEntryName: String?

    public var routeEntryType: String?

    public var routeTableId: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destCidrBlockList != nil {
            map["DestCidrBlockList"] = self.destCidrBlockList!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.maxResult != nil {
            map["MaxResult"] = self.maxResult!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestCidrBlockList") {
            self.destCidrBlockList = dict["DestCidrBlockList"] as! [String]
        }
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("MaxResult") {
            self.maxResult = dict["MaxResult"] as! Int32
        }
        if dict.keys.contains("NextHopId") {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopType") {
            self.nextHopType = dict["NextHopType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntryId") {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
        if dict.keys.contains("RouteEntryName") {
            self.routeEntryName = dict["RouteEntryName"] as! String
        }
        if dict.keys.contains("RouteEntryType") {
            self.routeEntryType = dict["RouteEntryType"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class DescribeRouteEntryListResponseBody : Tea.TeaModel {
    public class RouteEntrys : Tea.TeaModel {
        public class RouteEntry : Tea.TeaModel {
            public class NextHops : Tea.TeaModel {
                public class NextHop : Tea.TeaModel {
                    public class NextHopRelatedInfo : Tea.TeaModel {
                        public var instanceId: String?

                        public var instanceType: String?

                        public var regionId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.instanceId != nil {
                                map["InstanceId"] = self.instanceId!
                            }
                            if self.instanceType != nil {
                                map["InstanceType"] = self.instanceType!
                            }
                            if self.regionId != nil {
                                map["RegionId"] = self.regionId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("InstanceId") {
                                self.instanceId = dict["InstanceId"] as! String
                            }
                            if dict.keys.contains("InstanceType") {
                                self.instanceType = dict["InstanceType"] as! String
                            }
                            if dict.keys.contains("RegionId") {
                                self.regionId = dict["RegionId"] as! String
                            }
                        }
                    }
                    public var enabled: Int32?

                    public var nextHopId: String?

                    public var nextHopRegionId: String?

                    public var nextHopRelatedInfo: DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop.NextHopRelatedInfo?

                    public var nextHopType: String?

                    public var weight: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.nextHopRelatedInfo?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.enabled != nil {
                            map["Enabled"] = self.enabled!
                        }
                        if self.nextHopId != nil {
                            map["NextHopId"] = self.nextHopId!
                        }
                        if self.nextHopRegionId != nil {
                            map["NextHopRegionId"] = self.nextHopRegionId!
                        }
                        if self.nextHopRelatedInfo != nil {
                            map["NextHopRelatedInfo"] = self.nextHopRelatedInfo?.toMap()
                        }
                        if self.nextHopType != nil {
                            map["NextHopType"] = self.nextHopType!
                        }
                        if self.weight != nil {
                            map["Weight"] = self.weight!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Enabled") {
                            self.enabled = dict["Enabled"] as! Int32
                        }
                        if dict.keys.contains("NextHopId") {
                            self.nextHopId = dict["NextHopId"] as! String
                        }
                        if dict.keys.contains("NextHopRegionId") {
                            self.nextHopRegionId = dict["NextHopRegionId"] as! String
                        }
                        if dict.keys.contains("NextHopRelatedInfo") {
                            var model = DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop.NextHopRelatedInfo()
                            model.fromMap(dict["NextHopRelatedInfo"] as! [String: Any])
                            self.nextHopRelatedInfo = model
                        }
                        if dict.keys.contains("NextHopType") {
                            self.nextHopType = dict["NextHopType"] as! String
                        }
                        if dict.keys.contains("Weight") {
                            self.weight = dict["Weight"] as! Int32
                        }
                    }
                }
                public var nextHop: [DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nextHop != nil {
                        var tmp : [Any] = []
                        for k in self.nextHop! {
                            tmp.append(k.toMap())
                        }
                        map["NextHop"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NextHop") {
                        var tmp : [DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop] = []
                        for v in dict["NextHop"] as! [Any] {
                            var model = DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.nextHop = tmp
                    }
                }
            }
            public var description_: String?

            public var destinationCidrBlock: String?

            public var gmtModified: String?

            public var ipVersion: String?

            public var nextHops: DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops?

            public var origin: String?

            public var routeEntryId: String?

            public var routeEntryName: String?

            public var routeTableId: String?

            public var serviceType: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.nextHops?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.destinationCidrBlock != nil {
                    map["DestinationCidrBlock"] = self.destinationCidrBlock!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.nextHops != nil {
                    map["NextHops"] = self.nextHops?.toMap()
                }
                if self.origin != nil {
                    map["Origin"] = self.origin!
                }
                if self.routeEntryId != nil {
                    map["RouteEntryId"] = self.routeEntryId!
                }
                if self.routeEntryName != nil {
                    map["RouteEntryName"] = self.routeEntryName!
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.serviceType != nil {
                    map["ServiceType"] = self.serviceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DestinationCidrBlock") {
                    self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("IpVersion") {
                    self.ipVersion = dict["IpVersion"] as! String
                }
                if dict.keys.contains("NextHops") {
                    var model = DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops()
                    model.fromMap(dict["NextHops"] as! [String: Any])
                    self.nextHops = model
                }
                if dict.keys.contains("Origin") {
                    self.origin = dict["Origin"] as! String
                }
                if dict.keys.contains("RouteEntryId") {
                    self.routeEntryId = dict["RouteEntryId"] as! String
                }
                if dict.keys.contains("RouteEntryName") {
                    self.routeEntryName = dict["RouteEntryName"] as! String
                }
                if dict.keys.contains("RouteTableId") {
                    self.routeTableId = dict["RouteTableId"] as! String
                }
                if dict.keys.contains("ServiceType") {
                    self.serviceType = dict["ServiceType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var routeEntry: [DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeEntry != nil {
                var tmp : [Any] = []
                for k in self.routeEntry! {
                    tmp.append(k.toMap())
                }
                map["RouteEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouteEntry") {
                var tmp : [DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry] = []
                for v in dict["RouteEntry"] as! [Any] {
                    var model = DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routeEntry = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var routeEntrys: DescribeRouteEntryListResponseBody.RouteEntrys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeEntrys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntrys != nil {
            map["RouteEntrys"] = self.routeEntrys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntrys") {
            var model = DescribeRouteEntryListResponseBody.RouteEntrys()
            model.fromMap(dict["RouteEntrys"] as! [String: Any])
            self.routeEntrys = model
        }
    }
}

public class DescribeRouteEntryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouteEntryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRouteEntryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRouteTableListRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var routeTableName: String?

    public var routeTableType: String?

    public var routerId: String?

    public var routerType: String?

    public var tag: [DescribeRouteTableListRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        if self.routeTableType != nil {
            map["RouteTableType"] = self.routeTableType!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("RouteTableName") {
            self.routeTableName = dict["RouteTableName"] as! String
        }
        if dict.keys.contains("RouteTableType") {
            self.routeTableType = dict["RouteTableType"] as! String
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
        if dict.keys.contains("RouterType") {
            self.routerType = dict["RouterType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeRouteTableListRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeRouteTableListRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeRouteTableListResponseBody : Tea.TeaModel {
    public class RouterTableList : Tea.TeaModel {
        public class RouterTableListType : Tea.TeaModel {
            public class GatewayIds : Tea.TeaModel {
                public var gatewayIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gatewayIds != nil {
                        map["GatewayIds"] = self.gatewayIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GatewayIds") {
                        self.gatewayIds = dict["GatewayIds"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! [String]
                    }
                }
            }
            public var associateType: String?

            public var creationTime: String?

            public var description_: String?

            public var gatewayIds: DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.GatewayIds?

            public var ownerId: Int64?

            public var resourceGroupId: String?

            public var routePropagationEnable: Bool?

            public var routeTableId: String?

            public var routeTableName: String?

            public var routeTableType: String?

            public var routerId: String?

            public var routerType: String?

            public var status: String?

            public var tags: DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags?

            public var vSwitchIds: DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.VSwitchIds?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.gatewayIds?.validate()
                try self.tags?.validate()
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associateType != nil {
                    map["AssociateType"] = self.associateType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gatewayIds != nil {
                    map["GatewayIds"] = self.gatewayIds?.toMap()
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routePropagationEnable != nil {
                    map["RoutePropagationEnable"] = self.routePropagationEnable!
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.routeTableName != nil {
                    map["RouteTableName"] = self.routeTableName!
                }
                if self.routeTableType != nil {
                    map["RouteTableType"] = self.routeTableType!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.routerType != nil {
                    map["RouterType"] = self.routerType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssociateType") {
                    self.associateType = dict["AssociateType"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GatewayIds") {
                    var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.GatewayIds()
                    model.fromMap(dict["GatewayIds"] as! [String: Any])
                    self.gatewayIds = model
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! Int64
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RoutePropagationEnable") {
                    self.routePropagationEnable = dict["RoutePropagationEnable"] as! Bool
                }
                if dict.keys.contains("RouteTableId") {
                    self.routeTableId = dict["RouteTableId"] as! String
                }
                if dict.keys.contains("RouteTableName") {
                    self.routeTableName = dict["RouteTableName"] as! String
                }
                if dict.keys.contains("RouteTableType") {
                    self.routeTableType = dict["RouteTableType"] as! String
                }
                if dict.keys.contains("RouterId") {
                    self.routerId = dict["RouterId"] as! String
                }
                if dict.keys.contains("RouterType") {
                    self.routerType = dict["RouterType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VSwitchIds") {
                    var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.VSwitchIds()
                    model.fromMap(dict["VSwitchIds"] as! [String: Any])
                    self.vSwitchIds = model
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var routerTableListType: [DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routerTableListType != nil {
                var tmp : [Any] = []
                for k in self.routerTableListType! {
                    tmp.append(k.toMap())
                }
                map["RouterTableListType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouterTableListType") {
                var tmp : [DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType] = []
                for v in dict["RouterTableListType"] as! [Any] {
                    var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routerTableListType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routerTableList: DescribeRouteTableListResponseBody.RouterTableList?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routerTableList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerTableList != nil {
            map["RouterTableList"] = self.routerTableList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouterTableList") {
            var model = DescribeRouteTableListResponseBody.RouterTableList()
            model.fromMap(dict["RouterTableList"] as! [String: Any])
            self.routerTableList = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeRouteTableListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouteTableListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRouteTableListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRouteTablesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var routeTableName: String?

    public var routerId: String?

    public var routerType: String?

    public var type: String?

    public var VRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("RouteTableName") {
            self.routeTableName = dict["RouteTableName"] as! String
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
        if dict.keys.contains("RouterType") {
            self.routerType = dict["RouterType"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
    }
}

public class DescribeRouteTablesResponseBody : Tea.TeaModel {
    public class RouteTables : Tea.TeaModel {
        public class RouteTable : Tea.TeaModel {
            public class RouteEntrys : Tea.TeaModel {
                public class RouteEntry : Tea.TeaModel {
                    public class NextHops : Tea.TeaModel {
                        public class NextHop : Tea.TeaModel {
                            public var enabled: Int32?

                            public var nextHopId: String?

                            public var nextHopType: String?

                            public var weight: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.enabled != nil {
                                    map["Enabled"] = self.enabled!
                                }
                                if self.nextHopId != nil {
                                    map["NextHopId"] = self.nextHopId!
                                }
                                if self.nextHopType != nil {
                                    map["NextHopType"] = self.nextHopType!
                                }
                                if self.weight != nil {
                                    map["Weight"] = self.weight!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Enabled") {
                                    self.enabled = dict["Enabled"] as! Int32
                                }
                                if dict.keys.contains("NextHopId") {
                                    self.nextHopId = dict["NextHopId"] as! String
                                }
                                if dict.keys.contains("NextHopType") {
                                    self.nextHopType = dict["NextHopType"] as! String
                                }
                                if dict.keys.contains("Weight") {
                                    self.weight = dict["Weight"] as! Int32
                                }
                            }
                        }
                        public var nextHop: [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.nextHop != nil {
                                var tmp : [Any] = []
                                for k in self.nextHop! {
                                    tmp.append(k.toMap())
                                }
                                map["NextHop"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("NextHop") {
                                var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop] = []
                                for v in dict["NextHop"] as! [Any] {
                                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.nextHop = tmp
                            }
                        }
                    }
                    public var description_: String?

                    public var destinationCidrBlock: String?

                    public var instanceId: String?

                    public var nextHopType: String?

                    public var nextHops: DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops?

                    public var routeEntryId: String?

                    public var routeEntryName: String?

                    public var routeTableId: String?

                    public var status: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.nextHops?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.destinationCidrBlock != nil {
                            map["DestinationCidrBlock"] = self.destinationCidrBlock!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.nextHopType != nil {
                            map["NextHopType"] = self.nextHopType!
                        }
                        if self.nextHops != nil {
                            map["NextHops"] = self.nextHops?.toMap()
                        }
                        if self.routeEntryId != nil {
                            map["RouteEntryId"] = self.routeEntryId!
                        }
                        if self.routeEntryName != nil {
                            map["RouteEntryName"] = self.routeEntryName!
                        }
                        if self.routeTableId != nil {
                            map["RouteTableId"] = self.routeTableId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("DestinationCidrBlock") {
                            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("NextHopType") {
                            self.nextHopType = dict["NextHopType"] as! String
                        }
                        if dict.keys.contains("NextHops") {
                            var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops()
                            model.fromMap(dict["NextHops"] as! [String: Any])
                            self.nextHops = model
                        }
                        if dict.keys.contains("RouteEntryId") {
                            self.routeEntryId = dict["RouteEntryId"] as! String
                        }
                        if dict.keys.contains("RouteEntryName") {
                            self.routeEntryName = dict["RouteEntryName"] as! String
                        }
                        if dict.keys.contains("RouteTableId") {
                            self.routeTableId = dict["RouteTableId"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var routeEntry: [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeEntry != nil {
                        var tmp : [Any] = []
                        for k in self.routeEntry! {
                            tmp.append(k.toMap())
                        }
                        map["RouteEntry"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RouteEntry") {
                        var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry] = []
                        for v in dict["RouteEntry"] as! [Any] {
                            var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.routeEntry = tmp
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! [String]
                    }
                }
            }
            public var creationTime: String?

            public var resourceGroupId: String?

            public var routeEntrys: DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys?

            public var routeTableId: String?

            public var routeTableType: String?

            public var status: String?

            public var VRouterId: String?

            public var vSwitchIds: DescribeRouteTablesResponseBody.RouteTables.RouteTable.VSwitchIds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeEntrys?.validate()
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routeEntrys != nil {
                    map["RouteEntrys"] = self.routeEntrys?.toMap()
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.routeTableType != nil {
                    map["RouteTableType"] = self.routeTableType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RouteEntrys") {
                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys()
                    model.fromMap(dict["RouteEntrys"] as! [String: Any])
                    self.routeEntrys = model
                }
                if dict.keys.contains("RouteTableId") {
                    self.routeTableId = dict["RouteTableId"] as! String
                }
                if dict.keys.contains("RouteTableType") {
                    self.routeTableType = dict["RouteTableType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VRouterId") {
                    self.VRouterId = dict["VRouterId"] as! String
                }
                if dict.keys.contains("VSwitchIds") {
                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.VSwitchIds()
                    model.fromMap(dict["VSwitchIds"] as! [String: Any])
                    self.vSwitchIds = model
                }
            }
        }
        public var routeTable: [DescribeRouteTablesResponseBody.RouteTables.RouteTable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeTable != nil {
                var tmp : [Any] = []
                for k in self.routeTable! {
                    tmp.append(k.toMap())
                }
                map["RouteTable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouteTable") {
                var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable] = []
                for v in dict["RouteTable"] as! [Any] {
                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routeTable = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routeTables: DescribeRouteTablesResponseBody.RouteTables?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeTables?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTables != nil {
            map["RouteTables"] = self.routeTables?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteTables") {
            var model = DescribeRouteTablesResponseBody.RouteTables()
            model.fromMap(dict["RouteTables"] as! [String: Any])
            self.routeTables = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeRouteTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouteTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRouteTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRouterInterfaceAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeRouterInterfaceAttributeResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var tags: [DescribeRouterInterfaceAttributeResponseBody.Tags.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tags") {
                var tmp : [DescribeRouterInterfaceAttributeResponseBody.Tags.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeRouterInterfaceAttributeResponseBody.Tags.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var accessPointId: String?

    public var bandwidth: Int32?

    public var businessStatus: String?

    public var chargeType: String?

    public var code: String?

    public var connectedTime: String?

    public var creationTime: String?

    public var crossBorder: Bool?

    public var description_: String?

    public var endTime: String?

    public var fastLinkMode: String?

    public var gmtModified: String?

    public var hasReservationData: String?

    public var hcRate: Int32?

    public var hcThreshold: Int32?

    public var healthCheckSourceIp: String?

    public var healthCheckStatus: String?

    public var healthCheckTargetIp: String?

    public var message: String?

    public var name: String?

    public var oppositeAccessPointId: String?

    public var oppositeBandwidth: Int32?

    public var oppositeInterfaceBusinessStatus: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: String?

    public var oppositeInterfaceSpec: String?

    public var oppositeInterfaceStatus: String?

    public var oppositeRegionId: String?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var oppositeVpcInstanceId: String?

    public var requestId: String?

    public var reservationActiveTime: String?

    public var reservationBandwidth: String?

    public var reservationInternetChargeType: String?

    public var reservationOrderType: String?

    public var resourceGroupId: String?

    public var role: String?

    public var routerId: String?

    public var routerInterfaceId: String?

    public var routerType: String?

    public var spec: String?

    public var status: String?

    public var success: Bool?

    public var tags: DescribeRouterInterfaceAttributeResponseBody.Tags?

    public var vpcInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.connectedTime != nil {
            map["ConnectedTime"] = self.connectedTime!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.crossBorder != nil {
            map["CrossBorder"] = self.crossBorder!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.fastLinkMode != nil {
            map["FastLinkMode"] = self.fastLinkMode!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.hasReservationData != nil {
            map["HasReservationData"] = self.hasReservationData!
        }
        if self.hcRate != nil {
            map["HcRate"] = self.hcRate!
        }
        if self.hcThreshold != nil {
            map["HcThreshold"] = self.hcThreshold!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckStatus != nil {
            map["HealthCheckStatus"] = self.healthCheckStatus!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeAccessPointId != nil {
            map["OppositeAccessPointId"] = self.oppositeAccessPointId!
        }
        if self.oppositeBandwidth != nil {
            map["OppositeBandwidth"] = self.oppositeBandwidth!
        }
        if self.oppositeInterfaceBusinessStatus != nil {
            map["OppositeInterfaceBusinessStatus"] = self.oppositeInterfaceBusinessStatus!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeInterfaceSpec != nil {
            map["OppositeInterfaceSpec"] = self.oppositeInterfaceSpec!
        }
        if self.oppositeInterfaceStatus != nil {
            map["OppositeInterfaceStatus"] = self.oppositeInterfaceStatus!
        }
        if self.oppositeRegionId != nil {
            map["OppositeRegionId"] = self.oppositeRegionId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.oppositeVpcInstanceId != nil {
            map["OppositeVpcInstanceId"] = self.oppositeVpcInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservationActiveTime != nil {
            map["ReservationActiveTime"] = self.reservationActiveTime!
        }
        if self.reservationBandwidth != nil {
            map["ReservationBandwidth"] = self.reservationBandwidth!
        }
        if self.reservationInternetChargeType != nil {
            map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
        }
        if self.reservationOrderType != nil {
            map["ReservationOrderType"] = self.reservationOrderType!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.vpcInstanceId != nil {
            map["VpcInstanceId"] = self.vpcInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPointId") {
            self.accessPointId = dict["AccessPointId"] as! String
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ConnectedTime") {
            self.connectedTime = dict["ConnectedTime"] as! String
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("CrossBorder") {
            self.crossBorder = dict["CrossBorder"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FastLinkMode") {
            self.fastLinkMode = dict["FastLinkMode"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("HasReservationData") {
            self.hasReservationData = dict["HasReservationData"] as! String
        }
        if dict.keys.contains("HcRate") {
            self.hcRate = dict["HcRate"] as! Int32
        }
        if dict.keys.contains("HcThreshold") {
            self.hcThreshold = dict["HcThreshold"] as! Int32
        }
        if dict.keys.contains("HealthCheckSourceIp") {
            self.healthCheckSourceIp = dict["HealthCheckSourceIp"] as! String
        }
        if dict.keys.contains("HealthCheckStatus") {
            self.healthCheckStatus = dict["HealthCheckStatus"] as! String
        }
        if dict.keys.contains("HealthCheckTargetIp") {
            self.healthCheckTargetIp = dict["HealthCheckTargetIp"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OppositeAccessPointId") {
            self.oppositeAccessPointId = dict["OppositeAccessPointId"] as! String
        }
        if dict.keys.contains("OppositeBandwidth") {
            self.oppositeBandwidth = dict["OppositeBandwidth"] as! Int32
        }
        if dict.keys.contains("OppositeInterfaceBusinessStatus") {
            self.oppositeInterfaceBusinessStatus = dict["OppositeInterfaceBusinessStatus"] as! String
        }
        if dict.keys.contains("OppositeInterfaceId") {
            self.oppositeInterfaceId = dict["OppositeInterfaceId"] as! String
        }
        if dict.keys.contains("OppositeInterfaceOwnerId") {
            self.oppositeInterfaceOwnerId = dict["OppositeInterfaceOwnerId"] as! String
        }
        if dict.keys.contains("OppositeInterfaceSpec") {
            self.oppositeInterfaceSpec = dict["OppositeInterfaceSpec"] as! String
        }
        if dict.keys.contains("OppositeInterfaceStatus") {
            self.oppositeInterfaceStatus = dict["OppositeInterfaceStatus"] as! String
        }
        if dict.keys.contains("OppositeRegionId") {
            self.oppositeRegionId = dict["OppositeRegionId"] as! String
        }
        if dict.keys.contains("OppositeRouterId") {
            self.oppositeRouterId = dict["OppositeRouterId"] as! String
        }
        if dict.keys.contains("OppositeRouterType") {
            self.oppositeRouterType = dict["OppositeRouterType"] as! String
        }
        if dict.keys.contains("OppositeVpcInstanceId") {
            self.oppositeVpcInstanceId = dict["OppositeVpcInstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservationActiveTime") {
            self.reservationActiveTime = dict["ReservationActiveTime"] as! String
        }
        if dict.keys.contains("ReservationBandwidth") {
            self.reservationBandwidth = dict["ReservationBandwidth"] as! String
        }
        if dict.keys.contains("ReservationInternetChargeType") {
            self.reservationInternetChargeType = dict["ReservationInternetChargeType"] as! String
        }
        if dict.keys.contains("ReservationOrderType") {
            self.reservationOrderType = dict["ReservationOrderType"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
        if dict.keys.contains("RouterType") {
            self.routerType = dict["RouterType"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Tags") {
            var model = DescribeRouterInterfaceAttributeResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
        if dict.keys.contains("VpcInstanceId") {
            self.vpcInstanceId = dict["VpcInstanceId"] as! String
        }
    }
}

public class DescribeRouterInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouterInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRouterInterfaceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRouterInterfacesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var filter: [DescribeRouterInterfacesRequest.Filter]?

    public var includeReservationData: Bool?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribeRouterInterfacesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeRouterInterfacesRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeRouterInterfacesRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("IncludeReservationData") {
            self.includeReservationData = dict["IncludeReservationData"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeRouterInterfacesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeRouterInterfacesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class DescribeRouterInterfacesResponseBody : Tea.TeaModel {
    public class RouterInterfaceSet : Tea.TeaModel {
        public class RouterInterfaceType : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tags: [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags.Tags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tags != nil {
                        var tmp : [Any] = []
                        for k in self.tags! {
                            tmp.append(k.toMap())
                        }
                        map["Tags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tags") {
                        var tmp : [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags.Tags] = []
                        for v in dict["Tags"] as! [Any] {
                            var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags.Tags()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tags = tmp
                    }
                }
            }
            public var accessPointId: String?

            public var bandwidth: Int32?

            public var businessStatus: String?

            public var chargeType: String?

            public var connectedTime: String?

            public var creationTime: String?

            public var crossBorder: Bool?

            public var description_: String?

            public var endTime: String?

            public var fastLinkMode: Bool?

            public var hasReservationData: String?

            public var hcRate: Int32?

            public var hcThreshold: Int32?

            public var healthCheckSourceIp: String?

            public var healthCheckTargetIp: String?

            public var ipv6Status: String?

            public var name: String?

            public var oppositeAccessPointId: String?

            public var oppositeBandwidth: Int32?

            public var oppositeInterfaceBusinessStatus: String?

            public var oppositeInterfaceId: String?

            public var oppositeInterfaceOwnerId: String?

            public var oppositeInterfaceSpec: String?

            public var oppositeInterfaceStatus: String?

            public var oppositeRegionId: String?

            public var oppositeRouterId: String?

            public var oppositeRouterType: String?

            public var oppositeVpcInstanceId: String?

            public var reservationActiveTime: String?

            public var reservationBandwidth: String?

            public var reservationInternetChargeType: String?

            public var reservationOrderType: String?

            public var resourceGroupId: String?

            public var role: String?

            public var routerId: String?

            public var routerInterfaceId: String?

            public var routerType: String?

            public var spec: String?

            public var status: String?

            public var tags: DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags?

            public var vpcInstanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.connectedTime != nil {
                    map["ConnectedTime"] = self.connectedTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.crossBorder != nil {
                    map["CrossBorder"] = self.crossBorder!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.fastLinkMode != nil {
                    map["FastLinkMode"] = self.fastLinkMode!
                }
                if self.hasReservationData != nil {
                    map["HasReservationData"] = self.hasReservationData!
                }
                if self.hcRate != nil {
                    map["HcRate"] = self.hcRate!
                }
                if self.hcThreshold != nil {
                    map["HcThreshold"] = self.hcThreshold!
                }
                if self.healthCheckSourceIp != nil {
                    map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
                }
                if self.healthCheckTargetIp != nil {
                    map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
                }
                if self.ipv6Status != nil {
                    map["Ipv6Status"] = self.ipv6Status!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.oppositeAccessPointId != nil {
                    map["OppositeAccessPointId"] = self.oppositeAccessPointId!
                }
                if self.oppositeBandwidth != nil {
                    map["OppositeBandwidth"] = self.oppositeBandwidth!
                }
                if self.oppositeInterfaceBusinessStatus != nil {
                    map["OppositeInterfaceBusinessStatus"] = self.oppositeInterfaceBusinessStatus!
                }
                if self.oppositeInterfaceId != nil {
                    map["OppositeInterfaceId"] = self.oppositeInterfaceId!
                }
                if self.oppositeInterfaceOwnerId != nil {
                    map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
                }
                if self.oppositeInterfaceSpec != nil {
                    map["OppositeInterfaceSpec"] = self.oppositeInterfaceSpec!
                }
                if self.oppositeInterfaceStatus != nil {
                    map["OppositeInterfaceStatus"] = self.oppositeInterfaceStatus!
                }
                if self.oppositeRegionId != nil {
                    map["OppositeRegionId"] = self.oppositeRegionId!
                }
                if self.oppositeRouterId != nil {
                    map["OppositeRouterId"] = self.oppositeRouterId!
                }
                if self.oppositeRouterType != nil {
                    map["OppositeRouterType"] = self.oppositeRouterType!
                }
                if self.oppositeVpcInstanceId != nil {
                    map["OppositeVpcInstanceId"] = self.oppositeVpcInstanceId!
                }
                if self.reservationActiveTime != nil {
                    map["ReservationActiveTime"] = self.reservationActiveTime!
                }
                if self.reservationBandwidth != nil {
                    map["ReservationBandwidth"] = self.reservationBandwidth!
                }
                if self.reservationInternetChargeType != nil {
                    map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                }
                if self.reservationOrderType != nil {
                    map["ReservationOrderType"] = self.reservationOrderType!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.routerInterfaceId != nil {
                    map["RouterInterfaceId"] = self.routerInterfaceId!
                }
                if self.routerType != nil {
                    map["RouterType"] = self.routerType!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcInstanceId != nil {
                    map["VpcInstanceId"] = self.vpcInstanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessPointId") {
                    self.accessPointId = dict["AccessPointId"] as! String
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("ConnectedTime") {
                    self.connectedTime = dict["ConnectedTime"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("CrossBorder") {
                    self.crossBorder = dict["CrossBorder"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("FastLinkMode") {
                    self.fastLinkMode = dict["FastLinkMode"] as! Bool
                }
                if dict.keys.contains("HasReservationData") {
                    self.hasReservationData = dict["HasReservationData"] as! String
                }
                if dict.keys.contains("HcRate") {
                    self.hcRate = dict["HcRate"] as! Int32
                }
                if dict.keys.contains("HcThreshold") {
                    self.hcThreshold = dict["HcThreshold"] as! Int32
                }
                if dict.keys.contains("HealthCheckSourceIp") {
                    self.healthCheckSourceIp = dict["HealthCheckSourceIp"] as! String
                }
                if dict.keys.contains("HealthCheckTargetIp") {
                    self.healthCheckTargetIp = dict["HealthCheckTargetIp"] as! String
                }
                if dict.keys.contains("Ipv6Status") {
                    self.ipv6Status = dict["Ipv6Status"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OppositeAccessPointId") {
                    self.oppositeAccessPointId = dict["OppositeAccessPointId"] as! String
                }
                if dict.keys.contains("OppositeBandwidth") {
                    self.oppositeBandwidth = dict["OppositeBandwidth"] as! Int32
                }
                if dict.keys.contains("OppositeInterfaceBusinessStatus") {
                    self.oppositeInterfaceBusinessStatus = dict["OppositeInterfaceBusinessStatus"] as! String
                }
                if dict.keys.contains("OppositeInterfaceId") {
                    self.oppositeInterfaceId = dict["OppositeInterfaceId"] as! String
                }
                if dict.keys.contains("OppositeInterfaceOwnerId") {
                    self.oppositeInterfaceOwnerId = dict["OppositeInterfaceOwnerId"] as! String
                }
                if dict.keys.contains("OppositeInterfaceSpec") {
                    self.oppositeInterfaceSpec = dict["OppositeInterfaceSpec"] as! String
                }
                if dict.keys.contains("OppositeInterfaceStatus") {
                    self.oppositeInterfaceStatus = dict["OppositeInterfaceStatus"] as! String
                }
                if dict.keys.contains("OppositeRegionId") {
                    self.oppositeRegionId = dict["OppositeRegionId"] as! String
                }
                if dict.keys.contains("OppositeRouterId") {
                    self.oppositeRouterId = dict["OppositeRouterId"] as! String
                }
                if dict.keys.contains("OppositeRouterType") {
                    self.oppositeRouterType = dict["OppositeRouterType"] as! String
                }
                if dict.keys.contains("OppositeVpcInstanceId") {
                    self.oppositeVpcInstanceId = dict["OppositeVpcInstanceId"] as! String
                }
                if dict.keys.contains("ReservationActiveTime") {
                    self.reservationActiveTime = dict["ReservationActiveTime"] as! String
                }
                if dict.keys.contains("ReservationBandwidth") {
                    self.reservationBandwidth = dict["ReservationBandwidth"] as! String
                }
                if dict.keys.contains("ReservationInternetChargeType") {
                    self.reservationInternetChargeType = dict["ReservationInternetChargeType"] as! String
                }
                if dict.keys.contains("ReservationOrderType") {
                    self.reservationOrderType = dict["ReservationOrderType"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("RouterId") {
                    self.routerId = dict["RouterId"] as! String
                }
                if dict.keys.contains("RouterInterfaceId") {
                    self.routerInterfaceId = dict["RouterInterfaceId"] as! String
                }
                if dict.keys.contains("RouterType") {
                    self.routerType = dict["RouterType"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VpcInstanceId") {
                    self.vpcInstanceId = dict["VpcInstanceId"] as! String
                }
            }
        }
        public var routerInterfaceType: [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routerInterfaceType != nil {
                var tmp : [Any] = []
                for k in self.routerInterfaceType! {
                    tmp.append(k.toMap())
                }
                map["RouterInterfaceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouterInterfaceType") {
                var tmp : [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType] = []
                for v in dict["RouterInterfaceType"] as! [Any] {
                    var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routerInterfaceType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routerInterfaceSet: DescribeRouterInterfacesResponseBody.RouterInterfaceSet?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routerInterfaceSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerInterfaceSet != nil {
            map["RouterInterfaceSet"] = self.routerInterfaceSet?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouterInterfaceSet") {
            var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet()
            model.fromMap(dict["RouterInterfaceSet"] as! [String: Any])
            self.routerInterfaceSet = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeRouterInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouterInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRouterInterfacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServerRelatedGlobalAccelerationInstancesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serverId: String?

    public var serverType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        if self.serverType != nil {
            map["ServerType"] = self.serverType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
        if dict.keys.contains("ServerType") {
            self.serverType = dict["ServerType"] as! String
        }
    }
}

public class DescribeServerRelatedGlobalAccelerationInstancesResponseBody : Tea.TeaModel {
    public class GlobalAccelerationInstances : Tea.TeaModel {
        public class GlobalAccelerationInstance : Tea.TeaModel {
            public var globalAccelerationInstanceId: String?

            public var ipAddress: String?

            public var regionId: String?

            public var serverIpAddress: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.globalAccelerationInstanceId != nil {
                    map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.serverIpAddress != nil {
                    map["ServerIpAddress"] = self.serverIpAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GlobalAccelerationInstanceId") {
                    self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ServerIpAddress") {
                    self.serverIpAddress = dict["ServerIpAddress"] as! String
                }
            }
        }
        public var globalAccelerationInstance: [DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.globalAccelerationInstance != nil {
                var tmp : [Any] = []
                for k in self.globalAccelerationInstance! {
                    tmp.append(k.toMap())
                }
                map["GlobalAccelerationInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GlobalAccelerationInstance") {
                var tmp : [DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance] = []
                for v in dict["GlobalAccelerationInstance"] as! [Any] {
                    var model = DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.globalAccelerationInstance = tmp
            }
        }
    }
    public var globalAccelerationInstances: DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.globalAccelerationInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstances != nil {
            map["GlobalAccelerationInstances"] = self.globalAccelerationInstances?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalAccelerationInstances") {
            var model = DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances()
            model.fromMap(dict["GlobalAccelerationInstances"] as! [String: Any])
            self.globalAccelerationInstances = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeServerRelatedGlobalAccelerationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServerRelatedGlobalAccelerationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeServerRelatedGlobalAccelerationInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnatTableEntriesRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var networkInterfaceIds: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snatEntryId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public var snatTableId: String?

    public var sourceCIDR: String?

    public var sourceVSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.networkInterfaceIds != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.snatTableId != nil {
            map["SnatTableId"] = self.snatTableId!
        }
        if self.sourceCIDR != nil {
            map["SourceCIDR"] = self.sourceCIDR!
        }
        if self.sourceVSwitchId != nil {
            map["SourceVSwitchId"] = self.sourceVSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceIds") {
            self.networkInterfaceIds = dict["NetworkInterfaceIds"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatEntryName") {
            self.snatEntryName = dict["SnatEntryName"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
        if dict.keys.contains("SnatTableId") {
            self.snatTableId = dict["SnatTableId"] as! String
        }
        if dict.keys.contains("SourceCIDR") {
            self.sourceCIDR = dict["SourceCIDR"] as! String
        }
        if dict.keys.contains("SourceVSwitchId") {
            self.sourceVSwitchId = dict["SourceVSwitchId"] as! String
        }
    }
}

public class DescribeSnatTableEntriesResponseBody : Tea.TeaModel {
    public class SnatTableEntries : Tea.TeaModel {
        public class SnatTableEntry : Tea.TeaModel {
            public var eipAffinity: String?

            public var natGatewayId: String?

            public var networkInterfaceId: String?

            public var snatEntryId: String?

            public var snatEntryName: String?

            public var snatIp: String?

            public var snatTableId: String?

            public var sourceCIDR: String?

            public var sourceVSwitchId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eipAffinity != nil {
                    map["EipAffinity"] = self.eipAffinity!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.snatEntryId != nil {
                    map["SnatEntryId"] = self.snatEntryId!
                }
                if self.snatEntryName != nil {
                    map["SnatEntryName"] = self.snatEntryName!
                }
                if self.snatIp != nil {
                    map["SnatIp"] = self.snatIp!
                }
                if self.snatTableId != nil {
                    map["SnatTableId"] = self.snatTableId!
                }
                if self.sourceCIDR != nil {
                    map["SourceCIDR"] = self.sourceCIDR!
                }
                if self.sourceVSwitchId != nil {
                    map["SourceVSwitchId"] = self.sourceVSwitchId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EipAffinity") {
                    self.eipAffinity = dict["EipAffinity"] as! String
                }
                if dict.keys.contains("NatGatewayId") {
                    self.natGatewayId = dict["NatGatewayId"] as! String
                }
                if dict.keys.contains("NetworkInterfaceId") {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                }
                if dict.keys.contains("SnatEntryId") {
                    self.snatEntryId = dict["SnatEntryId"] as! String
                }
                if dict.keys.contains("SnatEntryName") {
                    self.snatEntryName = dict["SnatEntryName"] as! String
                }
                if dict.keys.contains("SnatIp") {
                    self.snatIp = dict["SnatIp"] as! String
                }
                if dict.keys.contains("SnatTableId") {
                    self.snatTableId = dict["SnatTableId"] as! String
                }
                if dict.keys.contains("SourceCIDR") {
                    self.sourceCIDR = dict["SourceCIDR"] as! String
                }
                if dict.keys.contains("SourceVSwitchId") {
                    self.sourceVSwitchId = dict["SourceVSwitchId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var snatTableEntry: [DescribeSnatTableEntriesResponseBody.SnatTableEntries.SnatTableEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snatTableEntry != nil {
                var tmp : [Any] = []
                for k in self.snatTableEntry! {
                    tmp.append(k.toMap())
                }
                map["SnatTableEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnatTableEntry") {
                var tmp : [DescribeSnatTableEntriesResponseBody.SnatTableEntries.SnatTableEntry] = []
                for v in dict["SnatTableEntry"] as! [Any] {
                    var model = DescribeSnatTableEntriesResponseBody.SnatTableEntries.SnatTableEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.snatTableEntry = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snatTableEntries: DescribeSnatTableEntriesResponseBody.SnatTableEntries?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snatTableEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatTableEntries != nil {
            map["SnatTableEntries"] = self.snatTableEntries?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnatTableEntries") {
            var model = DescribeSnatTableEntriesResponseBody.SnatTableEntries()
            model.fromMap(dict["SnatTableEntries"] as! [String: Any])
            self.snatTableEntries = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSnatTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnatTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnatTableEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSslVpnClientCertRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslVpnClientCertId") {
            self.sslVpnClientCertId = dict["SslVpnClientCertId"] as! String
        }
    }
}

public class DescribeSslVpnClientCertResponseBody : Tea.TeaModel {
    public var caCert: String?

    public var clientCert: String?

    public var clientConfig: String?

    public var clientKey: String?

    public var createTime: Int64?

    public var endTime: Int64?

    public var name: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var sslVpnClientCertId: String?

    public var sslVpnServerId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.caCert != nil {
            map["CaCert"] = self.caCert!
        }
        if self.clientCert != nil {
            map["ClientCert"] = self.clientCert!
        }
        if self.clientConfig != nil {
            map["ClientConfig"] = self.clientConfig!
        }
        if self.clientKey != nil {
            map["ClientKey"] = self.clientKey!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CaCert") {
            self.caCert = dict["CaCert"] as! String
        }
        if dict.keys.contains("ClientCert") {
            self.clientCert = dict["ClientCert"] as! String
        }
        if dict.keys.contains("ClientConfig") {
            self.clientConfig = dict["ClientConfig"] as! String
        }
        if dict.keys.contains("ClientKey") {
            self.clientKey = dict["ClientKey"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SslVpnClientCertId") {
            self.sslVpnClientCertId = dict["SslVpnClientCertId"] as! String
        }
        if dict.keys.contains("SslVpnServerId") {
            self.sslVpnServerId = dict["SslVpnServerId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeSslVpnClientCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSslVpnClientCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSslVpnClientCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSslVpnClientCertsRequest : Tea.TeaModel {
    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslVpnClientCertId") {
            self.sslVpnClientCertId = dict["SslVpnClientCertId"] as! String
        }
        if dict.keys.contains("SslVpnServerId") {
            self.sslVpnServerId = dict["SslVpnServerId"] as! String
        }
    }
}

public class DescribeSslVpnClientCertsResponseBody : Tea.TeaModel {
    public class SslVpnClientCertKeys : Tea.TeaModel {
        public class SslVpnClientCertKey : Tea.TeaModel {
            public var createTime: Int64?

            public var endTime: Int64?

            public var name: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var sslVpnClientCertId: String?

            public var sslVpnServerId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.sslVpnClientCertId != nil {
                    map["SslVpnClientCertId"] = self.sslVpnClientCertId!
                }
                if self.sslVpnServerId != nil {
                    map["SslVpnServerId"] = self.sslVpnServerId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SslVpnClientCertId") {
                    self.sslVpnClientCertId = dict["SslVpnClientCertId"] as! String
                }
                if dict.keys.contains("SslVpnServerId") {
                    self.sslVpnServerId = dict["SslVpnServerId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var sslVpnClientCertKey: [DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys.SslVpnClientCertKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sslVpnClientCertKey != nil {
                var tmp : [Any] = []
                for k in self.sslVpnClientCertKey! {
                    tmp.append(k.toMap())
                }
                map["SslVpnClientCertKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SslVpnClientCertKey") {
                var tmp : [DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys.SslVpnClientCertKey] = []
                for v in dict["SslVpnClientCertKey"] as! [Any] {
                    var model = DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys.SslVpnClientCertKey()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sslVpnClientCertKey = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sslVpnClientCertKeys: DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sslVpnClientCertKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnClientCertKeys != nil {
            map["SslVpnClientCertKeys"] = self.sslVpnClientCertKeys?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SslVpnClientCertKeys") {
            var model = DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys()
            model.fromMap(dict["SslVpnClientCertKeys"] as! [String: Any])
            self.sslVpnClientCertKeys = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSslVpnClientCertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSslVpnClientCertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSslVpnClientCertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSslVpnClientsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DescribeSslVpnClientsResponseBody : Tea.TeaModel {
    public class ClientInfoList : Tea.TeaModel {
        public var commonName: String?

        public var connectedTime: Int64?

        public var ip: String?

        public var port: String?

        public var privateIp: String?

        public var receiveBytes: Int64?

        public var sendBytes: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commonName != nil {
                map["CommonName"] = self.commonName!
            }
            if self.connectedTime != nil {
                map["ConnectedTime"] = self.connectedTime!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.privateIp != nil {
                map["PrivateIp"] = self.privateIp!
            }
            if self.receiveBytes != nil {
                map["ReceiveBytes"] = self.receiveBytes!
            }
            if self.sendBytes != nil {
                map["SendBytes"] = self.sendBytes!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommonName") {
                self.commonName = dict["CommonName"] as! String
            }
            if dict.keys.contains("ConnectedTime") {
                self.connectedTime = dict["ConnectedTime"] as! Int64
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("PrivateIp") {
                self.privateIp = dict["PrivateIp"] as! String
            }
            if dict.keys.contains("ReceiveBytes") {
                self.receiveBytes = dict["ReceiveBytes"] as! Int64
            }
            if dict.keys.contains("SendBytes") {
                self.sendBytes = dict["SendBytes"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var clientInfoList: [DescribeSslVpnClientsResponseBody.ClientInfoList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientInfoList != nil {
            var tmp : [Any] = []
            for k in self.clientInfoList! {
                tmp.append(k.toMap())
            }
            map["ClientInfoList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientInfoList") {
            var tmp : [DescribeSslVpnClientsResponseBody.ClientInfoList] = []
            for v in dict["ClientInfoList"] as! [Any] {
                var model = DescribeSslVpnClientsResponseBody.ClientInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clientInfoList = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DescribeSslVpnClientsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSslVpnClientsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSslVpnClientsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSslVpnServersRequest : Tea.TeaModel {
    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnServerId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslVpnServerId") {
            self.sslVpnServerId = dict["SslVpnServerId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DescribeSslVpnServersResponseBody : Tea.TeaModel {
    public class SslVpnServers : Tea.TeaModel {
        public class SslVpnServer : Tea.TeaModel {
            public var cipher: String?

            public var clientIpPool: String?

            public var compress: Bool?

            public var connections: Int32?

            public var createTime: Int64?

            public var enableMultiFactorAuth: Bool?

            public var IDaaSApplicationId: String?

            public var IDaaSInstanceId: String?

            public var IDaaSInstanceVersion: String?

            public var IDaaSRegionId: String?

            public var internetIp: String?

            public var localSubnet: String?

            public var maxConnections: Int32?

            public var name: String?

            public var port: Int32?

            public var proto: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var sslVpnServerId: String?

            public var vpnGatewayId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cipher != nil {
                    map["Cipher"] = self.cipher!
                }
                if self.clientIpPool != nil {
                    map["ClientIpPool"] = self.clientIpPool!
                }
                if self.compress != nil {
                    map["Compress"] = self.compress!
                }
                if self.connections != nil {
                    map["Connections"] = self.connections!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.enableMultiFactorAuth != nil {
                    map["EnableMultiFactorAuth"] = self.enableMultiFactorAuth!
                }
                if self.IDaaSApplicationId != nil {
                    map["IDaaSApplicationId"] = self.IDaaSApplicationId!
                }
                if self.IDaaSInstanceId != nil {
                    map["IDaaSInstanceId"] = self.IDaaSInstanceId!
                }
                if self.IDaaSInstanceVersion != nil {
                    map["IDaaSInstanceVersion"] = self.IDaaSInstanceVersion!
                }
                if self.IDaaSRegionId != nil {
                    map["IDaaSRegionId"] = self.IDaaSRegionId!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.localSubnet != nil {
                    map["LocalSubnet"] = self.localSubnet!
                }
                if self.maxConnections != nil {
                    map["MaxConnections"] = self.maxConnections!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.proto != nil {
                    map["Proto"] = self.proto!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.sslVpnServerId != nil {
                    map["SslVpnServerId"] = self.sslVpnServerId!
                }
                if self.vpnGatewayId != nil {
                    map["VpnGatewayId"] = self.vpnGatewayId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cipher") {
                    self.cipher = dict["Cipher"] as! String
                }
                if dict.keys.contains("ClientIpPool") {
                    self.clientIpPool = dict["ClientIpPool"] as! String
                }
                if dict.keys.contains("Compress") {
                    self.compress = dict["Compress"] as! Bool
                }
                if dict.keys.contains("Connections") {
                    self.connections = dict["Connections"] as! Int32
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("EnableMultiFactorAuth") {
                    self.enableMultiFactorAuth = dict["EnableMultiFactorAuth"] as! Bool
                }
                if dict.keys.contains("IDaaSApplicationId") {
                    self.IDaaSApplicationId = dict["IDaaSApplicationId"] as! String
                }
                if dict.keys.contains("IDaaSInstanceId") {
                    self.IDaaSInstanceId = dict["IDaaSInstanceId"] as! String
                }
                if dict.keys.contains("IDaaSInstanceVersion") {
                    self.IDaaSInstanceVersion = dict["IDaaSInstanceVersion"] as! String
                }
                if dict.keys.contains("IDaaSRegionId") {
                    self.IDaaSRegionId = dict["IDaaSRegionId"] as! String
                }
                if dict.keys.contains("InternetIp") {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("LocalSubnet") {
                    self.localSubnet = dict["LocalSubnet"] as! String
                }
                if dict.keys.contains("MaxConnections") {
                    self.maxConnections = dict["MaxConnections"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Proto") {
                    self.proto = dict["Proto"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SslVpnServerId") {
                    self.sslVpnServerId = dict["SslVpnServerId"] as! String
                }
                if dict.keys.contains("VpnGatewayId") {
                    self.vpnGatewayId = dict["VpnGatewayId"] as! String
                }
            }
        }
        public var sslVpnServer: [DescribeSslVpnServersResponseBody.SslVpnServers.SslVpnServer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sslVpnServer != nil {
                var tmp : [Any] = []
                for k in self.sslVpnServer! {
                    tmp.append(k.toMap())
                }
                map["SslVpnServer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SslVpnServer") {
                var tmp : [DescribeSslVpnServersResponseBody.SslVpnServers.SslVpnServer] = []
                for v in dict["SslVpnServer"] as! [Any] {
                    var model = DescribeSslVpnServersResponseBody.SslVpnServers.SslVpnServer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sslVpnServer = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sslVpnServers: DescribeSslVpnServersResponseBody.SslVpnServers?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sslVpnServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnServers != nil {
            map["SslVpnServers"] = self.sslVpnServers?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SslVpnServers") {
            var model = DescribeSslVpnServersResponseBody.SslVpnServers()
            model.fromMap(dict["SslVpnServers"] as! [String: Any])
            self.sslVpnServers = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSslVpnServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSslVpnServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSslVpnServersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagKeysRequest : Tea.TeaModel {
    public var keyword: String?

    public var maxResult: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.maxResult != nil {
            map["MaxResult"] = self.maxResult!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("MaxResult") {
            self.maxResult = dict["MaxResult"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeTagKeysResponseBody : Tea.TeaModel {
    public class TagKeys : Tea.TeaModel {
        public class TagKey : Tea.TeaModel {
            public var tagKey: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var tagKey: [DescribeTagKeysResponseBody.TagKeys.TagKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                var tmp : [Any] = []
                for k in self.tagKey! {
                    tmp.append(k.toMap())
                }
                map["TagKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagKey") {
                var tmp : [DescribeTagKeysResponseBody.TagKeys.TagKey] = []
                for v in dict["TagKey"] as! [Any] {
                    var model = DescribeTagKeysResponseBody.TagKeys.TagKey()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagKey = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagKeys: DescribeTagKeysResponseBody.TagKeys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagKeys") {
            var model = DescribeTagKeysResponseBody.TagKeys()
            model.fromMap(dict["TagKeys"] as! [String: Any])
            self.tagKeys = model
        }
    }
}

public class DescribeTagKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagKeysForExpressConnectRequest : Tea.TeaModel {
    public var keyword: String?

    public var maxResult: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.maxResult != nil {
            map["MaxResult"] = self.maxResult!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("MaxResult") {
            self.maxResult = dict["MaxResult"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeTagKeysForExpressConnectResponseBody : Tea.TeaModel {
    public class TagKeys : Tea.TeaModel {
        public class TagKey : Tea.TeaModel {
            public var tagKey: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var tagKey: [DescribeTagKeysForExpressConnectResponseBody.TagKeys.TagKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                var tmp : [Any] = []
                for k in self.tagKey! {
                    tmp.append(k.toMap())
                }
                map["TagKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagKey") {
                var tmp : [DescribeTagKeysForExpressConnectResponseBody.TagKeys.TagKey] = []
                for v in dict["TagKey"] as! [Any] {
                    var model = DescribeTagKeysForExpressConnectResponseBody.TagKeys.TagKey()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagKey = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagKeys: DescribeTagKeysForExpressConnectResponseBody.TagKeys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagKeys") {
            var model = DescribeTagKeysForExpressConnectResponseBody.TagKeys()
            model.fromMap(dict["TagKeys"] as! [String: Any])
            self.tagKeys = model
        }
    }
}

public class DescribeTagKeysForExpressConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagKeysForExpressConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagKeysForExpressConnectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var maxResult: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [DescribeTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResult != nil {
            map["MaxResult"] = self.maxResult!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResult") {
            self.maxResult = dict["MaxResult"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeTagsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeTagsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeTagsResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [DescribeTagsResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") {
                var tmp : [DescribeTagsResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = DescribeTagsResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: DescribeTagsResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var model = DescribeTagsResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class DescribeTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVRoutersRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
    }
}

public class DescribeVRoutersResponseBody : Tea.TeaModel {
    public class VRouters : Tea.TeaModel {
        public class VRouter : Tea.TeaModel {
            public class RouteTableIds : Tea.TeaModel {
                public var routeTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeTableId != nil {
                        map["RouteTableId"] = self.routeTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RouteTableId") {
                        self.routeTableId = dict["RouteTableId"] as! [String]
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var regionId: String?

            public var routeTableIds: DescribeVRoutersResponseBody.VRouters.VRouter.RouteTableIds?

            public var VRouterId: String?

            public var VRouterName: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeTableIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.routeTableIds != nil {
                    map["RouteTableIds"] = self.routeTableIds?.toMap()
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.VRouterName != nil {
                    map["VRouterName"] = self.VRouterName!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RouteTableIds") {
                    var model = DescribeVRoutersResponseBody.VRouters.VRouter.RouteTableIds()
                    model.fromMap(dict["RouteTableIds"] as! [String: Any])
                    self.routeTableIds = model
                }
                if dict.keys.contains("VRouterId") {
                    self.VRouterId = dict["VRouterId"] as! String
                }
                if dict.keys.contains("VRouterName") {
                    self.VRouterName = dict["VRouterName"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var VRouter: [DescribeVRoutersResponseBody.VRouters.VRouter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.VRouter != nil {
                var tmp : [Any] = []
                for k in self.VRouter! {
                    tmp.append(k.toMap())
                }
                map["VRouter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VRouter") {
                var tmp : [DescribeVRoutersResponseBody.VRouters.VRouter] = []
                for v in dict["VRouter"] as! [Any] {
                    var model = DescribeVRoutersResponseBody.VRouters.VRouter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VRouter = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var VRouters: DescribeVRoutersResponseBody.VRouters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.VRouters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.VRouters != nil {
            map["VRouters"] = self.VRouters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VRouters") {
            var model = DescribeVRoutersResponseBody.VRouters()
            model.fromMap(dict["VRouters"] as! [String: Any])
            self.VRouters = model
        }
    }
}

public class DescribeVRoutersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVRoutersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVRoutersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVSwitchAttributesRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeVSwitchAttributesResponseBody : Tea.TeaModel {
    public class RouteTable : Tea.TeaModel {
        public var routeTableId: String?

        public var routeTableType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            if self.routeTableType != nil {
                map["RouteTableType"] = self.routeTableType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! String
            }
            if dict.keys.contains("RouteTableType") {
                self.routeTableType = dict["RouteTableType"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var tag: [DescribeVSwitchAttributesResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") {
                var tmp : [DescribeVSwitchAttributesResponseBody.Tags.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = DescribeVSwitchAttributesResponseBody.Tags.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public var availableIpAddressCount: Int64?

    public var cidrBlock: String?

    public var creationTime: String?

    public var description_: String?

    public var enabledIpv6: Bool?

    public var ipv6CidrBlock: String?

    public var isDefault: Bool?

    public var networkAclId: String?

    public var ownerId: Int64?

    public var requestId: String?

    public var resourceGroupId: String?

    public var routeTable: DescribeVSwitchAttributesResponseBody.RouteTable?

    public var shareType: String?

    public var status: String?

    public var tags: DescribeVSwitchAttributesResponseBody.Tags?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeTable?.validate()
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableIpAddressCount != nil {
            map["AvailableIpAddressCount"] = self.availableIpAddressCount!
        }
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabledIpv6 != nil {
            map["EnabledIpv6"] = self.enabledIpv6!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.routeTable != nil {
            map["RouteTable"] = self.routeTable?.toMap()
        }
        if self.shareType != nil {
            map["ShareType"] = self.shareType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableIpAddressCount") {
            self.availableIpAddressCount = dict["AvailableIpAddressCount"] as! Int64
        }
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnabledIpv6") {
            self.enabledIpv6 = dict["EnabledIpv6"] as! Bool
        }
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RouteTable") {
            var model = DescribeVSwitchAttributesResponseBody.RouteTable()
            model.fromMap(dict["RouteTable"] as! [String: Any])
            self.routeTable = model
        }
        if dict.keys.contains("ShareType") {
            self.shareType = dict["ShareType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var model = DescribeVSwitchAttributesResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeVSwitchAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVSwitchAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVSwitchesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dryRun: Bool?

    public var enableIpv6: Bool?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var tag: [DescribeVSwitchesRequest.Tag]?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public var vSwitchOwnerId: Int64?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vSwitchOwnerId != nil {
            map["VSwitchOwnerId"] = self.vSwitchOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnableIpv6") {
            self.enableIpv6 = dict["EnableIpv6"] as! Bool
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeVSwitchesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeVSwitchesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
        if dict.keys.contains("VSwitchOwnerId") {
            self.vSwitchOwnerId = dict["VSwitchOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeVSwitchesResponseBody : Tea.TeaModel {
    public class VSwitches : Tea.TeaModel {
        public class VSwitch : Tea.TeaModel {
            public class RouteTable : Tea.TeaModel {
                public var routeTableId: String?

                public var routeTableType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeTableId != nil {
                        map["RouteTableId"] = self.routeTableId!
                    }
                    if self.routeTableType != nil {
                        map["RouteTableType"] = self.routeTableType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RouteTableId") {
                        self.routeTableId = dict["RouteTableId"] as! String
                    }
                    if dict.keys.contains("RouteTableType") {
                        self.routeTableType = dict["RouteTableType"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var availableIpAddressCount: Int64?

            public var cidrBlock: String?

            public var creationTime: String?

            public var description_: String?

            public var enabledIpv6: Bool?

            public var ipv6CidrBlock: String?

            public var isDefault: Bool?

            public var networkAclId: String?

            public var ownerId: Int64?

            public var resourceGroupId: String?

            public var routeTable: DescribeVSwitchesResponseBody.VSwitches.VSwitch.RouteTable?

            public var shareType: String?

            public var status: String?

            public var tags: DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags?

            public var vSwitchId: String?

            public var vSwitchName: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeTable?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableIpAddressCount != nil {
                    map["AvailableIpAddressCount"] = self.availableIpAddressCount!
                }
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabledIpv6 != nil {
                    map["EnabledIpv6"] = self.enabledIpv6!
                }
                if self.ipv6CidrBlock != nil {
                    map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.networkAclId != nil {
                    map["NetworkAclId"] = self.networkAclId!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routeTable != nil {
                    map["RouteTable"] = self.routeTable?.toMap()
                }
                if self.shareType != nil {
                    map["ShareType"] = self.shareType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vSwitchName != nil {
                    map["VSwitchName"] = self.vSwitchName!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableIpAddressCount") {
                    self.availableIpAddressCount = dict["AvailableIpAddressCount"] as! Int64
                }
                if dict.keys.contains("CidrBlock") {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnabledIpv6") {
                    self.enabledIpv6 = dict["EnabledIpv6"] as! Bool
                }
                if dict.keys.contains("Ipv6CidrBlock") {
                    self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
                }
                if dict.keys.contains("IsDefault") {
                    self.isDefault = dict["IsDefault"] as! Bool
                }
                if dict.keys.contains("NetworkAclId") {
                    self.networkAclId = dict["NetworkAclId"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! Int64
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RouteTable") {
                    var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch.RouteTable()
                    model.fromMap(dict["RouteTable"] as! [String: Any])
                    self.routeTable = model
                }
                if dict.keys.contains("ShareType") {
                    self.shareType = dict["ShareType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VSwitchName") {
                    self.vSwitchName = dict["VSwitchName"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var vSwitch: [DescribeVSwitchesResponseBody.VSwitches.VSwitch]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitch != nil {
                var tmp : [Any] = []
                for k in self.vSwitch! {
                    tmp.append(k.toMap())
                }
                map["VSwitch"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VSwitch") {
                var tmp : [DescribeVSwitchesResponseBody.VSwitches.VSwitch] = []
                for v in dict["VSwitch"] as! [Any] {
                    var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vSwitch = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vSwitches: DescribeVSwitchesResponseBody.VSwitches?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vSwitches?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vSwitches != nil {
            map["VSwitches"] = self.vSwitches?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VSwitches") {
            var model = DescribeVSwitchesResponseBody.VSwitches()
            model.fromMap(dict["VSwitches"] as! [String: Any])
            self.vSwitches = model
        }
    }
}

public class DescribeVSwitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVSwitchesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVbrHaRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrHaId: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrHaId != nil {
            map["VbrHaId"] = self.vbrHaId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VbrHaId") {
            self.vbrHaId = dict["VbrHaId"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class DescribeVbrHaResponseBody : Tea.TeaModel {
    public var creationTime: String?

    public var description_: String?

    public var name: String?

    public var peerVbrId: String?

    public var regionId: String?

    public var requestId: String?

    public var status: String?

    public var vbrHaId: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.peerVbrId != nil {
            map["PeerVbrId"] = self.peerVbrId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vbrHaId != nil {
            map["VbrHaId"] = self.vbrHaId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PeerVbrId") {
            self.peerVbrId = dict["PeerVbrId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VbrHaId") {
            self.vbrHaId = dict["VbrHaId"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class DescribeVbrHaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVbrHaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVbrHaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVcoRouteEntriesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryType: String?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntryType") {
            self.routeEntryType = dict["RouteEntryType"] as! String
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class DescribeVcoRouteEntriesResponseBody : Tea.TeaModel {
    public class VcoRouteEntries : Tea.TeaModel {
        public var asPath: String?

        public var community: String?

        public var createTime: Int64?

        public var nextHop: String?

        public var nextHopTunnelIdList: [String]?

        public var routeDest: String?

        public var routeEntryType: String?

        public var source: String?

        public var state: String?

        public var vpnConnectionId: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asPath != nil {
                map["AsPath"] = self.asPath!
            }
            if self.community != nil {
                map["Community"] = self.community!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            if self.nextHopTunnelIdList != nil {
                map["NextHopTunnelIdList"] = self.nextHopTunnelIdList!
            }
            if self.routeDest != nil {
                map["RouteDest"] = self.routeDest!
            }
            if self.routeEntryType != nil {
                map["RouteEntryType"] = self.routeEntryType!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.vpnConnectionId != nil {
                map["VpnConnectionId"] = self.vpnConnectionId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsPath") {
                self.asPath = dict["AsPath"] as! String
            }
            if dict.keys.contains("Community") {
                self.community = dict["Community"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("NextHop") {
                self.nextHop = dict["NextHop"] as! String
            }
            if dict.keys.contains("NextHopTunnelIdList") {
                self.nextHopTunnelIdList = dict["NextHopTunnelIdList"] as! [String]
            }
            if dict.keys.contains("RouteDest") {
                self.routeDest = dict["RouteDest"] as! String
            }
            if dict.keys.contains("RouteEntryType") {
                self.routeEntryType = dict["RouteEntryType"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("VpnConnectionId") {
                self.vpnConnectionId = dict["VpnConnectionId"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class VpnRouteCounts : Tea.TeaModel {
        public var routeCount: Int32?

        public var routeEntryType: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeCount != nil {
                map["RouteCount"] = self.routeCount!
            }
            if self.routeEntryType != nil {
                map["RouteEntryType"] = self.routeEntryType!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouteCount") {
                self.routeCount = dict["RouteCount"] as! Int32
            }
            if dict.keys.contains("RouteEntryType") {
                self.routeEntryType = dict["RouteEntryType"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vcoRouteEntries: [DescribeVcoRouteEntriesResponseBody.VcoRouteEntries]?

    public var vpnRouteCounts: [DescribeVcoRouteEntriesResponseBody.VpnRouteCounts]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vcoRouteEntries != nil {
            var tmp : [Any] = []
            for k in self.vcoRouteEntries! {
                tmp.append(k.toMap())
            }
            map["VcoRouteEntries"] = tmp
        }
        if self.vpnRouteCounts != nil {
            var tmp : [Any] = []
            for k in self.vpnRouteCounts! {
                tmp.append(k.toMap())
            }
            map["VpnRouteCounts"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VcoRouteEntries") {
            var tmp : [DescribeVcoRouteEntriesResponseBody.VcoRouteEntries] = []
            for v in dict["VcoRouteEntries"] as! [Any] {
                var model = DescribeVcoRouteEntriesResponseBody.VcoRouteEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vcoRouteEntries = tmp
        }
        if dict.keys.contains("VpnRouteCounts") {
            var tmp : [DescribeVcoRouteEntriesResponseBody.VpnRouteCounts] = []
            for v in dict["VpnRouteCounts"] as! [Any] {
                var model = DescribeVcoRouteEntriesResponseBody.VpnRouteCounts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vpnRouteCounts = tmp
        }
    }
}

public class DescribeVcoRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVcoRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVcoRouteEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVirtualBorderRoutersRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var filter: [DescribeVirtualBorderRoutersRequest.Filter]?

    public var includeCrossAccountVbr: Bool?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribeVirtualBorderRoutersRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.includeCrossAccountVbr != nil {
            map["IncludeCrossAccountVbr"] = self.includeCrossAccountVbr!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeVirtualBorderRoutersRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeVirtualBorderRoutersRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("IncludeCrossAccountVbr") {
            self.includeCrossAccountVbr = dict["IncludeCrossAccountVbr"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeVirtualBorderRoutersRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeVirtualBorderRoutersRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class DescribeVirtualBorderRoutersResponseBody : Tea.TeaModel {
    public class VirtualBorderRouterSet : Tea.TeaModel {
        public class VirtualBorderRouterType : Tea.TeaModel {
            public class AssociatedCens : Tea.TeaModel {
                public class AssociatedCen : Tea.TeaModel {
                    public var cenId: String?

                    public var cenOwnerId: Int64?

                    public var cenStatus: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cenId != nil {
                            map["CenId"] = self.cenId!
                        }
                        if self.cenOwnerId != nil {
                            map["CenOwnerId"] = self.cenOwnerId!
                        }
                        if self.cenStatus != nil {
                            map["CenStatus"] = self.cenStatus!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CenId") {
                            self.cenId = dict["CenId"] as! String
                        }
                        if dict.keys.contains("CenOwnerId") {
                            self.cenOwnerId = dict["CenOwnerId"] as! Int64
                        }
                        if dict.keys.contains("CenStatus") {
                            self.cenStatus = dict["CenStatus"] as! String
                        }
                    }
                }
                public var associatedCen: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens.AssociatedCen]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedCen != nil {
                        var tmp : [Any] = []
                        for k in self.associatedCen! {
                            tmp.append(k.toMap())
                        }
                        map["AssociatedCen"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AssociatedCen") {
                        var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens.AssociatedCen] = []
                        for v in dict["AssociatedCen"] as! [Any] {
                            var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens.AssociatedCen()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.associatedCen = tmp
                    }
                }
            }
            public class AssociatedPhysicalConnections : Tea.TeaModel {
                public class AssociatedPhysicalConnection : Tea.TeaModel {
                    public var circuitCode: String?

                    public var enableIpv6: Bool?

                    public var localGatewayIp: String?

                    public var localIpv6GatewayIp: String?

                    public var peerGatewayIp: String?

                    public var peerIpv6GatewayIp: String?

                    public var peeringIpv6SubnetMask: String?

                    public var peeringSubnetMask: String?

                    public var physicalConnectionBusinessStatus: String?

                    public var physicalConnectionId: String?

                    public var physicalConnectionOwnerUid: String?

                    public var physicalConnectionStatus: String?

                    public var status: String?

                    public var vlanId: String?

                    public var vlanInterfaceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.circuitCode != nil {
                            map["CircuitCode"] = self.circuitCode!
                        }
                        if self.enableIpv6 != nil {
                            map["EnableIpv6"] = self.enableIpv6!
                        }
                        if self.localGatewayIp != nil {
                            map["LocalGatewayIp"] = self.localGatewayIp!
                        }
                        if self.localIpv6GatewayIp != nil {
                            map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
                        }
                        if self.peerGatewayIp != nil {
                            map["PeerGatewayIp"] = self.peerGatewayIp!
                        }
                        if self.peerIpv6GatewayIp != nil {
                            map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
                        }
                        if self.peeringIpv6SubnetMask != nil {
                            map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
                        }
                        if self.peeringSubnetMask != nil {
                            map["PeeringSubnetMask"] = self.peeringSubnetMask!
                        }
                        if self.physicalConnectionBusinessStatus != nil {
                            map["PhysicalConnectionBusinessStatus"] = self.physicalConnectionBusinessStatus!
                        }
                        if self.physicalConnectionId != nil {
                            map["PhysicalConnectionId"] = self.physicalConnectionId!
                        }
                        if self.physicalConnectionOwnerUid != nil {
                            map["PhysicalConnectionOwnerUid"] = self.physicalConnectionOwnerUid!
                        }
                        if self.physicalConnectionStatus != nil {
                            map["PhysicalConnectionStatus"] = self.physicalConnectionStatus!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.vlanId != nil {
                            map["VlanId"] = self.vlanId!
                        }
                        if self.vlanInterfaceId != nil {
                            map["VlanInterfaceId"] = self.vlanInterfaceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CircuitCode") {
                            self.circuitCode = dict["CircuitCode"] as! String
                        }
                        if dict.keys.contains("EnableIpv6") {
                            self.enableIpv6 = dict["EnableIpv6"] as! Bool
                        }
                        if dict.keys.contains("LocalGatewayIp") {
                            self.localGatewayIp = dict["LocalGatewayIp"] as! String
                        }
                        if dict.keys.contains("LocalIpv6GatewayIp") {
                            self.localIpv6GatewayIp = dict["LocalIpv6GatewayIp"] as! String
                        }
                        if dict.keys.contains("PeerGatewayIp") {
                            self.peerGatewayIp = dict["PeerGatewayIp"] as! String
                        }
                        if dict.keys.contains("PeerIpv6GatewayIp") {
                            self.peerIpv6GatewayIp = dict["PeerIpv6GatewayIp"] as! String
                        }
                        if dict.keys.contains("PeeringIpv6SubnetMask") {
                            self.peeringIpv6SubnetMask = dict["PeeringIpv6SubnetMask"] as! String
                        }
                        if dict.keys.contains("PeeringSubnetMask") {
                            self.peeringSubnetMask = dict["PeeringSubnetMask"] as! String
                        }
                        if dict.keys.contains("PhysicalConnectionBusinessStatus") {
                            self.physicalConnectionBusinessStatus = dict["PhysicalConnectionBusinessStatus"] as! String
                        }
                        if dict.keys.contains("PhysicalConnectionId") {
                            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
                        }
                        if dict.keys.contains("PhysicalConnectionOwnerUid") {
                            self.physicalConnectionOwnerUid = dict["PhysicalConnectionOwnerUid"] as! String
                        }
                        if dict.keys.contains("PhysicalConnectionStatus") {
                            self.physicalConnectionStatus = dict["PhysicalConnectionStatus"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                        if dict.keys.contains("VlanId") {
                            self.vlanId = dict["VlanId"] as! String
                        }
                        if dict.keys.contains("VlanInterfaceId") {
                            self.vlanInterfaceId = dict["VlanInterfaceId"] as! String
                        }
                    }
                }
                public var associatedPhysicalConnection: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections.AssociatedPhysicalConnection]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedPhysicalConnection != nil {
                        var tmp : [Any] = []
                        for k in self.associatedPhysicalConnection! {
                            tmp.append(k.toMap())
                        }
                        map["AssociatedPhysicalConnection"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AssociatedPhysicalConnection") {
                        var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections.AssociatedPhysicalConnection] = []
                        for v in dict["AssociatedPhysicalConnection"] as! [Any] {
                            var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections.AssociatedPhysicalConnection()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.associatedPhysicalConnection = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tags: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags.Tags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tags != nil {
                        var tmp : [Any] = []
                        for k in self.tags! {
                            tmp.append(k.toMap())
                        }
                        map["Tags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tags") {
                        var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags.Tags] = []
                        for v in dict["Tags"] as! [Any] {
                            var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags.Tags()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tags = tmp
                    }
                }
            }
            public var accessPointId: String?

            public var activationTime: String?

            public var associatedCens: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens?

            public var associatedPhysicalConnections: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections?

            public var bandwidth: Int32?

            public var circuitCode: String?

            public var cloudBoxInstanceId: String?

            public var creationTime: String?

            public var description_: String?

            public var detectMultiplier: Int64?

            public var eccId: String?

            public var ecrAttatchStatus: String?

            public var ecrId: String?

            public var ecrOwnerId: String?

            public var enableIpv6: Bool?

            public var localGatewayIp: String?

            public var localIpv6GatewayIp: String?

            public var minRxInterval: Int64?

            public var minTxInterval: Int64?

            public var name: String?

            public var PConnVbrChargeType: String?

            public var PConnVbrExpireTime: String?

            public var peerGatewayIp: String?

            public var peerIpv6GatewayIp: String?

            public var peeringIpv6SubnetMask: String?

            public var peeringSubnetMask: String?

            public var physicalConnectionBusinessStatus: String?

            public var physicalConnectionId: String?

            public var physicalConnectionOwnerUid: String?

            public var physicalConnectionStatus: String?

            public var recoveryTime: String?

            public var resourceGroupId: String?

            public var routeTableId: String?

            public var sitelinkEnable: Bool?

            public var status: String?

            public var tags: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags?

            public var terminationTime: String?

            public var type: String?

            public var vbrId: String?

            public var vlanId: Int32?

            public var vlanInterfaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedCens?.validate()
                try self.associatedPhysicalConnections?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.activationTime != nil {
                    map["ActivationTime"] = self.activationTime!
                }
                if self.associatedCens != nil {
                    map["AssociatedCens"] = self.associatedCens?.toMap()
                }
                if self.associatedPhysicalConnections != nil {
                    map["AssociatedPhysicalConnections"] = self.associatedPhysicalConnections?.toMap()
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.cloudBoxInstanceId != nil {
                    map["CloudBoxInstanceId"] = self.cloudBoxInstanceId!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.detectMultiplier != nil {
                    map["DetectMultiplier"] = self.detectMultiplier!
                }
                if self.eccId != nil {
                    map["EccId"] = self.eccId!
                }
                if self.ecrAttatchStatus != nil {
                    map["EcrAttatchStatus"] = self.ecrAttatchStatus!
                }
                if self.ecrId != nil {
                    map["EcrId"] = self.ecrId!
                }
                if self.ecrOwnerId != nil {
                    map["EcrOwnerId"] = self.ecrOwnerId!
                }
                if self.enableIpv6 != nil {
                    map["EnableIpv6"] = self.enableIpv6!
                }
                if self.localGatewayIp != nil {
                    map["LocalGatewayIp"] = self.localGatewayIp!
                }
                if self.localIpv6GatewayIp != nil {
                    map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
                }
                if self.minRxInterval != nil {
                    map["MinRxInterval"] = self.minRxInterval!
                }
                if self.minTxInterval != nil {
                    map["MinTxInterval"] = self.minTxInterval!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.PConnVbrChargeType != nil {
                    map["PConnVbrChargeType"] = self.PConnVbrChargeType!
                }
                if self.PConnVbrExpireTime != nil {
                    map["PConnVbrExpireTime"] = self.PConnVbrExpireTime!
                }
                if self.peerGatewayIp != nil {
                    map["PeerGatewayIp"] = self.peerGatewayIp!
                }
                if self.peerIpv6GatewayIp != nil {
                    map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
                }
                if self.peeringIpv6SubnetMask != nil {
                    map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
                }
                if self.peeringSubnetMask != nil {
                    map["PeeringSubnetMask"] = self.peeringSubnetMask!
                }
                if self.physicalConnectionBusinessStatus != nil {
                    map["PhysicalConnectionBusinessStatus"] = self.physicalConnectionBusinessStatus!
                }
                if self.physicalConnectionId != nil {
                    map["PhysicalConnectionId"] = self.physicalConnectionId!
                }
                if self.physicalConnectionOwnerUid != nil {
                    map["PhysicalConnectionOwnerUid"] = self.physicalConnectionOwnerUid!
                }
                if self.physicalConnectionStatus != nil {
                    map["PhysicalConnectionStatus"] = self.physicalConnectionStatus!
                }
                if self.recoveryTime != nil {
                    map["RecoveryTime"] = self.recoveryTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.sitelinkEnable != nil {
                    map["SitelinkEnable"] = self.sitelinkEnable!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.terminationTime != nil {
                    map["TerminationTime"] = self.terminationTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.vbrId != nil {
                    map["VbrId"] = self.vbrId!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                if self.vlanInterfaceId != nil {
                    map["VlanInterfaceId"] = self.vlanInterfaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessPointId") {
                    self.accessPointId = dict["AccessPointId"] as! String
                }
                if dict.keys.contains("ActivationTime") {
                    self.activationTime = dict["ActivationTime"] as! String
                }
                if dict.keys.contains("AssociatedCens") {
                    var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens()
                    model.fromMap(dict["AssociatedCens"] as! [String: Any])
                    self.associatedCens = model
                }
                if dict.keys.contains("AssociatedPhysicalConnections") {
                    var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections()
                    model.fromMap(dict["AssociatedPhysicalConnections"] as! [String: Any])
                    self.associatedPhysicalConnections = model
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("CircuitCode") {
                    self.circuitCode = dict["CircuitCode"] as! String
                }
                if dict.keys.contains("CloudBoxInstanceId") {
                    self.cloudBoxInstanceId = dict["CloudBoxInstanceId"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DetectMultiplier") {
                    self.detectMultiplier = dict["DetectMultiplier"] as! Int64
                }
                if dict.keys.contains("EccId") {
                    self.eccId = dict["EccId"] as! String
                }
                if dict.keys.contains("EcrAttatchStatus") {
                    self.ecrAttatchStatus = dict["EcrAttatchStatus"] as! String
                }
                if dict.keys.contains("EcrId") {
                    self.ecrId = dict["EcrId"] as! String
                }
                if dict.keys.contains("EcrOwnerId") {
                    self.ecrOwnerId = dict["EcrOwnerId"] as! String
                }
                if dict.keys.contains("EnableIpv6") {
                    self.enableIpv6 = dict["EnableIpv6"] as! Bool
                }
                if dict.keys.contains("LocalGatewayIp") {
                    self.localGatewayIp = dict["LocalGatewayIp"] as! String
                }
                if dict.keys.contains("LocalIpv6GatewayIp") {
                    self.localIpv6GatewayIp = dict["LocalIpv6GatewayIp"] as! String
                }
                if dict.keys.contains("MinRxInterval") {
                    self.minRxInterval = dict["MinRxInterval"] as! Int64
                }
                if dict.keys.contains("MinTxInterval") {
                    self.minTxInterval = dict["MinTxInterval"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PConnVbrChargeType") {
                    self.PConnVbrChargeType = dict["PConnVbrChargeType"] as! String
                }
                if dict.keys.contains("PConnVbrExpireTime") {
                    self.PConnVbrExpireTime = dict["PConnVbrExpireTime"] as! String
                }
                if dict.keys.contains("PeerGatewayIp") {
                    self.peerGatewayIp = dict["PeerGatewayIp"] as! String
                }
                if dict.keys.contains("PeerIpv6GatewayIp") {
                    self.peerIpv6GatewayIp = dict["PeerIpv6GatewayIp"] as! String
                }
                if dict.keys.contains("PeeringIpv6SubnetMask") {
                    self.peeringIpv6SubnetMask = dict["PeeringIpv6SubnetMask"] as! String
                }
                if dict.keys.contains("PeeringSubnetMask") {
                    self.peeringSubnetMask = dict["PeeringSubnetMask"] as! String
                }
                if dict.keys.contains("PhysicalConnectionBusinessStatus") {
                    self.physicalConnectionBusinessStatus = dict["PhysicalConnectionBusinessStatus"] as! String
                }
                if dict.keys.contains("PhysicalConnectionId") {
                    self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
                }
                if dict.keys.contains("PhysicalConnectionOwnerUid") {
                    self.physicalConnectionOwnerUid = dict["PhysicalConnectionOwnerUid"] as! String
                }
                if dict.keys.contains("PhysicalConnectionStatus") {
                    self.physicalConnectionStatus = dict["PhysicalConnectionStatus"] as! String
                }
                if dict.keys.contains("RecoveryTime") {
                    self.recoveryTime = dict["RecoveryTime"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RouteTableId") {
                    self.routeTableId = dict["RouteTableId"] as! String
                }
                if dict.keys.contains("SitelinkEnable") {
                    self.sitelinkEnable = dict["SitelinkEnable"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TerminationTime") {
                    self.terminationTime = dict["TerminationTime"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VbrId") {
                    self.vbrId = dict["VbrId"] as! String
                }
                if dict.keys.contains("VlanId") {
                    self.vlanId = dict["VlanId"] as! Int32
                }
                if dict.keys.contains("VlanInterfaceId") {
                    self.vlanInterfaceId = dict["VlanInterfaceId"] as! String
                }
            }
        }
        public var virtualBorderRouterType: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.virtualBorderRouterType != nil {
                var tmp : [Any] = []
                for k in self.virtualBorderRouterType! {
                    tmp.append(k.toMap())
                }
                map["VirtualBorderRouterType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VirtualBorderRouterType") {
                var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType] = []
                for v in dict["VirtualBorderRouterType"] as! [Any] {
                    var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.virtualBorderRouterType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualBorderRouterSet: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.virtualBorderRouterSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualBorderRouterSet != nil {
            map["VirtualBorderRouterSet"] = self.virtualBorderRouterSet?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VirtualBorderRouterSet") {
            var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet()
            model.fromMap(dict["VirtualBorderRouterSet"] as! [String: Any])
            self.virtualBorderRouterSet = model
        }
    }
}

public class DescribeVirtualBorderRoutersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVirtualBorderRoutersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVirtualBorderRoutersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var filter: [DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody : Tea.TeaModel {
    public class VirtualBorderRouterForPhysicalConnectionSet : Tea.TeaModel {
        public class VirtualBorderRouterForPhysicalConnectionType : Tea.TeaModel {
            public var activationTime: String?

            public var bandwidth: String?

            public var bandwidthStatus: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var eccId: String?

            public var enableIpv6: Bool?

            public var localGatewayIp: String?

            public var localIpv6GatewayIp: String?

            public var PConnVbrBussinessStatus: String?

            public var PConnVbrChargeType: String?

            public var PConnVbrExpireTime: String?

            public var peerGatewayIp: String?

            public var peerIpv6GatewayIp: String?

            public var peeringIpv6SubnetMask: String?

            public var peeringSubnetMask: String?

            public var recoveryTime: String?

            public var status: String?

            public var terminationTime: String?

            public var type: String?

            public var vbrId: String?

            public var vbrOwnerUid: Int64?

            public var vlanId: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activationTime != nil {
                    map["ActivationTime"] = self.activationTime!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthStatus != nil {
                    map["BandwidthStatus"] = self.bandwidthStatus!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.eccId != nil {
                    map["EccId"] = self.eccId!
                }
                if self.enableIpv6 != nil {
                    map["EnableIpv6"] = self.enableIpv6!
                }
                if self.localGatewayIp != nil {
                    map["LocalGatewayIp"] = self.localGatewayIp!
                }
                if self.localIpv6GatewayIp != nil {
                    map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
                }
                if self.PConnVbrBussinessStatus != nil {
                    map["PConnVbrBussinessStatus"] = self.PConnVbrBussinessStatus!
                }
                if self.PConnVbrChargeType != nil {
                    map["PConnVbrChargeType"] = self.PConnVbrChargeType!
                }
                if self.PConnVbrExpireTime != nil {
                    map["PConnVbrExpireTime"] = self.PConnVbrExpireTime!
                }
                if self.peerGatewayIp != nil {
                    map["PeerGatewayIp"] = self.peerGatewayIp!
                }
                if self.peerIpv6GatewayIp != nil {
                    map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
                }
                if self.peeringIpv6SubnetMask != nil {
                    map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
                }
                if self.peeringSubnetMask != nil {
                    map["PeeringSubnetMask"] = self.peeringSubnetMask!
                }
                if self.recoveryTime != nil {
                    map["RecoveryTime"] = self.recoveryTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.terminationTime != nil {
                    map["TerminationTime"] = self.terminationTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.vbrId != nil {
                    map["VbrId"] = self.vbrId!
                }
                if self.vbrOwnerUid != nil {
                    map["VbrOwnerUid"] = self.vbrOwnerUid!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivationTime") {
                    self.activationTime = dict["ActivationTime"] as! String
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! String
                }
                if dict.keys.contains("BandwidthStatus") {
                    self.bandwidthStatus = dict["BandwidthStatus"] as! String
                }
                if dict.keys.contains("CircuitCode") {
                    self.circuitCode = dict["CircuitCode"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("EccId") {
                    self.eccId = dict["EccId"] as! String
                }
                if dict.keys.contains("EnableIpv6") {
                    self.enableIpv6 = dict["EnableIpv6"] as! Bool
                }
                if dict.keys.contains("LocalGatewayIp") {
                    self.localGatewayIp = dict["LocalGatewayIp"] as! String
                }
                if dict.keys.contains("LocalIpv6GatewayIp") {
                    self.localIpv6GatewayIp = dict["LocalIpv6GatewayIp"] as! String
                }
                if dict.keys.contains("PConnVbrBussinessStatus") {
                    self.PConnVbrBussinessStatus = dict["PConnVbrBussinessStatus"] as! String
                }
                if dict.keys.contains("PConnVbrChargeType") {
                    self.PConnVbrChargeType = dict["PConnVbrChargeType"] as! String
                }
                if dict.keys.contains("PConnVbrExpireTime") {
                    self.PConnVbrExpireTime = dict["PConnVbrExpireTime"] as! String
                }
                if dict.keys.contains("PeerGatewayIp") {
                    self.peerGatewayIp = dict["PeerGatewayIp"] as! String
                }
                if dict.keys.contains("PeerIpv6GatewayIp") {
                    self.peerIpv6GatewayIp = dict["PeerIpv6GatewayIp"] as! String
                }
                if dict.keys.contains("PeeringIpv6SubnetMask") {
                    self.peeringIpv6SubnetMask = dict["PeeringIpv6SubnetMask"] as! String
                }
                if dict.keys.contains("PeeringSubnetMask") {
                    self.peeringSubnetMask = dict["PeeringSubnetMask"] as! String
                }
                if dict.keys.contains("RecoveryTime") {
                    self.recoveryTime = dict["RecoveryTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TerminationTime") {
                    self.terminationTime = dict["TerminationTime"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VbrId") {
                    self.vbrId = dict["VbrId"] as! String
                }
                if dict.keys.contains("VbrOwnerUid") {
                    self.vbrOwnerUid = dict["VbrOwnerUid"] as! Int64
                }
                if dict.keys.contains("VlanId") {
                    self.vlanId = dict["VlanId"] as! Int32
                }
            }
        }
        public var virtualBorderRouterForPhysicalConnectionType: [DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.virtualBorderRouterForPhysicalConnectionType != nil {
                var tmp : [Any] = []
                for k in self.virtualBorderRouterForPhysicalConnectionType! {
                    tmp.append(k.toMap())
                }
                map["VirtualBorderRouterForPhysicalConnectionType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VirtualBorderRouterForPhysicalConnectionType") {
                var tmp : [DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType] = []
                for v in dict["VirtualBorderRouterForPhysicalConnectionType"] as! [Any] {
                    var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.virtualBorderRouterForPhysicalConnectionType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualBorderRouterForPhysicalConnectionSet: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.virtualBorderRouterForPhysicalConnectionSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualBorderRouterForPhysicalConnectionSet != nil {
            map["VirtualBorderRouterForPhysicalConnectionSet"] = self.virtualBorderRouterForPhysicalConnectionSet?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VirtualBorderRouterForPhysicalConnectionSet") {
            var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet()
            model.fromMap(dict["VirtualBorderRouterForPhysicalConnectionSet"] as! [String: Any])
            self.virtualBorderRouterForPhysicalConnectionSet = model
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpcAttributeRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeVpcAttributeResponseBody : Tea.TeaModel {
    public class AssociatedCens : Tea.TeaModel {
        public class AssociatedCen : Tea.TeaModel {
            public var cenId: String?

            public var cenOwnerId: Int64?

            public var cenStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cenId != nil {
                    map["CenId"] = self.cenId!
                }
                if self.cenOwnerId != nil {
                    map["CenOwnerId"] = self.cenOwnerId!
                }
                if self.cenStatus != nil {
                    map["CenStatus"] = self.cenStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CenId") {
                    self.cenId = dict["CenId"] as! String
                }
                if dict.keys.contains("CenOwnerId") {
                    self.cenOwnerId = dict["CenOwnerId"] as! Int64
                }
                if dict.keys.contains("CenStatus") {
                    self.cenStatus = dict["CenStatus"] as! String
                }
            }
        }
        public var associatedCen: [DescribeVpcAttributeResponseBody.AssociatedCens.AssociatedCen]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associatedCen != nil {
                var tmp : [Any] = []
                for k in self.associatedCen! {
                    tmp.append(k.toMap())
                }
                map["AssociatedCen"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociatedCen") {
                var tmp : [DescribeVpcAttributeResponseBody.AssociatedCens.AssociatedCen] = []
                for v in dict["AssociatedCen"] as! [Any] {
                    var model = DescribeVpcAttributeResponseBody.AssociatedCens.AssociatedCen()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.associatedCen = tmp
            }
        }
    }
    public class AssociatedPropagationSources : Tea.TeaModel {
        public class AssociatedPropagationSources : Tea.TeaModel {
            public var routePropagated: Bool?

            public var sourceInstanceId: String?

            public var sourceOwnerId: Int64?

            public var sourceType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.routePropagated != nil {
                    map["RoutePropagated"] = self.routePropagated!
                }
                if self.sourceInstanceId != nil {
                    map["SourceInstanceId"] = self.sourceInstanceId!
                }
                if self.sourceOwnerId != nil {
                    map["SourceOwnerId"] = self.sourceOwnerId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RoutePropagated") {
                    self.routePropagated = dict["RoutePropagated"] as! Bool
                }
                if dict.keys.contains("SourceInstanceId") {
                    self.sourceInstanceId = dict["SourceInstanceId"] as! String
                }
                if dict.keys.contains("SourceOwnerId") {
                    self.sourceOwnerId = dict["SourceOwnerId"] as! Int64
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var associatedPropagationSources: [DescribeVpcAttributeResponseBody.AssociatedPropagationSources.AssociatedPropagationSources]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associatedPropagationSources != nil {
                var tmp : [Any] = []
                for k in self.associatedPropagationSources! {
                    tmp.append(k.toMap())
                }
                map["AssociatedPropagationSources"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociatedPropagationSources") {
                var tmp : [DescribeVpcAttributeResponseBody.AssociatedPropagationSources.AssociatedPropagationSources] = []
                for v in dict["AssociatedPropagationSources"] as! [Any] {
                    var model = DescribeVpcAttributeResponseBody.AssociatedPropagationSources.AssociatedPropagationSources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.associatedPropagationSources = tmp
            }
        }
    }
    public class CloudResources : Tea.TeaModel {
        public class CloudResourceSetType : Tea.TeaModel {
            public var resourceCount: Int32?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceCount != nil {
                    map["ResourceCount"] = self.resourceCount!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceCount") {
                    self.resourceCount = dict["ResourceCount"] as! Int32
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
            }
        }
        public var cloudResourceSetType: [DescribeVpcAttributeResponseBody.CloudResources.CloudResourceSetType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cloudResourceSetType != nil {
                var tmp : [Any] = []
                for k in self.cloudResourceSetType! {
                    tmp.append(k.toMap())
                }
                map["CloudResourceSetType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CloudResourceSetType") {
                var tmp : [DescribeVpcAttributeResponseBody.CloudResources.CloudResourceSetType] = []
                for v in dict["CloudResourceSetType"] as! [Any] {
                    var model = DescribeVpcAttributeResponseBody.CloudResources.CloudResourceSetType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cloudResourceSetType = tmp
            }
        }
    }
    public class Ipv6CidrBlocks : Tea.TeaModel {
        public class Ipv6CidrBlock : Tea.TeaModel {
            public var ipv6CidrBlock: String?

            public var ipv6Isp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6CidrBlock != nil {
                    map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
                }
                if self.ipv6Isp != nil {
                    map["Ipv6Isp"] = self.ipv6Isp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ipv6CidrBlock") {
                    self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
                }
                if dict.keys.contains("Ipv6Isp") {
                    self.ipv6Isp = dict["Ipv6Isp"] as! String
                }
            }
        }
        public var ipv6CidrBlock: [DescribeVpcAttributeResponseBody.Ipv6CidrBlocks.Ipv6CidrBlock]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6CidrBlock != nil {
                var tmp : [Any] = []
                for k in self.ipv6CidrBlock! {
                    tmp.append(k.toMap())
                }
                map["Ipv6CidrBlock"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6CidrBlock") {
                var tmp : [DescribeVpcAttributeResponseBody.Ipv6CidrBlocks.Ipv6CidrBlock] = []
                for v in dict["Ipv6CidrBlock"] as! [Any] {
                    var model = DescribeVpcAttributeResponseBody.Ipv6CidrBlocks.Ipv6CidrBlock()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6CidrBlock = tmp
            }
        }
    }
    public class SecondaryCidrBlocks : Tea.TeaModel {
        public var secondaryCidrBlock: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secondaryCidrBlock != nil {
                map["SecondaryCidrBlock"] = self.secondaryCidrBlock!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecondaryCidrBlock") {
                self.secondaryCidrBlock = dict["SecondaryCidrBlock"] as! [String]
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var tag: [DescribeVpcAttributeResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") {
                var tmp : [DescribeVpcAttributeResponseBody.Tags.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = DescribeVpcAttributeResponseBody.Tags.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public class UserCidrs : Tea.TeaModel {
        public var userCidr: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userCidr != nil {
                map["UserCidr"] = self.userCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserCidr") {
                self.userCidr = dict["UserCidr"] as! [String]
            }
        }
    }
    public class VSwitchIds : Tea.TeaModel {
        public var vSwitchId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! [String]
            }
        }
    }
    public var associatedCens: DescribeVpcAttributeResponseBody.AssociatedCens?

    public var associatedPropagationSources: DescribeVpcAttributeResponseBody.AssociatedPropagationSources?

    public var cidrBlock: String?

    public var classicLinkEnabled: Bool?

    public var cloudResources: DescribeVpcAttributeResponseBody.CloudResources?

    public var creationTime: String?

    public var description_: String?

    public var dhcpOptionsSetId: String?

    public var dhcpOptionsSetStatus: String?

    public var dnsHostnameStatus: String?

    public var enabledIpv6: Bool?

    public var ipv4GatewayId: String?

    public var ipv6CidrBlock: String?

    public var ipv6CidrBlocks: DescribeVpcAttributeResponseBody.Ipv6CidrBlocks?

    public var isDefault: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var secondaryCidrBlocks: DescribeVpcAttributeResponseBody.SecondaryCidrBlocks?

    public var status: String?

    public var supportIpv4Gateway: Bool?

    public var tags: DescribeVpcAttributeResponseBody.Tags?

    public var userCidrs: DescribeVpcAttributeResponseBody.UserCidrs?

    public var VRouterId: String?

    public var vSwitchIds: DescribeVpcAttributeResponseBody.VSwitchIds?

    public var vpcId: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.associatedCens?.validate()
        try self.associatedPropagationSources?.validate()
        try self.cloudResources?.validate()
        try self.ipv6CidrBlocks?.validate()
        try self.secondaryCidrBlocks?.validate()
        try self.tags?.validate()
        try self.userCidrs?.validate()
        try self.vSwitchIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associatedCens != nil {
            map["AssociatedCens"] = self.associatedCens?.toMap()
        }
        if self.associatedPropagationSources != nil {
            map["AssociatedPropagationSources"] = self.associatedPropagationSources?.toMap()
        }
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.classicLinkEnabled != nil {
            map["ClassicLinkEnabled"] = self.classicLinkEnabled!
        }
        if self.cloudResources != nil {
            map["CloudResources"] = self.cloudResources?.toMap()
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dhcpOptionsSetStatus != nil {
            map["DhcpOptionsSetStatus"] = self.dhcpOptionsSetStatus!
        }
        if self.dnsHostnameStatus != nil {
            map["DnsHostnameStatus"] = self.dnsHostnameStatus!
        }
        if self.enabledIpv6 != nil {
            map["EnabledIpv6"] = self.enabledIpv6!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ipv6CidrBlocks != nil {
            map["Ipv6CidrBlocks"] = self.ipv6CidrBlocks?.toMap()
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.secondaryCidrBlocks != nil {
            map["SecondaryCidrBlocks"] = self.secondaryCidrBlocks?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.supportIpv4Gateway != nil {
            map["SupportIpv4Gateway"] = self.supportIpv4Gateway!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.userCidrs != nil {
            map["UserCidrs"] = self.userCidrs?.toMap()
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds?.toMap()
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssociatedCens") {
            var model = DescribeVpcAttributeResponseBody.AssociatedCens()
            model.fromMap(dict["AssociatedCens"] as! [String: Any])
            self.associatedCens = model
        }
        if dict.keys.contains("AssociatedPropagationSources") {
            var model = DescribeVpcAttributeResponseBody.AssociatedPropagationSources()
            model.fromMap(dict["AssociatedPropagationSources"] as! [String: Any])
            self.associatedPropagationSources = model
        }
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("ClassicLinkEnabled") {
            self.classicLinkEnabled = dict["ClassicLinkEnabled"] as! Bool
        }
        if dict.keys.contains("CloudResources") {
            var model = DescribeVpcAttributeResponseBody.CloudResources()
            model.fromMap(dict["CloudResources"] as! [String: Any])
            self.cloudResources = model
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetStatus") {
            self.dhcpOptionsSetStatus = dict["DhcpOptionsSetStatus"] as! String
        }
        if dict.keys.contains("DnsHostnameStatus") {
            self.dnsHostnameStatus = dict["DnsHostnameStatus"] as! String
        }
        if dict.keys.contains("EnabledIpv6") {
            self.enabledIpv6 = dict["EnabledIpv6"] as! Bool
        }
        if dict.keys.contains("Ipv4GatewayId") {
            self.ipv4GatewayId = dict["Ipv4GatewayId"] as! String
        }
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
        }
        if dict.keys.contains("Ipv6CidrBlocks") {
            var model = DescribeVpcAttributeResponseBody.Ipv6CidrBlocks()
            model.fromMap(dict["Ipv6CidrBlocks"] as! [String: Any])
            self.ipv6CidrBlocks = model
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecondaryCidrBlocks") {
            var model = DescribeVpcAttributeResponseBody.SecondaryCidrBlocks()
            model.fromMap(dict["SecondaryCidrBlocks"] as! [String: Any])
            self.secondaryCidrBlocks = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SupportIpv4Gateway") {
            self.supportIpv4Gateway = dict["SupportIpv4Gateway"] as! Bool
        }
        if dict.keys.contains("Tags") {
            var model = DescribeVpcAttributeResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
        if dict.keys.contains("UserCidrs") {
            var model = DescribeVpcAttributeResponseBody.UserCidrs()
            model.fromMap(dict["UserCidrs"] as! [String: Any])
            self.userCidrs = model
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
        if dict.keys.contains("VSwitchIds") {
            var model = DescribeVpcAttributeResponseBody.VSwitchIds()
            model.fromMap(dict["VSwitchIds"] as! [String: Any])
            self.vSwitchIds = model
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcName") {
            self.vpcName = dict["VpcName"] as! String
        }
    }
}

public class DescribeVpcAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpcAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpcsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var enableIpv6: Bool?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeVpcsRequest.Tag]?

    public var vpcId: String?

    public var vpcName: String?

    public var vpcOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        if self.vpcOwnerId != nil {
            map["VpcOwnerId"] = self.vpcOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnableIpv6") {
            self.enableIpv6 = dict["EnableIpv6"] as! Bool
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeVpcsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeVpcsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcName") {
            self.vpcName = dict["VpcName"] as! String
        }
        if dict.keys.contains("VpcOwnerId") {
            self.vpcOwnerId = dict["VpcOwnerId"] as! Int64
        }
    }
}

public class DescribeVpcsResponseBody : Tea.TeaModel {
    public class Vpcs : Tea.TeaModel {
        public class Vpc : Tea.TeaModel {
            public class Ipv6CidrBlocks : Tea.TeaModel {
                public class Ipv6CidrBlock : Tea.TeaModel {
                    public var ipv6CidrBlock: String?

                    public var ipv6Isp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv6CidrBlock != nil {
                            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
                        }
                        if self.ipv6Isp != nil {
                            map["Ipv6Isp"] = self.ipv6Isp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Ipv6CidrBlock") {
                            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
                        }
                        if dict.keys.contains("Ipv6Isp") {
                            self.ipv6Isp = dict["Ipv6Isp"] as! String
                        }
                    }
                }
                public var ipv6CidrBlock: [DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks.Ipv6CidrBlock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6CidrBlock != nil {
                        var tmp : [Any] = []
                        for k in self.ipv6CidrBlock! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv6CidrBlock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ipv6CidrBlock") {
                        var tmp : [DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks.Ipv6CidrBlock] = []
                        for v in dict["Ipv6CidrBlock"] as! [Any] {
                            var model = DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks.Ipv6CidrBlock()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ipv6CidrBlock = tmp
                    }
                }
            }
            public class NatGatewayIds : Tea.TeaModel {
                public var natGatewayIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.natGatewayIds != nil {
                        map["NatGatewayIds"] = self.natGatewayIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NatGatewayIds") {
                        self.natGatewayIds = dict["NatGatewayIds"] as! [String]
                    }
                }
            }
            public class RouterTableIds : Tea.TeaModel {
                public var routerTableIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routerTableIds != nil {
                        map["RouterTableIds"] = self.routerTableIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RouterTableIds") {
                        self.routerTableIds = dict["RouterTableIds"] as! [String]
                    }
                }
            }
            public class SecondaryCidrBlocks : Tea.TeaModel {
                public var secondaryCidrBlock: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.secondaryCidrBlock != nil {
                        map["SecondaryCidrBlock"] = self.secondaryCidrBlock!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecondaryCidrBlock") {
                        self.secondaryCidrBlock = dict["SecondaryCidrBlock"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeVpcsResponseBody.Vpcs.Vpc.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeVpcsResponseBody.Vpcs.Vpc.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeVpcsResponseBody.Vpcs.Vpc.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public class UserCidrs : Tea.TeaModel {
                public var userCidr: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.userCidr != nil {
                        map["UserCidr"] = self.userCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("UserCidr") {
                        self.userCidr = dict["UserCidr"] as! [String]
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! [String]
                    }
                }
            }
            public var cenStatus: String?

            public var cidrBlock: String?

            public var creationTime: String?

            public var description_: String?

            public var dhcpOptionsSetId: String?

            public var dhcpOptionsSetStatus: String?

            public var dnsHostnameStatus: String?

            public var enabledIpv6: Bool?

            public var ipv6CidrBlock: String?

            public var ipv6CidrBlocks: DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks?

            public var isDefault: Bool?

            public var natGatewayIds: DescribeVpcsResponseBody.Vpcs.Vpc.NatGatewayIds?

            public var ownerId: Int64?

            public var regionId: String?

            public var resourceGroupId: String?

            public var routerTableIds: DescribeVpcsResponseBody.Vpcs.Vpc.RouterTableIds?

            public var secondaryCidrBlocks: DescribeVpcsResponseBody.Vpcs.Vpc.SecondaryCidrBlocks?

            public var status: String?

            public var tags: DescribeVpcsResponseBody.Vpcs.Vpc.Tags?

            public var userCidrs: DescribeVpcsResponseBody.Vpcs.Vpc.UserCidrs?

            public var VRouterId: String?

            public var vSwitchIds: DescribeVpcsResponseBody.Vpcs.Vpc.VSwitchIds?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ipv6CidrBlocks?.validate()
                try self.natGatewayIds?.validate()
                try self.routerTableIds?.validate()
                try self.secondaryCidrBlocks?.validate()
                try self.tags?.validate()
                try self.userCidrs?.validate()
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cenStatus != nil {
                    map["CenStatus"] = self.cenStatus!
                }
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dhcpOptionsSetId != nil {
                    map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
                }
                if self.dhcpOptionsSetStatus != nil {
                    map["DhcpOptionsSetStatus"] = self.dhcpOptionsSetStatus!
                }
                if self.dnsHostnameStatus != nil {
                    map["DnsHostnameStatus"] = self.dnsHostnameStatus!
                }
                if self.enabledIpv6 != nil {
                    map["EnabledIpv6"] = self.enabledIpv6!
                }
                if self.ipv6CidrBlock != nil {
                    map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
                }
                if self.ipv6CidrBlocks != nil {
                    map["Ipv6CidrBlocks"] = self.ipv6CidrBlocks?.toMap()
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.natGatewayIds != nil {
                    map["NatGatewayIds"] = self.natGatewayIds?.toMap()
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routerTableIds != nil {
                    map["RouterTableIds"] = self.routerTableIds?.toMap()
                }
                if self.secondaryCidrBlocks != nil {
                    map["SecondaryCidrBlocks"] = self.secondaryCidrBlocks?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.userCidrs != nil {
                    map["UserCidrs"] = self.userCidrs?.toMap()
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CenStatus") {
                    self.cenStatus = dict["CenStatus"] as! String
                }
                if dict.keys.contains("CidrBlock") {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DhcpOptionsSetId") {
                    self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
                }
                if dict.keys.contains("DhcpOptionsSetStatus") {
                    self.dhcpOptionsSetStatus = dict["DhcpOptionsSetStatus"] as! String
                }
                if dict.keys.contains("DnsHostnameStatus") {
                    self.dnsHostnameStatus = dict["DnsHostnameStatus"] as! String
                }
                if dict.keys.contains("EnabledIpv6") {
                    self.enabledIpv6 = dict["EnabledIpv6"] as! Bool
                }
                if dict.keys.contains("Ipv6CidrBlock") {
                    self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
                }
                if dict.keys.contains("Ipv6CidrBlocks") {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks()
                    model.fromMap(dict["Ipv6CidrBlocks"] as! [String: Any])
                    self.ipv6CidrBlocks = model
                }
                if dict.keys.contains("IsDefault") {
                    self.isDefault = dict["IsDefault"] as! Bool
                }
                if dict.keys.contains("NatGatewayIds") {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.NatGatewayIds()
                    model.fromMap(dict["NatGatewayIds"] as! [String: Any])
                    self.natGatewayIds = model
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! Int64
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RouterTableIds") {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.RouterTableIds()
                    model.fromMap(dict["RouterTableIds"] as! [String: Any])
                    self.routerTableIds = model
                }
                if dict.keys.contains("SecondaryCidrBlocks") {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.SecondaryCidrBlocks()
                    model.fromMap(dict["SecondaryCidrBlocks"] as! [String: Any])
                    self.secondaryCidrBlocks = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("UserCidrs") {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.UserCidrs()
                    model.fromMap(dict["UserCidrs"] as! [String: Any])
                    self.userCidrs = model
                }
                if dict.keys.contains("VRouterId") {
                    self.VRouterId = dict["VRouterId"] as! String
                }
                if dict.keys.contains("VSwitchIds") {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.VSwitchIds()
                    model.fromMap(dict["VSwitchIds"] as! [String: Any])
                    self.vSwitchIds = model
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcName") {
                    self.vpcName = dict["VpcName"] as! String
                }
            }
        }
        public var vpc: [DescribeVpcsResponseBody.Vpcs.Vpc]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpc != nil {
                var tmp : [Any] = []
                for k in self.vpc! {
                    tmp.append(k.toMap())
                }
                map["Vpc"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Vpc") {
                var tmp : [DescribeVpcsResponseBody.Vpcs.Vpc] = []
                for v in dict["Vpc"] as! [Any] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpc = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpcs: DescribeVpcsResponseBody.Vpcs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpcs != nil {
            map["Vpcs"] = self.vpcs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("Vpcs") {
            var model = DescribeVpcsResponseBody.Vpcs()
            model.fromMap(dict["Vpcs"] as! [String: Any])
            self.vpcs = model
        }
    }
}

public class DescribeVpcsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpcsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnAttachmentsRequest : Tea.TeaModel {
    public var attachType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachType != nil {
            map["AttachType"] = self.attachType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachType") {
            self.attachType = dict["AttachType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class DescribeVpnAttachmentsResponseBody : Tea.TeaModel {
    public class VpnAttachments : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var attachType: String?

        public var crossAccountAuthorized: Bool?

        public var description_: String?

        public var instanceId: String?

        public var name: String?

        public var tag: String?

        public var tags: [DescribeVpnAttachmentsResponseBody.VpnAttachments.Tags]?

        public var transitRouterId: String?

        public var transitRouterName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachType != nil {
                map["AttachType"] = self.attachType!
            }
            if self.crossAccountAuthorized != nil {
                map["CrossAccountAuthorized"] = self.crossAccountAuthorized!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.transitRouterId != nil {
                map["TransitRouterId"] = self.transitRouterId!
            }
            if self.transitRouterName != nil {
                map["TransitRouterName"] = self.transitRouterName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachType") {
                self.attachType = dict["AttachType"] as! String
            }
            if dict.keys.contains("CrossAccountAuthorized") {
                self.crossAccountAuthorized = dict["CrossAccountAuthorized"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Tag") {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeVpnAttachmentsResponseBody.VpnAttachments.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeVpnAttachmentsResponseBody.VpnAttachments.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TransitRouterId") {
                self.transitRouterId = dict["TransitRouterId"] as! String
            }
            if dict.keys.contains("TransitRouterName") {
                self.transitRouterName = dict["TransitRouterName"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnAttachments: [DescribeVpnAttachmentsResponseBody.VpnAttachments]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnAttachments != nil {
            var tmp : [Any] = []
            for k in self.vpnAttachments! {
                tmp.append(k.toMap())
            }
            map["VpnAttachments"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpnAttachments") {
            var tmp : [DescribeVpnAttachmentsResponseBody.VpnAttachments] = []
            for v in dict["VpnAttachments"] as! [Any] {
                var model = DescribeVpnAttachmentsResponseBody.VpnAttachments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vpnAttachments = tmp
        }
    }
}

public class DescribeVpnAttachmentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnAttachmentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnAttachmentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnConnectionRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class DescribeVpnConnectionResponseBody : Tea.TeaModel {
    public class IkeConfig : Tea.TeaModel {
        public var ikeAuthAlg: String?

        public var ikeEncAlg: String?

        public var ikeLifetime: Int64?

        public var ikeMode: String?

        public var ikePfs: String?

        public var ikeVersion: String?

        public var localId: String?

        public var psk: String?

        public var remoteId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ikeAuthAlg != nil {
                map["IkeAuthAlg"] = self.ikeAuthAlg!
            }
            if self.ikeEncAlg != nil {
                map["IkeEncAlg"] = self.ikeEncAlg!
            }
            if self.ikeLifetime != nil {
                map["IkeLifetime"] = self.ikeLifetime!
            }
            if self.ikeMode != nil {
                map["IkeMode"] = self.ikeMode!
            }
            if self.ikePfs != nil {
                map["IkePfs"] = self.ikePfs!
            }
            if self.ikeVersion != nil {
                map["IkeVersion"] = self.ikeVersion!
            }
            if self.localId != nil {
                map["LocalId"] = self.localId!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.remoteId != nil {
                map["RemoteId"] = self.remoteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IkeAuthAlg") {
                self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
            }
            if dict.keys.contains("IkeEncAlg") {
                self.ikeEncAlg = dict["IkeEncAlg"] as! String
            }
            if dict.keys.contains("IkeLifetime") {
                self.ikeLifetime = dict["IkeLifetime"] as! Int64
            }
            if dict.keys.contains("IkeMode") {
                self.ikeMode = dict["IkeMode"] as! String
            }
            if dict.keys.contains("IkePfs") {
                self.ikePfs = dict["IkePfs"] as! String
            }
            if dict.keys.contains("IkeVersion") {
                self.ikeVersion = dict["IkeVersion"] as! String
            }
            if dict.keys.contains("LocalId") {
                self.localId = dict["LocalId"] as! String
            }
            if dict.keys.contains("Psk") {
                self.psk = dict["Psk"] as! String
            }
            if dict.keys.contains("RemoteId") {
                self.remoteId = dict["RemoteId"] as! String
            }
        }
    }
    public class IpsecConfig : Tea.TeaModel {
        public var ipsecAuthAlg: String?

        public var ipsecEncAlg: String?

        public var ipsecLifetime: Int64?

        public var ipsecPfs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipsecAuthAlg != nil {
                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
            }
            if self.ipsecEncAlg != nil {
                map["IpsecEncAlg"] = self.ipsecEncAlg!
            }
            if self.ipsecLifetime != nil {
                map["IpsecLifetime"] = self.ipsecLifetime!
            }
            if self.ipsecPfs != nil {
                map["IpsecPfs"] = self.ipsecPfs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpsecAuthAlg") {
                self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
            }
            if dict.keys.contains("IpsecEncAlg") {
                self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
            }
            if dict.keys.contains("IpsecLifetime") {
                self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
            }
            if dict.keys.contains("IpsecPfs") {
                self.ipsecPfs = dict["IpsecPfs"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var tag: [DescribeVpnConnectionResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") {
                var tmp : [DescribeVpnConnectionResponseBody.Tags.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = DescribeVpnConnectionResponseBody.Tags.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelOptions : Tea.TeaModel {
            public class TunnelBgpConfig : Tea.TeaModel {
                public var bgpStatus: String?

                public var localAsn: String?

                public var localBgpIp: String?

                public var peerAsn: String?

                public var peerBgpIp: String?

                public var tunnelCidr: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bgpStatus != nil {
                        map["BgpStatus"] = self.bgpStatus!
                    }
                    if self.localAsn != nil {
                        map["LocalAsn"] = self.localAsn!
                    }
                    if self.localBgpIp != nil {
                        map["LocalBgpIp"] = self.localBgpIp!
                    }
                    if self.peerAsn != nil {
                        map["PeerAsn"] = self.peerAsn!
                    }
                    if self.peerBgpIp != nil {
                        map["PeerBgpIp"] = self.peerBgpIp!
                    }
                    if self.tunnelCidr != nil {
                        map["TunnelCidr"] = self.tunnelCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BgpStatus") {
                        self.bgpStatus = dict["BgpStatus"] as! String
                    }
                    if dict.keys.contains("LocalAsn") {
                        self.localAsn = dict["LocalAsn"] as! String
                    }
                    if dict.keys.contains("LocalBgpIp") {
                        self.localBgpIp = dict["LocalBgpIp"] as! String
                    }
                    if dict.keys.contains("PeerAsn") {
                        self.peerAsn = dict["PeerAsn"] as! String
                    }
                    if dict.keys.contains("PeerBgpIp") {
                        self.peerBgpIp = dict["PeerBgpIp"] as! String
                    }
                    if dict.keys.contains("TunnelCidr") {
                        self.tunnelCidr = dict["TunnelCidr"] as! String
                    }
                }
            }
            public class TunnelIkeConfig : Tea.TeaModel {
                public var ikeAuthAlg: String?

                public var ikeEncAlg: String?

                public var ikeLifetime: String?

                public var ikeMode: String?

                public var ikePfs: String?

                public var ikeVersion: String?

                public var localId: String?

                public var psk: String?

                public var remoteId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ikeAuthAlg != nil {
                        map["IkeAuthAlg"] = self.ikeAuthAlg!
                    }
                    if self.ikeEncAlg != nil {
                        map["IkeEncAlg"] = self.ikeEncAlg!
                    }
                    if self.ikeLifetime != nil {
                        map["IkeLifetime"] = self.ikeLifetime!
                    }
                    if self.ikeMode != nil {
                        map["IkeMode"] = self.ikeMode!
                    }
                    if self.ikePfs != nil {
                        map["IkePfs"] = self.ikePfs!
                    }
                    if self.ikeVersion != nil {
                        map["IkeVersion"] = self.ikeVersion!
                    }
                    if self.localId != nil {
                        map["LocalId"] = self.localId!
                    }
                    if self.psk != nil {
                        map["Psk"] = self.psk!
                    }
                    if self.remoteId != nil {
                        map["RemoteId"] = self.remoteId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IkeAuthAlg") {
                        self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                    }
                    if dict.keys.contains("IkeEncAlg") {
                        self.ikeEncAlg = dict["IkeEncAlg"] as! String
                    }
                    if dict.keys.contains("IkeLifetime") {
                        self.ikeLifetime = dict["IkeLifetime"] as! String
                    }
                    if dict.keys.contains("IkeMode") {
                        self.ikeMode = dict["IkeMode"] as! String
                    }
                    if dict.keys.contains("IkePfs") {
                        self.ikePfs = dict["IkePfs"] as! String
                    }
                    if dict.keys.contains("IkeVersion") {
                        self.ikeVersion = dict["IkeVersion"] as! String
                    }
                    if dict.keys.contains("LocalId") {
                        self.localId = dict["LocalId"] as! String
                    }
                    if dict.keys.contains("Psk") {
                        self.psk = dict["Psk"] as! String
                    }
                    if dict.keys.contains("RemoteId") {
                        self.remoteId = dict["RemoteId"] as! String
                    }
                }
            }
            public class TunnelIpsecConfig : Tea.TeaModel {
                public var ipsecAuthAlg: String?

                public var ipsecEncAlg: String?

                public var ipsecLifetime: String?

                public var ipsecPfs: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipsecAuthAlg != nil {
                        map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                    }
                    if self.ipsecEncAlg != nil {
                        map["IpsecEncAlg"] = self.ipsecEncAlg!
                    }
                    if self.ipsecLifetime != nil {
                        map["IpsecLifetime"] = self.ipsecLifetime!
                    }
                    if self.ipsecPfs != nil {
                        map["IpsecPfs"] = self.ipsecPfs!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpsecAuthAlg") {
                        self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                    }
                    if dict.keys.contains("IpsecEncAlg") {
                        self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                    }
                    if dict.keys.contains("IpsecLifetime") {
                        self.ipsecLifetime = dict["IpsecLifetime"] as! String
                    }
                    if dict.keys.contains("IpsecPfs") {
                        self.ipsecPfs = dict["IpsecPfs"] as! String
                    }
                }
            }
            public var customerGatewayId: String?

            public var enableDpd: String?

            public var enableNatTraversal: String?

            public var internetIp: String?

            public var remoteCaCertificate: String?

            public var role: String?

            public var state: String?

            public var status: String?

            public var tunnelBgpConfig: DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig?

            public var tunnelId: String?

            public var tunnelIkeConfig: DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig?

            public var tunnelIndex: Int32?

            public var tunnelIpsecConfig: DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig?

            public var zoneNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tunnelBgpConfig?.validate()
                try self.tunnelIkeConfig?.validate()
                try self.tunnelIpsecConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customerGatewayId != nil {
                    map["CustomerGatewayId"] = self.customerGatewayId!
                }
                if self.enableDpd != nil {
                    map["EnableDpd"] = self.enableDpd!
                }
                if self.enableNatTraversal != nil {
                    map["EnableNatTraversal"] = self.enableNatTraversal!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.remoteCaCertificate != nil {
                    map["RemoteCaCertificate"] = self.remoteCaCertificate!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tunnelBgpConfig != nil {
                    map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
                }
                if self.tunnelId != nil {
                    map["TunnelId"] = self.tunnelId!
                }
                if self.tunnelIkeConfig != nil {
                    map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
                }
                if self.tunnelIndex != nil {
                    map["TunnelIndex"] = self.tunnelIndex!
                }
                if self.tunnelIpsecConfig != nil {
                    map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
                }
                if self.zoneNo != nil {
                    map["ZoneNo"] = self.zoneNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomerGatewayId") {
                    self.customerGatewayId = dict["CustomerGatewayId"] as! String
                }
                if dict.keys.contains("EnableDpd") {
                    self.enableDpd = dict["EnableDpd"] as! String
                }
                if dict.keys.contains("EnableNatTraversal") {
                    self.enableNatTraversal = dict["EnableNatTraversal"] as! String
                }
                if dict.keys.contains("InternetIp") {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("RemoteCaCertificate") {
                    self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TunnelBgpConfig") {
                    var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig()
                    model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
                    self.tunnelBgpConfig = model
                }
                if dict.keys.contains("TunnelId") {
                    self.tunnelId = dict["TunnelId"] as! String
                }
                if dict.keys.contains("TunnelIkeConfig") {
                    var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig()
                    model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
                    self.tunnelIkeConfig = model
                }
                if dict.keys.contains("TunnelIndex") {
                    self.tunnelIndex = dict["TunnelIndex"] as! Int32
                }
                if dict.keys.contains("TunnelIpsecConfig") {
                    var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig()
                    model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
                    self.tunnelIpsecConfig = model
                }
                if dict.keys.contains("ZoneNo") {
                    self.zoneNo = dict["ZoneNo"] as! String
                }
            }
        }
        public var tunnelOptions: [DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tunnelOptions != nil {
                var tmp : [Any] = []
                for k in self.tunnelOptions! {
                    tmp.append(k.toMap())
                }
                map["TunnelOptions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TunnelOptions") {
                var tmp : [DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions] = []
                for v in dict["TunnelOptions"] as! [Any] {
                    var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tunnelOptions = tmp
            }
        }
    }
    public class VcoHealthCheck : Tea.TeaModel {
        public var dip: String?

        public var enable: String?

        public var interval: Int32?

        public var policy: String?

        public var retry: Int32?

        public var sip: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dip != nil {
                map["Dip"] = self.dip!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.retry != nil {
                map["Retry"] = self.retry!
            }
            if self.sip != nil {
                map["Sip"] = self.sip!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dip") {
                self.dip = dict["Dip"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! String
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Retry") {
                self.retry = dict["Retry"] as! Int32
            }
            if dict.keys.contains("Sip") {
                self.sip = dict["Sip"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class VpnBgpConfig : Tea.TeaModel {
        public var authKey: String?

        public var enableBgp: String?

        public var localAsn: Int64?

        public var localBgpIp: String?

        public var peerAsn: Int64?

        public var peerBgpIp: String?

        public var status: String?

        public var tunnelCidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authKey != nil {
                map["AuthKey"] = self.authKey!
            }
            if self.enableBgp != nil {
                map["EnableBgp"] = self.enableBgp!
            }
            if self.localAsn != nil {
                map["LocalAsn"] = self.localAsn!
            }
            if self.localBgpIp != nil {
                map["LocalBgpIp"] = self.localBgpIp!
            }
            if self.peerAsn != nil {
                map["PeerAsn"] = self.peerAsn!
            }
            if self.peerBgpIp != nil {
                map["PeerBgpIp"] = self.peerBgpIp!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tunnelCidr != nil {
                map["TunnelCidr"] = self.tunnelCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthKey") {
                self.authKey = dict["AuthKey"] as! String
            }
            if dict.keys.contains("EnableBgp") {
                self.enableBgp = dict["EnableBgp"] as! String
            }
            if dict.keys.contains("LocalAsn") {
                self.localAsn = dict["LocalAsn"] as! Int64
            }
            if dict.keys.contains("LocalBgpIp") {
                self.localBgpIp = dict["LocalBgpIp"] as! String
            }
            if dict.keys.contains("PeerAsn") {
                self.peerAsn = dict["PeerAsn"] as! Int64
            }
            if dict.keys.contains("PeerBgpIp") {
                self.peerBgpIp = dict["PeerBgpIp"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TunnelCidr") {
                self.tunnelCidr = dict["TunnelCidr"] as! String
            }
        }
    }
    public var attachInstanceId: String?

    public var attachType: String?

    public var createTime: Int64?

    public var crossAccountAuthorized: Bool?

    public var customerGatewayId: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var ikeConfig: DescribeVpnConnectionResponseBody.IkeConfig?

    public var internetIp: String?

    public var ipsecConfig: DescribeVpnConnectionResponseBody.IpsecConfig?

    public var localSubnet: String?

    public var name: String?

    public var networkType: String?

    public var remoteCaCertificate: String?

    public var remoteSubnet: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var spec: String?

    public var state: String?

    public var status: String?

    public var tags: DescribeVpnConnectionResponseBody.Tags?

    public var transitRouterId: String?

    public var transitRouterName: String?

    public var tunnelOptionsSpecification: DescribeVpnConnectionResponseBody.TunnelOptionsSpecification?

    public var vcoHealthCheck: DescribeVpnConnectionResponseBody.VcoHealthCheck?

    public var vpnBgpConfig: DescribeVpnConnectionResponseBody.VpnBgpConfig?

    public var vpnConnectionId: String?

    public var vpnGatewayId: String?

    public var zoneNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ikeConfig?.validate()
        try self.ipsecConfig?.validate()
        try self.tags?.validate()
        try self.tunnelOptionsSpecification?.validate()
        try self.vcoHealthCheck?.validate()
        try self.vpnBgpConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachInstanceId != nil {
            map["AttachInstanceId"] = self.attachInstanceId!
        }
        if self.attachType != nil {
            map["AttachType"] = self.attachType!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.crossAccountAuthorized != nil {
            map["CrossAccountAuthorized"] = self.crossAccountAuthorized!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig?.toMap()
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig?.toMap()
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.remoteCaCertificate != nil {
            map["RemoteCaCertificate"] = self.remoteCaCertificate!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.transitRouterId != nil {
            map["TransitRouterId"] = self.transitRouterId!
        }
        if self.transitRouterName != nil {
            map["TransitRouterName"] = self.transitRouterName!
        }
        if self.tunnelOptionsSpecification != nil {
            map["TunnelOptionsSpecification"] = self.tunnelOptionsSpecification?.toMap()
        }
        if self.vcoHealthCheck != nil {
            map["VcoHealthCheck"] = self.vcoHealthCheck?.toMap()
        }
        if self.vpnBgpConfig != nil {
            map["VpnBgpConfig"] = self.vpnBgpConfig?.toMap()
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.zoneNo != nil {
            map["ZoneNo"] = self.zoneNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachInstanceId") {
            self.attachInstanceId = dict["AttachInstanceId"] as! String
        }
        if dict.keys.contains("AttachType") {
            self.attachType = dict["AttachType"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("CrossAccountAuthorized") {
            self.crossAccountAuthorized = dict["CrossAccountAuthorized"] as! Bool
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("EffectImmediately") {
            self.effectImmediately = dict["EffectImmediately"] as! Bool
        }
        if dict.keys.contains("EnableDpd") {
            self.enableDpd = dict["EnableDpd"] as! Bool
        }
        if dict.keys.contains("EnableNatTraversal") {
            self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
        }
        if dict.keys.contains("EnableTunnelsBgp") {
            self.enableTunnelsBgp = dict["EnableTunnelsBgp"] as! Bool
        }
        if dict.keys.contains("IkeConfig") {
            var model = DescribeVpnConnectionResponseBody.IkeConfig()
            model.fromMap(dict["IkeConfig"] as! [String: Any])
            self.ikeConfig = model
        }
        if dict.keys.contains("InternetIp") {
            self.internetIp = dict["InternetIp"] as! String
        }
        if dict.keys.contains("IpsecConfig") {
            var model = DescribeVpnConnectionResponseBody.IpsecConfig()
            model.fromMap(dict["IpsecConfig"] as! [String: Any])
            self.ipsecConfig = model
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("RemoteCaCertificate") {
            self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
        }
        if dict.keys.contains("RemoteSubnet") {
            self.remoteSubnet = dict["RemoteSubnet"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var model = DescribeVpnConnectionResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
        if dict.keys.contains("TransitRouterId") {
            self.transitRouterId = dict["TransitRouterId"] as! String
        }
        if dict.keys.contains("TransitRouterName") {
            self.transitRouterName = dict["TransitRouterName"] as! String
        }
        if dict.keys.contains("TunnelOptionsSpecification") {
            var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification()
            model.fromMap(dict["TunnelOptionsSpecification"] as! [String: Any])
            self.tunnelOptionsSpecification = model
        }
        if dict.keys.contains("VcoHealthCheck") {
            var model = DescribeVpnConnectionResponseBody.VcoHealthCheck()
            model.fromMap(dict["VcoHealthCheck"] as! [String: Any])
            self.vcoHealthCheck = model
        }
        if dict.keys.contains("VpnBgpConfig") {
            var model = DescribeVpnConnectionResponseBody.VpnBgpConfig()
            model.fromMap(dict["VpnBgpConfig"] as! [String: Any])
            self.vpnBgpConfig = model
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("ZoneNo") {
            self.zoneNo = dict["ZoneNo"] as! String
        }
    }
}

public class DescribeVpnConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnConnectionLogsRequest : Tea.TeaModel {
    public var from: Int32?

    public var minutePeriod: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var to: Int32?

    public var tunnelId: String?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.minutePeriod != nil {
            map["MinutePeriod"] = self.minutePeriod!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        if self.tunnelId != nil {
            map["TunnelId"] = self.tunnelId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") {
            self.from = dict["From"] as! Int32
        }
        if dict.keys.contains("MinutePeriod") {
            self.minutePeriod = dict["MinutePeriod"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("To") {
            self.to = dict["To"] as! Int32
        }
        if dict.keys.contains("TunnelId") {
            self.tunnelId = dict["TunnelId"] as! String
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class DescribeVpnConnectionLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var logs: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logs != nil {
                map["Logs"] = self.logs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Logs") {
                self.logs = dict["Logs"] as! [String]
            }
        }
    }
    public var count: Int32?

    public var data: DescribeVpnConnectionLogsResponseBody.Data?

    public var isCompleted: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.isCompleted != nil {
            map["IsCompleted"] = self.isCompleted!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DescribeVpnConnectionLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("IsCompleted") {
            self.isCompleted = dict["IsCompleted"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVpnConnectionLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnConnectionLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnConnectionLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnConnectionsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var customerGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeVpnConnectionsRequest.Tag]?

    public var vpnConnectionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeVpnConnectionsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeVpnConnectionsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DescribeVpnConnectionsResponseBody : Tea.TeaModel {
    public class VpnConnections : Tea.TeaModel {
        public class VpnConnection : Tea.TeaModel {
            public class IkeConfig : Tea.TeaModel {
                public var ikeAuthAlg: String?

                public var ikeEncAlg: String?

                public var ikeLifetime: Int64?

                public var ikeMode: String?

                public var ikePfs: String?

                public var ikeVersion: String?

                public var localId: String?

                public var psk: String?

                public var remoteId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ikeAuthAlg != nil {
                        map["IkeAuthAlg"] = self.ikeAuthAlg!
                    }
                    if self.ikeEncAlg != nil {
                        map["IkeEncAlg"] = self.ikeEncAlg!
                    }
                    if self.ikeLifetime != nil {
                        map["IkeLifetime"] = self.ikeLifetime!
                    }
                    if self.ikeMode != nil {
                        map["IkeMode"] = self.ikeMode!
                    }
                    if self.ikePfs != nil {
                        map["IkePfs"] = self.ikePfs!
                    }
                    if self.ikeVersion != nil {
                        map["IkeVersion"] = self.ikeVersion!
                    }
                    if self.localId != nil {
                        map["LocalId"] = self.localId!
                    }
                    if self.psk != nil {
                        map["Psk"] = self.psk!
                    }
                    if self.remoteId != nil {
                        map["RemoteId"] = self.remoteId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IkeAuthAlg") {
                        self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                    }
                    if dict.keys.contains("IkeEncAlg") {
                        self.ikeEncAlg = dict["IkeEncAlg"] as! String
                    }
                    if dict.keys.contains("IkeLifetime") {
                        self.ikeLifetime = dict["IkeLifetime"] as! Int64
                    }
                    if dict.keys.contains("IkeMode") {
                        self.ikeMode = dict["IkeMode"] as! String
                    }
                    if dict.keys.contains("IkePfs") {
                        self.ikePfs = dict["IkePfs"] as! String
                    }
                    if dict.keys.contains("IkeVersion") {
                        self.ikeVersion = dict["IkeVersion"] as! String
                    }
                    if dict.keys.contains("LocalId") {
                        self.localId = dict["LocalId"] as! String
                    }
                    if dict.keys.contains("Psk") {
                        self.psk = dict["Psk"] as! String
                    }
                    if dict.keys.contains("RemoteId") {
                        self.remoteId = dict["RemoteId"] as! String
                    }
                }
            }
            public class IpsecConfig : Tea.TeaModel {
                public var ipsecAuthAlg: String?

                public var ipsecEncAlg: String?

                public var ipsecLifetime: Int64?

                public var ipsecPfs: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipsecAuthAlg != nil {
                        map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                    }
                    if self.ipsecEncAlg != nil {
                        map["IpsecEncAlg"] = self.ipsecEncAlg!
                    }
                    if self.ipsecLifetime != nil {
                        map["IpsecLifetime"] = self.ipsecLifetime!
                    }
                    if self.ipsecPfs != nil {
                        map["IpsecPfs"] = self.ipsecPfs!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpsecAuthAlg") {
                        self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                    }
                    if dict.keys.contains("IpsecEncAlg") {
                        self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                    }
                    if dict.keys.contains("IpsecLifetime") {
                        self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
                    }
                    if dict.keys.contains("IpsecPfs") {
                        self.ipsecPfs = dict["IpsecPfs"] as! String
                    }
                }
            }
            public class Tag : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public class TunnelOptionsSpecification : Tea.TeaModel {
                public class TunnelOptions : Tea.TeaModel {
                    public class TunnelBgpConfig : Tea.TeaModel {
                        public var bgpStatus: String?

                        public var localAsn: String?

                        public var localBgpIp: String?

                        public var peerAsn: String?

                        public var peerBgpIp: String?

                        public var tunnelCidr: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bgpStatus != nil {
                                map["BgpStatus"] = self.bgpStatus!
                            }
                            if self.localAsn != nil {
                                map["LocalAsn"] = self.localAsn!
                            }
                            if self.localBgpIp != nil {
                                map["LocalBgpIp"] = self.localBgpIp!
                            }
                            if self.peerAsn != nil {
                                map["PeerAsn"] = self.peerAsn!
                            }
                            if self.peerBgpIp != nil {
                                map["PeerBgpIp"] = self.peerBgpIp!
                            }
                            if self.tunnelCidr != nil {
                                map["TunnelCidr"] = self.tunnelCidr!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("BgpStatus") {
                                self.bgpStatus = dict["BgpStatus"] as! String
                            }
                            if dict.keys.contains("LocalAsn") {
                                self.localAsn = dict["LocalAsn"] as! String
                            }
                            if dict.keys.contains("LocalBgpIp") {
                                self.localBgpIp = dict["LocalBgpIp"] as! String
                            }
                            if dict.keys.contains("PeerAsn") {
                                self.peerAsn = dict["PeerAsn"] as! String
                            }
                            if dict.keys.contains("PeerBgpIp") {
                                self.peerBgpIp = dict["PeerBgpIp"] as! String
                            }
                            if dict.keys.contains("TunnelCidr") {
                                self.tunnelCidr = dict["TunnelCidr"] as! String
                            }
                        }
                    }
                    public class TunnelIkeConfig : Tea.TeaModel {
                        public var ikeAuthAlg: String?

                        public var ikeEncAlg: String?

                        public var ikeLifetime: String?

                        public var ikeMode: String?

                        public var ikePfs: String?

                        public var ikeVersion: String?

                        public var localId: String?

                        public var psk: String?

                        public var remoteId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ikeAuthAlg != nil {
                                map["IkeAuthAlg"] = self.ikeAuthAlg!
                            }
                            if self.ikeEncAlg != nil {
                                map["IkeEncAlg"] = self.ikeEncAlg!
                            }
                            if self.ikeLifetime != nil {
                                map["IkeLifetime"] = self.ikeLifetime!
                            }
                            if self.ikeMode != nil {
                                map["IkeMode"] = self.ikeMode!
                            }
                            if self.ikePfs != nil {
                                map["IkePfs"] = self.ikePfs!
                            }
                            if self.ikeVersion != nil {
                                map["IkeVersion"] = self.ikeVersion!
                            }
                            if self.localId != nil {
                                map["LocalId"] = self.localId!
                            }
                            if self.psk != nil {
                                map["Psk"] = self.psk!
                            }
                            if self.remoteId != nil {
                                map["RemoteId"] = self.remoteId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("IkeAuthAlg") {
                                self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                            }
                            if dict.keys.contains("IkeEncAlg") {
                                self.ikeEncAlg = dict["IkeEncAlg"] as! String
                            }
                            if dict.keys.contains("IkeLifetime") {
                                self.ikeLifetime = dict["IkeLifetime"] as! String
                            }
                            if dict.keys.contains("IkeMode") {
                                self.ikeMode = dict["IkeMode"] as! String
                            }
                            if dict.keys.contains("IkePfs") {
                                self.ikePfs = dict["IkePfs"] as! String
                            }
                            if dict.keys.contains("IkeVersion") {
                                self.ikeVersion = dict["IkeVersion"] as! String
                            }
                            if dict.keys.contains("LocalId") {
                                self.localId = dict["LocalId"] as! String
                            }
                            if dict.keys.contains("Psk") {
                                self.psk = dict["Psk"] as! String
                            }
                            if dict.keys.contains("RemoteId") {
                                self.remoteId = dict["RemoteId"] as! String
                            }
                        }
                    }
                    public class TunnelIpsecConfig : Tea.TeaModel {
                        public var ipsecAuthAlg: String?

                        public var ipsecEncAlg: String?

                        public var ipsecLifetime: String?

                        public var ipsecPfs: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ipsecAuthAlg != nil {
                                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                            }
                            if self.ipsecEncAlg != nil {
                                map["IpsecEncAlg"] = self.ipsecEncAlg!
                            }
                            if self.ipsecLifetime != nil {
                                map["IpsecLifetime"] = self.ipsecLifetime!
                            }
                            if self.ipsecPfs != nil {
                                map["IpsecPfs"] = self.ipsecPfs!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("IpsecAuthAlg") {
                                self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                            }
                            if dict.keys.contains("IpsecEncAlg") {
                                self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                            }
                            if dict.keys.contains("IpsecLifetime") {
                                self.ipsecLifetime = dict["IpsecLifetime"] as! String
                            }
                            if dict.keys.contains("IpsecPfs") {
                                self.ipsecPfs = dict["IpsecPfs"] as! String
                            }
                        }
                    }
                    public var customerGatewayId: String?

                    public var enableDpd: String?

                    public var enableNatTraversal: String?

                    public var internetIp: String?

                    public var remoteCaCertificate: String?

                    public var role: String?

                    public var state: String?

                    public var status: String?

                    public var tunnelBgpConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig?

                    public var tunnelId: String?

                    public var tunnelIkeConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig?

                    public var tunnelIndex: Int32?

                    public var tunnelIpsecConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig?

                    public var zoneNo: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.tunnelBgpConfig?.validate()
                        try self.tunnelIkeConfig?.validate()
                        try self.tunnelIpsecConfig?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.customerGatewayId != nil {
                            map["CustomerGatewayId"] = self.customerGatewayId!
                        }
                        if self.enableDpd != nil {
                            map["EnableDpd"] = self.enableDpd!
                        }
                        if self.enableNatTraversal != nil {
                            map["EnableNatTraversal"] = self.enableNatTraversal!
                        }
                        if self.internetIp != nil {
                            map["InternetIp"] = self.internetIp!
                        }
                        if self.remoteCaCertificate != nil {
                            map["RemoteCaCertificate"] = self.remoteCaCertificate!
                        }
                        if self.role != nil {
                            map["Role"] = self.role!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.tunnelBgpConfig != nil {
                            map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
                        }
                        if self.tunnelId != nil {
                            map["TunnelId"] = self.tunnelId!
                        }
                        if self.tunnelIkeConfig != nil {
                            map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
                        }
                        if self.tunnelIndex != nil {
                            map["TunnelIndex"] = self.tunnelIndex!
                        }
                        if self.tunnelIpsecConfig != nil {
                            map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
                        }
                        if self.zoneNo != nil {
                            map["ZoneNo"] = self.zoneNo!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CustomerGatewayId") {
                            self.customerGatewayId = dict["CustomerGatewayId"] as! String
                        }
                        if dict.keys.contains("EnableDpd") {
                            self.enableDpd = dict["EnableDpd"] as! String
                        }
                        if dict.keys.contains("EnableNatTraversal") {
                            self.enableNatTraversal = dict["EnableNatTraversal"] as! String
                        }
                        if dict.keys.contains("InternetIp") {
                            self.internetIp = dict["InternetIp"] as! String
                        }
                        if dict.keys.contains("RemoteCaCertificate") {
                            self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
                        }
                        if dict.keys.contains("Role") {
                            self.role = dict["Role"] as! String
                        }
                        if dict.keys.contains("State") {
                            self.state = dict["State"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                        if dict.keys.contains("TunnelBgpConfig") {
                            var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig()
                            model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
                            self.tunnelBgpConfig = model
                        }
                        if dict.keys.contains("TunnelId") {
                            self.tunnelId = dict["TunnelId"] as! String
                        }
                        if dict.keys.contains("TunnelIkeConfig") {
                            var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig()
                            model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
                            self.tunnelIkeConfig = model
                        }
                        if dict.keys.contains("TunnelIndex") {
                            self.tunnelIndex = dict["TunnelIndex"] as! Int32
                        }
                        if dict.keys.contains("TunnelIpsecConfig") {
                            var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig()
                            model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
                            self.tunnelIpsecConfig = model
                        }
                        if dict.keys.contains("ZoneNo") {
                            self.zoneNo = dict["ZoneNo"] as! String
                        }
                    }
                }
                public var tunnelOptions: [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tunnelOptions != nil {
                        var tmp : [Any] = []
                        for k in self.tunnelOptions! {
                            tmp.append(k.toMap())
                        }
                        map["TunnelOptions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TunnelOptions") {
                        var tmp : [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions] = []
                        for v in dict["TunnelOptions"] as! [Any] {
                            var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tunnelOptions = tmp
                    }
                }
            }
            public class VcoHealthCheck : Tea.TeaModel {
                public var dip: String?

                public var enable: String?

                public var interval: Int32?

                public var policy: String?

                public var retry: Int32?

                public var sip: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dip != nil {
                        map["Dip"] = self.dip!
                    }
                    if self.enable != nil {
                        map["Enable"] = self.enable!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.retry != nil {
                        map["Retry"] = self.retry!
                    }
                    if self.sip != nil {
                        map["Sip"] = self.sip!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Dip") {
                        self.dip = dict["Dip"] as! String
                    }
                    if dict.keys.contains("Enable") {
                        self.enable = dict["Enable"] as! String
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Retry") {
                        self.retry = dict["Retry"] as! Int32
                    }
                    if dict.keys.contains("Sip") {
                        self.sip = dict["Sip"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class VpnBgpConfig : Tea.TeaModel {
                public var authKey: String?

                public var localAsn: Int64?

                public var localBgpIp: String?

                public var peerAsn: Int64?

                public var peerBgpIp: String?

                public var status: String?

                public var tunnelCidr: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.authKey != nil {
                        map["AuthKey"] = self.authKey!
                    }
                    if self.localAsn != nil {
                        map["LocalAsn"] = self.localAsn!
                    }
                    if self.localBgpIp != nil {
                        map["LocalBgpIp"] = self.localBgpIp!
                    }
                    if self.peerAsn != nil {
                        map["PeerAsn"] = self.peerAsn!
                    }
                    if self.peerBgpIp != nil {
                        map["PeerBgpIp"] = self.peerBgpIp!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tunnelCidr != nil {
                        map["TunnelCidr"] = self.tunnelCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AuthKey") {
                        self.authKey = dict["AuthKey"] as! String
                    }
                    if dict.keys.contains("LocalAsn") {
                        self.localAsn = dict["LocalAsn"] as! Int64
                    }
                    if dict.keys.contains("LocalBgpIp") {
                        self.localBgpIp = dict["LocalBgpIp"] as! String
                    }
                    if dict.keys.contains("PeerAsn") {
                        self.peerAsn = dict["PeerAsn"] as! Int64
                    }
                    if dict.keys.contains("PeerBgpIp") {
                        self.peerBgpIp = dict["PeerBgpIp"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("TunnelCidr") {
                        self.tunnelCidr = dict["TunnelCidr"] as! String
                    }
                }
            }
            public var attachInstanceId: String?

            public var attachType: String?

            public var createTime: Int64?

            public var crossAccountAuthorized: Bool?

            public var customerGatewayId: String?

            public var effectImmediately: Bool?

            public var enableDpd: Bool?

            public var enableNatTraversal: Bool?

            public var enableTunnelsBgp: Bool?

            public var ikeConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.IkeConfig?

            public var internetIp: String?

            public var ipsecConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.IpsecConfig?

            public var localSubnet: String?

            public var name: String?

            public var networkType: String?

            public var remoteCaCertificate: String?

            public var remoteSubnet: String?

            public var resourceGroupId: String?

            public var spec: String?

            public var state: String?

            public var status: String?

            public var tag: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag?

            public var transitRouterId: String?

            public var transitRouterName: String?

            public var tunnelOptionsSpecification: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification?

            public var vcoHealthCheck: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.VcoHealthCheck?

            public var vpnBgpConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.VpnBgpConfig?

            public var vpnConnectionId: String?

            public var vpnGatewayId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ikeConfig?.validate()
                try self.ipsecConfig?.validate()
                try self.tag?.validate()
                try self.tunnelOptionsSpecification?.validate()
                try self.vcoHealthCheck?.validate()
                try self.vpnBgpConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attachInstanceId != nil {
                    map["AttachInstanceId"] = self.attachInstanceId!
                }
                if self.attachType != nil {
                    map["AttachType"] = self.attachType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.crossAccountAuthorized != nil {
                    map["CrossAccountAuthorized"] = self.crossAccountAuthorized!
                }
                if self.customerGatewayId != nil {
                    map["CustomerGatewayId"] = self.customerGatewayId!
                }
                if self.effectImmediately != nil {
                    map["EffectImmediately"] = self.effectImmediately!
                }
                if self.enableDpd != nil {
                    map["EnableDpd"] = self.enableDpd!
                }
                if self.enableNatTraversal != nil {
                    map["EnableNatTraversal"] = self.enableNatTraversal!
                }
                if self.enableTunnelsBgp != nil {
                    map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
                }
                if self.ikeConfig != nil {
                    map["IkeConfig"] = self.ikeConfig?.toMap()
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.ipsecConfig != nil {
                    map["IpsecConfig"] = self.ipsecConfig?.toMap()
                }
                if self.localSubnet != nil {
                    map["LocalSubnet"] = self.localSubnet!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.remoteCaCertificate != nil {
                    map["RemoteCaCertificate"] = self.remoteCaCertificate!
                }
                if self.remoteSubnet != nil {
                    map["RemoteSubnet"] = self.remoteSubnet!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag?.toMap()
                }
                if self.transitRouterId != nil {
                    map["TransitRouterId"] = self.transitRouterId!
                }
                if self.transitRouterName != nil {
                    map["TransitRouterName"] = self.transitRouterName!
                }
                if self.tunnelOptionsSpecification != nil {
                    map["TunnelOptionsSpecification"] = self.tunnelOptionsSpecification?.toMap()
                }
                if self.vcoHealthCheck != nil {
                    map["VcoHealthCheck"] = self.vcoHealthCheck?.toMap()
                }
                if self.vpnBgpConfig != nil {
                    map["VpnBgpConfig"] = self.vpnBgpConfig?.toMap()
                }
                if self.vpnConnectionId != nil {
                    map["VpnConnectionId"] = self.vpnConnectionId!
                }
                if self.vpnGatewayId != nil {
                    map["VpnGatewayId"] = self.vpnGatewayId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AttachInstanceId") {
                    self.attachInstanceId = dict["AttachInstanceId"] as! String
                }
                if dict.keys.contains("AttachType") {
                    self.attachType = dict["AttachType"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CrossAccountAuthorized") {
                    self.crossAccountAuthorized = dict["CrossAccountAuthorized"] as! Bool
                }
                if dict.keys.contains("CustomerGatewayId") {
                    self.customerGatewayId = dict["CustomerGatewayId"] as! String
                }
                if dict.keys.contains("EffectImmediately") {
                    self.effectImmediately = dict["EffectImmediately"] as! Bool
                }
                if dict.keys.contains("EnableDpd") {
                    self.enableDpd = dict["EnableDpd"] as! Bool
                }
                if dict.keys.contains("EnableNatTraversal") {
                    self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
                }
                if dict.keys.contains("EnableTunnelsBgp") {
                    self.enableTunnelsBgp = dict["EnableTunnelsBgp"] as! Bool
                }
                if dict.keys.contains("IkeConfig") {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.IkeConfig()
                    model.fromMap(dict["IkeConfig"] as! [String: Any])
                    self.ikeConfig = model
                }
                if dict.keys.contains("InternetIp") {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("IpsecConfig") {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.IpsecConfig()
                    model.fromMap(dict["IpsecConfig"] as! [String: Any])
                    self.ipsecConfig = model
                }
                if dict.keys.contains("LocalSubnet") {
                    self.localSubnet = dict["LocalSubnet"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("RemoteCaCertificate") {
                    self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
                }
                if dict.keys.contains("RemoteSubnet") {
                    self.remoteSubnet = dict["RemoteSubnet"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tag") {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag()
                    model.fromMap(dict["Tag"] as! [String: Any])
                    self.tag = model
                }
                if dict.keys.contains("TransitRouterId") {
                    self.transitRouterId = dict["TransitRouterId"] as! String
                }
                if dict.keys.contains("TransitRouterName") {
                    self.transitRouterName = dict["TransitRouterName"] as! String
                }
                if dict.keys.contains("TunnelOptionsSpecification") {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification()
                    model.fromMap(dict["TunnelOptionsSpecification"] as! [String: Any])
                    self.tunnelOptionsSpecification = model
                }
                if dict.keys.contains("VcoHealthCheck") {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.VcoHealthCheck()
                    model.fromMap(dict["VcoHealthCheck"] as! [String: Any])
                    self.vcoHealthCheck = model
                }
                if dict.keys.contains("VpnBgpConfig") {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.VpnBgpConfig()
                    model.fromMap(dict["VpnBgpConfig"] as! [String: Any])
                    self.vpnBgpConfig = model
                }
                if dict.keys.contains("VpnConnectionId") {
                    self.vpnConnectionId = dict["VpnConnectionId"] as! String
                }
                if dict.keys.contains("VpnGatewayId") {
                    self.vpnGatewayId = dict["VpnGatewayId"] as! String
                }
            }
        }
        public var vpnConnection: [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnConnection != nil {
                var tmp : [Any] = []
                for k in self.vpnConnection! {
                    tmp.append(k.toMap())
                }
                map["VpnConnection"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpnConnection") {
                var tmp : [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection] = []
                for v in dict["VpnConnection"] as! [Any] {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpnConnection = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnConnections: DescribeVpnConnectionsResponseBody.VpnConnections?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnConnections?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnConnections != nil {
            map["VpnConnections"] = self.vpnConnections?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpnConnections") {
            var model = DescribeVpnConnectionsResponseBody.VpnConnections()
            model.fromMap(dict["VpnConnections"] as! [String: Any])
            self.vpnConnections = model
        }
    }
}

public class DescribeVpnConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnCrossAccountAuthorizationsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class DescribeVpnCrossAccountAuthorizationsResponseBody : Tea.TeaModel {
    public class CrossAccountAuthorizations : Tea.TeaModel {
        public var aliUid: Int64?

        public var bindInstance: String?

        public var bindProduct: String?

        public var bindUid: Int64?

        public var creationTime: Int64?

        public var vpnConnectionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.bindInstance != nil {
                map["BindInstance"] = self.bindInstance!
            }
            if self.bindProduct != nil {
                map["BindProduct"] = self.bindProduct!
            }
            if self.bindUid != nil {
                map["BindUid"] = self.bindUid!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.vpnConnectionId != nil {
                map["VpnConnectionId"] = self.vpnConnectionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliUid") {
                self.aliUid = dict["AliUid"] as! Int64
            }
            if dict.keys.contains("BindInstance") {
                self.bindInstance = dict["BindInstance"] as! String
            }
            if dict.keys.contains("BindProduct") {
                self.bindProduct = dict["BindProduct"] as! String
            }
            if dict.keys.contains("BindUid") {
                self.bindUid = dict["BindUid"] as! Int64
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("VpnConnectionId") {
                self.vpnConnectionId = dict["VpnConnectionId"] as! String
            }
        }
    }
    public var crossAccountAuthorizations: [DescribeVpnCrossAccountAuthorizationsResponseBody.CrossAccountAuthorizations]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.crossAccountAuthorizations != nil {
            var tmp : [Any] = []
            for k in self.crossAccountAuthorizations! {
                tmp.append(k.toMap())
            }
            map["CrossAccountAuthorizations"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CrossAccountAuthorizations") {
            var tmp : [DescribeVpnCrossAccountAuthorizationsResponseBody.CrossAccountAuthorizations] = []
            for v in dict["CrossAccountAuthorizations"] as! [Any] {
                var model = DescribeVpnCrossAccountAuthorizationsResponseBody.CrossAccountAuthorizations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.crossAccountAuthorizations = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeVpnCrossAccountAuthorizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnCrossAccountAuthorizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnCrossAccountAuthorizationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnGatewayRequest : Tea.TeaModel {
    public var includeReservationData: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IncludeReservationData") {
            self.includeReservationData = dict["IncludeReservationData"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DescribeVpnGatewayResponseBody : Tea.TeaModel {
    public class EniInstanceIds : Tea.TeaModel {
        public var eniInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eniInstanceId != nil {
                map["EniInstanceId"] = self.eniInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EniInstanceId") {
                self.eniInstanceId = dict["EniInstanceId"] as! [String]
            }
        }
    }
    public class ReservationData : Tea.TeaModel {
        public var reservationEndTime: String?

        public var reservationIpsec: String?

        public var reservationMaxConnections: Int32?

        public var reservationOrderType: String?

        public var reservationSpec: String?

        public var reservationSsl: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservationEndTime != nil {
                map["ReservationEndTime"] = self.reservationEndTime!
            }
            if self.reservationIpsec != nil {
                map["ReservationIpsec"] = self.reservationIpsec!
            }
            if self.reservationMaxConnections != nil {
                map["ReservationMaxConnections"] = self.reservationMaxConnections!
            }
            if self.reservationOrderType != nil {
                map["ReservationOrderType"] = self.reservationOrderType!
            }
            if self.reservationSpec != nil {
                map["ReservationSpec"] = self.reservationSpec!
            }
            if self.reservationSsl != nil {
                map["ReservationSsl"] = self.reservationSsl!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservationEndTime") {
                self.reservationEndTime = dict["ReservationEndTime"] as! String
            }
            if dict.keys.contains("ReservationIpsec") {
                self.reservationIpsec = dict["ReservationIpsec"] as! String
            }
            if dict.keys.contains("ReservationMaxConnections") {
                self.reservationMaxConnections = dict["ReservationMaxConnections"] as! Int32
            }
            if dict.keys.contains("ReservationOrderType") {
                self.reservationOrderType = dict["ReservationOrderType"] as! String
            }
            if dict.keys.contains("ReservationSpec") {
                self.reservationSpec = dict["ReservationSpec"] as! String
            }
            if dict.keys.contains("ReservationSsl") {
                self.reservationSsl = dict["ReservationSsl"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var tag: [DescribeVpnGatewayResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") {
                var tmp : [DescribeVpnGatewayResponseBody.Tags.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = DescribeVpnGatewayResponseBody.Tags.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public var autoPropagate: Bool?

    public var businessStatus: String?

    public var chargeType: String?

    public var createTime: Int64?

    public var description_: String?

    public var disasterRecoveryInternetIp: String?

    public var disasterRecoveryVSwitchId: String?

    public var enableBgp: Bool?

    public var endTime: Int64?

    public var eniInstanceIds: DescribeVpnGatewayResponseBody.EniInstanceIds?

    public var internetIp: String?

    public var ipsecVpn: String?

    public var name: String?

    public var networkType: String?

    public var requestId: String?

    public var reservationData: DescribeVpnGatewayResponseBody.ReservationData?

    public var resourceGroupId: String?

    public var spec: String?

    public var sslMaxConnections: Int64?

    public var sslVpn: String?

    public var sslVpnInternetIp: String?

    public var status: String?

    public var tag: String?

    public var tags: DescribeVpnGatewayResponseBody.Tags?

    public var vSwitchId: String?

    public var vpcId: String?

    public var vpnGatewayId: String?

    public var vpnType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eniInstanceIds?.validate()
        try self.reservationData?.validate()
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPropagate != nil {
            map["AutoPropagate"] = self.autoPropagate!
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disasterRecoveryInternetIp != nil {
            map["DisasterRecoveryInternetIp"] = self.disasterRecoveryInternetIp!
        }
        if self.disasterRecoveryVSwitchId != nil {
            map["DisasterRecoveryVSwitchId"] = self.disasterRecoveryVSwitchId!
        }
        if self.enableBgp != nil {
            map["EnableBgp"] = self.enableBgp!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eniInstanceIds != nil {
            map["EniInstanceIds"] = self.eniInstanceIds?.toMap()
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.ipsecVpn != nil {
            map["IpsecVpn"] = self.ipsecVpn!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservationData != nil {
            map["ReservationData"] = self.reservationData?.toMap()
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.sslMaxConnections != nil {
            map["SslMaxConnections"] = self.sslMaxConnections!
        }
        if self.sslVpn != nil {
            map["SslVpn"] = self.sslVpn!
        }
        if self.sslVpnInternetIp != nil {
            map["SslVpnInternetIp"] = self.sslVpnInternetIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.vpnType != nil {
            map["VpnType"] = self.vpnType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPropagate") {
            self.autoPropagate = dict["AutoPropagate"] as! Bool
        }
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisasterRecoveryInternetIp") {
            self.disasterRecoveryInternetIp = dict["DisasterRecoveryInternetIp"] as! String
        }
        if dict.keys.contains("DisasterRecoveryVSwitchId") {
            self.disasterRecoveryVSwitchId = dict["DisasterRecoveryVSwitchId"] as! String
        }
        if dict.keys.contains("EnableBgp") {
            self.enableBgp = dict["EnableBgp"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("EniInstanceIds") {
            var model = DescribeVpnGatewayResponseBody.EniInstanceIds()
            model.fromMap(dict["EniInstanceIds"] as! [String: Any])
            self.eniInstanceIds = model
        }
        if dict.keys.contains("InternetIp") {
            self.internetIp = dict["InternetIp"] as! String
        }
        if dict.keys.contains("IpsecVpn") {
            self.ipsecVpn = dict["IpsecVpn"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservationData") {
            var model = DescribeVpnGatewayResponseBody.ReservationData()
            model.fromMap(dict["ReservationData"] as! [String: Any])
            self.reservationData = model
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("SslMaxConnections") {
            self.sslMaxConnections = dict["SslMaxConnections"] as! Int64
        }
        if dict.keys.contains("SslVpn") {
            self.sslVpn = dict["SslVpn"] as! String
        }
        if dict.keys.contains("SslVpnInternetIp") {
            self.sslVpnInternetIp = dict["SslVpnInternetIp"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("Tags") {
            var model = DescribeVpnGatewayResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("VpnType") {
            self.vpnType = dict["VpnType"] as! String
        }
    }
}

public class DescribeVpnGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnGatewayAvailableZonesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class DescribeVpnGatewayAvailableZonesResponseBody : Tea.TeaModel {
    public class AvailableZoneIdList : Tea.TeaModel {
        public var zoneId: String?

        public var zoneName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            if self.zoneName != nil {
                map["ZoneName"] = self.zoneName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
            if dict.keys.contains("ZoneName") {
                self.zoneName = dict["ZoneName"] as! String
            }
        }
    }
    public var availableZoneIdList: [DescribeVpnGatewayAvailableZonesResponseBody.AvailableZoneIdList]?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableZoneIdList != nil {
            var tmp : [Any] = []
            for k in self.availableZoneIdList! {
                tmp.append(k.toMap())
            }
            map["AvailableZoneIdList"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableZoneIdList") {
            var tmp : [DescribeVpnGatewayAvailableZonesResponseBody.AvailableZoneIdList] = []
            for v in dict["AvailableZoneIdList"] as! [Any] {
                var model = DescribeVpnGatewayAvailableZonesResponseBody.AvailableZoneIdList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.availableZoneIdList = tmp
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVpnGatewayAvailableZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnGatewayAvailableZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnGatewayAvailableZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnGatewaysRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var businessStatus: String?

    public var includeReservationData: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeVpnGatewaysRequest.Tag]?

    public var vpcId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("IncludeReservationData") {
            self.includeReservationData = dict["IncludeReservationData"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeVpnGatewaysRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeVpnGatewaysRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DescribeVpnGatewaysResponseBody : Tea.TeaModel {
    public class VpnGateways : Tea.TeaModel {
        public class VpnGateway : Tea.TeaModel {
            public class EniInstanceIds : Tea.TeaModel {
                public var eniInstanceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eniInstanceId != nil {
                        map["EniInstanceId"] = self.eniInstanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EniInstanceId") {
                        self.eniInstanceId = dict["EniInstanceId"] as! [String]
                    }
                }
            }
            public class ReservationData : Tea.TeaModel {
                public var reservationEndTime: String?

                public var reservationIpsec: String?

                public var reservationMaxConnections: Int32?

                public var reservationOrderType: String?

                public var reservationSpec: String?

                public var reservationSsl: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.reservationEndTime != nil {
                        map["ReservationEndTime"] = self.reservationEndTime!
                    }
                    if self.reservationIpsec != nil {
                        map["ReservationIpsec"] = self.reservationIpsec!
                    }
                    if self.reservationMaxConnections != nil {
                        map["ReservationMaxConnections"] = self.reservationMaxConnections!
                    }
                    if self.reservationOrderType != nil {
                        map["ReservationOrderType"] = self.reservationOrderType!
                    }
                    if self.reservationSpec != nil {
                        map["ReservationSpec"] = self.reservationSpec!
                    }
                    if self.reservationSsl != nil {
                        map["ReservationSsl"] = self.reservationSsl!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ReservationEndTime") {
                        self.reservationEndTime = dict["ReservationEndTime"] as! String
                    }
                    if dict.keys.contains("ReservationIpsec") {
                        self.reservationIpsec = dict["ReservationIpsec"] as! String
                    }
                    if dict.keys.contains("ReservationMaxConnections") {
                        self.reservationMaxConnections = dict["ReservationMaxConnections"] as! Int32
                    }
                    if dict.keys.contains("ReservationOrderType") {
                        self.reservationOrderType = dict["ReservationOrderType"] as! String
                    }
                    if dict.keys.contains("ReservationSpec") {
                        self.reservationSpec = dict["ReservationSpec"] as! String
                    }
                    if dict.keys.contains("ReservationSsl") {
                        self.reservationSsl = dict["ReservationSsl"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var autoPropagate: Bool?

            public var businessStatus: String?

            public var chargeType: String?

            public var createTime: Int64?

            public var description_: String?

            public var disasterRecoveryInternetIp: String?

            public var disasterRecoveryVSwitchId: String?

            public var enableBgp: Bool?

            public var endTime: Int64?

            public var eniInstanceIds: DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.EniInstanceIds?

            public var internetIp: String?

            public var ipsecVpn: String?

            public var name: String?

            public var networkType: String?

            public var reservationData: DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.ReservationData?

            public var resourceGroupId: String?

            public var spec: String?

            public var sslMaxConnections: Int64?

            public var sslVpn: String?

            public var sslVpnInternetIp: String?

            public var status: String?

            public var tag: String?

            public var tags: DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags?

            public var vSwitchId: String?

            public var vpcId: String?

            public var vpnGatewayId: String?

            public var vpnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.eniInstanceIds?.validate()
                try self.reservationData?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoPropagate != nil {
                    map["AutoPropagate"] = self.autoPropagate!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.disasterRecoveryInternetIp != nil {
                    map["DisasterRecoveryInternetIp"] = self.disasterRecoveryInternetIp!
                }
                if self.disasterRecoveryVSwitchId != nil {
                    map["DisasterRecoveryVSwitchId"] = self.disasterRecoveryVSwitchId!
                }
                if self.enableBgp != nil {
                    map["EnableBgp"] = self.enableBgp!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.eniInstanceIds != nil {
                    map["EniInstanceIds"] = self.eniInstanceIds?.toMap()
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.ipsecVpn != nil {
                    map["IpsecVpn"] = self.ipsecVpn!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.reservationData != nil {
                    map["ReservationData"] = self.reservationData?.toMap()
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.sslMaxConnections != nil {
                    map["SslMaxConnections"] = self.sslMaxConnections!
                }
                if self.sslVpn != nil {
                    map["SslVpn"] = self.sslVpn!
                }
                if self.sslVpnInternetIp != nil {
                    map["SslVpnInternetIp"] = self.sslVpnInternetIp!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpnGatewayId != nil {
                    map["VpnGatewayId"] = self.vpnGatewayId!
                }
                if self.vpnType != nil {
                    map["VpnType"] = self.vpnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoPropagate") {
                    self.autoPropagate = dict["AutoPropagate"] as! Bool
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DisasterRecoveryInternetIp") {
                    self.disasterRecoveryInternetIp = dict["DisasterRecoveryInternetIp"] as! String
                }
                if dict.keys.contains("DisasterRecoveryVSwitchId") {
                    self.disasterRecoveryVSwitchId = dict["DisasterRecoveryVSwitchId"] as! String
                }
                if dict.keys.contains("EnableBgp") {
                    self.enableBgp = dict["EnableBgp"] as! Bool
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("EniInstanceIds") {
                    var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.EniInstanceIds()
                    model.fromMap(dict["EniInstanceIds"] as! [String: Any])
                    self.eniInstanceIds = model
                }
                if dict.keys.contains("InternetIp") {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("IpsecVpn") {
                    self.ipsecVpn = dict["IpsecVpn"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("ReservationData") {
                    var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.ReservationData()
                    model.fromMap(dict["ReservationData"] as! [String: Any])
                    self.reservationData = model
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("SslMaxConnections") {
                    self.sslMaxConnections = dict["SslMaxConnections"] as! Int64
                }
                if dict.keys.contains("SslVpn") {
                    self.sslVpn = dict["SslVpn"] as! String
                }
                if dict.keys.contains("SslVpnInternetIp") {
                    self.sslVpnInternetIp = dict["SslVpnInternetIp"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpnGatewayId") {
                    self.vpnGatewayId = dict["VpnGatewayId"] as! String
                }
                if dict.keys.contains("VpnType") {
                    self.vpnType = dict["VpnType"] as! String
                }
            }
        }
        public var vpnGateway: [DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnGateway != nil {
                var tmp : [Any] = []
                for k in self.vpnGateway! {
                    tmp.append(k.toMap())
                }
                map["VpnGateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpnGateway") {
                var tmp : [DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway] = []
                for v in dict["VpnGateway"] as! [Any] {
                    var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpnGateway = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnGateways: DescribeVpnGatewaysResponseBody.VpnGateways?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnGateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnGateways != nil {
            map["VpnGateways"] = self.vpnGateways?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpnGateways") {
            var model = DescribeVpnGatewaysResponseBody.VpnGateways()
            model.fromMap(dict["VpnGateways"] as! [String: Any])
            self.vpnGateways = model
        }
    }
}

public class DescribeVpnGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnGatewaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnPbrRouteEntriesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DescribeVpnPbrRouteEntriesResponseBody : Tea.TeaModel {
    public class VpnPbrRouteEntries : Tea.TeaModel {
        public class VpnPbrRouteEntry : Tea.TeaModel {
            public var createTime: Int64?

            public var nextHop: String?

            public var nextHopTunnelId: String?

            public var priority: Int32?

            public var routeDest: String?

            public var routeSource: String?

            public var state: String?

            public var vpnInstanceId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.nextHop != nil {
                    map["NextHop"] = self.nextHop!
                }
                if self.nextHopTunnelId != nil {
                    map["NextHopTunnelId"] = self.nextHopTunnelId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.routeDest != nil {
                    map["RouteDest"] = self.routeDest!
                }
                if self.routeSource != nil {
                    map["RouteSource"] = self.routeSource!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.vpnInstanceId != nil {
                    map["VpnInstanceId"] = self.vpnInstanceId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("NextHop") {
                    self.nextHop = dict["NextHop"] as! String
                }
                if dict.keys.contains("NextHopTunnelId") {
                    self.nextHopTunnelId = dict["NextHopTunnelId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("RouteDest") {
                    self.routeDest = dict["RouteDest"] as! String
                }
                if dict.keys.contains("RouteSource") {
                    self.routeSource = dict["RouteSource"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("VpnInstanceId") {
                    self.vpnInstanceId = dict["VpnInstanceId"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var vpnPbrRouteEntry: [DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries.VpnPbrRouteEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnPbrRouteEntry != nil {
                var tmp : [Any] = []
                for k in self.vpnPbrRouteEntry! {
                    tmp.append(k.toMap())
                }
                map["VpnPbrRouteEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpnPbrRouteEntry") {
                var tmp : [DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries.VpnPbrRouteEntry] = []
                for v in dict["VpnPbrRouteEntry"] as! [Any] {
                    var model = DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries.VpnPbrRouteEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpnPbrRouteEntry = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnPbrRouteEntries: DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnPbrRouteEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnPbrRouteEntries != nil {
            map["VpnPbrRouteEntries"] = self.vpnPbrRouteEntries?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpnPbrRouteEntries") {
            var model = DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries()
            model.fromMap(dict["VpnPbrRouteEntries"] as! [String: Any])
            self.vpnPbrRouteEntries = model
        }
    }
}

public class DescribeVpnPbrRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnPbrRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnPbrRouteEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnRouteEntriesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryType: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntryType") {
            self.routeEntryType = dict["RouteEntryType"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DescribeVpnRouteEntriesResponseBody : Tea.TeaModel {
    public class VpnRouteCounts : Tea.TeaModel {
        public class VpnRouteCount : Tea.TeaModel {
            public var routeCount: Int32?

            public var routeEntryType: String?

            public var source: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.routeCount != nil {
                    map["RouteCount"] = self.routeCount!
                }
                if self.routeEntryType != nil {
                    map["RouteEntryType"] = self.routeEntryType!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RouteCount") {
                    self.routeCount = dict["RouteCount"] as! Int32
                }
                if dict.keys.contains("RouteEntryType") {
                    self.routeEntryType = dict["RouteEntryType"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
            }
        }
        public var vpnRouteCount: [DescribeVpnRouteEntriesResponseBody.VpnRouteCounts.VpnRouteCount]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnRouteCount != nil {
                var tmp : [Any] = []
                for k in self.vpnRouteCount! {
                    tmp.append(k.toMap())
                }
                map["VpnRouteCount"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpnRouteCount") {
                var tmp : [DescribeVpnRouteEntriesResponseBody.VpnRouteCounts.VpnRouteCount] = []
                for v in dict["VpnRouteCount"] as! [Any] {
                    var model = DescribeVpnRouteEntriesResponseBody.VpnRouteCounts.VpnRouteCount()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpnRouteCount = tmp
            }
        }
    }
    public class VpnRouteEntries : Tea.TeaModel {
        public class VpnRouteEntry : Tea.TeaModel {
            public var asPath: String?

            public var community: String?

            public var createTime: Int64?

            public var nextHop: String?

            public var nextHopTunnelId: String?

            public var routeDest: String?

            public var routeEntryType: String?

            public var source: String?

            public var state: String?

            public var vpnInstanceId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.asPath != nil {
                    map["AsPath"] = self.asPath!
                }
                if self.community != nil {
                    map["Community"] = self.community!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.nextHop != nil {
                    map["NextHop"] = self.nextHop!
                }
                if self.nextHopTunnelId != nil {
                    map["NextHopTunnelId"] = self.nextHopTunnelId!
                }
                if self.routeDest != nil {
                    map["RouteDest"] = self.routeDest!
                }
                if self.routeEntryType != nil {
                    map["RouteEntryType"] = self.routeEntryType!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.vpnInstanceId != nil {
                    map["VpnInstanceId"] = self.vpnInstanceId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AsPath") {
                    self.asPath = dict["AsPath"] as! String
                }
                if dict.keys.contains("Community") {
                    self.community = dict["Community"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("NextHop") {
                    self.nextHop = dict["NextHop"] as! String
                }
                if dict.keys.contains("NextHopTunnelId") {
                    self.nextHopTunnelId = dict["NextHopTunnelId"] as! String
                }
                if dict.keys.contains("RouteDest") {
                    self.routeDest = dict["RouteDest"] as! String
                }
                if dict.keys.contains("RouteEntryType") {
                    self.routeEntryType = dict["RouteEntryType"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("VpnInstanceId") {
                    self.vpnInstanceId = dict["VpnInstanceId"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var vpnRouteEntry: [DescribeVpnRouteEntriesResponseBody.VpnRouteEntries.VpnRouteEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnRouteEntry != nil {
                var tmp : [Any] = []
                for k in self.vpnRouteEntry! {
                    tmp.append(k.toMap())
                }
                map["VpnRouteEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpnRouteEntry") {
                var tmp : [DescribeVpnRouteEntriesResponseBody.VpnRouteEntries.VpnRouteEntry] = []
                for v in dict["VpnRouteEntry"] as! [Any] {
                    var model = DescribeVpnRouteEntriesResponseBody.VpnRouteEntries.VpnRouteEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpnRouteEntry = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnRouteCounts: DescribeVpnRouteEntriesResponseBody.VpnRouteCounts?

    public var vpnRouteEntries: DescribeVpnRouteEntriesResponseBody.VpnRouteEntries?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnRouteCounts?.validate()
        try self.vpnRouteEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnRouteCounts != nil {
            map["VpnRouteCounts"] = self.vpnRouteCounts?.toMap()
        }
        if self.vpnRouteEntries != nil {
            map["VpnRouteEntries"] = self.vpnRouteEntries?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpnRouteCounts") {
            var model = DescribeVpnRouteEntriesResponseBody.VpnRouteCounts()
            model.fromMap(dict["VpnRouteCounts"] as! [String: Any])
            self.vpnRouteCounts = model
        }
        if dict.keys.contains("VpnRouteEntries") {
            var model = DescribeVpnRouteEntriesResponseBody.VpnRouteEntries()
            model.fromMap(dict["VpnRouteEntries"] as! [String: Any])
            self.vpnRouteEntries = model
        }
    }
}

public class DescribeVpnRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnRouteEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpnSslServerLogsRequest : Tea.TeaModel {
    public var from: Int32?

    public var minutePeriod: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public var to: Int32?

    public var vpnSslServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.minutePeriod != nil {
            map["MinutePeriod"] = self.minutePeriod!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        if self.vpnSslServerId != nil {
            map["VpnSslServerId"] = self.vpnSslServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") {
            self.from = dict["From"] as! Int32
        }
        if dict.keys.contains("MinutePeriod") {
            self.minutePeriod = dict["MinutePeriod"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslVpnClientCertId") {
            self.sslVpnClientCertId = dict["SslVpnClientCertId"] as! String
        }
        if dict.keys.contains("To") {
            self.to = dict["To"] as! Int32
        }
        if dict.keys.contains("VpnSslServerId") {
            self.vpnSslServerId = dict["VpnSslServerId"] as! String
        }
    }
}

public class DescribeVpnSslServerLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var logs: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logs != nil {
                map["Logs"] = self.logs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Logs") {
                self.logs = dict["Logs"] as! [String]
            }
        }
    }
    public var count: Int32?

    public var data: DescribeVpnSslServerLogsResponseBody.Data?

    public var isCompleted: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.isCompleted != nil {
            map["IsCompleted"] = self.isCompleted!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DescribeVpnSslServerLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("IsCompleted") {
            self.isCompleted = dict["IsCompleted"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVpnSslServerLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnSslServerLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpnSslServerLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeZonesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneType != nil {
            map["ZoneType"] = self.zoneType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneType") {
            self.zoneType = dict["ZoneType"] as! String
        }
    }
}

public class DescribeZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public class Zone : Tea.TeaModel {
            public var localName: String?

            public var zoneId: String?

            public var zoneType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneType != nil {
                    map["ZoneType"] = self.zoneType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
                if dict.keys.contains("ZoneType") {
                    self.zoneType = dict["ZoneType"] as! String
                }
            }
        }
        public var zone: [DescribeZonesResponseBody.Zones.Zone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zone != nil {
                var tmp : [Any] = []
                for k in self.zone! {
                    tmp.append(k.toMap())
                }
                map["Zone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Zone") {
                var tmp : [DescribeZonesResponseBody.Zones.Zone] = []
                for v in dict["Zone"] as! [Any] {
                    var model = DescribeZonesResponseBody.Zones.Zone()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.zone = tmp
            }
        }
    }
    public var requestId: String?

    public var zones: DescribeZonesResponseBody.Zones?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.zones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            map["Zones"] = self.zones?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Zones") {
            var model = DescribeZonesResponseBody.Zones()
            model.fromMap(dict["Zones"] as! [String: Any])
            self.zones = model
        }
    }
}

public class DescribeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachDhcpOptionsSetFromVpcRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DetachDhcpOptionsSetFromVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachDhcpOptionsSetFromVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDhcpOptionsSetFromVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachDhcpOptionsSetFromVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DiagnoseVpnConnectionsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var tunnelIds: [String]?

    public var vpnConnectionIds: [String]?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tunnelIds != nil {
            map["TunnelIds"] = self.tunnelIds!
        }
        if self.vpnConnectionIds != nil {
            map["VpnConnectionIds"] = self.vpnConnectionIds!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TunnelIds") {
            self.tunnelIds = dict["TunnelIds"] as! [String]
        }
        if dict.keys.contains("VpnConnectionIds") {
            self.vpnConnectionIds = dict["VpnConnectionIds"] as! [String]
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DiagnoseVpnConnectionsResponseBody : Tea.TeaModel {
    public class VpnConnections : Tea.TeaModel {
        public var failedReason: String?

        public var failedReasonCode: String?

        public var failedTime: Int64?

        public var mismatchLocalParam: String?

        public var mismatchRemoteParam: String?

        public var severity: String?

        public var sourceLog: String?

        public var tunnelId: String?

        public var vpnConnectionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedReason != nil {
                map["FailedReason"] = self.failedReason!
            }
            if self.failedReasonCode != nil {
                map["FailedReasonCode"] = self.failedReasonCode!
            }
            if self.failedTime != nil {
                map["FailedTime"] = self.failedTime!
            }
            if self.mismatchLocalParam != nil {
                map["MismatchLocalParam"] = self.mismatchLocalParam!
            }
            if self.mismatchRemoteParam != nil {
                map["MismatchRemoteParam"] = self.mismatchRemoteParam!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.sourceLog != nil {
                map["SourceLog"] = self.sourceLog!
            }
            if self.tunnelId != nil {
                map["TunnelId"] = self.tunnelId!
            }
            if self.vpnConnectionId != nil {
                map["VpnConnectionId"] = self.vpnConnectionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedReason") {
                self.failedReason = dict["FailedReason"] as! String
            }
            if dict.keys.contains("FailedReasonCode") {
                self.failedReasonCode = dict["FailedReasonCode"] as! String
            }
            if dict.keys.contains("FailedTime") {
                self.failedTime = dict["FailedTime"] as! Int64
            }
            if dict.keys.contains("MismatchLocalParam") {
                self.mismatchLocalParam = dict["MismatchLocalParam"] as! String
            }
            if dict.keys.contains("MismatchRemoteParam") {
                self.mismatchRemoteParam = dict["MismatchRemoteParam"] as! String
            }
            if dict.keys.contains("Severity") {
                self.severity = dict["Severity"] as! String
            }
            if dict.keys.contains("SourceLog") {
                self.sourceLog = dict["SourceLog"] as! String
            }
            if dict.keys.contains("TunnelId") {
                self.tunnelId = dict["TunnelId"] as! String
            }
            if dict.keys.contains("VpnConnectionId") {
                self.vpnConnectionId = dict["VpnConnectionId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnConnections: [DiagnoseVpnConnectionsResponseBody.VpnConnections]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnConnections != nil {
            var tmp : [Any] = []
            for k in self.vpnConnections! {
                tmp.append(k.toMap())
            }
            map["VpnConnections"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpnConnections") {
            var tmp : [DiagnoseVpnConnectionsResponseBody.VpnConnections] = []
            for v in dict["VpnConnections"] as! [Any] {
                var model = DiagnoseVpnConnectionsResponseBody.VpnConnections()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vpnConnections = tmp
        }
    }
}

public class DiagnoseVpnConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DiagnoseVpnConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DiagnoseVpnConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DiagnoseVpnGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var IPsecExtendInfo: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceType: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.IPsecExtendInfo != nil {
            map["IPsecExtendInfo"] = self.IPsecExtendInfo!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IPsecExtendInfo") {
            self.IPsecExtendInfo = dict["IPsecExtendInfo"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DiagnoseVpnGatewayResponseBody : Tea.TeaModel {
    public var diagnoseId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiagnoseId") {
            self.diagnoseId = dict["DiagnoseId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DiagnoseVpnGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DiagnoseVpnGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DiagnoseVpnGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableNatGatewayEcsMetricRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var natGatewayId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DisableNatGatewayEcsMetricResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableNatGatewayEcsMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableNatGatewayEcsMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableNatGatewayEcsMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableVpcClassicLinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DisableVpcClassicLinkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableVpcClassicLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableVpcClassicLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableVpcClassicLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DissociateRouteTableFromGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var gatewayId: String?

    public var gatewayType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayType != nil {
            map["GatewayType"] = self.gatewayType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! String
        }
        if dict.keys.contains("GatewayType") {
            self.gatewayType = dict["GatewayType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class DissociateRouteTableFromGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DissociateRouteTableFromGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateRouteTableFromGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DissociateRouteTableFromGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DissociateRouteTablesFromVpcGatewayEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableIds != nil {
            map["RouteTableIds"] = self.routeTableIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointId") {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableIds") {
            self.routeTableIds = dict["RouteTableIds"] as! [String]
        }
    }
}

public class DissociateRouteTablesFromVpcGatewayEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DissociateRouteTablesFromVpcGatewayEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateRouteTablesFromVpcGatewayEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DissociateRouteTablesFromVpcGatewayEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DissociateVpnGatewayWithCertificateRequest : Tea.TeaModel {
    public var certificateId: String?

    public var certificateType: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.certificateType != nil {
            map["CertificateType"] = self.certificateType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateId") {
            self.certificateId = dict["CertificateId"] as! String
        }
        if dict.keys.contains("CertificateType") {
            self.certificateType = dict["CertificateType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class DissociateVpnGatewayWithCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DissociateVpnGatewayWithCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateVpnGatewayWithCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DissociateVpnGatewayWithCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadVpnConnectionConfigRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class DownloadVpnConnectionConfigResponseBody : Tea.TeaModel {
    public class VpnConnectionConfig : Tea.TeaModel {
        public class IkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IkeAuthAlg") {
                    self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                }
                if dict.keys.contains("IkeEncAlg") {
                    self.ikeEncAlg = dict["IkeEncAlg"] as! String
                }
                if dict.keys.contains("IkeLifetime") {
                    self.ikeLifetime = dict["IkeLifetime"] as! Int64
                }
                if dict.keys.contains("IkeMode") {
                    self.ikeMode = dict["IkeMode"] as! String
                }
                if dict.keys.contains("IkePfs") {
                    self.ikePfs = dict["IkePfs"] as! String
                }
                if dict.keys.contains("IkeVersion") {
                    self.ikeVersion = dict["IkeVersion"] as! String
                }
                if dict.keys.contains("LocalId") {
                    self.localId = dict["LocalId"] as! String
                }
                if dict.keys.contains("Psk") {
                    self.psk = dict["Psk"] as! String
                }
                if dict.keys.contains("RemoteId") {
                    self.remoteId = dict["RemoteId"] as! String
                }
            }
        }
        public class IpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpsecAuthAlg") {
                    self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                }
                if dict.keys.contains("IpsecEncAlg") {
                    self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                }
                if dict.keys.contains("IpsecLifetime") {
                    self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
                }
                if dict.keys.contains("IpsecPfs") {
                    self.ipsecPfs = dict["IpsecPfs"] as! String
                }
            }
        }
        public class TunnelsConfig : Tea.TeaModel {
            public class TunnelConfig : Tea.TeaModel {
                public class IkeConfig : Tea.TeaModel {
                    public var ikeAuthAlg: String?

                    public var ikeEncAlg: String?

                    public var ikeLifetime: Int64?

                    public var ikeMode: String?

                    public var ikePfs: String?

                    public var ikeVersion: String?

                    public var localId: String?

                    public var psk: String?

                    public var remoteId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ikeAuthAlg != nil {
                            map["IkeAuthAlg"] = self.ikeAuthAlg!
                        }
                        if self.ikeEncAlg != nil {
                            map["IkeEncAlg"] = self.ikeEncAlg!
                        }
                        if self.ikeLifetime != nil {
                            map["IkeLifetime"] = self.ikeLifetime!
                        }
                        if self.ikeMode != nil {
                            map["IkeMode"] = self.ikeMode!
                        }
                        if self.ikePfs != nil {
                            map["IkePfs"] = self.ikePfs!
                        }
                        if self.ikeVersion != nil {
                            map["IkeVersion"] = self.ikeVersion!
                        }
                        if self.localId != nil {
                            map["LocalId"] = self.localId!
                        }
                        if self.psk != nil {
                            map["Psk"] = self.psk!
                        }
                        if self.remoteId != nil {
                            map["RemoteId"] = self.remoteId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IkeAuthAlg") {
                            self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                        }
                        if dict.keys.contains("IkeEncAlg") {
                            self.ikeEncAlg = dict["IkeEncAlg"] as! String
                        }
                        if dict.keys.contains("IkeLifetime") {
                            self.ikeLifetime = dict["IkeLifetime"] as! Int64
                        }
                        if dict.keys.contains("IkeMode") {
                            self.ikeMode = dict["IkeMode"] as! String
                        }
                        if dict.keys.contains("IkePfs") {
                            self.ikePfs = dict["IkePfs"] as! String
                        }
                        if dict.keys.contains("IkeVersion") {
                            self.ikeVersion = dict["IkeVersion"] as! String
                        }
                        if dict.keys.contains("LocalId") {
                            self.localId = dict["LocalId"] as! String
                        }
                        if dict.keys.contains("Psk") {
                            self.psk = dict["Psk"] as! String
                        }
                        if dict.keys.contains("RemoteId") {
                            self.remoteId = dict["RemoteId"] as! String
                        }
                    }
                }
                public class IpsecConfig : Tea.TeaModel {
                    public var ipsecAuthAlg: String?

                    public var ipsecEncAlg: String?

                    public var ipsecLifetime: Int64?

                    public var ipsecPfs: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipsecAuthAlg != nil {
                            map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                        }
                        if self.ipsecEncAlg != nil {
                            map["IpsecEncAlg"] = self.ipsecEncAlg!
                        }
                        if self.ipsecLifetime != nil {
                            map["IpsecLifetime"] = self.ipsecLifetime!
                        }
                        if self.ipsecPfs != nil {
                            map["IpsecPfs"] = self.ipsecPfs!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IpsecAuthAlg") {
                            self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                        }
                        if dict.keys.contains("IpsecEncAlg") {
                            self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                        }
                        if dict.keys.contains("IpsecLifetime") {
                            self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
                        }
                        if dict.keys.contains("IpsecPfs") {
                            self.ipsecPfs = dict["IpsecPfs"] as! String
                        }
                    }
                }
                public var ikeConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig.IkeConfig?

                public var ipsecConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig.IpsecConfig?

                public var local: String?

                public var remote: String?

                public var tunnelId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.ikeConfig?.validate()
                    try self.ipsecConfig?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ikeConfig != nil {
                        map["IkeConfig"] = self.ikeConfig?.toMap()
                    }
                    if self.ipsecConfig != nil {
                        map["IpsecConfig"] = self.ipsecConfig?.toMap()
                    }
                    if self.local != nil {
                        map["Local"] = self.local!
                    }
                    if self.remote != nil {
                        map["Remote"] = self.remote!
                    }
                    if self.tunnelId != nil {
                        map["TunnelId"] = self.tunnelId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IkeConfig") {
                        var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig.IkeConfig()
                        model.fromMap(dict["IkeConfig"] as! [String: Any])
                        self.ikeConfig = model
                    }
                    if dict.keys.contains("IpsecConfig") {
                        var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig.IpsecConfig()
                        model.fromMap(dict["IpsecConfig"] as! [String: Any])
                        self.ipsecConfig = model
                    }
                    if dict.keys.contains("Local") {
                        self.local = dict["Local"] as! String
                    }
                    if dict.keys.contains("Remote") {
                        self.remote = dict["Remote"] as! String
                    }
                    if dict.keys.contains("TunnelId") {
                        self.tunnelId = dict["TunnelId"] as! String
                    }
                }
            }
            public var tunnelConfig: [DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tunnelConfig != nil {
                    var tmp : [Any] = []
                    for k in self.tunnelConfig! {
                        tmp.append(k.toMap())
                    }
                    map["TunnelConfig"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TunnelConfig") {
                    var tmp : [DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig] = []
                    for v in dict["TunnelConfig"] as! [Any] {
                        var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tunnelConfig = tmp
                }
            }
        }
        public var ikeConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.IkeConfig?

        public var ipsecConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.IpsecConfig?

        public var local: String?

        public var localSubnet: String?

        public var remote: String?

        public var remoteSubnet: String?

        public var tunnelsConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ikeConfig?.validate()
            try self.ipsecConfig?.validate()
            try self.tunnelsConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ikeConfig != nil {
                map["IkeConfig"] = self.ikeConfig?.toMap()
            }
            if self.ipsecConfig != nil {
                map["IpsecConfig"] = self.ipsecConfig?.toMap()
            }
            if self.local != nil {
                map["Local"] = self.local!
            }
            if self.localSubnet != nil {
                map["LocalSubnet"] = self.localSubnet!
            }
            if self.remote != nil {
                map["Remote"] = self.remote!
            }
            if self.remoteSubnet != nil {
                map["RemoteSubnet"] = self.remoteSubnet!
            }
            if self.tunnelsConfig != nil {
                map["TunnelsConfig"] = self.tunnelsConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IkeConfig") {
                var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.IkeConfig()
                model.fromMap(dict["IkeConfig"] as! [String: Any])
                self.ikeConfig = model
            }
            if dict.keys.contains("IpsecConfig") {
                var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.IpsecConfig()
                model.fromMap(dict["IpsecConfig"] as! [String: Any])
                self.ipsecConfig = model
            }
            if dict.keys.contains("Local") {
                self.local = dict["Local"] as! String
            }
            if dict.keys.contains("LocalSubnet") {
                self.localSubnet = dict["LocalSubnet"] as! String
            }
            if dict.keys.contains("Remote") {
                self.remote = dict["Remote"] as! String
            }
            if dict.keys.contains("RemoteSubnet") {
                self.remoteSubnet = dict["RemoteSubnet"] as! String
            }
            if dict.keys.contains("TunnelsConfig") {
                var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig()
                model.fromMap(dict["TunnelsConfig"] as! [String: Any])
                self.tunnelsConfig = model
            }
        }
    }
    public var requestId: String?

    public var vpnConnectionConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnConnectionConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpnConnectionConfig != nil {
            map["VpnConnectionConfig"] = self.vpnConnectionConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpnConnectionConfig") {
            var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig()
            model.fromMap(dict["VpnConnectionConfig"] as! [String: Any])
            self.vpnConnectionConfig = model
        }
    }
}

public class DownloadVpnConnectionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadVpnConnectionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadVpnConnectionConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableNatGatewayEcsMetricRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var natGatewayId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class EnableNatGatewayEcsMetricResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableNatGatewayEcsMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableNatGatewayEcsMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableNatGatewayEcsMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnablePhysicalConnectionRequest : Tea.TeaModel {
    public var byPassSp: Bool?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.byPassSp != nil {
            map["ByPassSp"] = self.byPassSp!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ByPassSp") {
            self.byPassSp = dict["ByPassSp"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class EnablePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnablePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnablePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnablePhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableVpcClassicLinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class EnableVpcClassicLinkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableVpcClassicLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableVpcClassicLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableVpcClassicLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableVpcIpv4GatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv4GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableList != nil {
            map["RouteTableList"] = self.routeTableList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv4GatewayId") {
            self.ipv4GatewayId = dict["Ipv4GatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableList") {
            self.routeTableList = dict["RouteTableList"] as! [String]
        }
    }
}

public class EnableVpcIpv4GatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableVpcIpv4GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableVpcIpv4GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableVpcIpv4GatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDhcpOptionsSetRequest : Tea.TeaModel {
    public var dhcpOptionsSetId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetDhcpOptionsSetResponseBody : Tea.TeaModel {
    public class AssociateVpcs : Tea.TeaModel {
        public var associateStatus: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associateStatus != nil {
                map["AssociateStatus"] = self.associateStatus!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociateStatus") {
                self.associateStatus = dict["AssociateStatus"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public class DhcpOptions : Tea.TeaModel {
        public var domainName: String?

        public var domainNameServers: String?

        public var ipv6LeaseTime: String?

        public var leaseTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameServers != nil {
                map["DomainNameServers"] = self.domainNameServers!
            }
            if self.ipv6LeaseTime != nil {
                map["Ipv6LeaseTime"] = self.ipv6LeaseTime!
            }
            if self.leaseTime != nil {
                map["LeaseTime"] = self.leaseTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainNameServers") {
                self.domainNameServers = dict["DomainNameServers"] as! String
            }
            if dict.keys.contains("Ipv6LeaseTime") {
                self.ipv6LeaseTime = dict["Ipv6LeaseTime"] as! String
            }
            if dict.keys.contains("LeaseTime") {
                self.leaseTime = dict["LeaseTime"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var associateVpcs: [GetDhcpOptionsSetResponseBody.AssociateVpcs]?

    public var dhcpOptions: GetDhcpOptionsSetResponseBody.DhcpOptions?

    public var dhcpOptionsSetDescription: String?

    public var dhcpOptionsSetId: String?

    public var dhcpOptionsSetName: String?

    public var ownerId: Int64?

    public var requestId: String?

    public var resourceGroupId: String?

    public var status: String?

    public var tags: [GetDhcpOptionsSetResponseBody.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dhcpOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associateVpcs != nil {
            var tmp : [Any] = []
            for k in self.associateVpcs! {
                tmp.append(k.toMap())
            }
            map["AssociateVpcs"] = tmp
        }
        if self.dhcpOptions != nil {
            map["DhcpOptions"] = self.dhcpOptions?.toMap()
        }
        if self.dhcpOptionsSetDescription != nil {
            map["DhcpOptionsSetDescription"] = self.dhcpOptionsSetDescription!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dhcpOptionsSetName != nil {
            map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssociateVpcs") {
            var tmp : [GetDhcpOptionsSetResponseBody.AssociateVpcs] = []
            for v in dict["AssociateVpcs"] as! [Any] {
                var model = GetDhcpOptionsSetResponseBody.AssociateVpcs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.associateVpcs = tmp
        }
        if dict.keys.contains("DhcpOptions") {
            var model = GetDhcpOptionsSetResponseBody.DhcpOptions()
            model.fromMap(dict["DhcpOptions"] as! [String: Any])
            self.dhcpOptions = model
        }
        if dict.keys.contains("DhcpOptionsSetDescription") {
            self.dhcpOptionsSetDescription = dict["DhcpOptionsSetDescription"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetName") {
            self.dhcpOptionsSetName = dict["DhcpOptionsSetName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [GetDhcpOptionsSetResponseBody.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetDhcpOptionsSetResponseBody.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetDhcpOptionsSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDhcpOptionsSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDhcpOptionsSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFlowLogServiceStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetFlowLogServiceStatusResponseBody : Tea.TeaModel {
    public var enabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFlowLogServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFlowLogServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFlowLogServiceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIpv4GatewayAttributeRequest : Tea.TeaModel {
    public var ipv4GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv4GatewayId") {
            self.ipv4GatewayId = dict["Ipv4GatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetIpv4GatewayAttributeResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var createTime: String?

    public var enabled: Bool?

    public var ipv4GatewayDescription: String?

    public var ipv4GatewayId: String?

    public var ipv4GatewayName: String?

    public var ipv4GatewayRouteTableId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var status: String?

    public var tags: [GetIpv4GatewayAttributeResponseBody.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ipv4GatewayDescription != nil {
            map["Ipv4GatewayDescription"] = self.ipv4GatewayDescription!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ipv4GatewayName != nil {
            map["Ipv4GatewayName"] = self.ipv4GatewayName!
        }
        if self.ipv4GatewayRouteTableId != nil {
            map["Ipv4GatewayRouteTableId"] = self.ipv4GatewayRouteTableId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Ipv4GatewayDescription") {
            self.ipv4GatewayDescription = dict["Ipv4GatewayDescription"] as! String
        }
        if dict.keys.contains("Ipv4GatewayId") {
            self.ipv4GatewayId = dict["Ipv4GatewayId"] as! String
        }
        if dict.keys.contains("Ipv4GatewayName") {
            self.ipv4GatewayName = dict["Ipv4GatewayName"] as! String
        }
        if dict.keys.contains("Ipv4GatewayRouteTableId") {
            self.ipv4GatewayRouteTableId = dict["Ipv4GatewayRouteTableId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [GetIpv4GatewayAttributeResponseBody.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetIpv4GatewayAttributeResponseBody.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class GetIpv4GatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIpv4GatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetIpv4GatewayAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNatGatewayAttributeRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetNatGatewayAttributeResponseBody : Tea.TeaModel {
    public class AccessMode : Tea.TeaModel {
        public var modeValue: String?

        public var tunnelType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modeValue != nil {
                map["ModeValue"] = self.modeValue!
            }
            if self.tunnelType != nil {
                map["TunnelType"] = self.tunnelType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModeValue") {
                self.modeValue = dict["ModeValue"] as! String
            }
            if dict.keys.contains("TunnelType") {
                self.tunnelType = dict["TunnelType"] as! String
            }
        }
    }
    public class BillingConfig : Tea.TeaModel {
        public var autoPay: String?

        public var instanceChargeType: String?

        public var internetChargeType: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoPay != nil {
                map["AutoPay"] = self.autoPay!
            }
            if self.instanceChargeType != nil {
                map["InstanceChargeType"] = self.instanceChargeType!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoPay") {
                self.autoPay = dict["AutoPay"] as! String
            }
            if dict.keys.contains("InstanceChargeType") {
                self.instanceChargeType = dict["InstanceChargeType"] as! String
            }
            if dict.keys.contains("InternetChargeType") {
                self.internetChargeType = dict["InternetChargeType"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
        }
    }
    public class DeletionProtectionInfo : Tea.TeaModel {
        public var enabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
        }
    }
    public class ForwardTable : Tea.TeaModel {
        public var forwardEntryCount: Int32?

        public var forwardTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardEntryCount != nil {
                map["ForwardEntryCount"] = self.forwardEntryCount!
            }
            if self.forwardTableId != nil {
                map["ForwardTableId"] = self.forwardTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardEntryCount") {
                self.forwardEntryCount = dict["ForwardEntryCount"] as! Int32
            }
            if dict.keys.contains("ForwardTableId") {
                self.forwardTableId = dict["ForwardTableId"] as! String
            }
        }
    }
    public class FullNatTable : Tea.TeaModel {
        public var fullNatEntryCount: Int64?

        public var fullNatTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fullNatEntryCount != nil {
                map["FullNatEntryCount"] = self.fullNatEntryCount!
            }
            if self.fullNatTableId != nil {
                map["FullNatTableId"] = self.fullNatTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FullNatEntryCount") {
                self.fullNatEntryCount = dict["FullNatEntryCount"] as! Int64
            }
            if dict.keys.contains("FullNatTableId") {
                self.fullNatTableId = dict["FullNatTableId"] as! String
            }
        }
    }
    public class IpList : Tea.TeaModel {
        public var allocationId: String?

        public var ipAddress: String?

        public var usingStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocationId != nil {
                map["AllocationId"] = self.allocationId!
            }
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            if self.usingStatus != nil {
                map["UsingStatus"] = self.usingStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllocationId") {
                self.allocationId = dict["AllocationId"] as! String
            }
            if dict.keys.contains("IpAddress") {
                self.ipAddress = dict["IpAddress"] as! String
            }
            if dict.keys.contains("UsingStatus") {
                self.usingStatus = dict["UsingStatus"] as! String
            }
        }
    }
    public class LogDelivery : Tea.TeaModel {
        public var deliverLogsErrorMessage: String?

        public var deliveryStatus: String?

        public var logDeliveryType: String?

        public var logDestination: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deliverLogsErrorMessage != nil {
                map["DeliverLogsErrorMessage"] = self.deliverLogsErrorMessage!
            }
            if self.deliveryStatus != nil {
                map["DeliveryStatus"] = self.deliveryStatus!
            }
            if self.logDeliveryType != nil {
                map["LogDeliveryType"] = self.logDeliveryType!
            }
            if self.logDestination != nil {
                map["LogDestination"] = self.logDestination!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeliverLogsErrorMessage") {
                self.deliverLogsErrorMessage = dict["DeliverLogsErrorMessage"] as! String
            }
            if dict.keys.contains("DeliveryStatus") {
                self.deliveryStatus = dict["DeliveryStatus"] as! String
            }
            if dict.keys.contains("LogDeliveryType") {
                self.logDeliveryType = dict["LogDeliveryType"] as! String
            }
            if dict.keys.contains("LogDestination") {
                self.logDestination = dict["LogDestination"] as! String
            }
        }
    }
    public class PrivateInfo : Tea.TeaModel {
        public var eniInstanceId: String?

        public var izNo: String?

        public var maxBandwidth: Int32?

        public var privateIpAddress: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eniInstanceId != nil {
                map["EniInstanceId"] = self.eniInstanceId!
            }
            if self.izNo != nil {
                map["IzNo"] = self.izNo!
            }
            if self.maxBandwidth != nil {
                map["MaxBandwidth"] = self.maxBandwidth!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EniInstanceId") {
                self.eniInstanceId = dict["EniInstanceId"] as! String
            }
            if dict.keys.contains("IzNo") {
                self.izNo = dict["IzNo"] as! String
            }
            if dict.keys.contains("MaxBandwidth") {
                self.maxBandwidth = dict["MaxBandwidth"] as! Int32
            }
            if dict.keys.contains("PrivateIpAddress") {
                self.privateIpAddress = dict["PrivateIpAddress"] as! String
            }
            if dict.keys.contains("VswitchId") {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public class SnatTable : Tea.TeaModel {
        public var snatEntryCount: Int32?

        public var snatTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snatEntryCount != nil {
                map["SnatEntryCount"] = self.snatEntryCount!
            }
            if self.snatTableId != nil {
                map["SnatTableId"] = self.snatTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnatEntryCount") {
                self.snatEntryCount = dict["SnatEntryCount"] as! Int32
            }
            if dict.keys.contains("SnatTableId") {
                self.snatTableId = dict["SnatTableId"] as! String
            }
        }
    }
    public var accessMode: GetNatGatewayAttributeResponseBody.AccessMode?

    public var billingConfig: GetNatGatewayAttributeResponseBody.BillingConfig?

    public var businessStatus: String?

    public var creationTime: String?

    public var deletionProtectionInfo: GetNatGatewayAttributeResponseBody.DeletionProtectionInfo?

    public var description_: String?

    public var ecsMetricEnabled: Bool?

    public var enableSessionLog: Bool?

    public var expiredTime: String?

    public var forwardTable: GetNatGatewayAttributeResponseBody.ForwardTable?

    public var fullNatTable: GetNatGatewayAttributeResponseBody.FullNatTable?

    public var ipList: [GetNatGatewayAttributeResponseBody.IpList]?

    public var logDelivery: GetNatGatewayAttributeResponseBody.LogDelivery?

    public var name: String?

    public var natGatewayId: String?

    public var natType: String?

    public var networkType: String?

    public var privateInfo: GetNatGatewayAttributeResponseBody.PrivateInfo?

    public var privateLinkEnabled: Bool?

    public var privateLinkMode: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var snatTable: GetNatGatewayAttributeResponseBody.SnatTable?

    public var status: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessMode?.validate()
        try self.billingConfig?.validate()
        try self.deletionProtectionInfo?.validate()
        try self.forwardTable?.validate()
        try self.fullNatTable?.validate()
        try self.logDelivery?.validate()
        try self.privateInfo?.validate()
        try self.snatTable?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode?.toMap()
        }
        if self.billingConfig != nil {
            map["BillingConfig"] = self.billingConfig?.toMap()
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.deletionProtectionInfo != nil {
            map["DeletionProtectionInfo"] = self.deletionProtectionInfo?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ecsMetricEnabled != nil {
            map["EcsMetricEnabled"] = self.ecsMetricEnabled!
        }
        if self.enableSessionLog != nil {
            map["EnableSessionLog"] = self.enableSessionLog!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.forwardTable != nil {
            map["ForwardTable"] = self.forwardTable?.toMap()
        }
        if self.fullNatTable != nil {
            map["FullNatTable"] = self.fullNatTable?.toMap()
        }
        if self.ipList != nil {
            var tmp : [Any] = []
            for k in self.ipList! {
                tmp.append(k.toMap())
            }
            map["IpList"] = tmp
        }
        if self.logDelivery != nil {
            map["LogDelivery"] = self.logDelivery?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.privateInfo != nil {
            map["PrivateInfo"] = self.privateInfo?.toMap()
        }
        if self.privateLinkEnabled != nil {
            map["PrivateLinkEnabled"] = self.privateLinkEnabled!
        }
        if self.privateLinkMode != nil {
            map["PrivateLinkMode"] = self.privateLinkMode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.snatTable != nil {
            map["SnatTable"] = self.snatTable?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            var model = GetNatGatewayAttributeResponseBody.AccessMode()
            model.fromMap(dict["AccessMode"] as! [String: Any])
            self.accessMode = model
        }
        if dict.keys.contains("BillingConfig") {
            var model = GetNatGatewayAttributeResponseBody.BillingConfig()
            model.fromMap(dict["BillingConfig"] as! [String: Any])
            self.billingConfig = model
        }
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("DeletionProtectionInfo") {
            var model = GetNatGatewayAttributeResponseBody.DeletionProtectionInfo()
            model.fromMap(dict["DeletionProtectionInfo"] as! [String: Any])
            self.deletionProtectionInfo = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EcsMetricEnabled") {
            self.ecsMetricEnabled = dict["EcsMetricEnabled"] as! Bool
        }
        if dict.keys.contains("EnableSessionLog") {
            self.enableSessionLog = dict["EnableSessionLog"] as! Bool
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("ForwardTable") {
            var model = GetNatGatewayAttributeResponseBody.ForwardTable()
            model.fromMap(dict["ForwardTable"] as! [String: Any])
            self.forwardTable = model
        }
        if dict.keys.contains("FullNatTable") {
            var model = GetNatGatewayAttributeResponseBody.FullNatTable()
            model.fromMap(dict["FullNatTable"] as! [String: Any])
            self.fullNatTable = model
        }
        if dict.keys.contains("IpList") {
            var tmp : [GetNatGatewayAttributeResponseBody.IpList] = []
            for v in dict["IpList"] as! [Any] {
                var model = GetNatGatewayAttributeResponseBody.IpList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipList = tmp
        }
        if dict.keys.contains("LogDelivery") {
            var model = GetNatGatewayAttributeResponseBody.LogDelivery()
            model.fromMap(dict["LogDelivery"] as! [String: Any])
            self.logDelivery = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatType") {
            self.natType = dict["NatType"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("PrivateInfo") {
            var model = GetNatGatewayAttributeResponseBody.PrivateInfo()
            model.fromMap(dict["PrivateInfo"] as! [String: Any])
            self.privateInfo = model
        }
        if dict.keys.contains("PrivateLinkEnabled") {
            self.privateLinkEnabled = dict["PrivateLinkEnabled"] as! Bool
        }
        if dict.keys.contains("PrivateLinkMode") {
            self.privateLinkMode = dict["PrivateLinkMode"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SnatTable") {
            var model = GetNatGatewayAttributeResponseBody.SnatTable()
            model.fromMap(dict["SnatTable"] as! [String: Any])
            self.snatTable = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class GetNatGatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNatGatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNatGatewayAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPhysicalConnectionServiceStatusRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetPhysicalConnectionServiceStatusResponseBody : Tea.TeaModel {
    public var enabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPhysicalConnectionServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPhysicalConnectionServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPhysicalConnectionServiceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPublicIpAddressPoolServiceStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetPublicIpAddressPoolServiceStatusResponseBody : Tea.TeaModel {
    public var enabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPublicIpAddressPoolServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPublicIpAddressPoolServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPublicIpAddressPoolServiceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTrafficMirrorServiceStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetTrafficMirrorServiceStatusResponseBody : Tea.TeaModel {
    public var enabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTrafficMirrorServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTrafficMirrorServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTrafficMirrorServiceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVSwitchCidrReservationUsageRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchCidrReservationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchCidrReservationId != nil {
            map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchCidrReservationId") {
            self.vSwitchCidrReservationId = dict["VSwitchCidrReservationId"] as! String
        }
    }
}

public class GetVSwitchCidrReservationUsageResponseBody : Tea.TeaModel {
    public class CidrReservationUsages : Tea.TeaModel {
        public var ipPrefixCidr: String?

        public var ipPrefixId: String?

        public var resourceId: String?

        public var resourceType: String?

        public var vSwitchCidrReservationId: String?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipPrefixCidr != nil {
                map["IpPrefixCidr"] = self.ipPrefixCidr!
            }
            if self.ipPrefixId != nil {
                map["IpPrefixId"] = self.ipPrefixId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.vSwitchCidrReservationId != nil {
                map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpPrefixCidr") {
                self.ipPrefixCidr = dict["IpPrefixCidr"] as! String
            }
            if dict.keys.contains("IpPrefixId") {
                self.ipPrefixId = dict["IpPrefixId"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("VSwitchCidrReservationId") {
                self.vSwitchCidrReservationId = dict["VSwitchCidrReservationId"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public var cidrReservationUsages: [GetVSwitchCidrReservationUsageResponseBody.CidrReservationUsages]?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrReservationUsages != nil {
            var tmp : [Any] = []
            for k in self.cidrReservationUsages! {
                tmp.append(k.toMap())
            }
            map["CidrReservationUsages"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrReservationUsages") {
            var tmp : [GetVSwitchCidrReservationUsageResponseBody.CidrReservationUsages] = []
            for v in dict["CidrReservationUsages"] as! [Any] {
                var model = GetVSwitchCidrReservationUsageResponseBody.CidrReservationUsages()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cidrReservationUsages = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class GetVSwitchCidrReservationUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVSwitchCidrReservationUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVSwitchCidrReservationUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVpcGatewayEndpointAttributeRequest : Tea.TeaModel {
    public var endpointId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointId") {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetVpcGatewayEndpointAttributeResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var creationTime: String?

    public var endpointDescription: String?

    public var endpointId: String?

    public var endpointName: String?

    public var endpointStatus: String?

    public var policyDocument: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var routeTables: [String]?

    public var serviceName: String?

    public var tags: [GetVpcGatewayEndpointAttributeResponseBody.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.endpointDescription != nil {
            map["EndpointDescription"] = self.endpointDescription!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.endpointStatus != nil {
            map["EndpointStatus"] = self.endpointStatus!
        }
        if self.policyDocument != nil {
            map["PolicyDocument"] = self.policyDocument!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.routeTables != nil {
            map["RouteTables"] = self.routeTables!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("EndpointDescription") {
            self.endpointDescription = dict["EndpointDescription"] as! String
        }
        if dict.keys.contains("EndpointId") {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("EndpointName") {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("EndpointStatus") {
            self.endpointStatus = dict["EndpointStatus"] as! String
        }
        if dict.keys.contains("PolicyDocument") {
            self.policyDocument = dict["PolicyDocument"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RouteTables") {
            self.routeTables = dict["RouteTables"] as! [String]
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [GetVpcGatewayEndpointAttributeResponseBody.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetVpcGatewayEndpointAttributeResponseBody.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class GetVpcGatewayEndpointAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpcGatewayEndpointAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVpcGatewayEndpointAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVpcPrefixListAssociationsRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetVpcPrefixListAssociationsResponseBody : Tea.TeaModel {
    public class PrefixListAssociation : Tea.TeaModel {
        public var ownerId: String?

        public var prefixListId: String?

        public var reason: String?

        public var regionId: String?

        public var resourceId: String?

        public var resourceType: String?

        public var resourceUid: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.prefixListId != nil {
                map["PrefixListId"] = self.prefixListId!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.resourceUid != nil {
                map["ResourceUid"] = self.resourceUid!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! String
            }
            if dict.keys.contains("PrefixListId") {
                self.prefixListId = dict["PrefixListId"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("ResourceUid") {
                self.resourceUid = dict["ResourceUid"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var count: Int64?

    public var nextToken: String?

    public var prefixListAssociation: [GetVpcPrefixListAssociationsResponseBody.PrefixListAssociation]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixListAssociation != nil {
            var tmp : [Any] = []
            for k in self.prefixListAssociation! {
                tmp.append(k.toMap())
            }
            map["PrefixListAssociation"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PrefixListAssociation") {
            var tmp : [GetVpcPrefixListAssociationsResponseBody.PrefixListAssociation] = []
            for v in dict["PrefixListAssociation"] as! [Any] {
                var model = GetVpcPrefixListAssociationsResponseBody.PrefixListAssociation()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.prefixListAssociation = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class GetVpcPrefixListAssociationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpcPrefixListAssociationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVpcPrefixListAssociationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVpcPrefixListEntriesRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetVpcPrefixListEntriesResponseBody : Tea.TeaModel {
    public class PrefixListEntry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public var prefixListId: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.prefixListId != nil {
                map["PrefixListId"] = self.prefixListId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cidr") {
                self.cidr = dict["Cidr"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("PrefixListId") {
                self.prefixListId = dict["PrefixListId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var count: Int64?

    public var nextToken: String?

    public var prefixListEntry: [GetVpcPrefixListEntriesResponseBody.PrefixListEntry]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixListEntry != nil {
            var tmp : [Any] = []
            for k in self.prefixListEntry! {
                tmp.append(k.toMap())
            }
            map["PrefixListEntry"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PrefixListEntry") {
            var tmp : [GetVpcPrefixListEntriesResponseBody.PrefixListEntry] = []
            for v in dict["PrefixListEntry"] as! [Any] {
                var model = GetVpcPrefixListEntriesResponseBody.PrefixListEntry()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.prefixListEntry = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class GetVpcPrefixListEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpcPrefixListEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVpcPrefixListEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVpcRouteEntrySummaryRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryType: String?

    public var routeTableId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntryType") {
            self.routeEntryType = dict["RouteEntryType"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class GetVpcRouteEntrySummaryResponseBody : Tea.TeaModel {
    public class RouteEntrySummarys : Tea.TeaModel {
        public class EntrySummarys : Tea.TeaModel {
            public var count: Int32?

            public var routeEntryType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.routeEntryType != nil {
                    map["RouteEntryType"] = self.routeEntryType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("RouteEntryType") {
                    self.routeEntryType = dict["RouteEntryType"] as! String
                }
            }
        }
        public var entrySummarys: [GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys.EntrySummarys]?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entrySummarys != nil {
                var tmp : [Any] = []
                for k in self.entrySummarys! {
                    tmp.append(k.toMap())
                }
                map["EntrySummarys"] = tmp
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EntrySummarys") {
                var tmp : [GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys.EntrySummarys] = []
                for v in dict["EntrySummarys"] as! [Any] {
                    var model = GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys.EntrySummarys()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entrySummarys = tmp
            }
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! String
            }
        }
    }
    public var requestId: String?

    public var routeEntrySummarys: [GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntrySummarys != nil {
            var tmp : [Any] = []
            for k in self.routeEntrySummarys! {
                tmp.append(k.toMap())
            }
            map["RouteEntrySummarys"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntrySummarys") {
            var tmp : [GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys] = []
            for v in dict["RouteEntrySummarys"] as! [Any] {
                var model = GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeEntrySummarys = tmp
        }
    }
}

public class GetVpcRouteEntrySummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpcRouteEntrySummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVpcRouteEntrySummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVpnGatewayDiagnoseResultRequest : Tea.TeaModel {
    public var clientToken: String?

    public var diagnoseId: String?

    public var regionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DiagnoseId") {
            self.diagnoseId = dict["DiagnoseId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class GetVpnGatewayDiagnoseResultResponseBody : Tea.TeaModel {
    public class DiagnoseResult : Tea.TeaModel {
        public var diagnoseName: String?

        public var diagnoseResultDescription: String?

        public var diagnoseResultLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diagnoseName != nil {
                map["DiagnoseName"] = self.diagnoseName!
            }
            if self.diagnoseResultDescription != nil {
                map["DiagnoseResultDescription"] = self.diagnoseResultDescription!
            }
            if self.diagnoseResultLevel != nil {
                map["DiagnoseResultLevel"] = self.diagnoseResultLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiagnoseName") {
                self.diagnoseName = dict["DiagnoseName"] as! String
            }
            if dict.keys.contains("DiagnoseResultDescription") {
                self.diagnoseResultDescription = dict["DiagnoseResultDescription"] as! String
            }
            if dict.keys.contains("DiagnoseResultLevel") {
                self.diagnoseResultLevel = dict["DiagnoseResultLevel"] as! String
            }
        }
    }
    public var beginTime: String?

    public var diagnoseId: String?

    public var diagnoseResult: [GetVpnGatewayDiagnoseResultResponseBody.DiagnoseResult]?

    public var finishTime: String?

    public var finishedCount: Int32?

    public var requestId: String?

    public var resourceInstanceId: String?

    public var resourceType: String?

    public var totalCount: Int32?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.diagnoseResult != nil {
            var tmp : [Any] = []
            for k in self.diagnoseResult! {
                tmp.append(k.toMap())
            }
            map["DiagnoseResult"] = tmp
        }
        if self.finishTime != nil {
            map["FinishTime"] = self.finishTime!
        }
        if self.finishedCount != nil {
            map["FinishedCount"] = self.finishedCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceInstanceId != nil {
            map["ResourceInstanceId"] = self.resourceInstanceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") {
            self.beginTime = dict["BeginTime"] as! String
        }
        if dict.keys.contains("DiagnoseId") {
            self.diagnoseId = dict["DiagnoseId"] as! String
        }
        if dict.keys.contains("DiagnoseResult") {
            var tmp : [GetVpnGatewayDiagnoseResultResponseBody.DiagnoseResult] = []
            for v in dict["DiagnoseResult"] as! [Any] {
                var model = GetVpnGatewayDiagnoseResultResponseBody.DiagnoseResult()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.diagnoseResult = tmp
        }
        if dict.keys.contains("FinishTime") {
            self.finishTime = dict["FinishTime"] as! String
        }
        if dict.keys.contains("FinishedCount") {
            self.finishedCount = dict["FinishedCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceInstanceId") {
            self.resourceInstanceId = dict["ResourceInstanceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class GetVpnGatewayDiagnoseResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpnGatewayDiagnoseResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVpnGatewayDiagnoseResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantInstanceToCenRequest : Tea.TeaModel {
    public var cenId: String?

    public var cenOwnerId: Int64?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.cenOwnerId != nil {
            map["CenOwnerId"] = self.cenOwnerId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CenId") {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("CenOwnerId") {
            self.cenOwnerId = dict["CenOwnerId"] as! Int64
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GrantInstanceToCenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GrantInstanceToCenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantInstanceToCenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GrantInstanceToCenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantInstanceToVbrRequest : Tea.TeaModel {
    public var grantType: String?

    public var instanceId: String?

    public var regionId: String?

    public var vbrInstanceIds: [String]?

    public var vbrOwnerUid: Int64?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grantType != nil {
            map["GrantType"] = self.grantType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vbrInstanceIds != nil {
            map["VbrInstanceIds"] = self.vbrInstanceIds!
        }
        if self.vbrOwnerUid != nil {
            map["VbrOwnerUid"] = self.vbrOwnerUid!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GrantType") {
            self.grantType = dict["GrantType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VbrInstanceIds") {
            self.vbrInstanceIds = dict["VbrInstanceIds"] as! [String]
        }
        if dict.keys.contains("VbrOwnerUid") {
            self.vbrOwnerUid = dict["VbrOwnerUid"] as! Int64
        }
        if dict.keys.contains("VbrRegionNo") {
            self.vbrRegionNo = dict["VbrRegionNo"] as! String
        }
    }
}

public class GrantInstanceToVbrShrinkRequest : Tea.TeaModel {
    public var grantType: String?

    public var instanceId: String?

    public var regionId: String?

    public var vbrInstanceIdsShrink: String?

    public var vbrOwnerUid: Int64?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grantType != nil {
            map["GrantType"] = self.grantType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vbrInstanceIdsShrink != nil {
            map["VbrInstanceIds"] = self.vbrInstanceIdsShrink!
        }
        if self.vbrOwnerUid != nil {
            map["VbrOwnerUid"] = self.vbrOwnerUid!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GrantType") {
            self.grantType = dict["GrantType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VbrInstanceIds") {
            self.vbrInstanceIdsShrink = dict["VbrInstanceIds"] as! String
        }
        if dict.keys.contains("VbrOwnerUid") {
            self.vbrOwnerUid = dict["VbrOwnerUid"] as! Int64
        }
        if dict.keys.contains("VbrRegionNo") {
            self.vbrRegionNo = dict["VbrRegionNo"] as! String
        }
    }
}

public class GrantInstanceToVbrResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GrantInstanceToVbrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantInstanceToVbrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GrantInstanceToVbrResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBusinessAccessPointsRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListBusinessAccessPointsResponseBody : Tea.TeaModel {
    public class BusinessAccessPoints : Tea.TeaModel {
        public var accessPointId: String?

        public var accessPointName: String?

        public var cloudBoxInstanceIds: String?

        public var latitude: Double?

        public var longitude: Double?

        public var supportLineOperator: String?

        public var supportPortTypes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointId != nil {
                map["AccessPointId"] = self.accessPointId!
            }
            if self.accessPointName != nil {
                map["AccessPointName"] = self.accessPointName!
            }
            if self.cloudBoxInstanceIds != nil {
                map["CloudBoxInstanceIds"] = self.cloudBoxInstanceIds!
            }
            if self.latitude != nil {
                map["Latitude"] = self.latitude!
            }
            if self.longitude != nil {
                map["Longitude"] = self.longitude!
            }
            if self.supportLineOperator != nil {
                map["SupportLineOperator"] = self.supportLineOperator!
            }
            if self.supportPortTypes != nil {
                map["SupportPortTypes"] = self.supportPortTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessPointId") {
                self.accessPointId = dict["AccessPointId"] as! String
            }
            if dict.keys.contains("AccessPointName") {
                self.accessPointName = dict["AccessPointName"] as! String
            }
            if dict.keys.contains("CloudBoxInstanceIds") {
                self.cloudBoxInstanceIds = dict["CloudBoxInstanceIds"] as! String
            }
            if dict.keys.contains("Latitude") {
                self.latitude = dict["Latitude"] as! Double
            }
            if dict.keys.contains("Longitude") {
                self.longitude = dict["Longitude"] as! Double
            }
            if dict.keys.contains("SupportLineOperator") {
                self.supportLineOperator = dict["SupportLineOperator"] as! String
            }
            if dict.keys.contains("SupportPortTypes") {
                self.supportPortTypes = dict["SupportPortTypes"] as! String
            }
        }
    }
    public var businessAccessPoints: [ListBusinessAccessPointsResponseBody.BusinessAccessPoints]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessAccessPoints != nil {
            var tmp : [Any] = []
            for k in self.businessAccessPoints! {
                tmp.append(k.toMap())
            }
            map["BusinessAccessPoints"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessAccessPoints") {
            var tmp : [ListBusinessAccessPointsResponseBody.BusinessAccessPoints] = []
            for v in dict["BusinessAccessPoints"] as! [Any] {
                var model = ListBusinessAccessPointsResponseBody.BusinessAccessPoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.businessAccessPoints = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListBusinessAccessPointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBusinessAccessPointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBusinessAccessPointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDhcpOptionsSetsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dhcpOptionsSetId: [String]?

    public var dhcpOptionsSetName: String?

    public var domainName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListDhcpOptionsSetsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dhcpOptionsSetName != nil {
            map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! [String]
        }
        if dict.keys.contains("DhcpOptionsSetName") {
            self.dhcpOptionsSetName = dict["DhcpOptionsSetName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListDhcpOptionsSetsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListDhcpOptionsSetsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListDhcpOptionsSetsResponseBody : Tea.TeaModel {
    public class DhcpOptionsSets : Tea.TeaModel {
        public class DhcpOptions : Tea.TeaModel {
            public var domainName: String?

            public var domainNameServers: String?

            public var ipv6LeaseTime: String?

            public var leaseTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainNameServers != nil {
                    map["DomainNameServers"] = self.domainNameServers!
                }
                if self.ipv6LeaseTime != nil {
                    map["Ipv6LeaseTime"] = self.ipv6LeaseTime!
                }
                if self.leaseTime != nil {
                    map["LeaseTime"] = self.leaseTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainNameServers") {
                    self.domainNameServers = dict["DomainNameServers"] as! String
                }
                if dict.keys.contains("Ipv6LeaseTime") {
                    self.ipv6LeaseTime = dict["Ipv6LeaseTime"] as! String
                }
                if dict.keys.contains("LeaseTime") {
                    self.leaseTime = dict["LeaseTime"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var associateVpcCount: Int32?

        public var dhcpOptions: ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.DhcpOptions?

        public var dhcpOptionsSetDescription: String?

        public var dhcpOptionsSetId: String?

        public var dhcpOptionsSetName: String?

        public var ownerId: Int64?

        public var resourceGroupId: String?

        public var status: String?

        public var tags: [ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dhcpOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associateVpcCount != nil {
                map["AssociateVpcCount"] = self.associateVpcCount!
            }
            if self.dhcpOptions != nil {
                map["DhcpOptions"] = self.dhcpOptions?.toMap()
            }
            if self.dhcpOptionsSetDescription != nil {
                map["DhcpOptionsSetDescription"] = self.dhcpOptionsSetDescription!
            }
            if self.dhcpOptionsSetId != nil {
                map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
            }
            if self.dhcpOptionsSetName != nil {
                map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociateVpcCount") {
                self.associateVpcCount = dict["AssociateVpcCount"] as! Int32
            }
            if dict.keys.contains("DhcpOptions") {
                var model = ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.DhcpOptions()
                model.fromMap(dict["DhcpOptions"] as! [String: Any])
                self.dhcpOptions = model
            }
            if dict.keys.contains("DhcpOptionsSetDescription") {
                self.dhcpOptionsSetDescription = dict["DhcpOptionsSetDescription"] as! String
            }
            if dict.keys.contains("DhcpOptionsSetId") {
                self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
            }
            if dict.keys.contains("DhcpOptionsSetName") {
                self.dhcpOptionsSetName = dict["DhcpOptionsSetName"] as! String
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! Int64
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var dhcpOptionsSets: [ListDhcpOptionsSetsResponseBody.DhcpOptionsSets]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSets != nil {
            var tmp : [Any] = []
            for k in self.dhcpOptionsSets! {
                tmp.append(k.toMap())
            }
            map["DhcpOptionsSets"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DhcpOptionsSets") {
            var tmp : [ListDhcpOptionsSetsResponseBody.DhcpOptionsSets] = []
            for v in dict["DhcpOptionsSets"] as! [Any] {
                var model = ListDhcpOptionsSetsResponseBody.DhcpOptionsSets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dhcpOptionsSets = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListDhcpOptionsSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDhcpOptionsSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDhcpOptionsSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEnhanhcedNatGatewayAvailableZonesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var filter: [ListEnhanhcedNatGatewayAvailableZonesRequest.Filter]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Filter") {
            var tmp : [ListEnhanhcedNatGatewayAvailableZonesRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = ListEnhanhcedNatGatewayAvailableZonesRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListEnhanhcedNatGatewayAvailableZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public var localName: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LocalName") {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var requestId: String?

    public var zones: [ListEnhanhcedNatGatewayAvailableZonesResponseBody.Zones]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            var tmp : [Any] = []
            for k in self.zones! {
                tmp.append(k.toMap())
            }
            map["Zones"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Zones") {
            var tmp : [ListEnhanhcedNatGatewayAvailableZonesResponseBody.Zones] = []
            for v in dict["Zones"] as! [Any] {
                var model = ListEnhanhcedNatGatewayAvailableZonesResponseBody.Zones()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.zones = tmp
        }
    }
}

public class ListEnhanhcedNatGatewayAvailableZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnhanhcedNatGatewayAvailableZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEnhanhcedNatGatewayAvailableZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFullNatEntriesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var fullNatEntryId: String?

    public var fullNatEntryNames: [String]?

    public var fullNatTableId: String?

    public var ipProtocol: String?

    public var maxResults: Int64?

    public var natGatewayId: String?

    public var natIp: String?

    public var natIpPort: String?

    public var networkInterfaceIds: [String]?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.fullNatEntryId != nil {
            map["FullNatEntryId"] = self.fullNatEntryId!
        }
        if self.fullNatEntryNames != nil {
            map["FullNatEntryNames"] = self.fullNatEntryNames!
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpPort != nil {
            map["NatIpPort"] = self.natIpPort!
        }
        if self.networkInterfaceIds != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIds!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("FullNatEntryId") {
            self.fullNatEntryId = dict["FullNatEntryId"] as! String
        }
        if dict.keys.contains("FullNatEntryNames") {
            self.fullNatEntryNames = dict["FullNatEntryNames"] as! [String]
        }
        if dict.keys.contains("FullNatTableId") {
            self.fullNatTableId = dict["FullNatTableId"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatIp") {
            self.natIp = dict["NatIp"] as! String
        }
        if dict.keys.contains("NatIpPort") {
            self.natIpPort = dict["NatIpPort"] as! String
        }
        if dict.keys.contains("NetworkInterfaceIds") {
            self.networkInterfaceIds = dict["NetworkInterfaceIds"] as! [String]
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListFullNatEntriesResponseBody : Tea.TeaModel {
    public class FullNatEntries : Tea.TeaModel {
        public var accessIp: String?

        public var accessPort: String?

        public var creationTime: String?

        public var fullNatEntryDescription: String?

        public var fullNatEntryId: String?

        public var fullNatEntryName: String?

        public var fullNatEntryStatus: String?

        public var fullNatTableId: String?

        public var ipProtocol: String?

        public var natIp: String?

        public var natIpPort: String?

        public var networkInterfaceId: String?

        public var networkInterfaceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessIp != nil {
                map["AccessIp"] = self.accessIp!
            }
            if self.accessPort != nil {
                map["AccessPort"] = self.accessPort!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fullNatEntryDescription != nil {
                map["FullNatEntryDescription"] = self.fullNatEntryDescription!
            }
            if self.fullNatEntryId != nil {
                map["FullNatEntryId"] = self.fullNatEntryId!
            }
            if self.fullNatEntryName != nil {
                map["FullNatEntryName"] = self.fullNatEntryName!
            }
            if self.fullNatEntryStatus != nil {
                map["FullNatEntryStatus"] = self.fullNatEntryStatus!
            }
            if self.fullNatTableId != nil {
                map["FullNatTableId"] = self.fullNatTableId!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.natIp != nil {
                map["NatIp"] = self.natIp!
            }
            if self.natIpPort != nil {
                map["NatIpPort"] = self.natIpPort!
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.networkInterfaceType != nil {
                map["NetworkInterfaceType"] = self.networkInterfaceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessIp") {
                self.accessIp = dict["AccessIp"] as! String
            }
            if dict.keys.contains("AccessPort") {
                self.accessPort = dict["AccessPort"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FullNatEntryDescription") {
                self.fullNatEntryDescription = dict["FullNatEntryDescription"] as! String
            }
            if dict.keys.contains("FullNatEntryId") {
                self.fullNatEntryId = dict["FullNatEntryId"] as! String
            }
            if dict.keys.contains("FullNatEntryName") {
                self.fullNatEntryName = dict["FullNatEntryName"] as! String
            }
            if dict.keys.contains("FullNatEntryStatus") {
                self.fullNatEntryStatus = dict["FullNatEntryStatus"] as! String
            }
            if dict.keys.contains("FullNatTableId") {
                self.fullNatTableId = dict["FullNatTableId"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("NatIp") {
                self.natIp = dict["NatIp"] as! String
            }
            if dict.keys.contains("NatIpPort") {
                self.natIpPort = dict["NatIpPort"] as! String
            }
            if dict.keys.contains("NetworkInterfaceId") {
                self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
            }
            if dict.keys.contains("NetworkInterfaceType") {
                self.networkInterfaceType = dict["NetworkInterfaceType"] as! String
            }
        }
    }
    public var fullNatEntries: [ListFullNatEntriesResponseBody.FullNatEntries]?

    public var fullNatTableId: String?

    public var maxResults: Int64?

    public var natGatewayId: String?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fullNatEntries != nil {
            var tmp : [Any] = []
            for k in self.fullNatEntries! {
                tmp.append(k.toMap())
            }
            map["FullNatEntries"] = tmp
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FullNatEntries") {
            var tmp : [ListFullNatEntriesResponseBody.FullNatEntries] = []
            for v in dict["FullNatEntries"] as! [Any] {
                var model = ListFullNatEntriesResponseBody.FullNatEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fullNatEntries = tmp
        }
        if dict.keys.contains("FullNatTableId") {
            self.fullNatTableId = dict["FullNatTableId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListFullNatEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFullNatEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFullNatEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayRouteTableEntriesRequest : Tea.TeaModel {
    public var destinationCidrBlock: String?

    public var gatewayRouteTableId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.gatewayRouteTableId != nil {
            map["GatewayRouteTableId"] = self.gatewayRouteTableId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("GatewayRouteTableId") {
            self.gatewayRouteTableId = dict["GatewayRouteTableId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListGatewayRouteTableEntriesResponseBody : Tea.TeaModel {
    public class GatewayRouteEntryModels : Tea.TeaModel {
        public class NextHops : Tea.TeaModel {
            public var enabled: String?

            public var nextHopId: String?

            public var nextHopType: String?

            public var weight: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.nextHopId != nil {
                    map["NextHopId"] = self.nextHopId!
                }
                if self.nextHopType != nil {
                    map["NextHopType"] = self.nextHopType!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! String
                }
                if dict.keys.contains("NextHopId") {
                    self.nextHopId = dict["NextHopId"] as! String
                }
                if dict.keys.contains("NextHopType") {
                    self.nextHopType = dict["NextHopType"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! String
                }
            }
        }
        public var description_: String?

        public var destinationCidrBlock: String?

        public var name: String?

        public var nextHopId: String?

        public var nextHopType: String?

        public var nextHops: [ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels.NextHops]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            if self.nextHops != nil {
                var tmp : [Any] = []
                for k in self.nextHops! {
                    tmp.append(k.toMap())
                }
                map["NextHops"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NextHopId") {
                self.nextHopId = dict["NextHopId"] as! String
            }
            if dict.keys.contains("NextHopType") {
                self.nextHopType = dict["NextHopType"] as! String
            }
            if dict.keys.contains("NextHops") {
                var tmp : [ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels.NextHops] = []
                for v in dict["NextHops"] as! [Any] {
                    var model = ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels.NextHops()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nextHops = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var gatewayRouteEntryModels: [ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gatewayRouteEntryModels != nil {
            var tmp : [Any] = []
            for k in self.gatewayRouteEntryModels! {
                tmp.append(k.toMap())
            }
            map["GatewayRouteEntryModels"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GatewayRouteEntryModels") {
            var tmp : [ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels] = []
            for v in dict["GatewayRouteEntryModels"] as! [Any] {
                var model = ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.gatewayRouteEntryModels = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListGatewayRouteTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayRouteTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayRouteTableEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGeographicSubRegionsResponseBody : Tea.TeaModel {
    public var count: Int64?

    public var geographicSubRegions: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.geographicSubRegions != nil {
            map["GeographicSubRegions"] = self.geographicSubRegions!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int64
        }
        if dict.keys.contains("GeographicSubRegions") {
            self.geographicSubRegions = dict["GeographicSubRegions"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListGeographicSubRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGeographicSubRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGeographicSubRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIpsecServerLogsRequest : Tea.TeaModel {
    public var from: Int32?

    public var ipsecServerId: String?

    public var minutePeriod: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var to: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.minutePeriod != nil {
            map["MinutePeriod"] = self.minutePeriod!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") {
            self.from = dict["From"] as! Int32
        }
        if dict.keys.contains("IpsecServerId") {
            self.ipsecServerId = dict["IpsecServerId"] as! String
        }
        if dict.keys.contains("MinutePeriod") {
            self.minutePeriod = dict["MinutePeriod"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("To") {
            self.to = dict["To"] as! Int32
        }
    }
}

public class ListIpsecServerLogsResponseBody : Tea.TeaModel {
    public var count: Int32?

    public var data: [String]?

    public var isCompleted: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.isCompleted != nil {
            map["IsCompleted"] = self.isCompleted!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("IsCompleted") {
            self.isCompleted = dict["IsCompleted"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIpsecServerLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIpsecServerLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIpsecServerLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIpsecServersRequest : Tea.TeaModel {
    public var ipsecServerId: [String]?

    public var ipsecServerName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.ipsecServerName != nil {
            map["IpsecServerName"] = self.ipsecServerName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpsecServerId") {
            self.ipsecServerId = dict["IpsecServerId"] as! [String]
        }
        if dict.keys.contains("IpsecServerName") {
            self.ipsecServerName = dict["IpsecServerName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class ListIpsecServersResponseBody : Tea.TeaModel {
    public class IpsecServers : Tea.TeaModel {
        public class IkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IkeAuthAlg") {
                    self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                }
                if dict.keys.contains("IkeEncAlg") {
                    self.ikeEncAlg = dict["IkeEncAlg"] as! String
                }
                if dict.keys.contains("IkeLifetime") {
                    self.ikeLifetime = dict["IkeLifetime"] as! Int64
                }
                if dict.keys.contains("IkeMode") {
                    self.ikeMode = dict["IkeMode"] as! String
                }
                if dict.keys.contains("IkePfs") {
                    self.ikePfs = dict["IkePfs"] as! String
                }
                if dict.keys.contains("IkeVersion") {
                    self.ikeVersion = dict["IkeVersion"] as! String
                }
                if dict.keys.contains("LocalId") {
                    self.localId = dict["LocalId"] as! String
                }
                if dict.keys.contains("RemoteId") {
                    self.remoteId = dict["RemoteId"] as! String
                }
            }
        }
        public class IpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpsecAuthAlg") {
                    self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                }
                if dict.keys.contains("IpsecEncAlg") {
                    self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                }
                if dict.keys.contains("IpsecLifetime") {
                    self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
                }
                if dict.keys.contains("IpsecPfs") {
                    self.ipsecPfs = dict["IpsecPfs"] as! String
                }
            }
        }
        public var clientIpPool: String?

        public var creationTime: String?

        public var effectImmediately: Bool?

        public var IDaaSInstanceId: String?

        public var ikeConfig: ListIpsecServersResponseBody.IpsecServers.IkeConfig?

        public var internetIp: String?

        public var ipsecConfig: ListIpsecServersResponseBody.IpsecServers.IpsecConfig?

        public var ipsecServerId: String?

        public var ipsecServerName: String?

        public var localSubnet: String?

        public var maxConnections: Int32?

        public var multiFactorAuthEnabled: Bool?

        public var onlineClientCount: Int32?

        public var psk: String?

        public var pskEnabled: Bool?

        public var regionId: String?

        public var resourceGroupId: String?

        public var vpnGatewayId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ikeConfig?.validate()
            try self.ipsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIpPool != nil {
                map["ClientIpPool"] = self.clientIpPool!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.effectImmediately != nil {
                map["EffectImmediately"] = self.effectImmediately!
            }
            if self.IDaaSInstanceId != nil {
                map["IDaaSInstanceId"] = self.IDaaSInstanceId!
            }
            if self.ikeConfig != nil {
                map["IkeConfig"] = self.ikeConfig?.toMap()
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.ipsecConfig != nil {
                map["IpsecConfig"] = self.ipsecConfig?.toMap()
            }
            if self.ipsecServerId != nil {
                map["IpsecServerId"] = self.ipsecServerId!
            }
            if self.ipsecServerName != nil {
                map["IpsecServerName"] = self.ipsecServerName!
            }
            if self.localSubnet != nil {
                map["LocalSubnet"] = self.localSubnet!
            }
            if self.maxConnections != nil {
                map["MaxConnections"] = self.maxConnections!
            }
            if self.multiFactorAuthEnabled != nil {
                map["MultiFactorAuthEnabled"] = self.multiFactorAuthEnabled!
            }
            if self.onlineClientCount != nil {
                map["OnlineClientCount"] = self.onlineClientCount!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.pskEnabled != nil {
                map["PskEnabled"] = self.pskEnabled!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.vpnGatewayId != nil {
                map["VpnGatewayId"] = self.vpnGatewayId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientIpPool") {
                self.clientIpPool = dict["ClientIpPool"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EffectImmediately") {
                self.effectImmediately = dict["EffectImmediately"] as! Bool
            }
            if dict.keys.contains("IDaaSInstanceId") {
                self.IDaaSInstanceId = dict["IDaaSInstanceId"] as! String
            }
            if dict.keys.contains("IkeConfig") {
                var model = ListIpsecServersResponseBody.IpsecServers.IkeConfig()
                model.fromMap(dict["IkeConfig"] as! [String: Any])
                self.ikeConfig = model
            }
            if dict.keys.contains("InternetIp") {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IpsecConfig") {
                var model = ListIpsecServersResponseBody.IpsecServers.IpsecConfig()
                model.fromMap(dict["IpsecConfig"] as! [String: Any])
                self.ipsecConfig = model
            }
            if dict.keys.contains("IpsecServerId") {
                self.ipsecServerId = dict["IpsecServerId"] as! String
            }
            if dict.keys.contains("IpsecServerName") {
                self.ipsecServerName = dict["IpsecServerName"] as! String
            }
            if dict.keys.contains("LocalSubnet") {
                self.localSubnet = dict["LocalSubnet"] as! String
            }
            if dict.keys.contains("MaxConnections") {
                self.maxConnections = dict["MaxConnections"] as! Int32
            }
            if dict.keys.contains("MultiFactorAuthEnabled") {
                self.multiFactorAuthEnabled = dict["MultiFactorAuthEnabled"] as! Bool
            }
            if dict.keys.contains("OnlineClientCount") {
                self.onlineClientCount = dict["OnlineClientCount"] as! Int32
            }
            if dict.keys.contains("Psk") {
                self.psk = dict["Psk"] as! String
            }
            if dict.keys.contains("PskEnabled") {
                self.pskEnabled = dict["PskEnabled"] as! Bool
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("VpnGatewayId") {
                self.vpnGatewayId = dict["VpnGatewayId"] as! String
            }
        }
    }
    public var ipsecServers: [ListIpsecServersResponseBody.IpsecServers]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipsecServers != nil {
            var tmp : [Any] = []
            for k in self.ipsecServers! {
                tmp.append(k.toMap())
            }
            map["IpsecServers"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpsecServers") {
            var tmp : [ListIpsecServersResponseBody.IpsecServers] = []
            for v in dict["IpsecServers"] as! [Any] {
                var model = ListIpsecServersResponseBody.IpsecServers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipsecServers = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListIpsecServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIpsecServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIpsecServersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIpv4GatewaysRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ipv4GatewayId: String?

    public var ipv4GatewayName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListIpv4GatewaysRequest.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ipv4GatewayName != nil {
            map["Ipv4GatewayName"] = self.ipv4GatewayName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv4GatewayId") {
            self.ipv4GatewayId = dict["Ipv4GatewayId"] as! String
        }
        if dict.keys.contains("Ipv4GatewayName") {
            self.ipv4GatewayName = dict["Ipv4GatewayName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListIpv4GatewaysRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListIpv4GatewaysRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ListIpv4GatewaysResponseBody : Tea.TeaModel {
    public class Ipv4GatewayModels : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var enabled: Bool?

        public var gmtCreate: String?

        public var ipv4GatewayDescription: String?

        public var ipv4GatewayId: String?

        public var ipv4GatewayName: String?

        public var ipv4GatewayRouteTableId: String?

        public var resourceGroupId: String?

        public var status: String?

        public var tags: [ListIpv4GatewaysResponseBody.Ipv4GatewayModels.Tags]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.ipv4GatewayDescription != nil {
                map["Ipv4GatewayDescription"] = self.ipv4GatewayDescription!
            }
            if self.ipv4GatewayId != nil {
                map["Ipv4GatewayId"] = self.ipv4GatewayId!
            }
            if self.ipv4GatewayName != nil {
                map["Ipv4GatewayName"] = self.ipv4GatewayName!
            }
            if self.ipv4GatewayRouteTableId != nil {
                map["Ipv4GatewayRouteTableId"] = self.ipv4GatewayRouteTableId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("Ipv4GatewayDescription") {
                self.ipv4GatewayDescription = dict["Ipv4GatewayDescription"] as! String
            }
            if dict.keys.contains("Ipv4GatewayId") {
                self.ipv4GatewayId = dict["Ipv4GatewayId"] as! String
            }
            if dict.keys.contains("Ipv4GatewayName") {
                self.ipv4GatewayName = dict["Ipv4GatewayName"] as! String
            }
            if dict.keys.contains("Ipv4GatewayRouteTableId") {
                self.ipv4GatewayRouteTableId = dict["Ipv4GatewayRouteTableId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListIpv4GatewaysResponseBody.Ipv4GatewayModels.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListIpv4GatewaysResponseBody.Ipv4GatewayModels.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var ipv4GatewayModels: [ListIpv4GatewaysResponseBody.Ipv4GatewayModels]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4GatewayModels != nil {
            var tmp : [Any] = []
            for k in self.ipv4GatewayModels! {
                tmp.append(k.toMap())
            }
            map["Ipv4GatewayModels"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv4GatewayModels") {
            var tmp : [ListIpv4GatewaysResponseBody.Ipv4GatewayModels] = []
            for v in dict["Ipv4GatewayModels"] as! [Any] {
                var model = ListIpv4GatewaysResponseBody.Ipv4GatewayModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipv4GatewayModels = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListIpv4GatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIpv4GatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIpv4GatewaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNatIpCidrsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var maxResults: String?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var natIpCidrName: [String]?

    public var natIpCidrStatus: String?

    public var natIpCidrs: [String]?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpCidrName != nil {
            map["NatIpCidrName"] = self.natIpCidrName!
        }
        if self.natIpCidrStatus != nil {
            map["NatIpCidrStatus"] = self.natIpCidrStatus!
        }
        if self.natIpCidrs != nil {
            map["NatIpCidrs"] = self.natIpCidrs!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatIpCidr") {
            self.natIpCidr = dict["NatIpCidr"] as! String
        }
        if dict.keys.contains("NatIpCidrName") {
            self.natIpCidrName = dict["NatIpCidrName"] as! [String]
        }
        if dict.keys.contains("NatIpCidrStatus") {
            self.natIpCidrStatus = dict["NatIpCidrStatus"] as! String
        }
        if dict.keys.contains("NatIpCidrs") {
            self.natIpCidrs = dict["NatIpCidrs"] as! [String]
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListNatIpCidrsResponseBody : Tea.TeaModel {
    public class NatIpCidrs : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: Bool?

        public var natGatewayId: String?

        public var natIpCidr: String?

        public var natIpCidrDescription: String?

        public var natIpCidrId: String?

        public var natIpCidrName: String?

        public var natIpCidrStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.natIpCidr != nil {
                map["NatIpCidr"] = self.natIpCidr!
            }
            if self.natIpCidrDescription != nil {
                map["NatIpCidrDescription"] = self.natIpCidrDescription!
            }
            if self.natIpCidrId != nil {
                map["NatIpCidrId"] = self.natIpCidrId!
            }
            if self.natIpCidrName != nil {
                map["NatIpCidrName"] = self.natIpCidrName!
            }
            if self.natIpCidrStatus != nil {
                map["NatIpCidrStatus"] = self.natIpCidrStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("NatGatewayId") {
                self.natGatewayId = dict["NatGatewayId"] as! String
            }
            if dict.keys.contains("NatIpCidr") {
                self.natIpCidr = dict["NatIpCidr"] as! String
            }
            if dict.keys.contains("NatIpCidrDescription") {
                self.natIpCidrDescription = dict["NatIpCidrDescription"] as! String
            }
            if dict.keys.contains("NatIpCidrId") {
                self.natIpCidrId = dict["NatIpCidrId"] as! String
            }
            if dict.keys.contains("NatIpCidrName") {
                self.natIpCidrName = dict["NatIpCidrName"] as! String
            }
            if dict.keys.contains("NatIpCidrStatus") {
                self.natIpCidrStatus = dict["NatIpCidrStatus"] as! String
            }
        }
    }
    public var natIpCidrs: [ListNatIpCidrsResponseBody.NatIpCidrs]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natIpCidrs != nil {
            var tmp : [Any] = []
            for k in self.natIpCidrs! {
                tmp.append(k.toMap())
            }
            map["NatIpCidrs"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatIpCidrs") {
            var tmp : [ListNatIpCidrsResponseBody.NatIpCidrs] = []
            for v in dict["NatIpCidrs"] as! [Any] {
                var model = ListNatIpCidrsResponseBody.NatIpCidrs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.natIpCidrs = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListNatIpCidrsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNatIpCidrsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNatIpCidrsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNatIpsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var maxResults: String?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var natIpIds: [String]?

    public var natIpName: [String]?

    public var natIpStatus: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpIds != nil {
            map["NatIpIds"] = self.natIpIds!
        }
        if self.natIpName != nil {
            map["NatIpName"] = self.natIpName!
        }
        if self.natIpStatus != nil {
            map["NatIpStatus"] = self.natIpStatus!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatIpCidr") {
            self.natIpCidr = dict["NatIpCidr"] as! String
        }
        if dict.keys.contains("NatIpIds") {
            self.natIpIds = dict["NatIpIds"] as! [String]
        }
        if dict.keys.contains("NatIpName") {
            self.natIpName = dict["NatIpName"] as! [String]
        }
        if dict.keys.contains("NatIpStatus") {
            self.natIpStatus = dict["NatIpStatus"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListNatIpsResponseBody : Tea.TeaModel {
    public class NatIps : Tea.TeaModel {
        public var isDefault: Bool?

        public var natGatewayId: String?

        public var natIp: String?

        public var natIpCidr: String?

        public var natIpDescription: String?

        public var natIpId: String?

        public var natIpName: String?

        public var natIpStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.natIp != nil {
                map["NatIp"] = self.natIp!
            }
            if self.natIpCidr != nil {
                map["NatIpCidr"] = self.natIpCidr!
            }
            if self.natIpDescription != nil {
                map["NatIpDescription"] = self.natIpDescription!
            }
            if self.natIpId != nil {
                map["NatIpId"] = self.natIpId!
            }
            if self.natIpName != nil {
                map["NatIpName"] = self.natIpName!
            }
            if self.natIpStatus != nil {
                map["NatIpStatus"] = self.natIpStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("NatGatewayId") {
                self.natGatewayId = dict["NatGatewayId"] as! String
            }
            if dict.keys.contains("NatIp") {
                self.natIp = dict["NatIp"] as! String
            }
            if dict.keys.contains("NatIpCidr") {
                self.natIpCidr = dict["NatIpCidr"] as! String
            }
            if dict.keys.contains("NatIpDescription") {
                self.natIpDescription = dict["NatIpDescription"] as! String
            }
            if dict.keys.contains("NatIpId") {
                self.natIpId = dict["NatIpId"] as! String
            }
            if dict.keys.contains("NatIpName") {
                self.natIpName = dict["NatIpName"] as! String
            }
            if dict.keys.contains("NatIpStatus") {
                self.natIpStatus = dict["NatIpStatus"] as! String
            }
        }
    }
    public var natIps: [ListNatIpsResponseBody.NatIps]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natIps != nil {
            var tmp : [Any] = []
            for k in self.natIps! {
                tmp.append(k.toMap())
            }
            map["NatIps"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatIps") {
            var tmp : [ListNatIpsResponseBody.NatIps] = []
            for v in dict["NatIps"] as! [Any] {
                var model = ListNatIpsResponseBody.NatIps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.natIps = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListNatIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNatIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNatIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrefixListsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListIds: [String]?

    public var prefixListName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListPrefixListsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListIds != nil {
            map["PrefixListIds"] = self.prefixListIds!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListIds") {
            self.prefixListIds = dict["PrefixListIds"] as! [String]
        }
        if dict.keys.contains("PrefixListName") {
            self.prefixListName = dict["PrefixListName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListPrefixListsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListPrefixListsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListPrefixListsResponseBody : Tea.TeaModel {
    public class PrefixLists : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var cidrBlocks: [String]?

        public var creationTime: String?

        public var ipVersion: String?

        public var maxEntries: Int32?

        public var ownerId: String?

        public var prefixListDescription: String?

        public var prefixListId: String?

        public var prefixListName: String?

        public var prefixListStatus: String?

        public var prefixListType: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var shareType: String?

        public var status: String?

        public var tags: [ListPrefixListsResponseBody.PrefixLists.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlocks != nil {
                map["CidrBlocks"] = self.cidrBlocks!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.maxEntries != nil {
                map["MaxEntries"] = self.maxEntries!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.prefixListDescription != nil {
                map["PrefixListDescription"] = self.prefixListDescription!
            }
            if self.prefixListId != nil {
                map["PrefixListId"] = self.prefixListId!
            }
            if self.prefixListName != nil {
                map["PrefixListName"] = self.prefixListName!
            }
            if self.prefixListStatus != nil {
                map["PrefixListStatus"] = self.prefixListStatus!
            }
            if self.prefixListType != nil {
                map["PrefixListType"] = self.prefixListType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.shareType != nil {
                map["ShareType"] = self.shareType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrBlocks") {
                self.cidrBlocks = dict["CidrBlocks"] as! [String]
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IpVersion") {
                self.ipVersion = dict["IpVersion"] as! String
            }
            if dict.keys.contains("MaxEntries") {
                self.maxEntries = dict["MaxEntries"] as! Int32
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! String
            }
            if dict.keys.contains("PrefixListDescription") {
                self.prefixListDescription = dict["PrefixListDescription"] as! String
            }
            if dict.keys.contains("PrefixListId") {
                self.prefixListId = dict["PrefixListId"] as! String
            }
            if dict.keys.contains("PrefixListName") {
                self.prefixListName = dict["PrefixListName"] as! String
            }
            if dict.keys.contains("PrefixListStatus") {
                self.prefixListStatus = dict["PrefixListStatus"] as! String
            }
            if dict.keys.contains("PrefixListType") {
                self.prefixListType = dict["PrefixListType"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ShareType") {
                self.shareType = dict["ShareType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListPrefixListsResponseBody.PrefixLists.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListPrefixListsResponseBody.PrefixLists.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var prefixLists: [ListPrefixListsResponseBody.PrefixLists]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixLists != nil {
            var tmp : [Any] = []
            for k in self.prefixLists! {
                tmp.append(k.toMap())
            }
            map["PrefixLists"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PrefixLists") {
            var tmp : [ListPrefixListsResponseBody.PrefixLists] = []
            for v in dict["PrefixLists"] as! [Any] {
                var model = ListPrefixListsResponseBody.PrefixLists()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.prefixLists = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListPrefixListsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrefixListsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrefixListsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPublicIpAddressPoolCidrBlocksRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var dryRun: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PublicIpAddressPoolId") {
            self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListPublicIpAddressPoolCidrBlocksResponseBody : Tea.TeaModel {
    public class PublicIpPoolCidrBlockList : Tea.TeaModel {
        public var cidrBlock: String?

        public var creationTime: String?

        public var publicIpAddressPoolId: String?

        public var status: String?

        public var totalIpNum: Int32?

        public var usedIpNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.publicIpAddressPoolId != nil {
                map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalIpNum != nil {
                map["TotalIpNum"] = self.totalIpNum!
            }
            if self.usedIpNum != nil {
                map["UsedIpNum"] = self.usedIpNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrBlock") {
                self.cidrBlock = dict["CidrBlock"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("PublicIpAddressPoolId") {
                self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TotalIpNum") {
                self.totalIpNum = dict["TotalIpNum"] as! Int32
            }
            if dict.keys.contains("UsedIpNum") {
                self.usedIpNum = dict["UsedIpNum"] as! Int32
            }
        }
    }
    public var nextToken: String?

    public var publicIpPoolCidrBlockList: [ListPublicIpAddressPoolCidrBlocksResponseBody.PublicIpPoolCidrBlockList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.publicIpPoolCidrBlockList != nil {
            var tmp : [Any] = []
            for k in self.publicIpPoolCidrBlockList! {
                tmp.append(k.toMap())
            }
            map["PublicIpPoolCidrBlockList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PublicIpPoolCidrBlockList") {
            var tmp : [ListPublicIpAddressPoolCidrBlocksResponseBody.PublicIpPoolCidrBlockList] = []
            for v in dict["PublicIpPoolCidrBlockList"] as! [Any] {
                var model = ListPublicIpAddressPoolCidrBlocksResponseBody.PublicIpPoolCidrBlockList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.publicIpPoolCidrBlockList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListPublicIpAddressPoolCidrBlocksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublicIpAddressPoolCidrBlocksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPublicIpAddressPoolCidrBlocksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPublicIpAddressPoolsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dryRun: Bool?

    public var isp: String?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolIds: [String]?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var status: String?

    public var tags: [ListPublicIpAddressPoolsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolIds != nil {
            map["PublicIpAddressPoolIds"] = self.publicIpAddressPoolIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PublicIpAddressPoolIds") {
            self.publicIpAddressPoolIds = dict["PublicIpAddressPoolIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityProtectionEnabled") {
            self.securityProtectionEnabled = dict["SecurityProtectionEnabled"] as! Bool
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListPublicIpAddressPoolsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListPublicIpAddressPoolsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListPublicIpAddressPoolsResponseBody : Tea.TeaModel {
    public class PublicIpAddressPoolList : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var bizType: String?

        public var businessStatus: String?

        public var creationTime: String?

        public var description_: String?

        public var ipAddressRemaining: Bool?

        public var isp: String?

        public var name: String?

        public var ownerId: Int64?

        public var publicIpAddressPoolId: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var securityProtectionTypes: [String]?

        public var shareType: String?

        public var status: String?

        public var tags: [ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList.Tags]?

        public var totalIpNum: Int32?

        public var usedIpNum: Int32?

        public var userType: String?

        public var zones: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizType != nil {
                map["BizType"] = self.bizType!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ipAddressRemaining != nil {
                map["IpAddressRemaining"] = self.ipAddressRemaining!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.publicIpAddressPoolId != nil {
                map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityProtectionTypes != nil {
                map["SecurityProtectionTypes"] = self.securityProtectionTypes!
            }
            if self.shareType != nil {
                map["ShareType"] = self.shareType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.totalIpNum != nil {
                map["TotalIpNum"] = self.totalIpNum!
            }
            if self.usedIpNum != nil {
                map["UsedIpNum"] = self.usedIpNum!
            }
            if self.userType != nil {
                map["UserType"] = self.userType!
            }
            if self.zones != nil {
                map["Zones"] = self.zones!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizType") {
                self.bizType = dict["BizType"] as! String
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IpAddressRemaining") {
                self.ipAddressRemaining = dict["IpAddressRemaining"] as! Bool
            }
            if dict.keys.contains("Isp") {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! Int64
            }
            if dict.keys.contains("PublicIpAddressPoolId") {
                self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SecurityProtectionTypes") {
                self.securityProtectionTypes = dict["SecurityProtectionTypes"] as! [String]
            }
            if dict.keys.contains("ShareType") {
                self.shareType = dict["ShareType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TotalIpNum") {
                self.totalIpNum = dict["TotalIpNum"] as! Int32
            }
            if dict.keys.contains("UsedIpNum") {
                self.usedIpNum = dict["UsedIpNum"] as! Int32
            }
            if dict.keys.contains("UserType") {
                self.userType = dict["UserType"] as! String
            }
            if dict.keys.contains("Zones") {
                self.zones = dict["Zones"] as! [String]
            }
        }
    }
    public var nextToken: String?

    public var publicIpAddressPoolList: [ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.publicIpAddressPoolList != nil {
            var tmp : [Any] = []
            for k in self.publicIpAddressPoolList! {
                tmp.append(k.toMap())
            }
            map["PublicIpAddressPoolList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PublicIpAddressPoolList") {
            var tmp : [ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList] = []
            for v in dict["PublicIpAddressPoolList"] as! [Any] {
                var model = ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.publicIpAddressPoolList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListPublicIpAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublicIpAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPublicIpAddressPoolsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesForExpressConnectRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [ListTagResourcesForExpressConnectRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListTagResourcesForExpressConnectRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesForExpressConnectRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesForExpressConnectResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesForExpressConnectResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") {
                var tmp : [ListTagResourcesForExpressConnectResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesForExpressConnectResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesForExpressConnectResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var model = ListTagResourcesForExpressConnectResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesForExpressConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesForExpressConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesForExpressConnectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTrafficMirrorFiltersRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListTrafficMirrorFiltersRequest.Tags]?

    public var trafficMirrorFilterIds: [String]?

    public var trafficMirrorFilterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.trafficMirrorFilterIds != nil {
            map["TrafficMirrorFilterIds"] = self.trafficMirrorFilterIds!
        }
        if self.trafficMirrorFilterName != nil {
            map["TrafficMirrorFilterName"] = self.trafficMirrorFilterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListTrafficMirrorFiltersRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListTrafficMirrorFiltersRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TrafficMirrorFilterIds") {
            self.trafficMirrorFilterIds = dict["TrafficMirrorFilterIds"] as! [String]
        }
        if dict.keys.contains("TrafficMirrorFilterName") {
            self.trafficMirrorFilterName = dict["TrafficMirrorFilterName"] as! String
        }
    }
}

public class ListTrafficMirrorFiltersResponseBody : Tea.TeaModel {
    public class TrafficMirrorFilters : Tea.TeaModel {
        public class EgressRules : Tea.TeaModel {
            public var action: String?

            public var destinationCidrBlock: String?

            public var destinationPortRange: String?

            public var priority: Int32?

            public var protocol_: String?

            public var sourceCidrBlock: String?

            public var sourcePortRange: String?

            public var trafficDirection: String?

            public var trafficMirrorFilterId: String?

            public var trafficMirrorFilterRuleId: String?

            public var trafficMirrorFilterRuleStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.destinationCidrBlock != nil {
                    map["DestinationCidrBlock"] = self.destinationCidrBlock!
                }
                if self.destinationPortRange != nil {
                    map["DestinationPortRange"] = self.destinationPortRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.sourceCidrBlock != nil {
                    map["SourceCidrBlock"] = self.sourceCidrBlock!
                }
                if self.sourcePortRange != nil {
                    map["SourcePortRange"] = self.sourcePortRange!
                }
                if self.trafficDirection != nil {
                    map["TrafficDirection"] = self.trafficDirection!
                }
                if self.trafficMirrorFilterId != nil {
                    map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
                }
                if self.trafficMirrorFilterRuleId != nil {
                    map["TrafficMirrorFilterRuleId"] = self.trafficMirrorFilterRuleId!
                }
                if self.trafficMirrorFilterRuleStatus != nil {
                    map["TrafficMirrorFilterRuleStatus"] = self.trafficMirrorFilterRuleStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("DestinationCidrBlock") {
                    self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
                }
                if dict.keys.contains("DestinationPortRange") {
                    self.destinationPortRange = dict["DestinationPortRange"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("SourceCidrBlock") {
                    self.sourceCidrBlock = dict["SourceCidrBlock"] as! String
                }
                if dict.keys.contains("SourcePortRange") {
                    self.sourcePortRange = dict["SourcePortRange"] as! String
                }
                if dict.keys.contains("TrafficDirection") {
                    self.trafficDirection = dict["TrafficDirection"] as! String
                }
                if dict.keys.contains("TrafficMirrorFilterId") {
                    self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
                }
                if dict.keys.contains("TrafficMirrorFilterRuleId") {
                    self.trafficMirrorFilterRuleId = dict["TrafficMirrorFilterRuleId"] as! String
                }
                if dict.keys.contains("TrafficMirrorFilterRuleStatus") {
                    self.trafficMirrorFilterRuleStatus = dict["TrafficMirrorFilterRuleStatus"] as! String
                }
            }
        }
        public class IngressRules : Tea.TeaModel {
            public var action: String?

            public var destinationCidrBlock: String?

            public var destinationPortRange: String?

            public var priority: Int32?

            public var protocol_: String?

            public var sourceCidrBlock: String?

            public var sourcePortRange: String?

            public var trafficDirection: String?

            public var trafficMirrorFilterId: String?

            public var trafficMirrorFilterRuleId: String?

            public var trafficMirrorFilterRuleStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.destinationCidrBlock != nil {
                    map["DestinationCidrBlock"] = self.destinationCidrBlock!
                }
                if self.destinationPortRange != nil {
                    map["DestinationPortRange"] = self.destinationPortRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.sourceCidrBlock != nil {
                    map["SourceCidrBlock"] = self.sourceCidrBlock!
                }
                if self.sourcePortRange != nil {
                    map["SourcePortRange"] = self.sourcePortRange!
                }
                if self.trafficDirection != nil {
                    map["TrafficDirection"] = self.trafficDirection!
                }
                if self.trafficMirrorFilterId != nil {
                    map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
                }
                if self.trafficMirrorFilterRuleId != nil {
                    map["TrafficMirrorFilterRuleId"] = self.trafficMirrorFilterRuleId!
                }
                if self.trafficMirrorFilterRuleStatus != nil {
                    map["TrafficMirrorFilterRuleStatus"] = self.trafficMirrorFilterRuleStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("DestinationCidrBlock") {
                    self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
                }
                if dict.keys.contains("DestinationPortRange") {
                    self.destinationPortRange = dict["DestinationPortRange"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("SourceCidrBlock") {
                    self.sourceCidrBlock = dict["SourceCidrBlock"] as! String
                }
                if dict.keys.contains("SourcePortRange") {
                    self.sourcePortRange = dict["SourcePortRange"] as! String
                }
                if dict.keys.contains("TrafficDirection") {
                    self.trafficDirection = dict["TrafficDirection"] as! String
                }
                if dict.keys.contains("TrafficMirrorFilterId") {
                    self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
                }
                if dict.keys.contains("TrafficMirrorFilterRuleId") {
                    self.trafficMirrorFilterRuleId = dict["TrafficMirrorFilterRuleId"] as! String
                }
                if dict.keys.contains("TrafficMirrorFilterRuleStatus") {
                    self.trafficMirrorFilterRuleStatus = dict["TrafficMirrorFilterRuleStatus"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var creationTime: String?

        public var egressRules: [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.EgressRules]?

        public var ingressRules: [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.IngressRules]?

        public var resourceGroupId: String?

        public var tags: [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.Tags]?

        public var trafficMirrorFilterDescription: String?

        public var trafficMirrorFilterId: String?

        public var trafficMirrorFilterName: String?

        public var trafficMirrorFilterStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.egressRules != nil {
                var tmp : [Any] = []
                for k in self.egressRules! {
                    tmp.append(k.toMap())
                }
                map["EgressRules"] = tmp
            }
            if self.ingressRules != nil {
                var tmp : [Any] = []
                for k in self.ingressRules! {
                    tmp.append(k.toMap())
                }
                map["IngressRules"] = tmp
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.trafficMirrorFilterDescription != nil {
                map["TrafficMirrorFilterDescription"] = self.trafficMirrorFilterDescription!
            }
            if self.trafficMirrorFilterId != nil {
                map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
            }
            if self.trafficMirrorFilterName != nil {
                map["TrafficMirrorFilterName"] = self.trafficMirrorFilterName!
            }
            if self.trafficMirrorFilterStatus != nil {
                map["TrafficMirrorFilterStatus"] = self.trafficMirrorFilterStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EgressRules") {
                var tmp : [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.EgressRules] = []
                for v in dict["EgressRules"] as! [Any] {
                    var model = ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.EgressRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.egressRules = tmp
            }
            if dict.keys.contains("IngressRules") {
                var tmp : [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.IngressRules] = []
                for v in dict["IngressRules"] as! [Any] {
                    var model = ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.IngressRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ingressRules = tmp
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TrafficMirrorFilterDescription") {
                self.trafficMirrorFilterDescription = dict["TrafficMirrorFilterDescription"] as! String
            }
            if dict.keys.contains("TrafficMirrorFilterId") {
                self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
            }
            if dict.keys.contains("TrafficMirrorFilterName") {
                self.trafficMirrorFilterName = dict["TrafficMirrorFilterName"] as! String
            }
            if dict.keys.contains("TrafficMirrorFilterStatus") {
                self.trafficMirrorFilterStatus = dict["TrafficMirrorFilterStatus"] as! String
            }
        }
    }
    public var count: Int32?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public var trafficMirrorFilters: [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.trafficMirrorFilters != nil {
            var tmp : [Any] = []
            for k in self.trafficMirrorFilters! {
                tmp.append(k.toMap())
            }
            map["TrafficMirrorFilters"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
        if dict.keys.contains("TrafficMirrorFilters") {
            var tmp : [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters] = []
            for v in dict["TrafficMirrorFilters"] as! [Any] {
                var model = ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.trafficMirrorFilters = tmp
        }
    }
}

public class ListTrafficMirrorFiltersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTrafficMirrorFiltersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTrafficMirrorFiltersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTrafficMirrorSessionsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var enabled: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListTrafficMirrorSessionsRequest.Tags]?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorSessionIds: [String]?

    public var trafficMirrorSessionName: String?

    public var trafficMirrorSourceId: String?

    public var trafficMirrorTargetId: String?

    public var virtualNetworkId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorSessionIds != nil {
            map["TrafficMirrorSessionIds"] = self.trafficMirrorSessionIds!
        }
        if self.trafficMirrorSessionName != nil {
            map["TrafficMirrorSessionName"] = self.trafficMirrorSessionName!
        }
        if self.trafficMirrorSourceId != nil {
            map["TrafficMirrorSourceId"] = self.trafficMirrorSourceId!
        }
        if self.trafficMirrorTargetId != nil {
            map["TrafficMirrorTargetId"] = self.trafficMirrorTargetId!
        }
        if self.virtualNetworkId != nil {
            map["VirtualNetworkId"] = self.virtualNetworkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListTrafficMirrorSessionsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListTrafficMirrorSessionsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TrafficMirrorFilterId") {
            self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
        }
        if dict.keys.contains("TrafficMirrorSessionIds") {
            self.trafficMirrorSessionIds = dict["TrafficMirrorSessionIds"] as! [String]
        }
        if dict.keys.contains("TrafficMirrorSessionName") {
            self.trafficMirrorSessionName = dict["TrafficMirrorSessionName"] as! String
        }
        if dict.keys.contains("TrafficMirrorSourceId") {
            self.trafficMirrorSourceId = dict["TrafficMirrorSourceId"] as! String
        }
        if dict.keys.contains("TrafficMirrorTargetId") {
            self.trafficMirrorTargetId = dict["TrafficMirrorTargetId"] as! String
        }
        if dict.keys.contains("VirtualNetworkId") {
            self.virtualNetworkId = dict["VirtualNetworkId"] as! Int32
        }
    }
}

public class ListTrafficMirrorSessionsResponseBody : Tea.TeaModel {
    public class TrafficMirrorSessions : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var creationTime: String?

        public var enabled: Bool?

        public var packetLength: Int32?

        public var priority: Int32?

        public var resourceGroupId: String?

        public var tags: [ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions.Tags]?

        public var trafficMirrorFilterId: String?

        public var trafficMirrorSessionBusinessStatus: String?

        public var trafficMirrorSessionDescription: String?

        public var trafficMirrorSessionId: String?

        public var trafficMirrorSessionName: String?

        public var trafficMirrorSessionStatus: String?

        public var trafficMirrorSourceIds: [String]?

        public var trafficMirrorTargetId: String?

        public var trafficMirrorTargetType: String?

        public var virtualNetworkId: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.packetLength != nil {
                map["PacketLength"] = self.packetLength!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.trafficMirrorFilterId != nil {
                map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
            }
            if self.trafficMirrorSessionBusinessStatus != nil {
                map["TrafficMirrorSessionBusinessStatus"] = self.trafficMirrorSessionBusinessStatus!
            }
            if self.trafficMirrorSessionDescription != nil {
                map["TrafficMirrorSessionDescription"] = self.trafficMirrorSessionDescription!
            }
            if self.trafficMirrorSessionId != nil {
                map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
            }
            if self.trafficMirrorSessionName != nil {
                map["TrafficMirrorSessionName"] = self.trafficMirrorSessionName!
            }
            if self.trafficMirrorSessionStatus != nil {
                map["TrafficMirrorSessionStatus"] = self.trafficMirrorSessionStatus!
            }
            if self.trafficMirrorSourceIds != nil {
                map["TrafficMirrorSourceIds"] = self.trafficMirrorSourceIds!
            }
            if self.trafficMirrorTargetId != nil {
                map["TrafficMirrorTargetId"] = self.trafficMirrorTargetId!
            }
            if self.trafficMirrorTargetType != nil {
                map["TrafficMirrorTargetType"] = self.trafficMirrorTargetType!
            }
            if self.virtualNetworkId != nil {
                map["VirtualNetworkId"] = self.virtualNetworkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("PacketLength") {
                self.packetLength = dict["PacketLength"] as! Int32
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TrafficMirrorFilterId") {
                self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
            }
            if dict.keys.contains("TrafficMirrorSessionBusinessStatus") {
                self.trafficMirrorSessionBusinessStatus = dict["TrafficMirrorSessionBusinessStatus"] as! String
            }
            if dict.keys.contains("TrafficMirrorSessionDescription") {
                self.trafficMirrorSessionDescription = dict["TrafficMirrorSessionDescription"] as! String
            }
            if dict.keys.contains("TrafficMirrorSessionId") {
                self.trafficMirrorSessionId = dict["TrafficMirrorSessionId"] as! String
            }
            if dict.keys.contains("TrafficMirrorSessionName") {
                self.trafficMirrorSessionName = dict["TrafficMirrorSessionName"] as! String
            }
            if dict.keys.contains("TrafficMirrorSessionStatus") {
                self.trafficMirrorSessionStatus = dict["TrafficMirrorSessionStatus"] as! String
            }
            if dict.keys.contains("TrafficMirrorSourceIds") {
                self.trafficMirrorSourceIds = dict["TrafficMirrorSourceIds"] as! [String]
            }
            if dict.keys.contains("TrafficMirrorTargetId") {
                self.trafficMirrorTargetId = dict["TrafficMirrorTargetId"] as! String
            }
            if dict.keys.contains("TrafficMirrorTargetType") {
                self.trafficMirrorTargetType = dict["TrafficMirrorTargetType"] as! String
            }
            if dict.keys.contains("VirtualNetworkId") {
                self.virtualNetworkId = dict["VirtualNetworkId"] as! Int32
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public var trafficMirrorSessions: [ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.trafficMirrorSessions != nil {
            var tmp : [Any] = []
            for k in self.trafficMirrorSessions! {
                tmp.append(k.toMap())
            }
            map["TrafficMirrorSessions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
        if dict.keys.contains("TrafficMirrorSessions") {
            var tmp : [ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions] = []
            for v in dict["TrafficMirrorSessions"] as! [Any] {
                var model = ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.trafficMirrorSessions = tmp
        }
    }
}

public class ListTrafficMirrorSessionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTrafficMirrorSessionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTrafficMirrorSessionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVSwitchCidrReservationsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ipVersion: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListVSwitchCidrReservationsRequest.Tags]?

    public var vSwitchCidrReservationIds: [String]?

    public var vSwitchCidrReservationType: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vSwitchCidrReservationIds != nil {
            map["VSwitchCidrReservationIds"] = self.vSwitchCidrReservationIds!
        }
        if self.vSwitchCidrReservationType != nil {
            map["VSwitchCidrReservationType"] = self.vSwitchCidrReservationType!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListVSwitchCidrReservationsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListVSwitchCidrReservationsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VSwitchCidrReservationIds") {
            self.vSwitchCidrReservationIds = dict["VSwitchCidrReservationIds"] as! [String]
        }
        if dict.keys.contains("VSwitchCidrReservationType") {
            self.vSwitchCidrReservationType = dict["VSwitchCidrReservationType"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class ListVSwitchCidrReservationsResponseBody : Tea.TeaModel {
    public class VSwitchCidrReservations : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var assignedCidrCount: Int32?

        public var availableCidrCount: Int32?

        public var creationTime: String?

        public var ipVersion: String?

        public var status: String?

        public var tags: [ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations.Tags]?

        public var type: String?

        public var vSwitchCidrReservationCidr: String?

        public var vSwitchCidrReservationDescription: String?

        public var vSwitchCidrReservationId: String?

        public var vSwitchCidrReservationName: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedCidrCount != nil {
                map["AssignedCidrCount"] = self.assignedCidrCount!
            }
            if self.availableCidrCount != nil {
                map["AvailableCidrCount"] = self.availableCidrCount!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.vSwitchCidrReservationCidr != nil {
                map["VSwitchCidrReservationCidr"] = self.vSwitchCidrReservationCidr!
            }
            if self.vSwitchCidrReservationDescription != nil {
                map["VSwitchCidrReservationDescription"] = self.vSwitchCidrReservationDescription!
            }
            if self.vSwitchCidrReservationId != nil {
                map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
            }
            if self.vSwitchCidrReservationName != nil {
                map["VSwitchCidrReservationName"] = self.vSwitchCidrReservationName!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssignedCidrCount") {
                self.assignedCidrCount = dict["AssignedCidrCount"] as! Int32
            }
            if dict.keys.contains("AvailableCidrCount") {
                self.availableCidrCount = dict["AvailableCidrCount"] as! Int32
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IpVersion") {
                self.ipVersion = dict["IpVersion"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("VSwitchCidrReservationCidr") {
                self.vSwitchCidrReservationCidr = dict["VSwitchCidrReservationCidr"] as! String
            }
            if dict.keys.contains("VSwitchCidrReservationDescription") {
                self.vSwitchCidrReservationDescription = dict["VSwitchCidrReservationDescription"] as! String
            }
            if dict.keys.contains("VSwitchCidrReservationId") {
                self.vSwitchCidrReservationId = dict["VSwitchCidrReservationId"] as! String
            }
            if dict.keys.contains("VSwitchCidrReservationName") {
                self.vSwitchCidrReservationName = dict["VSwitchCidrReservationName"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public var vSwitchCidrReservations: [ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vSwitchCidrReservations != nil {
            var tmp : [Any] = []
            for k in self.vSwitchCidrReservations! {
                tmp.append(k.toMap())
            }
            map["VSwitchCidrReservations"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("VSwitchCidrReservations") {
            var tmp : [ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations] = []
            for v in dict["VSwitchCidrReservations"] as! [Any] {
                var model = ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vSwitchCidrReservations = tmp
        }
    }
}

public class ListVSwitchCidrReservationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVSwitchCidrReservationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVSwitchCidrReservationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVirtualPhysicalConnectionsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var isConfirmed: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [ListVirtualPhysicalConnectionsRequest.Tags]?

    public var virtualPhysicalConnectionAliUids: [String]?

    public var virtualPhysicalConnectionBusinessStatus: String?

    public var virtualPhysicalConnectionIds: [String]?

    public var virtualPhysicalConnectionStatuses: [String]?

    public var vlanIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isConfirmed != nil {
            map["IsConfirmed"] = self.isConfirmed!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.virtualPhysicalConnectionAliUids != nil {
            map["VirtualPhysicalConnectionAliUids"] = self.virtualPhysicalConnectionAliUids!
        }
        if self.virtualPhysicalConnectionBusinessStatus != nil {
            map["VirtualPhysicalConnectionBusinessStatus"] = self.virtualPhysicalConnectionBusinessStatus!
        }
        if self.virtualPhysicalConnectionIds != nil {
            map["VirtualPhysicalConnectionIds"] = self.virtualPhysicalConnectionIds!
        }
        if self.virtualPhysicalConnectionStatuses != nil {
            map["VirtualPhysicalConnectionStatuses"] = self.virtualPhysicalConnectionStatuses!
        }
        if self.vlanIds != nil {
            map["VlanIds"] = self.vlanIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsConfirmed") {
            self.isConfirmed = dict["IsConfirmed"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListVirtualPhysicalConnectionsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListVirtualPhysicalConnectionsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VirtualPhysicalConnectionAliUids") {
            self.virtualPhysicalConnectionAliUids = dict["VirtualPhysicalConnectionAliUids"] as! [String]
        }
        if dict.keys.contains("VirtualPhysicalConnectionBusinessStatus") {
            self.virtualPhysicalConnectionBusinessStatus = dict["VirtualPhysicalConnectionBusinessStatus"] as! String
        }
        if dict.keys.contains("VirtualPhysicalConnectionIds") {
            self.virtualPhysicalConnectionIds = dict["VirtualPhysicalConnectionIds"] as! [String]
        }
        if dict.keys.contains("VirtualPhysicalConnectionStatuses") {
            self.virtualPhysicalConnectionStatuses = dict["VirtualPhysicalConnectionStatuses"] as! [String]
        }
        if dict.keys.contains("VlanIds") {
            self.vlanIds = dict["VlanIds"] as! [String]
        }
    }
}

public class ListVirtualPhysicalConnectionsResponseBody : Tea.TeaModel {
    public class VirtualPhysicalConnections : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var accessPointId: String?

        public var adLocation: String?

        public var aliUid: String?

        public var bandwidth: Int64?

        public var businessStatus: String?

        public var chargeType: String?

        public var circuitCode: String?

        public var creationTime: String?

        public var description_: String?

        public var enabledTime: String?

        public var endTime: String?

        public var expectSpec: String?

        public var lineOperator: String?

        public var loaStatus: String?

        public var name: String?

        public var orderMode: String?

        public var parentPhysicalConnectionAliUid: String?

        public var parentPhysicalConnectionId: String?

        public var peerLocation: String?

        public var physicalConnectionId: String?

        public var portNumber: String?

        public var portType: String?

        public var productType: String?

        public var redundantPhysicalConnectionId: String?

        public var resourceGroupId: String?

        public var spec: String?

        public var status: String?

        public var tags: [ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections.Tags]?

        public var type: String?

        public var virtualPhysicalConnectionStatus: String?

        public var vlanId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointId != nil {
                map["AccessPointId"] = self.accessPointId!
            }
            if self.adLocation != nil {
                map["AdLocation"] = self.adLocation!
            }
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.circuitCode != nil {
                map["CircuitCode"] = self.circuitCode!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabledTime != nil {
                map["EnabledTime"] = self.enabledTime!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.expectSpec != nil {
                map["ExpectSpec"] = self.expectSpec!
            }
            if self.lineOperator != nil {
                map["LineOperator"] = self.lineOperator!
            }
            if self.loaStatus != nil {
                map["LoaStatus"] = self.loaStatus!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.orderMode != nil {
                map["OrderMode"] = self.orderMode!
            }
            if self.parentPhysicalConnectionAliUid != nil {
                map["ParentPhysicalConnectionAliUid"] = self.parentPhysicalConnectionAliUid!
            }
            if self.parentPhysicalConnectionId != nil {
                map["ParentPhysicalConnectionId"] = self.parentPhysicalConnectionId!
            }
            if self.peerLocation != nil {
                map["PeerLocation"] = self.peerLocation!
            }
            if self.physicalConnectionId != nil {
                map["PhysicalConnectionId"] = self.physicalConnectionId!
            }
            if self.portNumber != nil {
                map["PortNumber"] = self.portNumber!
            }
            if self.portType != nil {
                map["PortType"] = self.portType!
            }
            if self.productType != nil {
                map["ProductType"] = self.productType!
            }
            if self.redundantPhysicalConnectionId != nil {
                map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.virtualPhysicalConnectionStatus != nil {
                map["VirtualPhysicalConnectionStatus"] = self.virtualPhysicalConnectionStatus!
            }
            if self.vlanId != nil {
                map["VlanId"] = self.vlanId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessPointId") {
                self.accessPointId = dict["AccessPointId"] as! String
            }
            if dict.keys.contains("AdLocation") {
                self.adLocation = dict["AdLocation"] as! String
            }
            if dict.keys.contains("AliUid") {
                self.aliUid = dict["AliUid"] as! String
            }
            if dict.keys.contains("Bandwidth") {
                self.bandwidth = dict["Bandwidth"] as! Int64
            }
            if dict.keys.contains("BusinessStatus") {
                self.businessStatus = dict["BusinessStatus"] as! String
            }
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("CircuitCode") {
                self.circuitCode = dict["CircuitCode"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnabledTime") {
                self.enabledTime = dict["EnabledTime"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("ExpectSpec") {
                self.expectSpec = dict["ExpectSpec"] as! String
            }
            if dict.keys.contains("LineOperator") {
                self.lineOperator = dict["LineOperator"] as! String
            }
            if dict.keys.contains("LoaStatus") {
                self.loaStatus = dict["LoaStatus"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrderMode") {
                self.orderMode = dict["OrderMode"] as! String
            }
            if dict.keys.contains("ParentPhysicalConnectionAliUid") {
                self.parentPhysicalConnectionAliUid = dict["ParentPhysicalConnectionAliUid"] as! String
            }
            if dict.keys.contains("ParentPhysicalConnectionId") {
                self.parentPhysicalConnectionId = dict["ParentPhysicalConnectionId"] as! String
            }
            if dict.keys.contains("PeerLocation") {
                self.peerLocation = dict["PeerLocation"] as! String
            }
            if dict.keys.contains("PhysicalConnectionId") {
                self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
            }
            if dict.keys.contains("PortNumber") {
                self.portNumber = dict["PortNumber"] as! String
            }
            if dict.keys.contains("PortType") {
                self.portType = dict["PortType"] as! String
            }
            if dict.keys.contains("ProductType") {
                self.productType = dict["ProductType"] as! String
            }
            if dict.keys.contains("RedundantPhysicalConnectionId") {
                self.redundantPhysicalConnectionId = dict["RedundantPhysicalConnectionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("VirtualPhysicalConnectionStatus") {
                self.virtualPhysicalConnectionStatus = dict["VirtualPhysicalConnectionStatus"] as! String
            }
            if dict.keys.contains("VlanId") {
                self.vlanId = dict["VlanId"] as! String
            }
        }
    }
    public var count: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualPhysicalConnections: [ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualPhysicalConnections != nil {
            var tmp : [Any] = []
            for k in self.virtualPhysicalConnections! {
                tmp.append(k.toMap())
            }
            map["VirtualPhysicalConnections"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VirtualPhysicalConnections") {
            var tmp : [ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections] = []
            for v in dict["VirtualPhysicalConnections"] as! [Any] {
                var model = ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.virtualPhysicalConnections = tmp
        }
    }
}

public class ListVirtualPhysicalConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVirtualPhysicalConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVirtualPhysicalConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVpcEndpointServicesByEndUserRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListVpcEndpointServicesByEndUserResponseBody : Tea.TeaModel {
    public class Services : Tea.TeaModel {
        public var defaultPolicyDocument: String?

        public var serviceDomain: String?

        public var serviceId: String?

        public var serviceName: String?

        public var supportPolicy: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultPolicyDocument != nil {
                map["DefaultPolicyDocument"] = self.defaultPolicyDocument!
            }
            if self.serviceDomain != nil {
                map["ServiceDomain"] = self.serviceDomain!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.supportPolicy != nil {
                map["SupportPolicy"] = self.supportPolicy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultPolicyDocument") {
                self.defaultPolicyDocument = dict["DefaultPolicyDocument"] as! String
            }
            if dict.keys.contains("ServiceDomain") {
                self.serviceDomain = dict["ServiceDomain"] as! String
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("SupportPolicy") {
                self.supportPolicy = dict["SupportPolicy"] as! Bool
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var services: [ListVpcEndpointServicesByEndUserResponseBody.Services]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Services") {
            var tmp : [ListVpcEndpointServicesByEndUserResponseBody.Services] = []
            for v in dict["Services"] as! [Any] {
                var model = ListVpcEndpointServicesByEndUserResponseBody.Services()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.services = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListVpcEndpointServicesByEndUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcEndpointServicesByEndUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVpcEndpointServicesByEndUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVpcGatewayEndpointsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var endpointId: String?

    public var endpointName: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public var tags: [ListVpcGatewayEndpointsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointId") {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("EndpointName") {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [ListVpcGatewayEndpointsRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = ListVpcGatewayEndpointsRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class ListVpcGatewayEndpointsResponseBody : Tea.TeaModel {
    public class Endpoints : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var associatedRouteTables: [String]?

        public var creationTime: String?

        public var endpointDescription: String?

        public var endpointId: String?

        public var endpointName: String?

        public var endpointStatus: String?

        public var policyDocument: String?

        public var resourceGroupId: String?

        public var serviceName: String?

        public var tags: [ListVpcGatewayEndpointsResponseBody.Endpoints.Tags]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associatedRouteTables != nil {
                map["AssociatedRouteTables"] = self.associatedRouteTables!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.endpointDescription != nil {
                map["EndpointDescription"] = self.endpointDescription!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.endpointName != nil {
                map["EndpointName"] = self.endpointName!
            }
            if self.endpointStatus != nil {
                map["EndpointStatus"] = self.endpointStatus!
            }
            if self.policyDocument != nil {
                map["PolicyDocument"] = self.policyDocument!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociatedRouteTables") {
                self.associatedRouteTables = dict["AssociatedRouteTables"] as! [String]
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EndpointDescription") {
                self.endpointDescription = dict["EndpointDescription"] as! String
            }
            if dict.keys.contains("EndpointId") {
                self.endpointId = dict["EndpointId"] as! String
            }
            if dict.keys.contains("EndpointName") {
                self.endpointName = dict["EndpointName"] as! String
            }
            if dict.keys.contains("EndpointStatus") {
                self.endpointStatus = dict["EndpointStatus"] as! String
            }
            if dict.keys.contains("PolicyDocument") {
                self.policyDocument = dict["PolicyDocument"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [ListVpcGatewayEndpointsResponseBody.Endpoints.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListVpcGatewayEndpointsResponseBody.Endpoints.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var endpoints: [ListVpcGatewayEndpointsResponseBody.Endpoints]?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpoints != nil {
            var tmp : [Any] = []
            for k in self.endpoints! {
                tmp.append(k.toMap())
            }
            map["Endpoints"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Endpoints") {
            var tmp : [ListVpcGatewayEndpointsResponseBody.Endpoints] = []
            for v in dict["Endpoints"] as! [Any] {
                var model = ListVpcGatewayEndpointsResponseBody.Endpoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpoints = tmp
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListVpcGatewayEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcGatewayEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVpcGatewayEndpointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVpcPublishedRouteEntriesRequest : Tea.TeaModel {
    public var destinationCidrBlock: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var targetInstanceId: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("TargetInstanceId") {
            self.targetInstanceId = dict["TargetInstanceId"] as! String
        }
        if dict.keys.contains("TargetType") {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class ListVpcPublishedRouteEntriesResponseBody : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public class RoutePublishTargets : Tea.TeaModel {
            public var publishStatus: String?

            public var publishTargetInstanceId: String?

            public var publishTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.publishStatus != nil {
                    map["PublishStatus"] = self.publishStatus!
                }
                if self.publishTargetInstanceId != nil {
                    map["PublishTargetInstanceId"] = self.publishTargetInstanceId!
                }
                if self.publishTargetType != nil {
                    map["PublishTargetType"] = self.publishTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PublishStatus") {
                    self.publishStatus = dict["PublishStatus"] as! String
                }
                if dict.keys.contains("PublishTargetInstanceId") {
                    self.publishTargetInstanceId = dict["PublishTargetInstanceId"] as! String
                }
                if dict.keys.contains("PublishTargetType") {
                    self.publishTargetType = dict["PublishTargetType"] as! String
                }
            }
        }
        public var destinationCidrBlock: String?

        public var routeEntryId: String?

        public var routePublishTargets: [ListVpcPublishedRouteEntriesResponseBody.RouteEntries.RoutePublishTargets]?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.routeEntryId != nil {
                map["RouteEntryId"] = self.routeEntryId!
            }
            if self.routePublishTargets != nil {
                var tmp : [Any] = []
                for k in self.routePublishTargets! {
                    tmp.append(k.toMap())
                }
                map["RoutePublishTargets"] = tmp
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("RouteEntryId") {
                self.routeEntryId = dict["RouteEntryId"] as! String
            }
            if dict.keys.contains("RoutePublishTargets") {
                var tmp : [ListVpcPublishedRouteEntriesResponseBody.RouteEntries.RoutePublishTargets] = []
                for v in dict["RoutePublishTargets"] as! [Any] {
                    var model = ListVpcPublishedRouteEntriesResponseBody.RouteEntries.RoutePublishTargets()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routePublishTargets = tmp
            }
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var routeEntries: [ListVpcPublishedRouteEntriesResponseBody.RouteEntries]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntries") {
            var tmp : [ListVpcPublishedRouteEntriesResponseBody.RouteEntries] = []
            for v in dict["RouteEntries"] as! [Any] {
                var model = ListVpcPublishedRouteEntriesResponseBody.RouteEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeEntries = tmp
        }
    }
}

public class ListVpcPublishedRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcPublishedRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVpcPublishedRouteEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVpnCertificateAssociationsRequest : Tea.TeaModel {
    public var certificateId: [String]?

    public var certificateType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var vpnGatewayId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.certificateType != nil {
            map["CertificateType"] = self.certificateType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateId") {
            self.certificateId = dict["CertificateId"] as! [String]
        }
        if dict.keys.contains("CertificateType") {
            self.certificateType = dict["CertificateType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! [String]
        }
    }
}

public class ListVpnCertificateAssociationsResponseBody : Tea.TeaModel {
    public class VpnCertificateRelations : Tea.TeaModel {
        public var associationTime: String?

        public var certificateId: String?

        public var certificateType: String?

        public var regionId: String?

        public var vpnGatewayId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associationTime != nil {
                map["AssociationTime"] = self.associationTime!
            }
            if self.certificateId != nil {
                map["CertificateId"] = self.certificateId!
            }
            if self.certificateType != nil {
                map["CertificateType"] = self.certificateType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.vpnGatewayId != nil {
                map["VpnGatewayId"] = self.vpnGatewayId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociationTime") {
                self.associationTime = dict["AssociationTime"] as! String
            }
            if dict.keys.contains("CertificateId") {
                self.certificateId = dict["CertificateId"] as! String
            }
            if dict.keys.contains("CertificateType") {
                self.certificateType = dict["CertificateType"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("VpnGatewayId") {
                self.vpnGatewayId = dict["VpnGatewayId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnCertificateRelations: [ListVpnCertificateAssociationsResponseBody.VpnCertificateRelations]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnCertificateRelations != nil {
            var tmp : [Any] = []
            for k in self.vpnCertificateRelations! {
                tmp.append(k.toMap())
            }
            map["VpnCertificateRelations"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpnCertificateRelations") {
            var tmp : [ListVpnCertificateAssociationsResponseBody.VpnCertificateRelations] = []
            for v in dict["VpnCertificateRelations"] as! [Any] {
                var model = ListVpnCertificateAssociationsResponseBody.VpnCertificateRelations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vpnCertificateRelations = tmp
        }
    }
}

public class ListVpnCertificateAssociationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpnCertificateAssociationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVpnCertificateAssociationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBgpGroupAttributeRequest : Tea.TeaModel {
    public var authKey: String?

    public var bgpGroupId: String?

    public var clearAuthKey: Bool?

    public var clientToken: String?

    public var description_: String?

    public var isFakeAsn: Bool?

    public var localAsn: Int64?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerAsn: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeQuota: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.clearAuthKey != nil {
            map["ClearAuthKey"] = self.clearAuthKey!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.isFakeAsn != nil {
            map["IsFakeAsn"] = self.isFakeAsn!
        }
        if self.localAsn != nil {
            map["LocalAsn"] = self.localAsn!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerAsn != nil {
            map["PeerAsn"] = self.peerAsn!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeQuota != nil {
            map["RouteQuota"] = self.routeQuota!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("BgpGroupId") {
            self.bgpGroupId = dict["BgpGroupId"] as! String
        }
        if dict.keys.contains("ClearAuthKey") {
            self.clearAuthKey = dict["ClearAuthKey"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IsFakeAsn") {
            self.isFakeAsn = dict["IsFakeAsn"] as! Bool
        }
        if dict.keys.contains("LocalAsn") {
            self.localAsn = dict["LocalAsn"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerAsn") {
            self.peerAsn = dict["PeerAsn"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteQuota") {
            self.routeQuota = dict["RouteQuota"] as! Int32
        }
    }
}

public class ModifyBgpGroupAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBgpGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBgpGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyBgpGroupAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBgpPeerAttributeRequest : Tea.TeaModel {
    public var bfdMultiHop: Int32?

    public var bgpGroupId: String?

    public var bgpPeerId: String?

    public var clientToken: String?

    public var enableBfd: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bfdMultiHop != nil {
            map["BfdMultiHop"] = self.bfdMultiHop!
        }
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.bgpPeerId != nil {
            map["BgpPeerId"] = self.bgpPeerId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableBfd != nil {
            map["EnableBfd"] = self.enableBfd!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerIpAddress != nil {
            map["PeerIpAddress"] = self.peerIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BfdMultiHop") {
            self.bfdMultiHop = dict["BfdMultiHop"] as! Int32
        }
        if dict.keys.contains("BgpGroupId") {
            self.bgpGroupId = dict["BgpGroupId"] as! String
        }
        if dict.keys.contains("BgpPeerId") {
            self.bgpPeerId = dict["BgpPeerId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableBfd") {
            self.enableBfd = dict["EnableBfd"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerIpAddress") {
            self.peerIpAddress = dict["PeerIpAddress"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyBgpPeerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBgpPeerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBgpPeerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyBgpPeerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCommonBandwidthPackageAttributeRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyCommonBandwidthPackageAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCommonBandwidthPackageAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCommonBandwidthPackageAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCommonBandwidthPackageAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCommonBandwidthPackageIpBandwidthRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var bandwidthPackageId: String?

    public var eipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.eipId != nil {
            map["EipId"] = self.eipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("EipId") {
            self.eipId = dict["EipId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyCommonBandwidthPackageIpBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCommonBandwidthPackageIpBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCommonBandwidthPackageIpBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCommonBandwidthPackageIpBandwidthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCommonBandwidthPackageSpecRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var bandwidthPackageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyCommonBandwidthPackageSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCommonBandwidthPackageSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCommonBandwidthPackageSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCommonBandwidthPackageSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCustomerGatewayAttributeRequest : Tea.TeaModel {
    public var authKey: String?

    public var clientToken: String?

    public var customerGatewayId: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyCustomerGatewayAttributeResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ModifyCustomerGatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCustomerGatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCustomerGatewayAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEipAddressAttributeRequest : Tea.TeaModel {
    public var allocationId: String?

    public var bandwidth: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyEipAddressAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEipAddressAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEipAddressAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEipAddressAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyExpressCloudConnectionAttributeRequest : Tea.TeaModel {
    public var bgpAs: String?

    public var ceIp: String?

    public var description_: String?

    public var eccId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peIp: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpAs != nil {
            map["BgpAs"] = self.bgpAs!
        }
        if self.ceIp != nil {
            map["CeIp"] = self.ceIp!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eccId != nil {
            map["EccId"] = self.eccId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peIp != nil {
            map["PeIp"] = self.peIp!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgpAs") {
            self.bgpAs = dict["BgpAs"] as! String
        }
        if dict.keys.contains("CeIp") {
            self.ceIp = dict["CeIp"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EccId") {
            self.eccId = dict["EccId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeIp") {
            self.peIp = dict["PeIp"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyExpressCloudConnectionAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyExpressCloudConnectionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressCloudConnectionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyExpressCloudConnectionAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyExpressCloudConnectionBandwidthRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var eccId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.eccId != nil {
            map["EccId"] = self.eccId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("EccId") {
            self.eccId = dict["EccId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyExpressCloudConnectionBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyExpressCloudConnectionBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressCloudConnectionBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyExpressCloudConnectionBandwidthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyExpressConnectTrafficQosRequest : Tea.TeaModel {
    public class AddInstanceList : Tea.TeaModel {
        public var instanceId: String?

        public var instanceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
        }
    }
    public class RemoveInstanceList : Tea.TeaModel {
        public var instanceId: String?

        public var instanceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
        }
    }
    public var addInstanceList: [ModifyExpressConnectTrafficQosRequest.AddInstanceList]?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosDescription: String?

    public var qosId: String?

    public var qosName: String?

    public var regionId: String?

    public var removeInstanceList: [ModifyExpressConnectTrafficQosRequest.RemoveInstanceList]?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addInstanceList != nil {
            var tmp : [Any] = []
            for k in self.addInstanceList! {
                tmp.append(k.toMap())
            }
            map["AddInstanceList"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosDescription != nil {
            map["QosDescription"] = self.qosDescription!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.qosName != nil {
            map["QosName"] = self.qosName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeInstanceList != nil {
            var tmp : [Any] = []
            for k in self.removeInstanceList! {
                tmp.append(k.toMap())
            }
            map["RemoveInstanceList"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddInstanceList") {
            var tmp : [ModifyExpressConnectTrafficQosRequest.AddInstanceList] = []
            for v in dict["AddInstanceList"] as! [Any] {
                var model = ModifyExpressConnectTrafficQosRequest.AddInstanceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addInstanceList = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosDescription") {
            self.qosDescription = dict["QosDescription"] as! String
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QosName") {
            self.qosName = dict["QosName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoveInstanceList") {
            var tmp : [ModifyExpressConnectTrafficQosRequest.RemoveInstanceList] = []
            for v in dict["RemoveInstanceList"] as! [Any] {
                var model = ModifyExpressConnectTrafficQosRequest.RemoveInstanceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.removeInstanceList = tmp
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class ModifyExpressConnectTrafficQosResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyExpressConnectTrafficQosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressConnectTrafficQosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyExpressConnectTrafficQosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyExpressConnectTrafficQosQueueRequest : Tea.TeaModel {
    public var bandwidthPercent: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueDescription: String?

    public var queueId: String?

    public var queueName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPercent != nil {
            map["BandwidthPercent"] = self.bandwidthPercent!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueDescription != nil {
            map["QueueDescription"] = self.queueDescription!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.queueName != nil {
            map["QueueName"] = self.queueName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPercent") {
            self.bandwidthPercent = dict["BandwidthPercent"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueDescription") {
            self.queueDescription = dict["QueueDescription"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("QueueName") {
            self.queueName = dict["QueueName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class ModifyExpressConnectTrafficQosQueueResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyExpressConnectTrafficQosQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressConnectTrafficQosQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyExpressConnectTrafficQosQueueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyExpressConnectTrafficQosRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dstCidr: String?

    public var dstIPv6Cidr: String?

    public var dstPortRange: String?

    public var matchDscp: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var protocol_: String?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var remarkingDscp: Int32?

    public var resourceOwnerAccount: String?

    public var ruleDescription: String?

    public var ruleId: String?

    public var ruleName: String?

    public var srcCidr: String?

    public var srcIPv6Cidr: String?

    public var srcPortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dstCidr != nil {
            map["DstCidr"] = self.dstCidr!
        }
        if self.dstIPv6Cidr != nil {
            map["DstIPv6Cidr"] = self.dstIPv6Cidr!
        }
        if self.dstPortRange != nil {
            map["DstPortRange"] = self.dstPortRange!
        }
        if self.matchDscp != nil {
            map["MatchDscp"] = self.matchDscp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remarkingDscp != nil {
            map["RemarkingDscp"] = self.remarkingDscp!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.ruleDescription != nil {
            map["RuleDescription"] = self.ruleDescription!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.srcCidr != nil {
            map["SrcCidr"] = self.srcCidr!
        }
        if self.srcIPv6Cidr != nil {
            map["SrcIPv6Cidr"] = self.srcIPv6Cidr!
        }
        if self.srcPortRange != nil {
            map["SrcPortRange"] = self.srcPortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DstCidr") {
            self.dstCidr = dict["DstCidr"] as! String
        }
        if dict.keys.contains("DstIPv6Cidr") {
            self.dstIPv6Cidr = dict["DstIPv6Cidr"] as! String
        }
        if dict.keys.contains("DstPortRange") {
            self.dstPortRange = dict["DstPortRange"] as! String
        }
        if dict.keys.contains("MatchDscp") {
            self.matchDscp = dict["MatchDscp"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("QosId") {
            self.qosId = dict["QosId"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemarkingDscp") {
            self.remarkingDscp = dict["RemarkingDscp"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("RuleDescription") {
            self.ruleDescription = dict["RuleDescription"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("SrcCidr") {
            self.srcCidr = dict["SrcCidr"] as! String
        }
        if dict.keys.contains("SrcIPv6Cidr") {
            self.srcIPv6Cidr = dict["SrcIPv6Cidr"] as! String
        }
        if dict.keys.contains("SrcPortRange") {
            self.srcPortRange = dict["SrcPortRange"] as! String
        }
    }
}

public class ModifyExpressConnectTrafficQosRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyExpressConnectTrafficQosRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressConnectTrafficQosRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyExpressConnectTrafficQosRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyFlowLogAttributeRequest : Tea.TeaModel {
    public var aggregationInterval: Int32?

    public var description_: String?

    public var flowLogId: String?

    public var flowLogName: String?

    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregationInterval != nil {
            map["AggregationInterval"] = self.aggregationInterval!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.flowLogName != nil {
            map["FlowLogName"] = self.flowLogName!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AggregationInterval") {
            self.aggregationInterval = dict["AggregationInterval"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FlowLogId") {
            self.flowLogId = dict["FlowLogId"] as! String
        }
        if dict.keys.contains("FlowLogName") {
            self.flowLogName = dict["FlowLogName"] as! String
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyFlowLogAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyFlowLogAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFlowLogAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyFlowLogAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyForwardEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryId: String?

    public var forwardEntryName: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portBreak: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portBreak != nil {
            map["PortBreak"] = self.portBreak!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ExternalIp") {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ExternalPort") {
            self.externalPort = dict["ExternalPort"] as! String
        }
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardEntryName") {
            self.forwardEntryName = dict["ForwardEntryName"] as! String
        }
        if dict.keys.contains("ForwardTableId") {
            self.forwardTableId = dict["ForwardTableId"] as! String
        }
        if dict.keys.contains("InternalIp") {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("InternalPort") {
            self.internalPort = dict["InternalPort"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PortBreak") {
            self.portBreak = dict["PortBreak"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyFullNatEntryAttributeRequest : Tea.TeaModel {
    public var accessIp: String?

    public var accessPort: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var fullNatEntryDescription: String?

    public var fullNatEntryId: String?

    public var fullNatEntryName: String?

    public var fullNatTableId: String?

    public var ipProtocol: String?

    public var natIp: String?

    public var natIpPort: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessIp != nil {
            map["AccessIp"] = self.accessIp!
        }
        if self.accessPort != nil {
            map["AccessPort"] = self.accessPort!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.fullNatEntryDescription != nil {
            map["FullNatEntryDescription"] = self.fullNatEntryDescription!
        }
        if self.fullNatEntryId != nil {
            map["FullNatEntryId"] = self.fullNatEntryId!
        }
        if self.fullNatEntryName != nil {
            map["FullNatEntryName"] = self.fullNatEntryName!
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpPort != nil {
            map["NatIpPort"] = self.natIpPort!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessIp") {
            self.accessIp = dict["AccessIp"] as! String
        }
        if dict.keys.contains("AccessPort") {
            self.accessPort = dict["AccessPort"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("FullNatEntryDescription") {
            self.fullNatEntryDescription = dict["FullNatEntryDescription"] as! String
        }
        if dict.keys.contains("FullNatEntryId") {
            self.fullNatEntryId = dict["FullNatEntryId"] as! String
        }
        if dict.keys.contains("FullNatEntryName") {
            self.fullNatEntryName = dict["FullNatEntryName"] as! String
        }
        if dict.keys.contains("FullNatTableId") {
            self.fullNatTableId = dict["FullNatTableId"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("NatIp") {
            self.natIp = dict["NatIp"] as! String
        }
        if dict.keys.contains("NatIpPort") {
            self.natIpPort = dict["NatIpPort"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyFullNatEntryAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyFullNatEntryAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFullNatEntryAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyFullNatEntryAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyGlobalAccelerationInstanceAttributesRequest : Tea.TeaModel {
    public var description_: String?

    public var globalAccelerationInstanceId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GlobalAccelerationInstanceId") {
            self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyGlobalAccelerationInstanceAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyGlobalAccelerationInstanceAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGlobalAccelerationInstanceAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyGlobalAccelerationInstanceAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyGlobalAccelerationInstanceSpecRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var globalAccelerationInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("GlobalAccelerationInstanceId") {
            self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyGlobalAccelerationInstanceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyGlobalAccelerationInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGlobalAccelerationInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyGlobalAccelerationInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHaVipAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var haVipId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyHaVipAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyHaVipAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHaVipAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyHaVipAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorAclAttributeRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclName: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclName") {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyIPv6TranslatorAclAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIPv6TranslatorAclAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorAclAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIPv6TranslatorAclAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorAclListEntryRequest : Tea.TeaModel {
    public var aclEntryComment: String?

    public var aclEntryId: String?

    public var aclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntryComment != nil {
            map["AclEntryComment"] = self.aclEntryComment!
        }
        if self.aclEntryId != nil {
            map["AclEntryId"] = self.aclEntryId!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntryComment") {
            self.aclEntryComment = dict["AclEntryComment"] as! String
        }
        if dict.keys.contains("AclEntryId") {
            self.aclEntryId = dict["AclEntryId"] as! String
        }
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyIPv6TranslatorAclListEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIPv6TranslatorAclListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorAclListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIPv6TranslatorAclListEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var ipv6TranslatorId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorId") {
            self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyIPv6TranslatorAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIPv6TranslatorAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIPv6TranslatorAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorBandwidthRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var bandwidth: Int32?

    public var clientToken: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorId") {
            self.ipv6TranslatorId = dict["Ipv6TranslatorId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyIPv6TranslatorBandwidthResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIPv6TranslatorBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIPv6TranslatorBandwidthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorEntryRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclStatus: String?

    public var aclType: String?

    public var allocateIpv6Port: Int32?

    public var backendIpv4Addr: String?

    public var backendIpv4Port: Int32?

    public var entryBandwidth: Int32?

    public var entryDescription: String?

    public var entryName: String?

    public var ipv6TranslatorEntryId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var transProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclStatus != nil {
            map["AclStatus"] = self.aclStatus!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.allocateIpv6Port != nil {
            map["AllocateIpv6Port"] = self.allocateIpv6Port!
        }
        if self.backendIpv4Addr != nil {
            map["BackendIpv4Addr"] = self.backendIpv4Addr!
        }
        if self.backendIpv4Port != nil {
            map["BackendIpv4Port"] = self.backendIpv4Port!
        }
        if self.entryBandwidth != nil {
            map["EntryBandwidth"] = self.entryBandwidth!
        }
        if self.entryDescription != nil {
            map["EntryDescription"] = self.entryDescription!
        }
        if self.entryName != nil {
            map["EntryName"] = self.entryName!
        }
        if self.ipv6TranslatorEntryId != nil {
            map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.transProtocol != nil {
            map["TransProtocol"] = self.transProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclStatus") {
            self.aclStatus = dict["AclStatus"] as! String
        }
        if dict.keys.contains("AclType") {
            self.aclType = dict["AclType"] as! String
        }
        if dict.keys.contains("AllocateIpv6Port") {
            self.allocateIpv6Port = dict["AllocateIpv6Port"] as! Int32
        }
        if dict.keys.contains("BackendIpv4Addr") {
            self.backendIpv4Addr = dict["BackendIpv4Addr"] as! String
        }
        if dict.keys.contains("BackendIpv4Port") {
            self.backendIpv4Port = dict["BackendIpv4Port"] as! Int32
        }
        if dict.keys.contains("EntryBandwidth") {
            self.entryBandwidth = dict["EntryBandwidth"] as! Int32
        }
        if dict.keys.contains("EntryDescription") {
            self.entryDescription = dict["EntryDescription"] as! String
        }
        if dict.keys.contains("EntryName") {
            self.entryName = dict["EntryName"] as! String
        }
        if dict.keys.contains("Ipv6TranslatorEntryId") {
            self.ipv6TranslatorEntryId = dict["Ipv6TranslatorEntryId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TransProtocol") {
            self.transProtocol = dict["TransProtocol"] as! String
        }
    }
}

public class ModifyIPv6TranslatorEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIPv6TranslatorEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIPv6TranslatorEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIpv6AddressAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var ipv6AddressId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv6AddressId") {
            self.ipv6AddressId = dict["Ipv6AddressId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyIpv6AddressAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIpv6AddressAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpv6AddressAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIpv6AddressAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIpv6GatewayAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var ipv6GatewayId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv6GatewayId") {
            self.ipv6GatewayId = dict["Ipv6GatewayId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyIpv6GatewayAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIpv6GatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpv6GatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIpv6GatewayAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIpv6InternetBandwidthRequest : Tea.TeaModel {
    public var bandwidth: Int64?

    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6AddressId: String?

    public var ipv6InternetBandwidthId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ipv6InternetBandwidthId != nil {
            map["Ipv6InternetBandwidthId"] = self.ipv6InternetBandwidthId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int64
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv6AddressId") {
            self.ipv6AddressId = dict["Ipv6AddressId"] as! String
        }
        if dict.keys.contains("Ipv6InternetBandwidthId") {
            self.ipv6InternetBandwidthId = dict["Ipv6InternetBandwidthId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyIpv6InternetBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIpv6InternetBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpv6InternetBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIpv6InternetBandwidthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNatGatewayAttributeRequest : Tea.TeaModel {
    public class LogDelivery : Tea.TeaModel {
        public var logDeliveryType: String?

        public var logDestination: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logDeliveryType != nil {
                map["LogDeliveryType"] = self.logDeliveryType!
            }
            if self.logDestination != nil {
                map["LogDestination"] = self.logDestination!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogDeliveryType") {
                self.logDeliveryType = dict["LogDeliveryType"] as! String
            }
            if dict.keys.contains("LogDestination") {
                self.logDestination = dict["LogDestination"] as! String
            }
        }
    }
    public var description_: String?

    public var eipBindMode: String?

    public var enableSessionLog: Bool?

    public var icmpReplyEnabled: Bool?

    public var logDelivery: ModifyNatGatewayAttributeRequest.LogDelivery?

    public var name: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logDelivery?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipBindMode != nil {
            map["EipBindMode"] = self.eipBindMode!
        }
        if self.enableSessionLog != nil {
            map["EnableSessionLog"] = self.enableSessionLog!
        }
        if self.icmpReplyEnabled != nil {
            map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
        }
        if self.logDelivery != nil {
            map["LogDelivery"] = self.logDelivery?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipBindMode") {
            self.eipBindMode = dict["EipBindMode"] as! String
        }
        if dict.keys.contains("EnableSessionLog") {
            self.enableSessionLog = dict["EnableSessionLog"] as! Bool
        }
        if dict.keys.contains("IcmpReplyEnabled") {
            self.icmpReplyEnabled = dict["IcmpReplyEnabled"] as! Bool
        }
        if dict.keys.contains("LogDelivery") {
            var model = ModifyNatGatewayAttributeRequest.LogDelivery()
            model.fromMap(dict["LogDelivery"] as! [String: Any])
            self.logDelivery = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyNatGatewayAttributeShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var eipBindMode: String?

    public var enableSessionLog: Bool?

    public var icmpReplyEnabled: Bool?

    public var logDeliveryShrink: String?

    public var name: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipBindMode != nil {
            map["EipBindMode"] = self.eipBindMode!
        }
        if self.enableSessionLog != nil {
            map["EnableSessionLog"] = self.enableSessionLog!
        }
        if self.icmpReplyEnabled != nil {
            map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
        }
        if self.logDeliveryShrink != nil {
            map["LogDelivery"] = self.logDeliveryShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipBindMode") {
            self.eipBindMode = dict["EipBindMode"] as! String
        }
        if dict.keys.contains("EnableSessionLog") {
            self.enableSessionLog = dict["EnableSessionLog"] as! Bool
        }
        if dict.keys.contains("IcmpReplyEnabled") {
            self.icmpReplyEnabled = dict["IcmpReplyEnabled"] as! Bool
        }
        if dict.keys.contains("LogDelivery") {
            self.logDeliveryShrink = dict["LogDelivery"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyNatGatewayAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNatGatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNatGatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNatGatewayAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNatGatewaySpecRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class ModifyNatGatewaySpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNatGatewaySpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNatGatewaySpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNatGatewaySpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNatIpAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natIpDescription: String?

    public var natIpId: String?

    public var natIpName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natIpDescription != nil {
            map["NatIpDescription"] = self.natIpDescription!
        }
        if self.natIpId != nil {
            map["NatIpId"] = self.natIpId!
        }
        if self.natIpName != nil {
            map["NatIpName"] = self.natIpName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NatIpDescription") {
            self.natIpDescription = dict["NatIpDescription"] as! String
        }
        if dict.keys.contains("NatIpId") {
            self.natIpId = dict["NatIpId"] as! String
        }
        if dict.keys.contains("NatIpName") {
            self.natIpName = dict["NatIpName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyNatIpAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNatIpAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNatIpAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNatIpAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNatIpCidrAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var natIpCidrDescription: String?

    public var natIpCidrName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpCidrDescription != nil {
            map["NatIpCidrDescription"] = self.natIpCidrDescription!
        }
        if self.natIpCidrName != nil {
            map["NatIpCidrName"] = self.natIpCidrName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatIpCidr") {
            self.natIpCidr = dict["NatIpCidr"] as! String
        }
        if dict.keys.contains("NatIpCidrDescription") {
            self.natIpCidrDescription = dict["NatIpCidrDescription"] as! String
        }
        if dict.keys.contains("NatIpCidrName") {
            self.natIpCidrName = dict["NatIpCidrName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyNatIpCidrAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNatIpCidrAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNatIpCidrAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNatIpCidrAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNetworkAclAttributesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var networkAclName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("NetworkAclName") {
            self.networkAclName = dict["NetworkAclName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyNetworkAclAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNetworkAclAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNetworkAclAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNetworkAclAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPhysicalConnectionAttributeRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var lineOperator: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerLocation: String?

    public var physicalConnectionId: String?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var bandwidth: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.bandwidth != nil {
            map["bandwidth"] = self.bandwidth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CircuitCode") {
            self.circuitCode = dict["CircuitCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LineOperator") {
            self.lineOperator = dict["LineOperator"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerLocation") {
            self.peerLocation = dict["PeerLocation"] as! String
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("PortType") {
            self.portType = dict["PortType"] as! String
        }
        if dict.keys.contains("RedundantPhysicalConnectionId") {
            self.redundantPhysicalConnectionId = dict["RedundantPhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("bandwidth") {
            self.bandwidth = dict["bandwidth"] as! Int32
        }
    }
}

public class ModifyPhysicalConnectionAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPhysicalConnectionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPhysicalConnectionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPhysicalConnectionAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRouteEntryRequest : Tea.TeaModel {
    public var description_: String?

    public var destinationCidrBlock: String?

    public var newNextHopId: String?

    public var newNextHopType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryId: String?

    public var routeEntryName: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.newNextHopId != nil {
            map["NewNextHopId"] = self.newNextHopId!
        }
        if self.newNextHopType != nil {
            map["NewNextHopType"] = self.newNextHopType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("NewNextHopId") {
            self.newNextHopId = dict["NewNextHopId"] as! String
        }
        if dict.keys.contains("NewNextHopType") {
            self.newNextHopType = dict["NewNextHopType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntryId") {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
        if dict.keys.contains("RouteEntryName") {
            self.routeEntryName = dict["RouteEntryName"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class ModifyRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRouteTableAttributesRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routePropagationEnable: Bool?

    public var routeTableId: String?

    public var routeTableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routePropagationEnable != nil {
            map["RoutePropagationEnable"] = self.routePropagationEnable!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RoutePropagationEnable") {
            self.routePropagationEnable = dict["RoutePropagationEnable"] as! Bool
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("RouteTableName") {
            self.routeTableName = dict["RouteTableName"] as! String
        }
    }
}

public class ModifyRouteTableAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyRouteTableAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouteTableAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyRouteTableAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRouterInterfaceAttributeRequest : Tea.TeaModel {
    public var deleteHealthCheckIp: Bool?

    public var description_: String?

    public var hcRate: Int32?

    public var hcThreshold: Int32?

    public var healthCheckSourceIp: String?

    public var healthCheckTargetIp: String?

    public var name: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: Int64?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteHealthCheckIp != nil {
            map["DeleteHealthCheckIp"] = self.deleteHealthCheckIp!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hcRate != nil {
            map["HcRate"] = self.hcRate!
        }
        if self.hcThreshold != nil {
            map["HcThreshold"] = self.hcThreshold!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteHealthCheckIp") {
            self.deleteHealthCheckIp = dict["DeleteHealthCheckIp"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HcRate") {
            self.hcRate = dict["HcRate"] as! Int32
        }
        if dict.keys.contains("HcThreshold") {
            self.hcThreshold = dict["HcThreshold"] as! Int32
        }
        if dict.keys.contains("HealthCheckSourceIp") {
            self.healthCheckSourceIp = dict["HealthCheckSourceIp"] as! String
        }
        if dict.keys.contains("HealthCheckTargetIp") {
            self.healthCheckTargetIp = dict["HealthCheckTargetIp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OppositeInterfaceId") {
            self.oppositeInterfaceId = dict["OppositeInterfaceId"] as! String
        }
        if dict.keys.contains("OppositeInterfaceOwnerId") {
            self.oppositeInterfaceOwnerId = dict["OppositeInterfaceOwnerId"] as! Int64
        }
        if dict.keys.contains("OppositeRouterId") {
            self.oppositeRouterId = dict["OppositeRouterId"] as! String
        }
        if dict.keys.contains("OppositeRouterType") {
            self.oppositeRouterType = dict["OppositeRouterType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class ModifyRouterInterfaceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyRouterInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouterInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyRouterInterfaceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRouterInterfaceSpecRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class ModifyRouterInterfaceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class ModifyRouterInterfaceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouterInterfaceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyRouterInterfaceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySnatEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var eipAffinity: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snatEntryId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public var snatTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.eipAffinity != nil {
            map["EipAffinity"] = self.eipAffinity!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.snatTableId != nil {
            map["SnatTableId"] = self.snatTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EipAffinity") {
            self.eipAffinity = dict["EipAffinity"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatEntryName") {
            self.snatEntryName = dict["SnatEntryName"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
        if dict.keys.contains("SnatTableId") {
            self.snatTableId = dict["SnatTableId"] as! String
        }
    }
}

public class ModifySnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySslVpnClientCertRequest : Tea.TeaModel {
    public var clientToken: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslVpnClientCertId") {
            self.sslVpnClientCertId = dict["SslVpnClientCertId"] as! String
        }
    }
}

public class ModifySslVpnClientCertResponseBody : Tea.TeaModel {
    public var name: String?

    public var requestId: String?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SslVpnClientCertId") {
            self.sslVpnClientCertId = dict["SslVpnClientCertId"] as! String
        }
    }
}

public class ModifySslVpnClientCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySslVpnClientCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySslVpnClientCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySslVpnServerRequest : Tea.TeaModel {
    public var cipher: String?

    public var clientIpPool: String?

    public var clientToken: String?

    public var compress: Bool?

    public var enableMultiFactorAuth: Bool?

    public var IDaaSApplicationId: String?

    public var IDaaSInstanceId: String?

    public var IDaaSRegionId: String?

    public var localSubnet: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var port: Int32?

    public var proto: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipher != nil {
            map["Cipher"] = self.cipher!
        }
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compress != nil {
            map["Compress"] = self.compress!
        }
        if self.enableMultiFactorAuth != nil {
            map["EnableMultiFactorAuth"] = self.enableMultiFactorAuth!
        }
        if self.IDaaSApplicationId != nil {
            map["IDaaSApplicationId"] = self.IDaaSApplicationId!
        }
        if self.IDaaSInstanceId != nil {
            map["IDaaSInstanceId"] = self.IDaaSInstanceId!
        }
        if self.IDaaSRegionId != nil {
            map["IDaaSRegionId"] = self.IDaaSRegionId!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.proto != nil {
            map["Proto"] = self.proto!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cipher") {
            self.cipher = dict["Cipher"] as! String
        }
        if dict.keys.contains("ClientIpPool") {
            self.clientIpPool = dict["ClientIpPool"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Compress") {
            self.compress = dict["Compress"] as! Bool
        }
        if dict.keys.contains("EnableMultiFactorAuth") {
            self.enableMultiFactorAuth = dict["EnableMultiFactorAuth"] as! Bool
        }
        if dict.keys.contains("IDaaSApplicationId") {
            self.IDaaSApplicationId = dict["IDaaSApplicationId"] as! String
        }
        if dict.keys.contains("IDaaSInstanceId") {
            self.IDaaSInstanceId = dict["IDaaSInstanceId"] as! String
        }
        if dict.keys.contains("IDaaSRegionId") {
            self.IDaaSRegionId = dict["IDaaSRegionId"] as! String
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Proto") {
            self.proto = dict["Proto"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SslVpnServerId") {
            self.sslVpnServerId = dict["SslVpnServerId"] as! String
        }
    }
}

public class ModifySslVpnServerResponseBody : Tea.TeaModel {
    public var cipher: String?

    public var clientIpPool: String?

    public var compress: Bool?

    public var connections: Int32?

    public var createTime: Int64?

    public var enableMultiFactorAuth: Bool?

    public var IDaaSApplicationId: String?

    public var IDaaSInstanceId: String?

    public var IDaaSInstanceVersion: String?

    public var internetIp: String?

    public var localSubnet: String?

    public var maxConnections: Int32?

    public var name: String?

    public var port: Int32?

    public var proto: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var sslVpnServerId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipher != nil {
            map["Cipher"] = self.cipher!
        }
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.compress != nil {
            map["Compress"] = self.compress!
        }
        if self.connections != nil {
            map["Connections"] = self.connections!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.enableMultiFactorAuth != nil {
            map["EnableMultiFactorAuth"] = self.enableMultiFactorAuth!
        }
        if self.IDaaSApplicationId != nil {
            map["IDaaSApplicationId"] = self.IDaaSApplicationId!
        }
        if self.IDaaSInstanceId != nil {
            map["IDaaSInstanceId"] = self.IDaaSInstanceId!
        }
        if self.IDaaSInstanceVersion != nil {
            map["IDaaSInstanceVersion"] = self.IDaaSInstanceVersion!
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.maxConnections != nil {
            map["MaxConnections"] = self.maxConnections!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.proto != nil {
            map["Proto"] = self.proto!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cipher") {
            self.cipher = dict["Cipher"] as! String
        }
        if dict.keys.contains("ClientIpPool") {
            self.clientIpPool = dict["ClientIpPool"] as! String
        }
        if dict.keys.contains("Compress") {
            self.compress = dict["Compress"] as! Bool
        }
        if dict.keys.contains("Connections") {
            self.connections = dict["Connections"] as! Int32
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("EnableMultiFactorAuth") {
            self.enableMultiFactorAuth = dict["EnableMultiFactorAuth"] as! Bool
        }
        if dict.keys.contains("IDaaSApplicationId") {
            self.IDaaSApplicationId = dict["IDaaSApplicationId"] as! String
        }
        if dict.keys.contains("IDaaSInstanceId") {
            self.IDaaSInstanceId = dict["IDaaSInstanceId"] as! String
        }
        if dict.keys.contains("IDaaSInstanceVersion") {
            self.IDaaSInstanceVersion = dict["IDaaSInstanceVersion"] as! String
        }
        if dict.keys.contains("InternetIp") {
            self.internetIp = dict["InternetIp"] as! String
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("MaxConnections") {
            self.maxConnections = dict["MaxConnections"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Proto") {
            self.proto = dict["Proto"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SslVpnServerId") {
            self.sslVpnServerId = dict["SslVpnServerId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class ModifySslVpnServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySslVpnServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySslVpnServerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTunnelAttributeRequest : Tea.TeaModel {
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalAsn") {
                    self.localAsn = dict["LocalAsn"] as! Int64
                }
                if dict.keys.contains("LocalBgpIp") {
                    self.localBgpIp = dict["LocalBgpIp"] as! String
                }
                if dict.keys.contains("TunnelCidr") {
                    self.tunnelCidr = dict["TunnelCidr"] as! String
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IkeAuthAlg") {
                    self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                }
                if dict.keys.contains("IkeEncAlg") {
                    self.ikeEncAlg = dict["IkeEncAlg"] as! String
                }
                if dict.keys.contains("IkeLifetime") {
                    self.ikeLifetime = dict["IkeLifetime"] as! Int64
                }
                if dict.keys.contains("IkeMode") {
                    self.ikeMode = dict["IkeMode"] as! String
                }
                if dict.keys.contains("IkePfs") {
                    self.ikePfs = dict["IkePfs"] as! String
                }
                if dict.keys.contains("IkeVersion") {
                    self.ikeVersion = dict["IkeVersion"] as! String
                }
                if dict.keys.contains("LocalId") {
                    self.localId = dict["LocalId"] as! String
                }
                if dict.keys.contains("Psk") {
                    self.psk = dict["Psk"] as! String
                }
                if dict.keys.contains("RemoteId") {
                    self.remoteId = dict["RemoteId"] as! String
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpsecAuthAlg") {
                    self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                }
                if dict.keys.contains("IpsecEncAlg") {
                    self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                }
                if dict.keys.contains("IpsecLifetime") {
                    self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
                }
                if dict.keys.contains("IpsecPfs") {
                    self.ipsecPfs = dict["IpsecPfs"] as! String
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var remoteCaCertificate: String?

        public var tunnelBgpConfig: ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelIkeConfig: ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIpsecConfig: ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.remoteCaCertificate != nil {
                map["RemoteCaCertificate"] = self.remoteCaCertificate!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomerGatewayId") {
                self.customerGatewayId = dict["CustomerGatewayId"] as! String
            }
            if dict.keys.contains("EnableDpd") {
                self.enableDpd = dict["EnableDpd"] as! Bool
            }
            if dict.keys.contains("EnableNatTraversal") {
                self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
            }
            if dict.keys.contains("RemoteCaCertificate") {
                self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
            }
            if dict.keys.contains("TunnelBgpConfig") {
                var model = ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
                self.tunnelBgpConfig = model
            }
            if dict.keys.contains("TunnelIkeConfig") {
                var model = ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
                self.tunnelIkeConfig = model
            }
            if dict.keys.contains("TunnelIpsecConfig") {
                var model = ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tunnelId: String?

    public var tunnelOptionsSpecification: ModifyTunnelAttributeRequest.TunnelOptionsSpecification?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tunnelOptionsSpecification?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tunnelId != nil {
            map["TunnelId"] = self.tunnelId!
        }
        if self.tunnelOptionsSpecification != nil {
            map["TunnelOptionsSpecification"] = self.tunnelOptionsSpecification?.toMap()
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TunnelId") {
            self.tunnelId = dict["TunnelId"] as! String
        }
        if dict.keys.contains("TunnelOptionsSpecification") {
            var model = ModifyTunnelAttributeRequest.TunnelOptionsSpecification()
            model.fromMap(dict["TunnelOptionsSpecification"] as! [String: Any])
            self.tunnelOptionsSpecification = model
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class ModifyTunnelAttributeResponseBody : Tea.TeaModel {
    public class TunnelBgpConfig : Tea.TeaModel {
        public var enableBgp: Bool?

        public var localAsn: Int64?

        public var localBgpIp: String?

        public var peerAsn: Int64?

        public var peerBgpIp: String?

        public var tunnelCidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableBgp != nil {
                map["EnableBgp"] = self.enableBgp!
            }
            if self.localAsn != nil {
                map["LocalAsn"] = self.localAsn!
            }
            if self.localBgpIp != nil {
                map["LocalBgpIp"] = self.localBgpIp!
            }
            if self.peerAsn != nil {
                map["PeerAsn"] = self.peerAsn!
            }
            if self.peerBgpIp != nil {
                map["PeerBgpIp"] = self.peerBgpIp!
            }
            if self.tunnelCidr != nil {
                map["TunnelCidr"] = self.tunnelCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableBgp") {
                self.enableBgp = dict["EnableBgp"] as! Bool
            }
            if dict.keys.contains("LocalAsn") {
                self.localAsn = dict["LocalAsn"] as! Int64
            }
            if dict.keys.contains("LocalBgpIp") {
                self.localBgpIp = dict["LocalBgpIp"] as! String
            }
            if dict.keys.contains("PeerAsn") {
                self.peerAsn = dict["PeerAsn"] as! Int64
            }
            if dict.keys.contains("PeerBgpIp") {
                self.peerBgpIp = dict["PeerBgpIp"] as! String
            }
            if dict.keys.contains("TunnelCidr") {
                self.tunnelCidr = dict["TunnelCidr"] as! String
            }
        }
    }
    public class TunnelIkeConfig : Tea.TeaModel {
        public var ikeAuthAlg: String?

        public var ikeEncAlg: String?

        public var ikeLifetime: Int64?

        public var ikeMode: String?

        public var ikePfs: String?

        public var ikeVersion: String?

        public var localId: String?

        public var psk: String?

        public var remoteId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ikeAuthAlg != nil {
                map["IkeAuthAlg"] = self.ikeAuthAlg!
            }
            if self.ikeEncAlg != nil {
                map["IkeEncAlg"] = self.ikeEncAlg!
            }
            if self.ikeLifetime != nil {
                map["IkeLifetime"] = self.ikeLifetime!
            }
            if self.ikeMode != nil {
                map["IkeMode"] = self.ikeMode!
            }
            if self.ikePfs != nil {
                map["IkePfs"] = self.ikePfs!
            }
            if self.ikeVersion != nil {
                map["IkeVersion"] = self.ikeVersion!
            }
            if self.localId != nil {
                map["LocalId"] = self.localId!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.remoteId != nil {
                map["RemoteId"] = self.remoteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IkeAuthAlg") {
                self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
            }
            if dict.keys.contains("IkeEncAlg") {
                self.ikeEncAlg = dict["IkeEncAlg"] as! String
            }
            if dict.keys.contains("IkeLifetime") {
                self.ikeLifetime = dict["IkeLifetime"] as! Int64
            }
            if dict.keys.contains("IkeMode") {
                self.ikeMode = dict["IkeMode"] as! String
            }
            if dict.keys.contains("IkePfs") {
                self.ikePfs = dict["IkePfs"] as! String
            }
            if dict.keys.contains("IkeVersion") {
                self.ikeVersion = dict["IkeVersion"] as! String
            }
            if dict.keys.contains("LocalId") {
                self.localId = dict["LocalId"] as! String
            }
            if dict.keys.contains("Psk") {
                self.psk = dict["Psk"] as! String
            }
            if dict.keys.contains("RemoteId") {
                self.remoteId = dict["RemoteId"] as! String
            }
        }
    }
    public class TunnelIpsecConfig : Tea.TeaModel {
        public var ipsecAuthAlg: String?

        public var ipsecEncAlg: String?

        public var ipsecLifetime: Int64?

        public var ipsecPfs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipsecAuthAlg != nil {
                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
            }
            if self.ipsecEncAlg != nil {
                map["IpsecEncAlg"] = self.ipsecEncAlg!
            }
            if self.ipsecLifetime != nil {
                map["IpsecLifetime"] = self.ipsecLifetime!
            }
            if self.ipsecPfs != nil {
                map["IpsecPfs"] = self.ipsecPfs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpsecAuthAlg") {
                self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
            }
            if dict.keys.contains("IpsecEncAlg") {
                self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
            }
            if dict.keys.contains("IpsecLifetime") {
                self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
            }
            if dict.keys.contains("IpsecPfs") {
                self.ipsecPfs = dict["IpsecPfs"] as! String
            }
        }
    }
    public var customerGatewayId: String?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var internetIp: String?

    public var remoteCaCertificate: String?

    public var requestId: String?

    public var role: String?

    public var state: String?

    public var tunnelBgpConfig: ModifyTunnelAttributeResponseBody.TunnelBgpConfig?

    public var tunnelId: String?

    public var tunnelIkeConfig: ModifyTunnelAttributeResponseBody.TunnelIkeConfig?

    public var tunnelIpsecConfig: ModifyTunnelAttributeResponseBody.TunnelIpsecConfig?

    public var zoneNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tunnelBgpConfig?.validate()
        try self.tunnelIkeConfig?.validate()
        try self.tunnelIpsecConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.remoteCaCertificate != nil {
            map["RemoteCaCertificate"] = self.remoteCaCertificate!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.tunnelBgpConfig != nil {
            map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
        }
        if self.tunnelId != nil {
            map["TunnelId"] = self.tunnelId!
        }
        if self.tunnelIkeConfig != nil {
            map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
        }
        if self.tunnelIpsecConfig != nil {
            map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
        }
        if self.zoneNo != nil {
            map["ZoneNo"] = self.zoneNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("EnableDpd") {
            self.enableDpd = dict["EnableDpd"] as! Bool
        }
        if dict.keys.contains("EnableNatTraversal") {
            self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
        }
        if dict.keys.contains("InternetIp") {
            self.internetIp = dict["InternetIp"] as! String
        }
        if dict.keys.contains("RemoteCaCertificate") {
            self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("TunnelBgpConfig") {
            var model = ModifyTunnelAttributeResponseBody.TunnelBgpConfig()
            model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
            self.tunnelBgpConfig = model
        }
        if dict.keys.contains("TunnelId") {
            self.tunnelId = dict["TunnelId"] as! String
        }
        if dict.keys.contains("TunnelIkeConfig") {
            var model = ModifyTunnelAttributeResponseBody.TunnelIkeConfig()
            model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
            self.tunnelIkeConfig = model
        }
        if dict.keys.contains("TunnelIpsecConfig") {
            var model = ModifyTunnelAttributeResponseBody.TunnelIpsecConfig()
            model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
            self.tunnelIpsecConfig = model
        }
        if dict.keys.contains("ZoneNo") {
            self.zoneNo = dict["ZoneNo"] as! String
        }
    }
}

public class ModifyTunnelAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTunnelAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTunnelAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVRouterAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VRouterId: String?

    public var VRouterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.VRouterName != nil {
            map["VRouterName"] = self.VRouterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
        if dict.keys.contains("VRouterName") {
            self.VRouterName = dict["VRouterName"] as! String
        }
    }
}

public class ModifyVRouterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVRouterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVRouterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVRouterAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVSwitchAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var enableIPv6: Bool?

    public var ipv6CidrBlock: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public var vpcIpv6CidrBlock: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableIPv6 != nil {
            map["EnableIPv6"] = self.enableIPv6!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vpcIpv6CidrBlock != nil {
            map["VpcIpv6CidrBlock"] = self.vpcIpv6CidrBlock!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableIPv6") {
            self.enableIPv6 = dict["EnableIPv6"] as! Bool
        }
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
        if dict.keys.contains("VpcIpv6CidrBlock") {
            self.vpcIpv6CidrBlock = dict["VpcIpv6CidrBlock"] as! String
        }
    }
}

public class ModifyVSwitchAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVSwitchAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVSwitchAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVSwitchAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVSwitchCidrReservationAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchCidrReservationDescription: String?

    public var vSwitchCidrReservationId: String?

    public var vSwitchCidrReservationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchCidrReservationDescription != nil {
            map["VSwitchCidrReservationDescription"] = self.vSwitchCidrReservationDescription!
        }
        if self.vSwitchCidrReservationId != nil {
            map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
        }
        if self.vSwitchCidrReservationName != nil {
            map["VSwitchCidrReservationName"] = self.vSwitchCidrReservationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchCidrReservationDescription") {
            self.vSwitchCidrReservationDescription = dict["VSwitchCidrReservationDescription"] as! String
        }
        if dict.keys.contains("VSwitchCidrReservationId") {
            self.vSwitchCidrReservationId = dict["VSwitchCidrReservationId"] as! String
        }
        if dict.keys.contains("VSwitchCidrReservationName") {
            self.vSwitchCidrReservationName = dict["VSwitchCidrReservationName"] as! String
        }
    }
}

public class ModifyVSwitchCidrReservationAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVSwitchCidrReservationAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVSwitchCidrReservationAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVSwitchCidrReservationAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVcoRouteEntryWeightRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newWeight: Int32?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnConnectionId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newWeight != nil {
            map["NewWeight"] = self.newWeight!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NewWeight") {
            self.newWeight = dict["NewWeight"] as! Int32
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class ModifyVcoRouteEntryWeightResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVcoRouteEntryWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVcoRouteEntryWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVcoRouteEntryWeightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVirtualBorderRouterAttributeRequest : Tea.TeaModel {
    public var associatedPhysicalConnections: String?

    public var bandwidth: Int32?

    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var detectMultiplier: Int64?

    public var enableIpv6: Bool?

    public var localGatewayIp: String?

    public var localIpv6GatewayIp: String?

    public var minRxInterval: Int64?

    public var minTxInterval: Int64?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peerIpv6GatewayIp: String?

    public var peeringIpv6SubnetMask: String?

    public var peeringSubnetMask: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sitelinkEnable: Bool?

    public var vbrId: String?

    public var vlanId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associatedPhysicalConnections != nil {
            map["AssociatedPhysicalConnections"] = self.associatedPhysicalConnections!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.detectMultiplier != nil {
            map["DetectMultiplier"] = self.detectMultiplier!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.localIpv6GatewayIp != nil {
            map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
        }
        if self.minRxInterval != nil {
            map["MinRxInterval"] = self.minRxInterval!
        }
        if self.minTxInterval != nil {
            map["MinTxInterval"] = self.minTxInterval!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peerIpv6GatewayIp != nil {
            map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
        }
        if self.peeringIpv6SubnetMask != nil {
            map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sitelinkEnable != nil {
            map["SitelinkEnable"] = self.sitelinkEnable!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssociatedPhysicalConnections") {
            self.associatedPhysicalConnections = dict["AssociatedPhysicalConnections"] as! String
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("CircuitCode") {
            self.circuitCode = dict["CircuitCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DetectMultiplier") {
            self.detectMultiplier = dict["DetectMultiplier"] as! Int64
        }
        if dict.keys.contains("EnableIpv6") {
            self.enableIpv6 = dict["EnableIpv6"] as! Bool
        }
        if dict.keys.contains("LocalGatewayIp") {
            self.localGatewayIp = dict["LocalGatewayIp"] as! String
        }
        if dict.keys.contains("LocalIpv6GatewayIp") {
            self.localIpv6GatewayIp = dict["LocalIpv6GatewayIp"] as! String
        }
        if dict.keys.contains("MinRxInterval") {
            self.minRxInterval = dict["MinRxInterval"] as! Int64
        }
        if dict.keys.contains("MinTxInterval") {
            self.minTxInterval = dict["MinTxInterval"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerGatewayIp") {
            self.peerGatewayIp = dict["PeerGatewayIp"] as! String
        }
        if dict.keys.contains("PeerIpv6GatewayIp") {
            self.peerIpv6GatewayIp = dict["PeerIpv6GatewayIp"] as! String
        }
        if dict.keys.contains("PeeringIpv6SubnetMask") {
            self.peeringIpv6SubnetMask = dict["PeeringIpv6SubnetMask"] as! String
        }
        if dict.keys.contains("PeeringSubnetMask") {
            self.peeringSubnetMask = dict["PeeringSubnetMask"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SitelinkEnable") {
            self.sitelinkEnable = dict["SitelinkEnable"] as! Bool
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! Int32
        }
    }
}

public class ModifyVirtualBorderRouterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVirtualBorderRouterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVirtualBorderRouterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVirtualBorderRouterAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpcAttributeRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var enableDnsHostname: Bool?

    public var enableIPv6: Bool?

    public var ipv6CidrBlock: String?

    public var ipv6Isp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableDnsHostname != nil {
            map["EnableDnsHostname"] = self.enableDnsHostname!
        }
        if self.enableIPv6 != nil {
            map["EnableIPv6"] = self.enableIPv6!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ipv6Isp != nil {
            map["Ipv6Isp"] = self.ipv6Isp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableDnsHostname") {
            self.enableDnsHostname = dict["EnableDnsHostname"] as! Bool
        }
        if dict.keys.contains("EnableIPv6") {
            self.enableIPv6 = dict["EnableIPv6"] as! Bool
        }
        if dict.keys.contains("Ipv6CidrBlock") {
            self.ipv6CidrBlock = dict["Ipv6CidrBlock"] as! String
        }
        if dict.keys.contains("Ipv6Isp") {
            self.ipv6Isp = dict["Ipv6Isp"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcName") {
            self.vpcName = dict["VpcName"] as! String
        }
    }
}

public class ModifyVpcAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpcAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpcAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpcAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpcPrefixListRequest : Tea.TeaModel {
    public class AddPrefixListEntry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cidr") {
                self.cidr = dict["Cidr"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class RemovePrefixListEntry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cidr") {
                self.cidr = dict["Cidr"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public var addPrefixListEntry: [ModifyVpcPrefixListRequest.AddPrefixListEntry]?

    public var clientToken: String?

    public var dryRun: Bool?

    public var maxEntries: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListDescription: String?

    public var prefixListId: String?

    public var prefixListName: String?

    public var regionId: String?

    public var removePrefixListEntry: [ModifyVpcPrefixListRequest.RemovePrefixListEntry]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addPrefixListEntry != nil {
            var tmp : [Any] = []
            for k in self.addPrefixListEntry! {
                tmp.append(k.toMap())
            }
            map["AddPrefixListEntry"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.maxEntries != nil {
            map["MaxEntries"] = self.maxEntries!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListDescription != nil {
            map["PrefixListDescription"] = self.prefixListDescription!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removePrefixListEntry != nil {
            var tmp : [Any] = []
            for k in self.removePrefixListEntry! {
                tmp.append(k.toMap())
            }
            map["RemovePrefixListEntry"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddPrefixListEntry") {
            var tmp : [ModifyVpcPrefixListRequest.AddPrefixListEntry] = []
            for v in dict["AddPrefixListEntry"] as! [Any] {
                var model = ModifyVpcPrefixListRequest.AddPrefixListEntry()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addPrefixListEntry = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("MaxEntries") {
            self.maxEntries = dict["MaxEntries"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListDescription") {
            self.prefixListDescription = dict["PrefixListDescription"] as! String
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("PrefixListName") {
            self.prefixListName = dict["PrefixListName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemovePrefixListEntry") {
            var tmp : [ModifyVpcPrefixListRequest.RemovePrefixListEntry] = []
            for v in dict["RemovePrefixListEntry"] as! [Any] {
                var model = ModifyVpcPrefixListRequest.RemovePrefixListEntry()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.removePrefixListEntry = tmp
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyVpcPrefixListResponseBody : Tea.TeaModel {
    public var prefixListId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpcPrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpcPrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpcPrefixListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpnAttachmentAttributeRequest : Tea.TeaModel {
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalAsn") {
                    self.localAsn = dict["LocalAsn"] as! Int64
                }
                if dict.keys.contains("LocalBgpIp") {
                    self.localBgpIp = dict["LocalBgpIp"] as! String
                }
                if dict.keys.contains("TunnelCidr") {
                    self.tunnelCidr = dict["TunnelCidr"] as! String
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IkeAuthAlg") {
                    self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                }
                if dict.keys.contains("IkeEncAlg") {
                    self.ikeEncAlg = dict["IkeEncAlg"] as! String
                }
                if dict.keys.contains("IkeLifetime") {
                    self.ikeLifetime = dict["IkeLifetime"] as! Int64
                }
                if dict.keys.contains("IkeMode") {
                    self.ikeMode = dict["IkeMode"] as! String
                }
                if dict.keys.contains("IkePfs") {
                    self.ikePfs = dict["IkePfs"] as! String
                }
                if dict.keys.contains("IkeVersion") {
                    self.ikeVersion = dict["IkeVersion"] as! String
                }
                if dict.keys.contains("LocalId") {
                    self.localId = dict["LocalId"] as! String
                }
                if dict.keys.contains("Psk") {
                    self.psk = dict["Psk"] as! String
                }
                if dict.keys.contains("RemoteId") {
                    self.remoteId = dict["RemoteId"] as! String
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int32?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpsecAuthAlg") {
                    self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                }
                if dict.keys.contains("IpsecEncAlg") {
                    self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                }
                if dict.keys.contains("IpsecLifetime") {
                    self.ipsecLifetime = dict["IpsecLifetime"] as! Int32
                }
                if dict.keys.contains("IpsecPfs") {
                    self.ipsecPfs = dict["IpsecPfs"] as! String
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var tunnelBgpConfig: ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelId: String?

        public var tunnelIkeConfig: ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIndex: Int32?

        public var tunnelIpsecConfig: ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelId != nil {
                map["TunnelId"] = self.tunnelId!
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIndex != nil {
                map["TunnelIndex"] = self.tunnelIndex!
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomerGatewayId") {
                self.customerGatewayId = dict["CustomerGatewayId"] as! String
            }
            if dict.keys.contains("EnableDpd") {
                self.enableDpd = dict["EnableDpd"] as! Bool
            }
            if dict.keys.contains("EnableNatTraversal") {
                self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
            }
            if dict.keys.contains("TunnelBgpConfig") {
                var model = ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
                self.tunnelBgpConfig = model
            }
            if dict.keys.contains("TunnelId") {
                self.tunnelId = dict["TunnelId"] as! String
            }
            if dict.keys.contains("TunnelIkeConfig") {
                var model = ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
                self.tunnelIkeConfig = model
            }
            if dict.keys.contains("TunnelIndex") {
                self.tunnelIndex = dict["TunnelIndex"] as! Int32
            }
            if dict.keys.contains("TunnelIpsecConfig") {
                var model = ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var autoConfigRoute: Bool?

    public var bgpConfig: String?

    public var clientToken: String?

    public var customerGatewayId: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var healthCheckConfig: String?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var name: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var remoteCaCert: String?

    public var remoteSubnet: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tunnelOptionsSpecification: [ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification]?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoConfigRoute != nil {
            map["AutoConfigRoute"] = self.autoConfigRoute!
        }
        if self.bgpConfig != nil {
            map["BgpConfig"] = self.bgpConfig!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.healthCheckConfig != nil {
            map["HealthCheckConfig"] = self.healthCheckConfig!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCaCert != nil {
            map["RemoteCaCert"] = self.remoteCaCert!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoConfigRoute") {
            self.autoConfigRoute = dict["AutoConfigRoute"] as! Bool
        }
        if dict.keys.contains("BgpConfig") {
            self.bgpConfig = dict["BgpConfig"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("EffectImmediately") {
            self.effectImmediately = dict["EffectImmediately"] as! Bool
        }
        if dict.keys.contains("EnableDpd") {
            self.enableDpd = dict["EnableDpd"] as! Bool
        }
        if dict.keys.contains("EnableNatTraversal") {
            self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
        }
        if dict.keys.contains("EnableTunnelsBgp") {
            self.enableTunnelsBgp = dict["EnableTunnelsBgp"] as! Bool
        }
        if dict.keys.contains("HealthCheckConfig") {
            self.healthCheckConfig = dict["HealthCheckConfig"] as! String
        }
        if dict.keys.contains("IkeConfig") {
            self.ikeConfig = dict["IkeConfig"] as! String
        }
        if dict.keys.contains("IpsecConfig") {
            self.ipsecConfig = dict["IpsecConfig"] as! String
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteCaCert") {
            self.remoteCaCert = dict["RemoteCaCert"] as! String
        }
        if dict.keys.contains("RemoteSubnet") {
            self.remoteSubnet = dict["RemoteSubnet"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TunnelOptionsSpecification") {
            var tmp : [ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification] = []
            for v in dict["TunnelOptionsSpecification"] as! [Any] {
                var model = ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tunnelOptionsSpecification = tmp
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class ModifyVpnAttachmentAttributeResponseBody : Tea.TeaModel {
    public class IkeConfig : Tea.TeaModel {
        public var ikeAuthAlg: String?

        public var ikeEncAlg: String?

        public var ikeLifetime: Int64?

        public var ikeMode: String?

        public var ikePfs: String?

        public var ikeVersion: String?

        public var localId: String?

        public var psk: String?

        public var remoteId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ikeAuthAlg != nil {
                map["IkeAuthAlg"] = self.ikeAuthAlg!
            }
            if self.ikeEncAlg != nil {
                map["IkeEncAlg"] = self.ikeEncAlg!
            }
            if self.ikeLifetime != nil {
                map["IkeLifetime"] = self.ikeLifetime!
            }
            if self.ikeMode != nil {
                map["IkeMode"] = self.ikeMode!
            }
            if self.ikePfs != nil {
                map["IkePfs"] = self.ikePfs!
            }
            if self.ikeVersion != nil {
                map["IkeVersion"] = self.ikeVersion!
            }
            if self.localId != nil {
                map["LocalId"] = self.localId!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.remoteId != nil {
                map["RemoteId"] = self.remoteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IkeAuthAlg") {
                self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
            }
            if dict.keys.contains("IkeEncAlg") {
                self.ikeEncAlg = dict["IkeEncAlg"] as! String
            }
            if dict.keys.contains("IkeLifetime") {
                self.ikeLifetime = dict["IkeLifetime"] as! Int64
            }
            if dict.keys.contains("IkeMode") {
                self.ikeMode = dict["IkeMode"] as! String
            }
            if dict.keys.contains("IkePfs") {
                self.ikePfs = dict["IkePfs"] as! String
            }
            if dict.keys.contains("IkeVersion") {
                self.ikeVersion = dict["IkeVersion"] as! String
            }
            if dict.keys.contains("LocalId") {
                self.localId = dict["LocalId"] as! String
            }
            if dict.keys.contains("Psk") {
                self.psk = dict["Psk"] as! String
            }
            if dict.keys.contains("RemoteId") {
                self.remoteId = dict["RemoteId"] as! String
            }
        }
    }
    public class IpsecConfig : Tea.TeaModel {
        public var ipsecAuthAlg: String?

        public var ipsecEncAlg: String?

        public var ipsecLifetime: Int64?

        public var ipsecPfs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipsecAuthAlg != nil {
                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
            }
            if self.ipsecEncAlg != nil {
                map["IpsecEncAlg"] = self.ipsecEncAlg!
            }
            if self.ipsecLifetime != nil {
                map["IpsecLifetime"] = self.ipsecLifetime!
            }
            if self.ipsecPfs != nil {
                map["IpsecPfs"] = self.ipsecPfs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpsecAuthAlg") {
                self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
            }
            if dict.keys.contains("IpsecEncAlg") {
                self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
            }
            if dict.keys.contains("IpsecLifetime") {
                self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
            }
            if dict.keys.contains("IpsecPfs") {
                self.ipsecPfs = dict["IpsecPfs"] as! String
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var peerAsn: Int64?

            public var peerBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.peerAsn != nil {
                    map["PeerAsn"] = self.peerAsn!
                }
                if self.peerBgpIp != nil {
                    map["PeerBgpIp"] = self.peerBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalAsn") {
                    self.localAsn = dict["LocalAsn"] as! Int64
                }
                if dict.keys.contains("LocalBgpIp") {
                    self.localBgpIp = dict["LocalBgpIp"] as! String
                }
                if dict.keys.contains("PeerAsn") {
                    self.peerAsn = dict["PeerAsn"] as! Int64
                }
                if dict.keys.contains("PeerBgpIp") {
                    self.peerBgpIp = dict["PeerBgpIp"] as! String
                }
                if dict.keys.contains("TunnelCidr") {
                    self.tunnelCidr = dict["TunnelCidr"] as! String
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IkeAuthAlg") {
                    self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                }
                if dict.keys.contains("IkeEncAlg") {
                    self.ikeEncAlg = dict["IkeEncAlg"] as! String
                }
                if dict.keys.contains("IkeLifetime") {
                    self.ikeLifetime = dict["IkeLifetime"] as! Int64
                }
                if dict.keys.contains("IkeMode") {
                    self.ikeMode = dict["IkeMode"] as! String
                }
                if dict.keys.contains("IkePfs") {
                    self.ikePfs = dict["IkePfs"] as! String
                }
                if dict.keys.contains("IkeVersion") {
                    self.ikeVersion = dict["IkeVersion"] as! String
                }
                if dict.keys.contains("LocalId") {
                    self.localId = dict["LocalId"] as! String
                }
                if dict.keys.contains("Psk") {
                    self.psk = dict["Psk"] as! String
                }
                if dict.keys.contains("RemoteId") {
                    self.remoteId = dict["RemoteId"] as! String
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpsecAuthAlg") {
                    self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                }
                if dict.keys.contains("IpsecEncAlg") {
                    self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                }
                if dict.keys.contains("IpsecLifetime") {
                    self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
                }
                if dict.keys.contains("IpsecPfs") {
                    self.ipsecPfs = dict["IpsecPfs"] as! String
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var internetIp: String?

        public var role: String?

        public var state: String?

        public var tunnelBgpConfig: ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelId: String?

        public var tunnelIkeConfig: ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIndex: Int32?

        public var tunnelIpsecConfig: ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelId != nil {
                map["TunnelId"] = self.tunnelId!
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIndex != nil {
                map["TunnelIndex"] = self.tunnelIndex!
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomerGatewayId") {
                self.customerGatewayId = dict["CustomerGatewayId"] as! String
            }
            if dict.keys.contains("EnableDpd") {
                self.enableDpd = dict["EnableDpd"] as! Bool
            }
            if dict.keys.contains("EnableNatTraversal") {
                self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
            }
            if dict.keys.contains("InternetIp") {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TunnelBgpConfig") {
                var model = ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
                self.tunnelBgpConfig = model
            }
            if dict.keys.contains("TunnelId") {
                self.tunnelId = dict["TunnelId"] as! String
            }
            if dict.keys.contains("TunnelIkeConfig") {
                var model = ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
                self.tunnelIkeConfig = model
            }
            if dict.keys.contains("TunnelIndex") {
                self.tunnelIndex = dict["TunnelIndex"] as! Int32
            }
            if dict.keys.contains("TunnelIpsecConfig") {
                var model = ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
                self.tunnelIpsecConfig = model
            }
        }
    }
    public class VcoHealthCheck : Tea.TeaModel {
        public var dip: String?

        public var enable: String?

        public var interval: Int32?

        public var policy: String?

        public var retry: Int32?

        public var sip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dip != nil {
                map["Dip"] = self.dip!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.retry != nil {
                map["Retry"] = self.retry!
            }
            if self.sip != nil {
                map["Sip"] = self.sip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dip") {
                self.dip = dict["Dip"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! String
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Retry") {
                self.retry = dict["Retry"] as! Int32
            }
            if dict.keys.contains("Sip") {
                self.sip = dict["Sip"] as! String
            }
        }
    }
    public class VpnBgpConfig : Tea.TeaModel {
        public var enableBgp: String?

        public var localAsn: Int64?

        public var localBgpIp: String?

        public var peerAsn: Int64?

        public var peerBgpIp: String?

        public var status: String?

        public var tunnelCidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableBgp != nil {
                map["EnableBgp"] = self.enableBgp!
            }
            if self.localAsn != nil {
                map["LocalAsn"] = self.localAsn!
            }
            if self.localBgpIp != nil {
                map["LocalBgpIp"] = self.localBgpIp!
            }
            if self.peerAsn != nil {
                map["PeerAsn"] = self.peerAsn!
            }
            if self.peerBgpIp != nil {
                map["PeerBgpIp"] = self.peerBgpIp!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tunnelCidr != nil {
                map["TunnelCidr"] = self.tunnelCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableBgp") {
                self.enableBgp = dict["EnableBgp"] as! String
            }
            if dict.keys.contains("LocalAsn") {
                self.localAsn = dict["LocalAsn"] as! Int64
            }
            if dict.keys.contains("LocalBgpIp") {
                self.localBgpIp = dict["LocalBgpIp"] as! String
            }
            if dict.keys.contains("PeerAsn") {
                self.peerAsn = dict["PeerAsn"] as! Int64
            }
            if dict.keys.contains("PeerBgpIp") {
                self.peerBgpIp = dict["PeerBgpIp"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TunnelCidr") {
                self.tunnelCidr = dict["TunnelCidr"] as! String
            }
        }
    }
    public var attachInstanceId: String?

    public var attachType: String?

    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var ikeConfig: ModifyVpnAttachmentAttributeResponseBody.IkeConfig?

    public var ipsecConfig: ModifyVpnAttachmentAttributeResponseBody.IpsecConfig?

    public var localSubnet: String?

    public var name: String?

    public var networkType: String?

    public var remoteSubnet: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var spec: String?

    public var status: String?

    public var tunnelOptionsSpecification: [ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification]?

    public var vcoHealthCheck: ModifyVpnAttachmentAttributeResponseBody.VcoHealthCheck?

    public var vpnBgpConfig: ModifyVpnAttachmentAttributeResponseBody.VpnBgpConfig?

    public var vpnConnectionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ikeConfig?.validate()
        try self.ipsecConfig?.validate()
        try self.vcoHealthCheck?.validate()
        try self.vpnBgpConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachInstanceId != nil {
            map["AttachInstanceId"] = self.attachInstanceId!
        }
        if self.attachType != nil {
            map["AttachType"] = self.attachType!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig?.toMap()
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig?.toMap()
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        if self.vcoHealthCheck != nil {
            map["VcoHealthCheck"] = self.vcoHealthCheck?.toMap()
        }
        if self.vpnBgpConfig != nil {
            map["VpnBgpConfig"] = self.vpnBgpConfig?.toMap()
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachInstanceId") {
            self.attachInstanceId = dict["AttachInstanceId"] as! String
        }
        if dict.keys.contains("AttachType") {
            self.attachType = dict["AttachType"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EffectImmediately") {
            self.effectImmediately = dict["EffectImmediately"] as! Bool
        }
        if dict.keys.contains("EnableDpd") {
            self.enableDpd = dict["EnableDpd"] as! Bool
        }
        if dict.keys.contains("EnableNatTraversal") {
            self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
        }
        if dict.keys.contains("EnableTunnelsBgp") {
            self.enableTunnelsBgp = dict["EnableTunnelsBgp"] as! Bool
        }
        if dict.keys.contains("IkeConfig") {
            var model = ModifyVpnAttachmentAttributeResponseBody.IkeConfig()
            model.fromMap(dict["IkeConfig"] as! [String: Any])
            self.ikeConfig = model
        }
        if dict.keys.contains("IpsecConfig") {
            var model = ModifyVpnAttachmentAttributeResponseBody.IpsecConfig()
            model.fromMap(dict["IpsecConfig"] as! [String: Any])
            self.ipsecConfig = model
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("RemoteSubnet") {
            self.remoteSubnet = dict["RemoteSubnet"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TunnelOptionsSpecification") {
            var tmp : [ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification] = []
            for v in dict["TunnelOptionsSpecification"] as! [Any] {
                var model = ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tunnelOptionsSpecification = tmp
        }
        if dict.keys.contains("VcoHealthCheck") {
            var model = ModifyVpnAttachmentAttributeResponseBody.VcoHealthCheck()
            model.fromMap(dict["VcoHealthCheck"] as! [String: Any])
            self.vcoHealthCheck = model
        }
        if dict.keys.contains("VpnBgpConfig") {
            var model = ModifyVpnAttachmentAttributeResponseBody.VpnBgpConfig()
            model.fromMap(dict["VpnBgpConfig"] as! [String: Any])
            self.vpnBgpConfig = model
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class ModifyVpnAttachmentAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnAttachmentAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpnAttachmentAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpnConnectionAttributeRequest : Tea.TeaModel {
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalAsn") {
                    self.localAsn = dict["LocalAsn"] as! Int64
                }
                if dict.keys.contains("LocalBgpIp") {
                    self.localBgpIp = dict["LocalBgpIp"] as! String
                }
                if dict.keys.contains("TunnelCidr") {
                    self.tunnelCidr = dict["TunnelCidr"] as! String
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IkeAuthAlg") {
                    self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                }
                if dict.keys.contains("IkeEncAlg") {
                    self.ikeEncAlg = dict["IkeEncAlg"] as! String
                }
                if dict.keys.contains("IkeLifetime") {
                    self.ikeLifetime = dict["IkeLifetime"] as! Int64
                }
                if dict.keys.contains("IkeMode") {
                    self.ikeMode = dict["IkeMode"] as! String
                }
                if dict.keys.contains("IkePfs") {
                    self.ikePfs = dict["IkePfs"] as! String
                }
                if dict.keys.contains("IkeVersion") {
                    self.ikeVersion = dict["IkeVersion"] as! String
                }
                if dict.keys.contains("LocalId") {
                    self.localId = dict["LocalId"] as! String
                }
                if dict.keys.contains("Psk") {
                    self.psk = dict["Psk"] as! String
                }
                if dict.keys.contains("RemoteId") {
                    self.remoteId = dict["RemoteId"] as! String
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int32?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpsecAuthAlg") {
                    self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                }
                if dict.keys.contains("IpsecEncAlg") {
                    self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                }
                if dict.keys.contains("IpsecLifetime") {
                    self.ipsecLifetime = dict["IpsecLifetime"] as! Int32
                }
                if dict.keys.contains("IpsecPfs") {
                    self.ipsecPfs = dict["IpsecPfs"] as! String
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var remoteCaCertificate: String?

        public var role: String?

        public var tunnelBgpConfig: ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelId: String?

        public var tunnelIkeConfig: ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIpsecConfig: ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.remoteCaCertificate != nil {
                map["RemoteCaCertificate"] = self.remoteCaCertificate!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelId != nil {
                map["TunnelId"] = self.tunnelId!
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomerGatewayId") {
                self.customerGatewayId = dict["CustomerGatewayId"] as! String
            }
            if dict.keys.contains("EnableDpd") {
                self.enableDpd = dict["EnableDpd"] as! Bool
            }
            if dict.keys.contains("EnableNatTraversal") {
                self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
            }
            if dict.keys.contains("RemoteCaCertificate") {
                self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("TunnelBgpConfig") {
                var model = ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
                self.tunnelBgpConfig = model
            }
            if dict.keys.contains("TunnelId") {
                self.tunnelId = dict["TunnelId"] as! String
            }
            if dict.keys.contains("TunnelIkeConfig") {
                var model = ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
                self.tunnelIkeConfig = model
            }
            if dict.keys.contains("TunnelIpsecConfig") {
                var model = ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var autoConfigRoute: Bool?

    public var bgpConfig: String?

    public var clientToken: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var healthCheckConfig: String?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var remoteCaCertificate: String?

    public var remoteSubnet: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tunnelOptionsSpecification: [ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification]?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoConfigRoute != nil {
            map["AutoConfigRoute"] = self.autoConfigRoute!
        }
        if self.bgpConfig != nil {
            map["BgpConfig"] = self.bgpConfig!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.healthCheckConfig != nil {
            map["HealthCheckConfig"] = self.healthCheckConfig!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCaCertificate != nil {
            map["RemoteCaCertificate"] = self.remoteCaCertificate!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoConfigRoute") {
            self.autoConfigRoute = dict["AutoConfigRoute"] as! Bool
        }
        if dict.keys.contains("BgpConfig") {
            self.bgpConfig = dict["BgpConfig"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EffectImmediately") {
            self.effectImmediately = dict["EffectImmediately"] as! Bool
        }
        if dict.keys.contains("EnableDpd") {
            self.enableDpd = dict["EnableDpd"] as! Bool
        }
        if dict.keys.contains("EnableNatTraversal") {
            self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
        }
        if dict.keys.contains("EnableTunnelsBgp") {
            self.enableTunnelsBgp = dict["EnableTunnelsBgp"] as! Bool
        }
        if dict.keys.contains("HealthCheckConfig") {
            self.healthCheckConfig = dict["HealthCheckConfig"] as! String
        }
        if dict.keys.contains("IkeConfig") {
            self.ikeConfig = dict["IkeConfig"] as! String
        }
        if dict.keys.contains("IpsecConfig") {
            self.ipsecConfig = dict["IpsecConfig"] as! String
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoteCaCertificate") {
            self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
        }
        if dict.keys.contains("RemoteSubnet") {
            self.remoteSubnet = dict["RemoteSubnet"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TunnelOptionsSpecification") {
            var tmp : [ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification] = []
            for v in dict["TunnelOptionsSpecification"] as! [Any] {
                var model = ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tunnelOptionsSpecification = tmp
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
    }
}

public class ModifyVpnConnectionAttributeResponseBody : Tea.TeaModel {
    public class IkeConfig : Tea.TeaModel {
        public var ikeAuthAlg: String?

        public var ikeEncAlg: String?

        public var ikeLifetime: Int64?

        public var ikeMode: String?

        public var ikePfs: String?

        public var ikeVersion: String?

        public var localId: String?

        public var psk: String?

        public var remoteId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ikeAuthAlg != nil {
                map["IkeAuthAlg"] = self.ikeAuthAlg!
            }
            if self.ikeEncAlg != nil {
                map["IkeEncAlg"] = self.ikeEncAlg!
            }
            if self.ikeLifetime != nil {
                map["IkeLifetime"] = self.ikeLifetime!
            }
            if self.ikeMode != nil {
                map["IkeMode"] = self.ikeMode!
            }
            if self.ikePfs != nil {
                map["IkePfs"] = self.ikePfs!
            }
            if self.ikeVersion != nil {
                map["IkeVersion"] = self.ikeVersion!
            }
            if self.localId != nil {
                map["LocalId"] = self.localId!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.remoteId != nil {
                map["RemoteId"] = self.remoteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IkeAuthAlg") {
                self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
            }
            if dict.keys.contains("IkeEncAlg") {
                self.ikeEncAlg = dict["IkeEncAlg"] as! String
            }
            if dict.keys.contains("IkeLifetime") {
                self.ikeLifetime = dict["IkeLifetime"] as! Int64
            }
            if dict.keys.contains("IkeMode") {
                self.ikeMode = dict["IkeMode"] as! String
            }
            if dict.keys.contains("IkePfs") {
                self.ikePfs = dict["IkePfs"] as! String
            }
            if dict.keys.contains("IkeVersion") {
                self.ikeVersion = dict["IkeVersion"] as! String
            }
            if dict.keys.contains("LocalId") {
                self.localId = dict["LocalId"] as! String
            }
            if dict.keys.contains("Psk") {
                self.psk = dict["Psk"] as! String
            }
            if dict.keys.contains("RemoteId") {
                self.remoteId = dict["RemoteId"] as! String
            }
        }
    }
    public class IpsecConfig : Tea.TeaModel {
        public var ipsecAuthAlg: String?

        public var ipsecEncAlg: String?

        public var ipsecLifetime: Int64?

        public var ipsecPfs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipsecAuthAlg != nil {
                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
            }
            if self.ipsecEncAlg != nil {
                map["IpsecEncAlg"] = self.ipsecEncAlg!
            }
            if self.ipsecLifetime != nil {
                map["IpsecLifetime"] = self.ipsecLifetime!
            }
            if self.ipsecPfs != nil {
                map["IpsecPfs"] = self.ipsecPfs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpsecAuthAlg") {
                self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
            }
            if dict.keys.contains("IpsecEncAlg") {
                self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
            }
            if dict.keys.contains("IpsecLifetime") {
                self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
            }
            if dict.keys.contains("IpsecPfs") {
                self.ipsecPfs = dict["IpsecPfs"] as! String
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelOptions : Tea.TeaModel {
            public class TunnelBgpConfig : Tea.TeaModel {
                public var localAsn: Int64?

                public var localBgpIp: String?

                public var peerAsn: Int64?

                public var peerBgpIp: String?

                public var tunnelCidr: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.localAsn != nil {
                        map["LocalAsn"] = self.localAsn!
                    }
                    if self.localBgpIp != nil {
                        map["LocalBgpIp"] = self.localBgpIp!
                    }
                    if self.peerAsn != nil {
                        map["PeerAsn"] = self.peerAsn!
                    }
                    if self.peerBgpIp != nil {
                        map["PeerBgpIp"] = self.peerBgpIp!
                    }
                    if self.tunnelCidr != nil {
                        map["TunnelCidr"] = self.tunnelCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LocalAsn") {
                        self.localAsn = dict["LocalAsn"] as! Int64
                    }
                    if dict.keys.contains("LocalBgpIp") {
                        self.localBgpIp = dict["LocalBgpIp"] as! String
                    }
                    if dict.keys.contains("PeerAsn") {
                        self.peerAsn = dict["PeerAsn"] as! Int64
                    }
                    if dict.keys.contains("PeerBgpIp") {
                        self.peerBgpIp = dict["PeerBgpIp"] as! String
                    }
                    if dict.keys.contains("TunnelCidr") {
                        self.tunnelCidr = dict["TunnelCidr"] as! String
                    }
                }
            }
            public class TunnelIkeConfig : Tea.TeaModel {
                public var ikeAuthAlg: String?

                public var ikeEncAlg: String?

                public var ikeLifetime: Int64?

                public var ikeMode: String?

                public var ikePfs: String?

                public var ikeVersion: String?

                public var localId: String?

                public var psk: String?

                public var remoteId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ikeAuthAlg != nil {
                        map["IkeAuthAlg"] = self.ikeAuthAlg!
                    }
                    if self.ikeEncAlg != nil {
                        map["IkeEncAlg"] = self.ikeEncAlg!
                    }
                    if self.ikeLifetime != nil {
                        map["IkeLifetime"] = self.ikeLifetime!
                    }
                    if self.ikeMode != nil {
                        map["IkeMode"] = self.ikeMode!
                    }
                    if self.ikePfs != nil {
                        map["IkePfs"] = self.ikePfs!
                    }
                    if self.ikeVersion != nil {
                        map["IkeVersion"] = self.ikeVersion!
                    }
                    if self.localId != nil {
                        map["LocalId"] = self.localId!
                    }
                    if self.psk != nil {
                        map["Psk"] = self.psk!
                    }
                    if self.remoteId != nil {
                        map["RemoteId"] = self.remoteId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IkeAuthAlg") {
                        self.ikeAuthAlg = dict["IkeAuthAlg"] as! String
                    }
                    if dict.keys.contains("IkeEncAlg") {
                        self.ikeEncAlg = dict["IkeEncAlg"] as! String
                    }
                    if dict.keys.contains("IkeLifetime") {
                        self.ikeLifetime = dict["IkeLifetime"] as! Int64
                    }
                    if dict.keys.contains("IkeMode") {
                        self.ikeMode = dict["IkeMode"] as! String
                    }
                    if dict.keys.contains("IkePfs") {
                        self.ikePfs = dict["IkePfs"] as! String
                    }
                    if dict.keys.contains("IkeVersion") {
                        self.ikeVersion = dict["IkeVersion"] as! String
                    }
                    if dict.keys.contains("LocalId") {
                        self.localId = dict["LocalId"] as! String
                    }
                    if dict.keys.contains("Psk") {
                        self.psk = dict["Psk"] as! String
                    }
                    if dict.keys.contains("RemoteId") {
                        self.remoteId = dict["RemoteId"] as! String
                    }
                }
            }
            public class TunnelIpsecConfig : Tea.TeaModel {
                public var ipsecAuthAlg: String?

                public var ipsecEncAlg: String?

                public var ipsecLifetime: Int64?

                public var ipsecPfs: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipsecAuthAlg != nil {
                        map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                    }
                    if self.ipsecEncAlg != nil {
                        map["IpsecEncAlg"] = self.ipsecEncAlg!
                    }
                    if self.ipsecLifetime != nil {
                        map["IpsecLifetime"] = self.ipsecLifetime!
                    }
                    if self.ipsecPfs != nil {
                        map["IpsecPfs"] = self.ipsecPfs!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpsecAuthAlg") {
                        self.ipsecAuthAlg = dict["IpsecAuthAlg"] as! String
                    }
                    if dict.keys.contains("IpsecEncAlg") {
                        self.ipsecEncAlg = dict["IpsecEncAlg"] as! String
                    }
                    if dict.keys.contains("IpsecLifetime") {
                        self.ipsecLifetime = dict["IpsecLifetime"] as! Int64
                    }
                    if dict.keys.contains("IpsecPfs") {
                        self.ipsecPfs = dict["IpsecPfs"] as! String
                    }
                }
            }
            public var customerGatewayId: String?

            public var enableDpd: Bool?

            public var enableNatTraversal: Bool?

            public var internetIp: String?

            public var remoteCaCertificate: String?

            public var role: String?

            public var state: String?

            public var tunnelBgpConfig: ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig?

            public var tunnelId: String?

            public var tunnelIkeConfig: ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig?

            public var tunnelIpsecConfig: ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig?

            public var zoneNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tunnelBgpConfig?.validate()
                try self.tunnelIkeConfig?.validate()
                try self.tunnelIpsecConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customerGatewayId != nil {
                    map["CustomerGatewayId"] = self.customerGatewayId!
                }
                if self.enableDpd != nil {
                    map["EnableDpd"] = self.enableDpd!
                }
                if self.enableNatTraversal != nil {
                    map["EnableNatTraversal"] = self.enableNatTraversal!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.remoteCaCertificate != nil {
                    map["RemoteCaCertificate"] = self.remoteCaCertificate!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.tunnelBgpConfig != nil {
                    map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
                }
                if self.tunnelId != nil {
                    map["TunnelId"] = self.tunnelId!
                }
                if self.tunnelIkeConfig != nil {
                    map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
                }
                if self.tunnelIpsecConfig != nil {
                    map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
                }
                if self.zoneNo != nil {
                    map["ZoneNo"] = self.zoneNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomerGatewayId") {
                    self.customerGatewayId = dict["CustomerGatewayId"] as! String
                }
                if dict.keys.contains("EnableDpd") {
                    self.enableDpd = dict["EnableDpd"] as! Bool
                }
                if dict.keys.contains("EnableNatTraversal") {
                    self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
                }
                if dict.keys.contains("InternetIp") {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("RemoteCaCertificate") {
                    self.remoteCaCertificate = dict["RemoteCaCertificate"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TunnelBgpConfig") {
                    var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig()
                    model.fromMap(dict["TunnelBgpConfig"] as! [String: Any])
                    self.tunnelBgpConfig = model
                }
                if dict.keys.contains("TunnelId") {
                    self.tunnelId = dict["TunnelId"] as! String
                }
                if dict.keys.contains("TunnelIkeConfig") {
                    var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig()
                    model.fromMap(dict["TunnelIkeConfig"] as! [String: Any])
                    self.tunnelIkeConfig = model
                }
                if dict.keys.contains("TunnelIpsecConfig") {
                    var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig()
                    model.fromMap(dict["TunnelIpsecConfig"] as! [String: Any])
                    self.tunnelIpsecConfig = model
                }
                if dict.keys.contains("ZoneNo") {
                    self.zoneNo = dict["ZoneNo"] as! String
                }
            }
        }
        public var tunnelOptions: [ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tunnelOptions != nil {
                var tmp : [Any] = []
                for k in self.tunnelOptions! {
                    tmp.append(k.toMap())
                }
                map["TunnelOptions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TunnelOptions") {
                var tmp : [ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions] = []
                for v in dict["TunnelOptions"] as! [Any] {
                    var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tunnelOptions = tmp
            }
        }
    }
    public class VcoHealthCheck : Tea.TeaModel {
        public var dip: String?

        public var enable: String?

        public var interval: Int32?

        public var retry: Int32?

        public var sip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dip != nil {
                map["Dip"] = self.dip!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.retry != nil {
                map["Retry"] = self.retry!
            }
            if self.sip != nil {
                map["Sip"] = self.sip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dip") {
                self.dip = dict["Dip"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! String
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int32
            }
            if dict.keys.contains("Retry") {
                self.retry = dict["Retry"] as! Int32
            }
            if dict.keys.contains("Sip") {
                self.sip = dict["Sip"] as! String
            }
        }
    }
    public class VpnBgpConfig : Tea.TeaModel {
        public var enableBgp: String?

        public var localAsn: Int32?

        public var localBgpIp: String?

        public var peerAsn: Int32?

        public var peerBgpIp: String?

        public var status: String?

        public var tunnelCidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableBgp != nil {
                map["EnableBgp"] = self.enableBgp!
            }
            if self.localAsn != nil {
                map["LocalAsn"] = self.localAsn!
            }
            if self.localBgpIp != nil {
                map["LocalBgpIp"] = self.localBgpIp!
            }
            if self.peerAsn != nil {
                map["PeerAsn"] = self.peerAsn!
            }
            if self.peerBgpIp != nil {
                map["PeerBgpIp"] = self.peerBgpIp!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tunnelCidr != nil {
                map["TunnelCidr"] = self.tunnelCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableBgp") {
                self.enableBgp = dict["EnableBgp"] as! String
            }
            if dict.keys.contains("LocalAsn") {
                self.localAsn = dict["LocalAsn"] as! Int32
            }
            if dict.keys.contains("LocalBgpIp") {
                self.localBgpIp = dict["LocalBgpIp"] as! String
            }
            if dict.keys.contains("PeerAsn") {
                self.peerAsn = dict["PeerAsn"] as! Int32
            }
            if dict.keys.contains("PeerBgpIp") {
                self.peerBgpIp = dict["PeerBgpIp"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TunnelCidr") {
                self.tunnelCidr = dict["TunnelCidr"] as! String
            }
        }
    }
    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var ikeConfig: ModifyVpnConnectionAttributeResponseBody.IkeConfig?

    public var ipsecConfig: ModifyVpnConnectionAttributeResponseBody.IpsecConfig?

    public var localSubnet: String?

    public var name: String?

    public var remoteSubnet: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var tunnelOptionsSpecification: ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification?

    public var vcoHealthCheck: ModifyVpnConnectionAttributeResponseBody.VcoHealthCheck?

    public var vpnBgpConfig: ModifyVpnConnectionAttributeResponseBody.VpnBgpConfig?

    public var vpnConnectionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ikeConfig?.validate()
        try self.ipsecConfig?.validate()
        try self.tunnelOptionsSpecification?.validate()
        try self.vcoHealthCheck?.validate()
        try self.vpnBgpConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig?.toMap()
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig?.toMap()
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tunnelOptionsSpecification != nil {
            map["TunnelOptionsSpecification"] = self.tunnelOptionsSpecification?.toMap()
        }
        if self.vcoHealthCheck != nil {
            map["VcoHealthCheck"] = self.vcoHealthCheck?.toMap()
        }
        if self.vpnBgpConfig != nil {
            map["VpnBgpConfig"] = self.vpnBgpConfig?.toMap()
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("CustomerGatewayId") {
            self.customerGatewayId = dict["CustomerGatewayId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EffectImmediately") {
            self.effectImmediately = dict["EffectImmediately"] as! Bool
        }
        if dict.keys.contains("EnableDpd") {
            self.enableDpd = dict["EnableDpd"] as! Bool
        }
        if dict.keys.contains("EnableNatTraversal") {
            self.enableNatTraversal = dict["EnableNatTraversal"] as! Bool
        }
        if dict.keys.contains("EnableTunnelsBgp") {
            self.enableTunnelsBgp = dict["EnableTunnelsBgp"] as! Bool
        }
        if dict.keys.contains("IkeConfig") {
            var model = ModifyVpnConnectionAttributeResponseBody.IkeConfig()
            model.fromMap(dict["IkeConfig"] as! [String: Any])
            self.ikeConfig = model
        }
        if dict.keys.contains("IpsecConfig") {
            var model = ModifyVpnConnectionAttributeResponseBody.IpsecConfig()
            model.fromMap(dict["IpsecConfig"] as! [String: Any])
            self.ipsecConfig = model
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RemoteSubnet") {
            self.remoteSubnet = dict["RemoteSubnet"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TunnelOptionsSpecification") {
            var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification()
            model.fromMap(dict["TunnelOptionsSpecification"] as! [String: Any])
            self.tunnelOptionsSpecification = model
        }
        if dict.keys.contains("VcoHealthCheck") {
            var model = ModifyVpnConnectionAttributeResponseBody.VcoHealthCheck()
            model.fromMap(dict["VcoHealthCheck"] as! [String: Any])
            self.vcoHealthCheck = model
        }
        if dict.keys.contains("VpnBgpConfig") {
            var model = ModifyVpnConnectionAttributeResponseBody.VpnBgpConfig()
            model.fromMap(dict["VpnBgpConfig"] as! [String: Any])
            self.vpnBgpConfig = model
        }
        if dict.keys.contains("VpnConnectionId") {
            self.vpnConnectionId = dict["VpnConnectionId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class ModifyVpnConnectionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnConnectionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpnConnectionAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpnGatewayAttributeRequest : Tea.TeaModel {
    public var autoPropagate: Bool?

    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPropagate != nil {
            map["AutoPropagate"] = self.autoPropagate!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPropagate") {
            self.autoPropagate = dict["AutoPropagate"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class ModifyVpnGatewayAttributeResponseBody : Tea.TeaModel {
    public var autoPropagate: Bool?

    public var businessStatus: String?

    public var createTime: Int64?

    public var description_: String?

    public var disasterRecoveryInternetIp: String?

    public var disasterRecoveryVSwitchId: String?

    public var enableBgp: Bool?

    public var endTime: Int64?

    public var internetIp: String?

    public var intranetIp: String?

    public var name: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var spec: String?

    public var sslVpnInternetIp: String?

    public var status: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPropagate != nil {
            map["AutoPropagate"] = self.autoPropagate!
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disasterRecoveryInternetIp != nil {
            map["DisasterRecoveryInternetIp"] = self.disasterRecoveryInternetIp!
        }
        if self.disasterRecoveryVSwitchId != nil {
            map["DisasterRecoveryVSwitchId"] = self.disasterRecoveryVSwitchId!
        }
        if self.enableBgp != nil {
            map["EnableBgp"] = self.enableBgp!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.intranetIp != nil {
            map["IntranetIp"] = self.intranetIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.sslVpnInternetIp != nil {
            map["SslVpnInternetIp"] = self.sslVpnInternetIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPropagate") {
            self.autoPropagate = dict["AutoPropagate"] as! Bool
        }
        if dict.keys.contains("BusinessStatus") {
            self.businessStatus = dict["BusinessStatus"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisasterRecoveryInternetIp") {
            self.disasterRecoveryInternetIp = dict["DisasterRecoveryInternetIp"] as! String
        }
        if dict.keys.contains("DisasterRecoveryVSwitchId") {
            self.disasterRecoveryVSwitchId = dict["DisasterRecoveryVSwitchId"] as! String
        }
        if dict.keys.contains("EnableBgp") {
            self.enableBgp = dict["EnableBgp"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InternetIp") {
            self.internetIp = dict["InternetIp"] as! String
        }
        if dict.keys.contains("IntranetIp") {
            self.intranetIp = dict["IntranetIp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("SslVpnInternetIp") {
            self.sslVpnInternetIp = dict["SslVpnInternetIp"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class ModifyVpnGatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnGatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpnGatewayAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpnPbrRouteEntryAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newPriority: Int32?

    public var newWeight: Int32?

    public var nextHop: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newPriority != nil {
            map["NewPriority"] = self.newPriority!
        }
        if self.newWeight != nil {
            map["NewWeight"] = self.newWeight!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NewPriority") {
            self.newPriority = dict["NewPriority"] as! Int32
        }
        if dict.keys.contains("NewWeight") {
            self.newWeight = dict["NewWeight"] as! Int32
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("RouteSource") {
            self.routeSource = dict["RouteSource"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class ModifyVpnPbrRouteEntryAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpnPbrRouteEntryAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnPbrRouteEntryAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpnPbrRouteEntryAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpnPbrRouteEntryPriorityRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newPriority: Int32?

    public var nextHop: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newPriority != nil {
            map["NewPriority"] = self.newPriority!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NewPriority") {
            self.newPriority = dict["NewPriority"] as! Int32
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("RouteSource") {
            self.routeSource = dict["RouteSource"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class ModifyVpnPbrRouteEntryPriorityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpnPbrRouteEntryPriorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnPbrRouteEntryPriorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpnPbrRouteEntryPriorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpnPbrRouteEntryWeightRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newWeight: Int32?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newWeight != nil {
            map["NewWeight"] = self.newWeight!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NewWeight") {
            self.newWeight = dict["NewWeight"] as! Int32
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("RouteSource") {
            self.routeSource = dict["RouteSource"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class ModifyVpnPbrRouteEntryWeightResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpnPbrRouteEntryWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnPbrRouteEntryWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpnPbrRouteEntryWeightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpnRouteEntryWeightRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newWeight: Int32?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newWeight != nil {
            map["NewWeight"] = self.newWeight!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NewWeight") {
            self.newWeight = dict["NewWeight"] as! Int32
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OverlayMode") {
            self.overlayMode = dict["OverlayMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class ModifyVpnRouteEntryWeightResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpnRouteEntryWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnRouteEntryWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpnRouteEntryWeightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class MoveResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MoveResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveVpnResourceGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var newResourceGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class MoveVpnResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MoveVpnResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveVpnResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveVpnResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenFlowLogServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class OpenFlowLogServiceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenFlowLogServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenFlowLogServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenFlowLogServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenPhysicalConnectionServiceRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class OpenPhysicalConnectionServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenPhysicalConnectionServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenPhysicalConnectionServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenPhysicalConnectionServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenPublicIpAddressPoolServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class OpenPublicIpAddressPoolServiceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenPublicIpAddressPoolServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenPublicIpAddressPoolServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenPublicIpAddressPoolServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenTrafficMirrorServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class OpenTrafficMirrorServiceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenTrafficMirrorServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenTrafficMirrorServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenTrafficMirrorServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishVpcRouteEntriesRequest : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public var destinationCidrBlock: String?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! String
            }
        }
    }
    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntries: [PublishVpcRouteEntriesRequest.RouteEntries]?

    public var targetInstanceId: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntries") {
            var tmp : [PublishVpcRouteEntriesRequest.RouteEntries] = []
            for v in dict["RouteEntries"] as! [Any] {
                var model = PublishVpcRouteEntriesRequest.RouteEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeEntries = tmp
        }
        if dict.keys.contains("TargetInstanceId") {
            self.targetInstanceId = dict["TargetInstanceId"] as! String
        }
        if dict.keys.contains("TargetType") {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class PublishVpcRouteEntriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PublishVpcRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishVpcRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PublishVpcRouteEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishVpnRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var nextHop: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publishVpc: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeType: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publishVpc != nil {
            map["PublishVpc"] = self.publishVpc!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeType != nil {
            map["RouteType"] = self.routeType!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NextHop") {
            self.nextHop = dict["NextHop"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PublishVpc") {
            self.publishVpc = dict["PublishVpc"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteDest") {
            self.routeDest = dict["RouteDest"] as! String
        }
        if dict.keys.contains("RouteType") {
            self.routeType = dict["RouteType"] as! String
        }
        if dict.keys.contains("VpnGatewayId") {
            self.vpnGatewayId = dict["VpnGatewayId"] as! String
        }
    }
}

public class PublishVpnRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PublishVpnRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishVpnRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PublishVpnRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecoverPhysicalConnectionRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var instanceId: String?

    public var regionId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class RecoverPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RecoverPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecoverPhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecoverVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class RecoverVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RecoverVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecoverVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ReleaseEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseEipSegmentAddressRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var segmentInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.segmentInstanceId != nil {
            map["SegmentInstanceId"] = self.segmentInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SegmentInstanceId") {
            self.segmentInstanceId = dict["SegmentInstanceId"] as! String
        }
    }
}

public class ReleaseEipSegmentAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseEipSegmentAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseEipSegmentAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseEipSegmentAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseIpv6AddressRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6AddressId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv6AddressId") {
            self.ipv6AddressId = dict["Ipv6AddressId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ReleaseIpv6AddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseIpv6AddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseIpv6AddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseIpv6AddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveCommonBandwidthPackageIpRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ipInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipInstanceId != nil {
            map["IpInstanceId"] = self.ipInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpInstanceId") {
            self.ipInstanceId = dict["IpInstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RemoveCommonBandwidthPackageIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveCommonBandwidthPackageIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveCommonBandwidthPackageIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveCommonBandwidthPackageIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveGlobalAccelerationInstanceIpRequest : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var ipInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ipInstanceId != nil {
            map["IpInstanceId"] = self.ipInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalAccelerationInstanceId") {
            self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
        }
        if dict.keys.contains("IpInstanceId") {
            self.ipInstanceId = dict["IpInstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RemoveGlobalAccelerationInstanceIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveGlobalAccelerationInstanceIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveGlobalAccelerationInstanceIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveGlobalAccelerationInstanceIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveIPv6TranslatorAclListEntryRequest : Tea.TeaModel {
    public var aclEntryId: String?

    public var aclId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntryId != nil {
            map["AclEntryId"] = self.aclEntryId!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntryId") {
            self.aclEntryId = dict["AclEntryId"] as! String
        }
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RemoveIPv6TranslatorAclListEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveIPv6TranslatorAclListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveIPv6TranslatorAclListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveIPv6TranslatorAclListEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveSourcesFromTrafficMirrorSessionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorSessionId: String?

    public var trafficMirrorSourceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        if self.trafficMirrorSourceIds != nil {
            map["TrafficMirrorSourceIds"] = self.trafficMirrorSourceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrafficMirrorSessionId") {
            self.trafficMirrorSessionId = dict["TrafficMirrorSessionId"] as! String
        }
        if dict.keys.contains("TrafficMirrorSourceIds") {
            self.trafficMirrorSourceIds = dict["TrafficMirrorSourceIds"] as! [String]
        }
    }
}

public class RemoveSourcesFromTrafficMirrorSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveSourcesFromTrafficMirrorSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSourcesFromTrafficMirrorSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveSourcesFromTrafficMirrorSessionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReplaceVpcDhcpOptionsSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ReplaceVpcDhcpOptionsSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReplaceVpcDhcpOptionsSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceVpcDhcpOptionsSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReplaceVpcDhcpOptionsSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryVpcPrefixListAssociationRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class RetryVpcPrefixListAssociationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RetryVpcPrefixListAssociationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryVpcPrefixListAssociationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetryVpcPrefixListAssociationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeInstanceFromCenRequest : Tea.TeaModel {
    public var cenId: String?

    public var cenOwnerId: Int64?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.cenOwnerId != nil {
            map["CenOwnerId"] = self.cenOwnerId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CenId") {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("CenOwnerId") {
            self.cenOwnerId = dict["CenOwnerId"] as! Int64
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RevokeInstanceFromCenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeInstanceFromCenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeInstanceFromCenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeInstanceFromCenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeInstanceFromVbrRequest : Tea.TeaModel {
    public var grantType: String?

    public var instanceId: String?

    public var regionId: String?

    public var vbrInstanceIds: [String]?

    public var vbrOwnerUid: String?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grantType != nil {
            map["GrantType"] = self.grantType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vbrInstanceIds != nil {
            map["VbrInstanceIds"] = self.vbrInstanceIds!
        }
        if self.vbrOwnerUid != nil {
            map["VbrOwnerUid"] = self.vbrOwnerUid!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GrantType") {
            self.grantType = dict["GrantType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VbrInstanceIds") {
            self.vbrInstanceIds = dict["VbrInstanceIds"] as! [String]
        }
        if dict.keys.contains("VbrOwnerUid") {
            self.vbrOwnerUid = dict["VbrOwnerUid"] as! String
        }
        if dict.keys.contains("VbrRegionNo") {
            self.vbrRegionNo = dict["VbrRegionNo"] as! String
        }
    }
}

public class RevokeInstanceFromVbrShrinkRequest : Tea.TeaModel {
    public var grantType: String?

    public var instanceId: String?

    public var regionId: String?

    public var vbrInstanceIdsShrink: String?

    public var vbrOwnerUid: String?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grantType != nil {
            map["GrantType"] = self.grantType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vbrInstanceIdsShrink != nil {
            map["VbrInstanceIds"] = self.vbrInstanceIdsShrink!
        }
        if self.vbrOwnerUid != nil {
            map["VbrOwnerUid"] = self.vbrOwnerUid!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GrantType") {
            self.grantType = dict["GrantType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VbrInstanceIds") {
            self.vbrInstanceIdsShrink = dict["VbrInstanceIds"] as! String
        }
        if dict.keys.contains("VbrOwnerUid") {
            self.vbrOwnerUid = dict["VbrOwnerUid"] as! String
        }
        if dict.keys.contains("VbrRegionNo") {
            self.vbrRegionNo = dict["VbrRegionNo"] as! String
        }
    }
}

public class RevokeInstanceFromVbrResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeInstanceFromVbrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeInstanceFromVbrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeInstanceFromVbrResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SecondApplyPhysicalConnectionLOARequest : Tea.TeaModel {
    public class PMInfo : Tea.TeaModel {
        public var PMCertificateNo: String?

        public var PMCertificateType: String?

        public var PMContactInfo: String?

        public var PMGender: String?

        public var PMName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.PMCertificateNo != nil {
                map["PMCertificateNo"] = self.PMCertificateNo!
            }
            if self.PMCertificateType != nil {
                map["PMCertificateType"] = self.PMCertificateType!
            }
            if self.PMContactInfo != nil {
                map["PMContactInfo"] = self.PMContactInfo!
            }
            if self.PMGender != nil {
                map["PMGender"] = self.PMGender!
            }
            if self.PMName != nil {
                map["PMName"] = self.PMName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PMCertificateNo") {
                self.PMCertificateNo = dict["PMCertificateNo"] as! String
            }
            if dict.keys.contains("PMCertificateType") {
                self.PMCertificateType = dict["PMCertificateType"] as! String
            }
            if dict.keys.contains("PMContactInfo") {
                self.PMContactInfo = dict["PMContactInfo"] as! String
            }
            if dict.keys.contains("PMGender") {
                self.PMGender = dict["PMGender"] as! String
            }
            if dict.keys.contains("PMName") {
                self.PMName = dict["PMName"] as! String
            }
        }
    }
    public var bandwidth: Int32?

    public var clientToken: String?

    public var companyName: String?

    public var constructionTime: String?

    public var instanceId: String?

    public var lineType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var PMInfo: [SecondApplyPhysicalConnectionLOARequest.PMInfo]?

    public var peerLocation: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var si: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.companyName != nil {
            map["CompanyName"] = self.companyName!
        }
        if self.constructionTime != nil {
            map["ConstructionTime"] = self.constructionTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lineType != nil {
            map["LineType"] = self.lineType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.PMInfo != nil {
            var tmp : [Any] = []
            for k in self.PMInfo! {
                tmp.append(k.toMap())
            }
            map["PMInfo"] = tmp
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.si != nil {
            map["Si"] = self.si!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CompanyName") {
            self.companyName = dict["CompanyName"] as! String
        }
        if dict.keys.contains("ConstructionTime") {
            self.constructionTime = dict["ConstructionTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LineType") {
            self.lineType = dict["LineType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PMInfo") {
            var tmp : [SecondApplyPhysicalConnectionLOARequest.PMInfo] = []
            for v in dict["PMInfo"] as! [Any] {
                var model = SecondApplyPhysicalConnectionLOARequest.PMInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.PMInfo = tmp
        }
        if dict.keys.contains("PeerLocation") {
            self.peerLocation = dict["PeerLocation"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Si") {
            self.si = dict["Si"] as! String
        }
    }
}

public class SecondApplyPhysicalConnectionLOAResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SecondApplyPhysicalConnectionLOAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SecondApplyPhysicalConnectionLOAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SecondApplyPhysicalConnectionLOAResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetHighDefinitionMonitorLogStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var logProject: String?

    public var logStore: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.logProject != nil {
            map["LogProject"] = self.logProject!
        }
        if self.logStore != nil {
            map["LogStore"] = self.logStore!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("LogProject") {
            self.logProject = dict["LogProject"] as! String
        }
        if dict.keys.contains("LogStore") {
            self.logStore = dict["LogStore"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class SetHighDefinitionMonitorLogStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class SetHighDefinitionMonitorLogStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetHighDefinitionMonitorLogStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetHighDefinitionMonitorLogStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class StartFailoverTestJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartFailoverTestJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class StopFailoverTestJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopFailoverTestJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesForExpressConnectRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [TagResourcesForExpressConnectRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesForExpressConnectRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesForExpressConnectRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesForExpressConnectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesForExpressConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesForExpressConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesForExpressConnectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TerminatePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class TerminatePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TerminatePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminatePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TerminatePhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TerminateVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class TerminateVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TerminateVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TerminateVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnTagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UnTagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var clientToken: String?

    public var force: Bool?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnassociateEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateGlobalAccelerationInstanceRequest : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalAccelerationInstanceId") {
            self.globalAccelerationInstanceId = dict["GlobalAccelerationInstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnassociateGlobalAccelerationInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateGlobalAccelerationInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateGlobalAccelerationInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateGlobalAccelerationInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var force: String?

    public var haVipId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! String
        }
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnassociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateNetworkAclRequest : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resource: [UnassociateNetworkAclRequest.Resource]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            var tmp : [Any] = []
            for k in self.resource! {
                tmp.append(k.toMap())
            }
            map["Resource"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Resource") {
            var tmp : [UnassociateNetworkAclRequest.Resource] = []
            for v in dict["Resource"] as! [Any] {
                var model = UnassociateNetworkAclRequest.Resource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resource = tmp
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnassociateNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociatePhysicalConnectionFromVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociatePhysicalConnectionFromVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateRouteTableRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class UnassociateRouteTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateRouteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateRouteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateRouteTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateVpcCidrBlockRequest : Tea.TeaModel {
    public var IPv6CidrBlock: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var secondaryCidrBlock: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.IPv6CidrBlock != nil {
            map["IPv6CidrBlock"] = self.IPv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.secondaryCidrBlock != nil {
            map["SecondaryCidrBlock"] = self.secondaryCidrBlock!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IPv6CidrBlock") {
            self.IPv6CidrBlock = dict["IPv6CidrBlock"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecondaryCidrBlock") {
            self.secondaryCidrBlock = dict["SecondaryCidrBlock"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class UnassociateVpcCidrBlockResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateVpcCidrBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateVpcCidrBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateVpcCidrBlockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesForExpressConnectRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesForExpressConnectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesForExpressConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesForExpressConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesForExpressConnectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDhcpOptionsSetAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetDescription: String?

    public var dhcpOptionsSetId: String?

    public var dhcpOptionsSetName: String?

    public var domainName: String?

    public var domainNameServers: String?

    public var dryRun: Bool?

    public var ipv6LeaseTime: String?

    public var leaseTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetDescription != nil {
            map["DhcpOptionsSetDescription"] = self.dhcpOptionsSetDescription!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dhcpOptionsSetName != nil {
            map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainNameServers != nil {
            map["DomainNameServers"] = self.domainNameServers!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6LeaseTime != nil {
            map["Ipv6LeaseTime"] = self.ipv6LeaseTime!
        }
        if self.leaseTime != nil {
            map["LeaseTime"] = self.leaseTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetDescription") {
            self.dhcpOptionsSetDescription = dict["DhcpOptionsSetDescription"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetId") {
            self.dhcpOptionsSetId = dict["DhcpOptionsSetId"] as! String
        }
        if dict.keys.contains("DhcpOptionsSetName") {
            self.dhcpOptionsSetName = dict["DhcpOptionsSetName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainNameServers") {
            self.domainNameServers = dict["DomainNameServers"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv6LeaseTime") {
            self.ipv6LeaseTime = dict["Ipv6LeaseTime"] as! String
        }
        if dict.keys.contains("LeaseTime") {
            self.leaseTime = dict["LeaseTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateDhcpOptionsSetAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDhcpOptionsSetAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDhcpOptionsSetAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDhcpOptionsSetAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var jobDuration: Int32?

    public var jobId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.jobDuration != nil {
            map["JobDuration"] = self.jobDuration!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("JobDuration") {
            self.jobDuration = dict["JobDuration"] as! Int32
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class UpdateFailoverTestJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFailoverTestJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteTableEntryAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var destinationCidrBlock: String?

    public var dryRun: Bool?

    public var gatewayRouteTableId: String?

    public var IPv4GatewayRouteTableId: String?

    public var name: String?

    public var nextHopId: String?

    public var nextHopType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.gatewayRouteTableId != nil {
            map["GatewayRouteTableId"] = self.gatewayRouteTableId!
        }
        if self.IPv4GatewayRouteTableId != nil {
            map["IPv4GatewayRouteTableId"] = self.IPv4GatewayRouteTableId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("GatewayRouteTableId") {
            self.gatewayRouteTableId = dict["GatewayRouteTableId"] as! String
        }
        if dict.keys.contains("IPv4GatewayRouteTableId") {
            self.IPv4GatewayRouteTableId = dict["IPv4GatewayRouteTableId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NextHopId") {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopType") {
            self.nextHopType = dict["NextHopType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateGatewayRouteTableEntryAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGatewayRouteTableEntryAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteTableEntryAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteTableEntryAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIpsecServerRequest : Tea.TeaModel {
    public var clientIpPool: String?

    public var clientToken: String?

    public var dryRun: String?

    public var effectImmediately: Bool?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var ipsecServerId: String?

    public var ipsecServerName: String?

    public var localSubnet: String?

    public var psk: String?

    public var pskEnabled: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.ipsecServerName != nil {
            map["IpsecServerName"] = self.ipsecServerName!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.psk != nil {
            map["Psk"] = self.psk!
        }
        if self.pskEnabled != nil {
            map["PskEnabled"] = self.pskEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientIpPool") {
            self.clientIpPool = dict["ClientIpPool"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! String
        }
        if dict.keys.contains("EffectImmediately") {
            self.effectImmediately = dict["EffectImmediately"] as! Bool
        }
        if dict.keys.contains("IkeConfig") {
            self.ikeConfig = dict["IkeConfig"] as! String
        }
        if dict.keys.contains("IpsecConfig") {
            self.ipsecConfig = dict["IpsecConfig"] as! String
        }
        if dict.keys.contains("IpsecServerId") {
            self.ipsecServerId = dict["IpsecServerId"] as! String
        }
        if dict.keys.contains("IpsecServerName") {
            self.ipsecServerName = dict["IpsecServerName"] as! String
        }
        if dict.keys.contains("LocalSubnet") {
            self.localSubnet = dict["LocalSubnet"] as! String
        }
        if dict.keys.contains("Psk") {
            self.psk = dict["Psk"] as! String
        }
        if dict.keys.contains("PskEnabled") {
            self.pskEnabled = dict["PskEnabled"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateIpsecServerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateIpsecServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIpsecServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateIpsecServerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIpv4GatewayAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv4GatewayDescription: String?

    public var ipv4GatewayId: String?

    public var ipv4GatewayName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv4GatewayDescription != nil {
            map["Ipv4GatewayDescription"] = self.ipv4GatewayDescription!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ipv4GatewayName != nil {
            map["Ipv4GatewayName"] = self.ipv4GatewayName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Ipv4GatewayDescription") {
            self.ipv4GatewayDescription = dict["Ipv4GatewayDescription"] as! String
        }
        if dict.keys.contains("Ipv4GatewayId") {
            self.ipv4GatewayId = dict["Ipv4GatewayId"] as! String
        }
        if dict.keys.contains("Ipv4GatewayName") {
            self.ipv4GatewayName = dict["Ipv4GatewayName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateIpv4GatewayAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateIpv4GatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIpv4GatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateIpv4GatewayAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNatGatewayNatTypeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natGatewayId: String?

    public var natType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatType") {
            self.natType = dict["NatType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class UpdateNatGatewayNatTypeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateNatGatewayNatTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNatGatewayNatTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNatGatewayNatTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNetworkAclEntriesRequest : Tea.TeaModel {
    public class EgressAclEntries : Tea.TeaModel {
        public var description_: String?

        public var destinationCidrIp: String?

        public var entryType: String?

        public var ipVersion: String?

        public var networkAclEntryId: String?

        public var networkAclEntryName: String?

        public var policy: String?

        public var port: String?

        public var protocol_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationCidrIp != nil {
                map["DestinationCidrIp"] = self.destinationCidrIp!
            }
            if self.entryType != nil {
                map["EntryType"] = self.entryType!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.networkAclEntryId != nil {
                map["NetworkAclEntryId"] = self.networkAclEntryId!
            }
            if self.networkAclEntryName != nil {
                map["NetworkAclEntryName"] = self.networkAclEntryName!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationCidrIp") {
                self.destinationCidrIp = dict["DestinationCidrIp"] as! String
            }
            if dict.keys.contains("EntryType") {
                self.entryType = dict["EntryType"] as! String
            }
            if dict.keys.contains("IpVersion") {
                self.ipVersion = dict["IpVersion"] as! String
            }
            if dict.keys.contains("NetworkAclEntryId") {
                self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
            }
            if dict.keys.contains("NetworkAclEntryName") {
                self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
        }
    }
    public class IngressAclEntries : Tea.TeaModel {
        public var description_: String?

        public var entryType: String?

        public var ipVersion: String?

        public var networkAclEntryId: String?

        public var networkAclEntryName: String?

        public var policy: String?

        public var port: String?

        public var protocol_: String?

        public var sourceCidrIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.entryType != nil {
                map["EntryType"] = self.entryType!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.networkAclEntryId != nil {
                map["NetworkAclEntryId"] = self.networkAclEntryId!
            }
            if self.networkAclEntryName != nil {
                map["NetworkAclEntryName"] = self.networkAclEntryName!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EntryType") {
                self.entryType = dict["EntryType"] as! String
            }
            if dict.keys.contains("IpVersion") {
                self.ipVersion = dict["IpVersion"] as! String
            }
            if dict.keys.contains("NetworkAclEntryId") {
                self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
            }
            if dict.keys.contains("NetworkAclEntryName") {
                self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("SourceCidrIp") {
                self.sourceCidrIp = dict["SourceCidrIp"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var egressAclEntries: [UpdateNetworkAclEntriesRequest.EgressAclEntries]?

    public var ingressAclEntries: [UpdateNetworkAclEntriesRequest.IngressAclEntries]?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var updateEgressAclEntries: Bool?

    public var updateIngressAclEntries: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.egressAclEntries != nil {
            var tmp : [Any] = []
            for k in self.egressAclEntries! {
                tmp.append(k.toMap())
            }
            map["EgressAclEntries"] = tmp
        }
        if self.ingressAclEntries != nil {
            var tmp : [Any] = []
            for k in self.ingressAclEntries! {
                tmp.append(k.toMap())
            }
            map["IngressAclEntries"] = tmp
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.updateEgressAclEntries != nil {
            map["UpdateEgressAclEntries"] = self.updateEgressAclEntries!
        }
        if self.updateIngressAclEntries != nil {
            map["UpdateIngressAclEntries"] = self.updateIngressAclEntries!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EgressAclEntries") {
            var tmp : [UpdateNetworkAclEntriesRequest.EgressAclEntries] = []
            for v in dict["EgressAclEntries"] as! [Any] {
                var model = UpdateNetworkAclEntriesRequest.EgressAclEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.egressAclEntries = tmp
        }
        if dict.keys.contains("IngressAclEntries") {
            var tmp : [UpdateNetworkAclEntriesRequest.IngressAclEntries] = []
            for v in dict["IngressAclEntries"] as! [Any] {
                var model = UpdateNetworkAclEntriesRequest.IngressAclEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ingressAclEntries = tmp
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UpdateEgressAclEntries") {
            self.updateEgressAclEntries = dict["UpdateEgressAclEntries"] as! Bool
        }
        if dict.keys.contains("UpdateIngressAclEntries") {
            self.updateIngressAclEntries = dict["UpdateIngressAclEntries"] as! Bool
        }
    }
}

public class UpdateNetworkAclEntriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateNetworkAclEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNetworkAclEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNetworkAclEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePublicIpAddressPoolAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PublicIpAddressPoolId") {
            self.publicIpAddressPoolId = dict["PublicIpAddressPoolId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdatePublicIpAddressPoolAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePublicIpAddressPoolAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePublicIpAddressPoolAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePublicIpAddressPoolAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTrafficMirrorFilterAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterDescription: String?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorFilterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterDescription != nil {
            map["TrafficMirrorFilterDescription"] = self.trafficMirrorFilterDescription!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorFilterName != nil {
            map["TrafficMirrorFilterName"] = self.trafficMirrorFilterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrafficMirrorFilterDescription") {
            self.trafficMirrorFilterDescription = dict["TrafficMirrorFilterDescription"] as! String
        }
        if dict.keys.contains("TrafficMirrorFilterId") {
            self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
        }
        if dict.keys.contains("TrafficMirrorFilterName") {
            self.trafficMirrorFilterName = dict["TrafficMirrorFilterName"] as! String
        }
    }
}

public class UpdateTrafficMirrorFilterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateTrafficMirrorFilterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTrafficMirrorFilterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTrafficMirrorFilterAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTrafficMirrorFilterRuleAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var destinationCidrBlock: String?

    public var destinationPortRange: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var protocol_: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var ruleAction: String?

    public var sourceCidrBlock: String?

    public var sourcePortRange: String?

    public var trafficMirrorFilterRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.destinationPortRange != nil {
            map["DestinationPortRange"] = self.destinationPortRange!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.ruleAction != nil {
            map["RuleAction"] = self.ruleAction!
        }
        if self.sourceCidrBlock != nil {
            map["SourceCidrBlock"] = self.sourceCidrBlock!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.trafficMirrorFilterRuleId != nil {
            map["TrafficMirrorFilterRuleId"] = self.trafficMirrorFilterRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("DestinationPortRange") {
            self.destinationPortRange = dict["DestinationPortRange"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RuleAction") {
            self.ruleAction = dict["RuleAction"] as! String
        }
        if dict.keys.contains("SourceCidrBlock") {
            self.sourceCidrBlock = dict["SourceCidrBlock"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("TrafficMirrorFilterRuleId") {
            self.trafficMirrorFilterRuleId = dict["TrafficMirrorFilterRuleId"] as! String
        }
    }
}

public class UpdateTrafficMirrorFilterRuleAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateTrafficMirrorFilterRuleAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTrafficMirrorFilterRuleAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTrafficMirrorFilterRuleAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTrafficMirrorSessionAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var enabled: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var packetLength: Int32?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorSessionDescription: String?

    public var trafficMirrorSessionId: String?

    public var trafficMirrorSessionName: String?

    public var trafficMirrorTargetId: String?

    public var trafficMirrorTargetType: String?

    public var virtualNetworkId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.packetLength != nil {
            map["PacketLength"] = self.packetLength!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorSessionDescription != nil {
            map["TrafficMirrorSessionDescription"] = self.trafficMirrorSessionDescription!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        if self.trafficMirrorSessionName != nil {
            map["TrafficMirrorSessionName"] = self.trafficMirrorSessionName!
        }
        if self.trafficMirrorTargetId != nil {
            map["TrafficMirrorTargetId"] = self.trafficMirrorTargetId!
        }
        if self.trafficMirrorTargetType != nil {
            map["TrafficMirrorTargetType"] = self.trafficMirrorTargetType!
        }
        if self.virtualNetworkId != nil {
            map["VirtualNetworkId"] = self.virtualNetworkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PacketLength") {
            self.packetLength = dict["PacketLength"] as! Int32
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrafficMirrorFilterId") {
            self.trafficMirrorFilterId = dict["TrafficMirrorFilterId"] as! String
        }
        if dict.keys.contains("TrafficMirrorSessionDescription") {
            self.trafficMirrorSessionDescription = dict["TrafficMirrorSessionDescription"] as! String
        }
        if dict.keys.contains("TrafficMirrorSessionId") {
            self.trafficMirrorSessionId = dict["TrafficMirrorSessionId"] as! String
        }
        if dict.keys.contains("TrafficMirrorSessionName") {
            self.trafficMirrorSessionName = dict["TrafficMirrorSessionName"] as! String
        }
        if dict.keys.contains("TrafficMirrorTargetId") {
            self.trafficMirrorTargetId = dict["TrafficMirrorTargetId"] as! String
        }
        if dict.keys.contains("TrafficMirrorTargetType") {
            self.trafficMirrorTargetType = dict["TrafficMirrorTargetType"] as! String
        }
        if dict.keys.contains("VirtualNetworkId") {
            self.virtualNetworkId = dict["VirtualNetworkId"] as! Int32
        }
    }
}

public class UpdateTrafficMirrorSessionAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateTrafficMirrorSessionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTrafficMirrorSessionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTrafficMirrorSessionAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVirtualBorderBandwidthRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var virtualBorderRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.virtualBorderRouterId != nil {
            map["VirtualBorderRouterId"] = self.virtualBorderRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VirtualBorderRouterId") {
            self.virtualBorderRouterId = dict["VirtualBorderRouterId"] as! String
        }
    }
}

public class UpdateVirtualBorderBandwidthResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateVirtualBorderBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVirtualBorderBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateVirtualBorderBandwidthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVirtualPhysicalConnectionRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var expectSpec: String?

    public var instanceId: String?

    public var regionId: String?

    public var token: String?

    public var vlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.expectSpec != nil {
            map["ExpectSpec"] = self.expectSpec!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ExpectSpec") {
            self.expectSpec = dict["ExpectSpec"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! Int64
        }
    }
}

public class UpdateVirtualPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class UpdateVirtualPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVirtualPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateVirtualPhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVpcGatewayEndpointAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointDescription: String?

    public var endpointId: String?

    public var endpointName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var policyDocument: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointDescription != nil {
            map["EndpointDescription"] = self.endpointDescription!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policyDocument != nil {
            map["PolicyDocument"] = self.policyDocument!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointDescription") {
            self.endpointDescription = dict["EndpointDescription"] as! String
        }
        if dict.keys.contains("EndpointId") {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("EndpointName") {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PolicyDocument") {
            self.policyDocument = dict["PolicyDocument"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateVpcGatewayEndpointAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateVpcGatewayEndpointAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVpcGatewayEndpointAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateVpcGatewayEndpointAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest : Tea.TeaModel {
    public var clientToken: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceUid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceUid != nil {
            map["ResourceUid"] = self.resourceUid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceUid") {
            self.resourceUid = dict["ResourceUid"] as! Int64
        }
    }
}

public class VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody : Tea.TeaModel {
    public var quota: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.quota != nil {
            map["Quota"] = self.quota!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Quota") {
            self.quota = dict["Quota"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WithdrawVpcPublishedRouteEntriesRequest : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public var destinationCidrBlock: String?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! String
            }
        }
    }
    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntries: [WithdrawVpcPublishedRouteEntriesRequest.RouteEntries]?

    public var targetInstanceId: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteEntries") {
            var tmp : [WithdrawVpcPublishedRouteEntriesRequest.RouteEntries] = []
            for v in dict["RouteEntries"] as! [Any] {
                var model = WithdrawVpcPublishedRouteEntriesRequest.RouteEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeEntries = tmp
        }
        if dict.keys.contains("TargetInstanceId") {
            self.targetInstanceId = dict["TargetInstanceId"] as! String
        }
        if dict.keys.contains("TargetType") {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class WithdrawVpcPublishedRouteEntriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class WithdrawVpcPublishedRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WithdrawVpcPublishedRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = WithdrawVpcPublishedRouteEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
