import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ActivateRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class ActivateRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ActivateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ActivateRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ActiveFlowLogRequest : Tea.TeaModel {
    public var flowLogId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FlowLogId"] as? String {
            self.flowLogId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ActiveFlowLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class ActiveFlowLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActiveFlowLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ActiveFlowLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddBgpNetworkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dstCidrBlock: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dstCidrBlock != nil {
            map["DstCidrBlock"] = self.dstCidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DstCidrBlock"] as? String {
            self.dstCidrBlock = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class AddBgpNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddBgpNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBgpNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddBgpNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddCommonBandwidthPackageIpRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ipInstanceId: String?

    public var ipType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipInstanceId != nil {
            map["IpInstanceId"] = self.ipInstanceId!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["IpInstanceId"] as? String {
            self.ipInstanceId = value
        }
        if let value = dict["IpType"] as? String {
            self.ipType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AddCommonBandwidthPackageIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCommonBandwidthPackageIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCommonBandwidthPackageIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCommonBandwidthPackageIpResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddCommonBandwidthPackageIpsRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ipInstanceIds: [String]?

    public var ipType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipInstanceIds != nil {
            map["IpInstanceIds"] = self.ipInstanceIds!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["IpInstanceIds"] as? [String] {
            self.ipInstanceIds = value
        }
        if let value = dict["IpType"] as? String {
            self.ipType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AddCommonBandwidthPackageIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCommonBandwidthPackageIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCommonBandwidthPackageIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCommonBandwidthPackageIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddGlobalAccelerationInstanceIpRequest : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var ipInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ipInstanceId != nil {
            map["IpInstanceId"] = self.ipInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GlobalAccelerationInstanceId"] as? String {
            self.globalAccelerationInstanceId = value
        }
        if let value = dict["IpInstanceId"] as? String {
            self.ipInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AddGlobalAccelerationInstanceIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddGlobalAccelerationInstanceIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGlobalAccelerationInstanceIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddGlobalAccelerationInstanceIpResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddIPv6TranslatorAclListEntryRequest : Tea.TeaModel {
    public var aclEntryComment: String?

    public var aclEntryIp: String?

    public var aclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntryComment != nil {
            map["AclEntryComment"] = self.aclEntryComment!
        }
        if self.aclEntryIp != nil {
            map["AclEntryIp"] = self.aclEntryIp!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclEntryComment"] as? String {
            self.aclEntryComment = value
        }
        if let value = dict["AclEntryIp"] as? String {
            self.aclEntryIp = value
        }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AddIPv6TranslatorAclListEntryResponseBody : Tea.TeaModel {
    public var aclEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntryId != nil {
            map["AclEntryId"] = self.aclEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclEntryId"] as? String {
            self.aclEntryId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddIPv6TranslatorAclListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddIPv6TranslatorAclListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddIPv6TranslatorAclListEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddPublicIpAddressPoolCidrBlockRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var cidrMask: Int32?

    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.cidrMask != nil {
            map["CidrMask"] = self.cidrMask!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["CidrMask"] as? Int32 {
            self.cidrMask = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AddPublicIpAddressPoolCidrBlockResponseBody : Tea.TeaModel {
    public var cidrBlock: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddPublicIpAddressPoolCidrBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPublicIpAddressPoolCidrBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddPublicIpAddressPoolCidrBlockResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddSourcesToTrafficMirrorSessionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorSessionId: String?

    public var trafficMirrorSourceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        if self.trafficMirrorSourceIds != nil {
            map["TrafficMirrorSourceIds"] = self.trafficMirrorSourceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrafficMirrorSessionId"] as? String {
            self.trafficMirrorSessionId = value
        }
        if let value = dict["TrafficMirrorSourceIds"] as? [String] {
            self.trafficMirrorSourceIds = value
        }
    }
}

public class AddSourcesToTrafficMirrorSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddSourcesToTrafficMirrorSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSourcesToTrafficMirrorSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddSourcesToTrafficMirrorSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateEipAddressRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var activityId: Int64?

    public var autoPay: Bool?

    public var bandwidth: String?

    public var clientToken: String?

    public var description_: String?

    public var ISP: String?

    public var instanceChargeType: String?

    public var instanceId: String?

    public var internetChargeType: String?

    public var ipAddress: String?

    public var name: String?

    public var netmode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var pricingCycle: String?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionTypes: [String]?

    public var tag: [AllocateEipAddressRequest.Tag]?

    public var zone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.netmode != nil {
            map["Netmode"] = self.netmode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionTypes != nil {
            map["SecurityProtectionTypes"] = self.securityProtectionTypes!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zone != nil {
            map["Zone"] = self.zone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivityId"] as? Int64 {
            self.activityId = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ISP"] as? String {
            self.ISP = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Netmode"] as? String {
            self.netmode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PricingCycle"] as? String {
            self.pricingCycle = value
        }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityProtectionTypes"] as? [String] {
            self.securityProtectionTypes = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [AllocateEipAddressRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = AllocateEipAddressRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Zone"] as? String {
            self.zone = value
        }
    }
}

public class AllocateEipAddressResponseBody : Tea.TeaModel {
    public var allocationId: String?

    public var eipAddress: String?

    public var orderId: Int64?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["EipAddress"] as? String {
            self.eipAddress = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class AllocateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateEipAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateEipAddressProRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var autoPay: Bool?

    public var bandwidth: String?

    public var clientToken: String?

    public var ISP: String?

    public var instanceChargeType: String?

    public var instanceId: String?

    public var internetChargeType: String?

    public var ipAddress: String?

    public var netmode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var pricingCycle: String?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionTypes: [String]?

    public var tag: [AllocateEipAddressProRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.netmode != nil {
            map["Netmode"] = self.netmode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionTypes != nil {
            map["SecurityProtectionTypes"] = self.securityProtectionTypes!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ISP"] as? String {
            self.ISP = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["Netmode"] as? String {
            self.netmode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PricingCycle"] as? String {
            self.pricingCycle = value
        }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityProtectionTypes"] as? [String] {
            self.securityProtectionTypes = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [AllocateEipAddressProRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = AllocateEipAddressProRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class AllocateEipAddressProResponseBody : Tea.TeaModel {
    public var allocationId: String?

    public var eipAddress: String?

    public var orderId: Int64?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["EipAddress"] as? String {
            self.eipAddress = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class AllocateEipAddressProResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateEipAddressProResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateEipAddressProResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateEipSegmentAddressRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var clientToken: String?

    public var eipMask: String?

    public var internetChargeType: String?

    public var isp: String?

    public var netmode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.eipMask != nil {
            map["EipMask"] = self.eipMask!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.netmode != nil {
            map["Netmode"] = self.netmode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zone != nil {
            map["Zone"] = self.zone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EipMask"] as? String {
            self.eipMask = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["Isp"] as? String {
            self.isp = value
        }
        if let value = dict["Netmode"] as? String {
            self.netmode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Zone"] as? String {
            self.zone = value
        }
    }
}

public class AllocateEipSegmentAddressResponseBody : Tea.TeaModel {
    public var eipSegmentInstanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipSegmentInstanceId != nil {
            map["EipSegmentInstanceId"] = self.eipSegmentInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EipSegmentInstanceId"] as? String {
            self.eipSegmentInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AllocateEipSegmentAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateEipSegmentAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateEipSegmentAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateIpv6AddressRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var addressType: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6Address: String?

    public var ipv6AddressDescription: String?

    public var ipv6AddressName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [AllocateIpv6AddressRequest.Tag]?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressType != nil {
            map["AddressType"] = self.addressType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressDescription != nil {
            map["Ipv6AddressDescription"] = self.ipv6AddressDescription!
        }
        if self.ipv6AddressName != nil {
            map["Ipv6AddressName"] = self.ipv6AddressName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressType"] as? String {
            self.addressType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv6Address"] as? String {
            self.ipv6Address = value
        }
        if let value = dict["Ipv6AddressDescription"] as? String {
            self.ipv6AddressDescription = value
        }
        if let value = dict["Ipv6AddressName"] as? String {
            self.ipv6AddressName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [AllocateIpv6AddressRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = AllocateIpv6AddressRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class AllocateIpv6AddressResponseBody : Tea.TeaModel {
    public var ipv6Address: String?

    public var ipv6AddressId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6Address"] as? String {
            self.ipv6Address = value
        }
        if let value = dict["Ipv6AddressId"] as? String {
            self.ipv6AddressId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class AllocateIpv6AddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateIpv6AddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateIpv6AddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateIpv6InternetBandwidthRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var clientToken: String?

    public var dryRun: Bool?

    public var internetChargeType: String?

    public var ipv6AddressId: String?

    public var ipv6GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["Ipv6AddressId"] as? String {
            self.ipv6AddressId = value
        }
        if let value = dict["Ipv6GatewayId"] as? String {
            self.ipv6GatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AllocateIpv6InternetBandwidthResponseBody : Tea.TeaModel {
    public var internetBandwidthId: String?

    public var ipv6AddressId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.internetBandwidthId != nil {
            map["InternetBandwidthId"] = self.internetBandwidthId!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InternetBandwidthId"] as? String {
            self.internetBandwidthId = value
        }
        if let value = dict["Ipv6AddressId"] as? String {
            self.ipv6AddressId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AllocateIpv6InternetBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateIpv6InternetBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateIpv6InternetBandwidthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateVpcIpv6CidrRequest : Tea.TeaModel {
    public var addressPoolType: String?

    public var clientToken: String?

    public var ipv6CidrBlock: String?

    public var ipv6Isp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ipv6Isp != nil {
            map["Ipv6Isp"] = self.ipv6Isp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolType"] as? String {
            self.addressPoolType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Ipv6CidrBlock"] as? String {
            self.ipv6CidrBlock = value
        }
        if let value = dict["Ipv6Isp"] as? String {
            self.ipv6Isp = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AllocateVpcIpv6CidrResponseBody : Tea.TeaModel {
    public var ipv6CidrBlock: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6CidrBlock"] as? String {
            self.ipv6CidrBlock = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AllocateVpcIpv6CidrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateVpcIpv6CidrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateVpcIpv6CidrResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ApplyPhysicalConnectionLOARequest : Tea.TeaModel {
    public class PMInfo : Tea.TeaModel {
        public var PMCertificateNo: String?

        public var PMCertificateType: String?

        public var PMContactInfo: String?

        public var PMGender: String?

        public var PMName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.PMCertificateNo != nil {
                map["PMCertificateNo"] = self.PMCertificateNo!
            }
            if self.PMCertificateType != nil {
                map["PMCertificateType"] = self.PMCertificateType!
            }
            if self.PMContactInfo != nil {
                map["PMContactInfo"] = self.PMContactInfo!
            }
            if self.PMGender != nil {
                map["PMGender"] = self.PMGender!
            }
            if self.PMName != nil {
                map["PMName"] = self.PMName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PMCertificateNo"] as? String {
                self.PMCertificateNo = value
            }
            if let value = dict["PMCertificateType"] as? String {
                self.PMCertificateType = value
            }
            if let value = dict["PMContactInfo"] as? String {
                self.PMContactInfo = value
            }
            if let value = dict["PMGender"] as? String {
                self.PMGender = value
            }
            if let value = dict["PMName"] as? String {
                self.PMName = value
            }
        }
    }
    public var bandwidth: Int32?

    public var clientToken: String?

    public var companyName: String?

    public var constructionTime: String?

    public var instanceId: String?

    public var lineType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var PMInfo: [ApplyPhysicalConnectionLOARequest.PMInfo]?

    public var peerLocation: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var si: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.companyName != nil {
            map["CompanyName"] = self.companyName!
        }
        if self.constructionTime != nil {
            map["ConstructionTime"] = self.constructionTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lineType != nil {
            map["LineType"] = self.lineType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.PMInfo != nil {
            var tmp : [Any] = []
            for k in self.PMInfo! {
                tmp.append(k.toMap())
            }
            map["PMInfo"] = tmp
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.si != nil {
            map["Si"] = self.si!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompanyName"] as? String {
            self.companyName = value
        }
        if let value = dict["ConstructionTime"] as? String {
            self.constructionTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LineType"] as? String {
            self.lineType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PMInfo"] as? [Any?] {
            var tmp : [ApplyPhysicalConnectionLOARequest.PMInfo] = []
            for v in value {
                if v != nil {
                    var model = ApplyPhysicalConnectionLOARequest.PMInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.PMInfo = tmp
        }
        if let value = dict["PeerLocation"] as? String {
            self.peerLocation = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Si"] as? String {
            self.si = value
        }
    }
}

public class ApplyPhysicalConnectionLOAResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ApplyPhysicalConnectionLOAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyPhysicalConnectionLOAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ApplyPhysicalConnectionLOAResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceRegionId: String?

    public var instanceType: String?

    public var mode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceRegionId != nil {
            map["InstanceRegionId"] = self.instanceRegionId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceRegionId"] as? String {
            self.instanceRegionId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["Mode"] as? String {
            self.mode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class AssociateEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateEipAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateEipAddressBatchRequest : Tea.TeaModel {
    public var bindedInstanceId: String?

    public var bindedInstanceType: String?

    public var clientToken: String?

    public var instanceIds: [String]?

    public var mode: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindedInstanceId != nil {
            map["BindedInstanceId"] = self.bindedInstanceId!
        }
        if self.bindedInstanceType != nil {
            map["BindedInstanceType"] = self.bindedInstanceType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BindedInstanceId"] as? String {
            self.bindedInstanceId = value
        }
        if let value = dict["BindedInstanceType"] as? String {
            self.bindedInstanceType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["Mode"] as? String {
            self.mode = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AssociateEipAddressBatchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateEipAddressBatchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateEipAddressBatchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateEipAddressBatchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var haVipId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AssociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateHaVipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateNetworkAclRequest : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resource: [AssociateNetworkAclRequest.Resource]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            var tmp : [Any] = []
            for k in self.resource! {
                tmp.append(k.toMap())
            }
            map["Resource"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Resource"] as? [Any?] {
            var tmp : [AssociateNetworkAclRequest.Resource] = []
            for v in value {
                if v != nil {
                    var model = AssociateNetworkAclRequest.Resource()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resource = tmp
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AssociateNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateNetworkAclResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociatePhysicalConnectionToVirtualBorderRouterRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var enableIpv6: String?

    public var localGatewayIp: String?

    public var localIpv6GatewayIp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peerIpv6GatewayIp: String?

    public var peeringIpv6SubnetMask: String?

    public var peeringSubnetMask: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public var vlanId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.localIpv6GatewayIp != nil {
            map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peerIpv6GatewayIp != nil {
            map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
        }
        if self.peeringIpv6SubnetMask != nil {
            map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CircuitCode"] as? String {
            self.circuitCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableIpv6"] as? String {
            self.enableIpv6 = value
        }
        if let value = dict["LocalGatewayIp"] as? String {
            self.localGatewayIp = value
        }
        if let value = dict["LocalIpv6GatewayIp"] as? String {
            self.localIpv6GatewayIp = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerGatewayIp"] as? String {
            self.peerGatewayIp = value
        }
        if let value = dict["PeerIpv6GatewayIp"] as? String {
            self.peerIpv6GatewayIp = value
        }
        if let value = dict["PeeringIpv6SubnetMask"] as? String {
            self.peeringIpv6SubnetMask = value
        }
        if let value = dict["PeeringSubnetMask"] as? String {
            self.peeringSubnetMask = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
        if let value = dict["VlanId"] as? String {
            self.vlanId = value
        }
    }
}

public class AssociatePhysicalConnectionToVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociatePhysicalConnectionToVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociatePhysicalConnectionToVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociatePhysicalConnectionToVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateRouteTableRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class AssociateRouteTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateRouteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateRouteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateRouteTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateRouteTableWithGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var gatewayId: String?

    public var gatewayType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayType != nil {
            map["GatewayType"] = self.gatewayType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["GatewayId"] as? String {
            self.gatewayId = value
        }
        if let value = dict["GatewayType"] as? String {
            self.gatewayType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
    }
}

public class AssociateRouteTableWithGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateRouteTableWithGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateRouteTableWithGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateRouteTableWithGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateRouteTablesWithVpcGatewayEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableIds != nil {
            map["RouteTableIds"] = self.routeTableIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EndpointId"] as? String {
            self.endpointId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableIds"] as? [String] {
            self.routeTableIds = value
        }
    }
}

public class AssociateRouteTablesWithVpcGatewayEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateRouteTablesWithVpcGatewayEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateRouteTablesWithVpcGatewayEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateRouteTablesWithVpcGatewayEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateVpcCidrBlockRequest : Tea.TeaModel {
    public var IPv6CidrBlock: String?

    public var ipVersion: String?

    public var ipamPoolId: String?

    public var ipv6CidrMask: Int32?

    public var ipv6Isp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var secondaryCidrBlock: String?

    public var secondaryCidrMask: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.IPv6CidrBlock != nil {
            map["IPv6CidrBlock"] = self.IPv6CidrBlock!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ipamPoolId != nil {
            map["IpamPoolId"] = self.ipamPoolId!
        }
        if self.ipv6CidrMask != nil {
            map["Ipv6CidrMask"] = self.ipv6CidrMask!
        }
        if self.ipv6Isp != nil {
            map["Ipv6Isp"] = self.ipv6Isp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.secondaryCidrBlock != nil {
            map["SecondaryCidrBlock"] = self.secondaryCidrBlock!
        }
        if self.secondaryCidrMask != nil {
            map["SecondaryCidrMask"] = self.secondaryCidrMask!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IPv6CidrBlock"] as? String {
            self.IPv6CidrBlock = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["IpamPoolId"] as? String {
            self.ipamPoolId = value
        }
        if let value = dict["Ipv6CidrMask"] as? Int32 {
            self.ipv6CidrMask = value
        }
        if let value = dict["Ipv6Isp"] as? String {
            self.ipv6Isp = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecondaryCidrBlock"] as? String {
            self.secondaryCidrBlock = value
        }
        if let value = dict["SecondaryCidrMask"] as? Int32 {
            self.secondaryCidrMask = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class AssociateVpcCidrBlockResponseBody : Tea.TeaModel {
    public var cidrBlock: String?

    public var ipVersion: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateVpcCidrBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateVpcCidrBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateVpcCidrBlockResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateVpnGatewayWithCertificateRequest : Tea.TeaModel {
    public var certificateId: String?

    public var certificateType: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.certificateType != nil {
            map["CertificateType"] = self.certificateType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertificateId"] as? String {
            self.certificateId = value
        }
        if let value = dict["CertificateType"] as? String {
            self.certificateType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class AssociateVpnGatewayWithCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateVpnGatewayWithCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateVpnGatewayWithCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateVpnGatewayWithCertificateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachDhcpOptionsSetToVpcRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class AttachDhcpOptionsSetToVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachDhcpOptionsSetToVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDhcpOptionsSetToVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachDhcpOptionsSetToVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachVbrToVpconnRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var regionId: String?

    public var token: String?

    public var vbrId: String?

    public var vpconnId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        if self.vpconnId != nil {
            map["VpconnId"] = self.vpconnId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Token"] as? String {
            self.token = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
        if let value = dict["VpconnId"] as? String {
            self.vpconnId = value
        }
    }
}

public class AttachVbrToVpconnResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var virtualPhysicalConnection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.virtualPhysicalConnection != nil {
            map["VirtualPhysicalConnection"] = self.virtualPhysicalConnection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VirtualPhysicalConnection"] as? String {
            self.virtualPhysicalConnection = value
        }
    }
}

public class AttachVbrToVpconnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachVbrToVpconnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachVbrToVpconnResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelCommonBandwidthPackageIpBandwidthRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var eipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.eipId != nil {
            map["EipId"] = self.eipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["EipId"] as? String {
            self.eipId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CancelCommonBandwidthPackageIpBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelCommonBandwidthPackageIpBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelCommonBandwidthPackageIpBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelCommonBandwidthPackageIpBandwidthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelPhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CancelPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelPhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NewResourceGroupId"] as? String {
            self.newResourceGroupId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckCanAllocateVpcPrivateIpAddressRequest : Tea.TeaModel {
    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class CheckCanAllocateVpcPrivateIpAddressResponseBody : Tea.TeaModel {
    public var canAllocate: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.canAllocate != nil {
            map["CanAllocate"] = self.canAllocate!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CanAllocate"] as? Bool {
            self.canAllocate = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CheckCanAllocateVpcPrivateIpAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckCanAllocateVpcPrivateIpAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckCanAllocateVpcPrivateIpAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckVpnBgpEnabledRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CheckVpnBgpEnabledResponseBody : Tea.TeaModel {
    public var bgpEnabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpEnabled != nil {
            map["BgpEnabled"] = self.bgpEnabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpEnabled"] as? Bool {
            self.bgpEnabled = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CheckVpnBgpEnabledResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckVpnBgpEnabledResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckVpnBgpEnabledResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CompletePhysicalConnectionLOARequest : Tea.TeaModel {
    public var clientToken: String?

    public var finishWork: Bool?

    public var instanceId: String?

    public var lineCode: String?

    public var lineLabel: String?

    public var lineSPContactInfo: String?

    public var lineServiceProvider: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.finishWork != nil {
            map["FinishWork"] = self.finishWork!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lineCode != nil {
            map["LineCode"] = self.lineCode!
        }
        if self.lineLabel != nil {
            map["LineLabel"] = self.lineLabel!
        }
        if self.lineSPContactInfo != nil {
            map["LineSPContactInfo"] = self.lineSPContactInfo!
        }
        if self.lineServiceProvider != nil {
            map["LineServiceProvider"] = self.lineServiceProvider!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["FinishWork"] as? Bool {
            self.finishWork = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LineCode"] as? String {
            self.lineCode = value
        }
        if let value = dict["LineLabel"] as? String {
            self.lineLabel = value
        }
        if let value = dict["LineSPContactInfo"] as? String {
            self.lineSPContactInfo = value
        }
        if let value = dict["LineServiceProvider"] as? String {
            self.lineServiceProvider = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CompletePhysicalConnectionLOAResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CompletePhysicalConnectionLOAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CompletePhysicalConnectionLOAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CompletePhysicalConnectionLOAResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ConfirmPhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ConfirmPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ConfirmPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ConfirmPhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ConnectRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class ConnectRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ConnectRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConnectRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ConnectRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ConvertBandwidthPackageRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ConvertBandwidthPackageResponseBody : Tea.TeaModel {
    public var convertInstanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.convertInstanceId != nil {
            map["ConvertInstanceId"] = self.convertInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConvertInstanceId"] as? String {
            self.convertInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ConvertBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConvertBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ConvertBandwidthPackageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopyNetworkAclEntriesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sourceNetworkAclId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceNetworkAclId != nil {
            map["SourceNetworkAclId"] = self.sourceNetworkAclId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SourceNetworkAclId"] as? String {
            self.sourceNetworkAclId = value
        }
    }
}

public class CopyNetworkAclEntriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CopyNetworkAclEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyNetworkAclEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopyNetworkAclEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateBgpGroupRequest : Tea.TeaModel {
    public var authKey: String?

    public var clientToken: String?

    public var description_: String?

    public var ipVersion: String?

    public var isFakeAsn: Bool?

    public var localAsn: Int64?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerAsn: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeQuota: Int32?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.isFakeAsn != nil {
            map["IsFakeAsn"] = self.isFakeAsn!
        }
        if self.localAsn != nil {
            map["LocalAsn"] = self.localAsn!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerAsn != nil {
            map["PeerAsn"] = self.peerAsn!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeQuota != nil {
            map["RouteQuota"] = self.routeQuota!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthKey"] as? String {
            self.authKey = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["IsFakeAsn"] as? Bool {
            self.isFakeAsn = value
        }
        if let value = dict["LocalAsn"] as? Int64 {
            self.localAsn = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerAsn"] as? Int64 {
            self.peerAsn = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteQuota"] as? Int32 {
            self.routeQuota = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
    }
}

public class CreateBgpGroupResponseBody : Tea.TeaModel {
    public var bgpGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpGroupId"] as? String {
            self.bgpGroupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateBgpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBgpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateBgpGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateBgpPeerRequest : Tea.TeaModel {
    public var bfdMultiHop: Int32?

    public var bgpGroupId: String?

    public var clientToken: String?

    public var enableBfd: Bool?

    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bfdMultiHop != nil {
            map["BfdMultiHop"] = self.bfdMultiHop!
        }
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableBfd != nil {
            map["EnableBfd"] = self.enableBfd!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerIpAddress != nil {
            map["PeerIpAddress"] = self.peerIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BfdMultiHop"] as? Int32 {
            self.bfdMultiHop = value
        }
        if let value = dict["BgpGroupId"] as? String {
            self.bgpGroupId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableBfd"] as? Bool {
            self.enableBfd = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerIpAddress"] as? String {
            self.peerIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateBgpPeerResponseBody : Tea.TeaModel {
    public var bgpPeerId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpPeerId != nil {
            map["BgpPeerId"] = self.bgpPeerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpPeerId"] as? String {
            self.bgpPeerId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateBgpPeerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBgpPeerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateBgpPeerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCommonBandwidthPackageRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var bandwidth: Int32?

    public var clientToken: String?

    public var description_: String?

    public var ISP: String?

    public var internetChargeType: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var ratio: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionTypes: [String]?

    public var tag: [CreateCommonBandwidthPackageRequest.Tag]?

    public var zone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ratio != nil {
            map["Ratio"] = self.ratio!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionTypes != nil {
            map["SecurityProtectionTypes"] = self.securityProtectionTypes!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zone != nil {
            map["Zone"] = self.zone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ISP"] as? String {
            self.ISP = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Ratio"] as? Int32 {
            self.ratio = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityProtectionTypes"] as? [String] {
            self.securityProtectionTypes = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateCommonBandwidthPackageRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateCommonBandwidthPackageRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Zone"] as? String {
            self.zone = value
        }
    }
}

public class CreateCommonBandwidthPackageResponseBody : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class CreateCommonBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommonBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCommonBandwidthPackageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCustomerGatewayRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var asn: String?

    public var authKey: String?

    public var clientToken: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [CreateCustomerGatewayRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asn != nil {
            map["Asn"] = self.asn!
        }
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asn"] as? String {
            self.asn = value
        }
        if let value = dict["AuthKey"] as? String {
            self.authKey = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [CreateCustomerGatewayRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateCustomerGatewayRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class CreateCustomerGatewayResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateCustomerGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomerGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCustomerGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDefaultVSwitchRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6CidrBlock: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Ipv6CidrBlock"] as? Int32 {
            self.ipv6CidrBlock = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateDefaultVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class CreateDefaultVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDefaultVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDefaultVSwitchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDefaultVpcRequest : Tea.TeaModel {
    public var clientToken: String?

    public var enableIpv6: Bool?

    public var ipv6CidrBlock: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableIpv6"] as? Bool {
            self.enableIpv6 = value
        }
        if let value = dict["Ipv6CidrBlock"] as? String {
            self.ipv6CidrBlock = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateDefaultVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeTableId: String?

    public var VRouterId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateDefaultVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDefaultVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDefaultVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDhcpOptionsSetRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var dhcpOptionsSetDescription: String?

    public var dhcpOptionsSetName: String?

    public var domainName: String?

    public var domainNameServers: String?

    public var dryRun: Bool?

    public var ipv6LeaseTime: String?

    public var leaseTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateDhcpOptionsSetRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetDescription != nil {
            map["DhcpOptionsSetDescription"] = self.dhcpOptionsSetDescription!
        }
        if self.dhcpOptionsSetName != nil {
            map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainNameServers != nil {
            map["DomainNameServers"] = self.domainNameServers!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6LeaseTime != nil {
            map["Ipv6LeaseTime"] = self.ipv6LeaseTime!
        }
        if self.leaseTime != nil {
            map["LeaseTime"] = self.leaseTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DhcpOptionsSetDescription"] as? String {
            self.dhcpOptionsSetDescription = value
        }
        if let value = dict["DhcpOptionsSetName"] as? String {
            self.dhcpOptionsSetName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainNameServers"] as? String {
            self.domainNameServers = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv6LeaseTime"] as? String {
            self.ipv6LeaseTime = value
        }
        if let value = dict["LeaseTime"] as? String {
            self.leaseTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateDhcpOptionsSetRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateDhcpOptionsSetRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateDhcpOptionsSetResponseBody : Tea.TeaModel {
    public var dhcpOptionsSetId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class CreateDhcpOptionsSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDhcpOptionsSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDhcpOptionsSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateExpressCloudConnectionRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var contactMail: String?

    public var contactTel: String?

    public var description_: String?

    public var IDCardNo: String?

    public var idcSP: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerCity: String?

    public var peerLocation: String?

    public var portType: String?

    public var redundantEccId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.contactMail != nil {
            map["ContactMail"] = self.contactMail!
        }
        if self.contactTel != nil {
            map["ContactTel"] = self.contactTel!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.IDCardNo != nil {
            map["IDCardNo"] = self.IDCardNo!
        }
        if self.idcSP != nil {
            map["IdcSP"] = self.idcSP!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerCity != nil {
            map["PeerCity"] = self.peerCity!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantEccId != nil {
            map["RedundantEccId"] = self.redundantEccId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["ContactMail"] as? String {
            self.contactMail = value
        }
        if let value = dict["ContactTel"] as? String {
            self.contactTel = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IDCardNo"] as? String {
            self.IDCardNo = value
        }
        if let value = dict["IdcSP"] as? String {
            self.idcSP = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerCity"] as? String {
            self.peerCity = value
        }
        if let value = dict["PeerLocation"] as? String {
            self.peerLocation = value
        }
        if let value = dict["PortType"] as? String {
            self.portType = value
        }
        if let value = dict["RedundantEccId"] as? String {
            self.redundantEccId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateExpressCloudConnectionResponseBody : Tea.TeaModel {
    public var eccId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eccId != nil {
            map["EccId"] = self.eccId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EccId"] as? String {
            self.eccId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateExpressCloudConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExpressCloudConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateExpressCloudConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateExpressConnectTrafficQosRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosDescription: String?

    public var qosName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var tags: [CreateExpressConnectTrafficQosRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosDescription != nil {
            map["QosDescription"] = self.qosDescription!
        }
        if self.qosName != nil {
            map["QosName"] = self.qosName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosDescription"] as? String {
            self.qosDescription = value
        }
        if let value = dict["QosName"] as? String {
            self.qosName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [CreateExpressConnectTrafficQosRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateExpressConnectTrafficQosRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class CreateExpressConnectTrafficQosResponseBody : Tea.TeaModel {
    public var qosId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateExpressConnectTrafficQosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExpressConnectTrafficQosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateExpressConnectTrafficQosResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateExpressConnectTrafficQosQueueRequest : Tea.TeaModel {
    public var bandwidthPercent: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueDescription: String?

    public var queueName: String?

    public var queueType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPercent != nil {
            map["BandwidthPercent"] = self.bandwidthPercent!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueDescription != nil {
            map["QueueDescription"] = self.queueDescription!
        }
        if self.queueName != nil {
            map["QueueName"] = self.queueName!
        }
        if self.queueType != nil {
            map["QueueType"] = self.queueType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPercent"] as? String {
            self.bandwidthPercent = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueDescription"] as? String {
            self.queueDescription = value
        }
        if let value = dict["QueueName"] as? String {
            self.queueName = value
        }
        if let value = dict["QueueType"] as? String {
            self.queueType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class CreateExpressConnectTrafficQosQueueResponseBody : Tea.TeaModel {
    public var qosId: String?

    public var queueId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueId"] as? String {
            self.queueId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateExpressConnectTrafficQosQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExpressConnectTrafficQosQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateExpressConnectTrafficQosQueueResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateExpressConnectTrafficQosRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dstCidr: String?

    public var dstIPv6Cidr: String?

    public var dstPortRange: String?

    public var matchDscp: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var protocol_: String?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var remarkingDscp: Int32?

    public var resourceOwnerAccount: String?

    public var ruleDescription: String?

    public var ruleName: String?

    public var srcCidr: String?

    public var srcIPv6Cidr: String?

    public var srcPortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dstCidr != nil {
            map["DstCidr"] = self.dstCidr!
        }
        if self.dstIPv6Cidr != nil {
            map["DstIPv6Cidr"] = self.dstIPv6Cidr!
        }
        if self.dstPortRange != nil {
            map["DstPortRange"] = self.dstPortRange!
        }
        if self.matchDscp != nil {
            map["MatchDscp"] = self.matchDscp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remarkingDscp != nil {
            map["RemarkingDscp"] = self.remarkingDscp!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.ruleDescription != nil {
            map["RuleDescription"] = self.ruleDescription!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.srcCidr != nil {
            map["SrcCidr"] = self.srcCidr!
        }
        if self.srcIPv6Cidr != nil {
            map["SrcIPv6Cidr"] = self.srcIPv6Cidr!
        }
        if self.srcPortRange != nil {
            map["SrcPortRange"] = self.srcPortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DstCidr"] as? String {
            self.dstCidr = value
        }
        if let value = dict["DstIPv6Cidr"] as? String {
            self.dstIPv6Cidr = value
        }
        if let value = dict["DstPortRange"] as? String {
            self.dstPortRange = value
        }
        if let value = dict["MatchDscp"] as? Int32 {
            self.matchDscp = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueId"] as? String {
            self.queueId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemarkingDscp"] as? Int32 {
            self.remarkingDscp = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["RuleDescription"] as? String {
            self.ruleDescription = value
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
        if let value = dict["SrcCidr"] as? String {
            self.srcCidr = value
        }
        if let value = dict["SrcIPv6Cidr"] as? String {
            self.srcIPv6Cidr = value
        }
        if let value = dict["SrcPortRange"] as? String {
            self.srcPortRange = value
        }
    }
}

public class CreateExpressConnectTrafficQosRuleResponseBody : Tea.TeaModel {
    public var qosId: String?

    public var queueId: String?

    public var requestId: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueId"] as? String {
            self.queueId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RuleId"] as? String {
            self.ruleId = value
        }
    }
}

public class CreateExpressConnectTrafficQosRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateExpressConnectTrafficQosRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateExpressConnectTrafficQosRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var jobDuration: Int32?

    public var jobType: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.jobDuration != nil {
            map["JobDuration"] = self.jobDuration!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["JobDuration"] as? Int32 {
            self.jobDuration = value
        }
        if let value = dict["JobType"] as? String {
            self.jobType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class CreateFailoverTestJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateFailoverTestJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateFlowLogRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aggregationInterval: Int32?

    public var description_: String?

    public var flowLogName: String?

    public var ipVersion: String?

    public var logStoreName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var projectName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [CreateFlowLogRequest.Tag]?

    public var trafficPath: [String]?

    public var trafficType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregationInterval != nil {
            map["AggregationInterval"] = self.aggregationInterval!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.flowLogName != nil {
            map["FlowLogName"] = self.flowLogName!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.logStoreName != nil {
            map["LogStoreName"] = self.logStoreName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.trafficPath != nil {
            map["TrafficPath"] = self.trafficPath!
        }
        if self.trafficType != nil {
            map["TrafficType"] = self.trafficType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregationInterval"] as? Int32 {
            self.aggregationInterval = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FlowLogName"] as? String {
            self.flowLogName = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["LogStoreName"] as? String {
            self.logStoreName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateFlowLogRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateFlowLogRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TrafficPath"] as? [String] {
            self.trafficPath = value
        }
        if let value = dict["TrafficType"] as? String {
            self.trafficType = value
        }
    }
}

public class CreateFlowLogResponseBody : Tea.TeaModel {
    public var flowLogId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FlowLogId"] as? String {
            self.flowLogId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CreateFlowLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateFlowLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateForwardEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryName: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portBreak: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portBreak != nil {
            map["PortBreak"] = self.portBreak!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ExternalIp"] as? String {
            self.externalIp = value
        }
        if let value = dict["ExternalPort"] as? String {
            self.externalPort = value
        }
        if let value = dict["ForwardEntryName"] as? String {
            self.forwardEntryName = value
        }
        if let value = dict["ForwardTableId"] as? String {
            self.forwardTableId = value
        }
        if let value = dict["InternalIp"] as? String {
            self.internalIp = value
        }
        if let value = dict["InternalPort"] as? String {
            self.internalPort = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortBreak"] as? Bool {
            self.portBreak = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateForwardEntryResponseBody : Tea.TeaModel {
    public var forwardEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForwardEntryId"] as? String {
            self.forwardEntryId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateForwardEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateFullNatEntryRequest : Tea.TeaModel {
    public var accessIp: String?

    public var accessPort: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var fullNatEntryDescription: String?

    public var fullNatEntryName: String?

    public var fullNatTableId: String?

    public var ipProtocol: String?

    public var natIp: String?

    public var natIpPort: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessIp != nil {
            map["AccessIp"] = self.accessIp!
        }
        if self.accessPort != nil {
            map["AccessPort"] = self.accessPort!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.fullNatEntryDescription != nil {
            map["FullNatEntryDescription"] = self.fullNatEntryDescription!
        }
        if self.fullNatEntryName != nil {
            map["FullNatEntryName"] = self.fullNatEntryName!
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpPort != nil {
            map["NatIpPort"] = self.natIpPort!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessIp"] as? String {
            self.accessIp = value
        }
        if let value = dict["AccessPort"] as? String {
            self.accessPort = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["FullNatEntryDescription"] as? String {
            self.fullNatEntryDescription = value
        }
        if let value = dict["FullNatEntryName"] as? String {
            self.fullNatEntryName = value
        }
        if let value = dict["FullNatTableId"] as? String {
            self.fullNatTableId = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["NatIp"] as? String {
            self.natIp = value
        }
        if let value = dict["NatIpPort"] as? String {
            self.natIpPort = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateFullNatEntryResponseBody : Tea.TeaModel {
    public var fullNatEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fullNatEntryId != nil {
            map["FullNatEntryId"] = self.fullNatEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FullNatEntryId"] as? String {
            self.fullNatEntryId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateFullNatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFullNatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateFullNatEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateGlobalAccelerationInstanceRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var bandwidthType: String?

    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceLocation: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthType != nil {
            map["BandwidthType"] = self.bandwidthType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceLocation != nil {
            map["ServiceLocation"] = self.serviceLocation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["BandwidthType"] as? String {
            self.bandwidthType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServiceLocation"] as? String {
            self.serviceLocation = value
        }
    }
}

public class CreateGlobalAccelerationInstanceResponseBody : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var ipAddress: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GlobalAccelerationInstanceId"] as? String {
            self.globalAccelerationInstanceId = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateGlobalAccelerationInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGlobalAccelerationInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateGlobalAccelerationInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateHaVipRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateHaVipRequest.Tag]?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateHaVipRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateHaVipRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class CreateHaVipResponseBody : Tea.TeaModel {
    public var haVipId: String?

    public var ipAddress: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateHaVipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateHighReliablePhysicalConnectionRequest : Tea.TeaModel {
    public class ApList : Tea.TeaModel {
        public var accessPointId: String?

        public var bandwidth: Int64?

        public var circuitCode: String?

        public var description_: String?

        public var lineOperator: String?

        public var name: String?

        public var opticalModuleModel: String?

        public var peerLocation: String?

        public var portNum: Int32?

        public var regionId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointId != nil {
                map["AccessPointId"] = self.accessPointId!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.circuitCode != nil {
                map["CircuitCode"] = self.circuitCode!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.lineOperator != nil {
                map["LineOperator"] = self.lineOperator!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.opticalModuleModel != nil {
                map["OpticalModuleModel"] = self.opticalModuleModel!
            }
            if self.peerLocation != nil {
                map["PeerLocation"] = self.peerLocation!
            }
            if self.portNum != nil {
                map["PortNum"] = self.portNum!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessPointId"] as? String {
                self.accessPointId = value
            }
            if let value = dict["Bandwidth"] as? Int64 {
                self.bandwidth = value
            }
            if let value = dict["CircuitCode"] as? String {
                self.circuitCode = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["LineOperator"] as? String {
                self.lineOperator = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["OpticalModuleModel"] as? String {
                self.opticalModuleModel = value
            }
            if let value = dict["PeerLocation"] as? String {
                self.peerLocation = value
            }
            if let value = dict["PortNum"] as? Int32 {
                self.portNum = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var acceptLanguage: String?

    public var apList: [CreateHighReliablePhysicalConnectionRequest.ApList]?

    public var clientToken: String?

    public var deviceAdvancedCapacity: [String]?

    public var dryRun: String?

    public var highReliableType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateHighReliablePhysicalConnectionRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.apList != nil {
            var tmp : [Any] = []
            for k in self.apList! {
                tmp.append(k.toMap())
            }
            map["ApList"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.deviceAdvancedCapacity != nil {
            map["DeviceAdvancedCapacity"] = self.deviceAdvancedCapacity!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.highReliableType != nil {
            map["HighReliableType"] = self.highReliableType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ApList"] as? [Any?] {
            var tmp : [CreateHighReliablePhysicalConnectionRequest.ApList] = []
            for v in value {
                if v != nil {
                    var model = CreateHighReliablePhysicalConnectionRequest.ApList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.apList = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DeviceAdvancedCapacity"] as? [String] {
            self.deviceAdvancedCapacity = value
        }
        if let value = dict["DryRun"] as? String {
            self.dryRun = value
        }
        if let value = dict["HighReliableType"] as? String {
            self.highReliableType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortType"] as? String {
            self.portType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateHighReliablePhysicalConnectionRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateHighReliablePhysicalConnectionRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateHighReliablePhysicalConnectionResponseBody : Tea.TeaModel {
    public class ErrorInfoList : Tea.TeaModel {
        public class ErrorInfoList : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["ErrorMessage"] as? String {
                    self.errorMessage = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var errorInfoList: [CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList.ErrorInfoList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorInfoList != nil {
                var tmp : [Any] = []
                for k in self.errorInfoList! {
                    tmp.append(k.toMap())
                }
                map["errorInfoList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["errorInfoList"] as? [Any?] {
                var tmp : [CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList.ErrorInfoList] = []
                for v in value {
                    if v != nil {
                        var model = CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList.ErrorInfoList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.errorInfoList = tmp
            }
        }
    }
    public class PhysicalConnectionList : Tea.TeaModel {
        public class PhysicalConnectionList : Tea.TeaModel {
            public var instanceId: String?

            public var regionNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.regionNo != nil {
                    map["RegionNo"] = self.regionNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["RegionNo"] as? String {
                    self.regionNo = value
                }
            }
        }
        public var physicalConnectionList: [CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList.PhysicalConnectionList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.physicalConnectionList != nil {
                var tmp : [Any] = []
                for k in self.physicalConnectionList! {
                    tmp.append(k.toMap())
                }
                map["physicalConnectionList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["physicalConnectionList"] as? [Any?] {
                var tmp : [CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList.PhysicalConnectionList] = []
                for v in value {
                    if v != nil {
                        var model = CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList.PhysicalConnectionList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.physicalConnectionList = tmp
            }
        }
    }
    public var errorInfoList: CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList?

    public var physicalConnectionList: CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorInfoList?.validate()
        try self.physicalConnectionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorInfoList != nil {
            map["ErrorInfoList"] = self.errorInfoList?.toMap()
        }
        if self.physicalConnectionList != nil {
            map["PhysicalConnectionList"] = self.physicalConnectionList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorInfoList"] as? [String: Any?] {
            var model = CreateHighReliablePhysicalConnectionResponseBody.ErrorInfoList()
            model.fromMap(value)
            self.errorInfoList = model
        }
        if let value = dict["PhysicalConnectionList"] as? [String: Any?] {
            var model = CreateHighReliablePhysicalConnectionResponseBody.PhysicalConnectionList()
            model.fromMap(value)
            self.physicalConnectionList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateHighReliablePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHighReliablePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateHighReliablePhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIPv6TranslatorRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var bandwidth: Int32?

    public var clientToken: String?

    public var duration: Int32?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var pricingCycle: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Duration"] as? Int32 {
            self.duration = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["PricingCycle"] as? String {
            self.pricingCycle = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class CreateIPv6TranslatorResponseBody : Tea.TeaModel {
    public var ipv6TranslatorId: String?

    public var name: String?

    public var orderId: Int64?

    public var requestId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6TranslatorId"] as? String {
            self.ipv6TranslatorId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class CreateIPv6TranslatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIPv6TranslatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIPv6TranslatorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIPv6TranslatorAclListRequest : Tea.TeaModel {
    public var aclName: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclName"] as? String {
            self.aclName = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateIPv6TranslatorAclListResponseBody : Tea.TeaModel {
    public var aclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateIPv6TranslatorAclListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIPv6TranslatorAclListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIPv6TranslatorAclListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIPv6TranslatorEntryRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclStatus: String?

    public var aclType: String?

    public var allocateIpv6Port: Int32?

    public var backendIpv4Addr: String?

    public var backendIpv4Port: Int32?

    public var entryBandwidth: Int32?

    public var entryDescription: String?

    public var entryName: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var transProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclStatus != nil {
            map["AclStatus"] = self.aclStatus!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.allocateIpv6Port != nil {
            map["AllocateIpv6Port"] = self.allocateIpv6Port!
        }
        if self.backendIpv4Addr != nil {
            map["BackendIpv4Addr"] = self.backendIpv4Addr!
        }
        if self.backendIpv4Port != nil {
            map["BackendIpv4Port"] = self.backendIpv4Port!
        }
        if self.entryBandwidth != nil {
            map["EntryBandwidth"] = self.entryBandwidth!
        }
        if self.entryDescription != nil {
            map["EntryDescription"] = self.entryDescription!
        }
        if self.entryName != nil {
            map["EntryName"] = self.entryName!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.transProtocol != nil {
            map["TransProtocol"] = self.transProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["AclStatus"] as? String {
            self.aclStatus = value
        }
        if let value = dict["AclType"] as? String {
            self.aclType = value
        }
        if let value = dict["AllocateIpv6Port"] as? Int32 {
            self.allocateIpv6Port = value
        }
        if let value = dict["BackendIpv4Addr"] as? String {
            self.backendIpv4Addr = value
        }
        if let value = dict["BackendIpv4Port"] as? Int32 {
            self.backendIpv4Port = value
        }
        if let value = dict["EntryBandwidth"] as? Int32 {
            self.entryBandwidth = value
        }
        if let value = dict["EntryDescription"] as? String {
            self.entryDescription = value
        }
        if let value = dict["EntryName"] as? String {
            self.entryName = value
        }
        if let value = dict["Ipv6TranslatorId"] as? String {
            self.ipv6TranslatorId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TransProtocol"] as? String {
            self.transProtocol = value
        }
    }
}

public class CreateIPv6TranslatorEntryResponseBody : Tea.TeaModel {
    public var ipv6TranslatorEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6TranslatorEntryId != nil {
            map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6TranslatorEntryId"] as? String {
            self.ipv6TranslatorEntryId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateIPv6TranslatorEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIPv6TranslatorEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIPv6TranslatorEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIpsecServerRequest : Tea.TeaModel {
    public var clientIpPool: String?

    public var clientToken: String?

    public var dryRun: String?

    public var effectImmediately: Bool?

    public var ikeConfig: String?

    public var ipSecServerName: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var psk: String?

    public var pskEnabled: Bool?

    public var regionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipSecServerName != nil {
            map["IpSecServerName"] = self.ipSecServerName!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.psk != nil {
            map["Psk"] = self.psk!
        }
        if self.pskEnabled != nil {
            map["PskEnabled"] = self.pskEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientIpPool"] as? String {
            self.clientIpPool = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? String {
            self.dryRun = value
        }
        if let value = dict["EffectImmediately"] as? Bool {
            self.effectImmediately = value
        }
        if let value = dict["IkeConfig"] as? String {
            self.ikeConfig = value
        }
        if let value = dict["IpSecServerName"] as? String {
            self.ipSecServerName = value
        }
        if let value = dict["IpsecConfig"] as? String {
            self.ipsecConfig = value
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Psk"] as? String {
            self.psk = value
        }
        if let value = dict["PskEnabled"] as? Bool {
            self.pskEnabled = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class CreateIpsecServerResponseBody : Tea.TeaModel {
    public var creationTime: String?

    public var ipsecServerId: String?

    public var ipsecServerName: String?

    public var regionId: String?

    public var requestId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.ipsecServerName != nil {
            map["IpsecServerName"] = self.ipsecServerName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["IpsecServerId"] as? String {
            self.ipsecServerId = value
        }
        if let value = dict["IpsecServerName"] as? String {
            self.ipsecServerName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class CreateIpsecServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpsecServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIpsecServerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIpv4GatewayRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv4GatewayDescription: String?

    public var ipv4GatewayName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateIpv4GatewayRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv4GatewayDescription != nil {
            map["Ipv4GatewayDescription"] = self.ipv4GatewayDescription!
        }
        if self.ipv4GatewayName != nil {
            map["Ipv4GatewayName"] = self.ipv4GatewayName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv4GatewayDescription"] as? String {
            self.ipv4GatewayDescription = value
        }
        if let value = dict["Ipv4GatewayName"] as? String {
            self.ipv4GatewayName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateIpv4GatewayRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateIpv4GatewayRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateIpv4GatewayResponseBody : Tea.TeaModel {
    public var ipv4GatewayId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv4GatewayId"] as? String {
            self.ipv4GatewayId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class CreateIpv4GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpv4GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIpv4GatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIpv6EgressOnlyRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ipv6GatewayId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["Ipv6GatewayId"] as? String {
            self.ipv6GatewayId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateIpv6EgressOnlyRuleResponseBody : Tea.TeaModel {
    public var ipv6EgressRuleId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6EgressRuleId != nil {
            map["Ipv6EgressRuleId"] = self.ipv6EgressRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6EgressRuleId"] as? String {
            self.ipv6EgressRuleId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateIpv6EgressOnlyRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpv6EgressOnlyRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIpv6EgressOnlyRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIpv6GatewayRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateIpv6GatewayRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateIpv6GatewayRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateIpv6GatewayRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateIpv6GatewayResponseBody : Tea.TeaModel {
    public var ipv6GatewayId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6GatewayId"] as? String {
            self.ipv6GatewayId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class CreateIpv6GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpv6GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIpv6GatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNatGatewayRequest : Tea.TeaModel {
    public class AccessMode : Tea.TeaModel {
        public var modeValue: String?

        public var tunnelType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modeValue != nil {
                map["ModeValue"] = self.modeValue!
            }
            if self.tunnelType != nil {
                map["TunnelType"] = self.tunnelType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ModeValue"] as? String {
                self.modeValue = value
            }
            if let value = dict["TunnelType"] as? String {
                self.tunnelType = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var accessMode: CreateNatGatewayRequest.AccessMode?

    public var autoPay: Bool?

    public var clientToken: String?

    public var description_: String?

    public var duration: String?

    public var eipBindMode: String?

    public var icmpReplyEnabled: Bool?

    public var instanceChargeType: String?

    public var internetChargeType: String?

    public var ipv4Prefix: String?

    public var name: String?

    public var natIp: String?

    public var natType: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pricingCycle: String?

    public var privateLinkEnabled: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var spec: String?

    public var tag: [CreateNatGatewayRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessMode?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode?.toMap()
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.eipBindMode != nil {
            map["EipBindMode"] = self.eipBindMode!
        }
        if self.icmpReplyEnabled != nil {
            map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.privateLinkEnabled != nil {
            map["PrivateLinkEnabled"] = self.privateLinkEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessMode"] as? [String: Any?] {
            var model = CreateNatGatewayRequest.AccessMode()
            model.fromMap(value)
            self.accessMode = model
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Duration"] as? String {
            self.duration = value
        }
        if let value = dict["EipBindMode"] as? String {
            self.eipBindMode = value
        }
        if let value = dict["IcmpReplyEnabled"] as? Bool {
            self.icmpReplyEnabled = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["Ipv4Prefix"] as? String {
            self.ipv4Prefix = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NatIp"] as? String {
            self.natIp = value
        }
        if let value = dict["NatType"] as? String {
            self.natType = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PricingCycle"] as? String {
            self.pricingCycle = value
        }
        if let value = dict["PrivateLinkEnabled"] as? Bool {
            self.privateLinkEnabled = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityProtectionEnabled"] as? Bool {
            self.securityProtectionEnabled = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateNatGatewayRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateNatGatewayRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateNatGatewayShrinkRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var accessModeShrink: String?

    public var autoPay: Bool?

    public var clientToken: String?

    public var description_: String?

    public var duration: String?

    public var eipBindMode: String?

    public var icmpReplyEnabled: Bool?

    public var instanceChargeType: String?

    public var internetChargeType: String?

    public var ipv4Prefix: String?

    public var name: String?

    public var natIp: String?

    public var natType: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pricingCycle: String?

    public var privateLinkEnabled: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var spec: String?

    public var tag: [CreateNatGatewayShrinkRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessModeShrink != nil {
            map["AccessMode"] = self.accessModeShrink!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.eipBindMode != nil {
            map["EipBindMode"] = self.eipBindMode!
        }
        if self.icmpReplyEnabled != nil {
            map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.privateLinkEnabled != nil {
            map["PrivateLinkEnabled"] = self.privateLinkEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessMode"] as? String {
            self.accessModeShrink = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Duration"] as? String {
            self.duration = value
        }
        if let value = dict["EipBindMode"] as? String {
            self.eipBindMode = value
        }
        if let value = dict["IcmpReplyEnabled"] as? Bool {
            self.icmpReplyEnabled = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["Ipv4Prefix"] as? String {
            self.ipv4Prefix = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NatIp"] as? String {
            self.natIp = value
        }
        if let value = dict["NatType"] as? String {
            self.natType = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PricingCycle"] as? String {
            self.pricingCycle = value
        }
        if let value = dict["PrivateLinkEnabled"] as? Bool {
            self.privateLinkEnabled = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityProtectionEnabled"] as? Bool {
            self.securityProtectionEnabled = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateNatGatewayShrinkRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateNatGatewayShrinkRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateNatGatewayResponseBody : Tea.TeaModel {
    public class ForwardTableIds : Tea.TeaModel {
        public var forwardTableId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardTableId != nil {
                map["ForwardTableId"] = self.forwardTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ForwardTableId"] as? [String] {
                self.forwardTableId = value
            }
        }
    }
    public class FullNatTableIds : Tea.TeaModel {
        public var fullNatTableId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fullNatTableId != nil {
                map["FullNatTableId"] = self.fullNatTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FullNatTableId"] as? [String] {
                self.fullNatTableId = value
            }
        }
    }
    public class SnatTableIds : Tea.TeaModel {
        public var snatTableId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snatTableId != nil {
                map["SnatTableId"] = self.snatTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SnatTableId"] as? [String] {
                self.snatTableId = value
            }
        }
    }
    public var forwardTableIds: CreateNatGatewayResponseBody.ForwardTableIds?

    public var fullNatTableIds: CreateNatGatewayResponseBody.FullNatTableIds?

    public var natGatewayId: String?

    public var requestId: String?

    public var snatTableIds: CreateNatGatewayResponseBody.SnatTableIds?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forwardTableIds?.validate()
        try self.fullNatTableIds?.validate()
        try self.snatTableIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardTableIds != nil {
            map["ForwardTableIds"] = self.forwardTableIds?.toMap()
        }
        if self.fullNatTableIds != nil {
            map["FullNatTableIds"] = self.fullNatTableIds?.toMap()
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatTableIds != nil {
            map["SnatTableIds"] = self.snatTableIds?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForwardTableIds"] as? [String: Any?] {
            var model = CreateNatGatewayResponseBody.ForwardTableIds()
            model.fromMap(value)
            self.forwardTableIds = model
        }
        if let value = dict["FullNatTableIds"] as? [String: Any?] {
            var model = CreateNatGatewayResponseBody.FullNatTableIds()
            model.fromMap(value)
            self.fullNatTableIds = model
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnatTableIds"] as? [String: Any?] {
            var model = CreateNatGatewayResponseBody.SnatTableIds()
            model.fromMap(value)
            self.snatTableIds = model
        }
    }
}

public class CreateNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNatGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNatIpRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv4Prefix: String?

    public var ipv4PrefixCount: Int64?

    public var natGatewayId: String?

    public var natIp: String?

    public var natIpCidr: String?

    public var natIpDescription: String?

    public var natIpName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.ipv4PrefixCount != nil {
            map["Ipv4PrefixCount"] = self.ipv4PrefixCount!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpDescription != nil {
            map["NatIpDescription"] = self.natIpDescription!
        }
        if self.natIpName != nil {
            map["NatIpName"] = self.natIpName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv4Prefix"] as? String {
            self.ipv4Prefix = value
        }
        if let value = dict["Ipv4PrefixCount"] as? Int64 {
            self.ipv4PrefixCount = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatIp"] as? String {
            self.natIp = value
        }
        if let value = dict["NatIpCidr"] as? String {
            self.natIpCidr = value
        }
        if let value = dict["NatIpDescription"] as? String {
            self.natIpDescription = value
        }
        if let value = dict["NatIpName"] as? String {
            self.natIpName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateNatIpResponseBody : Tea.TeaModel {
    public class NatIps : Tea.TeaModel {
        public var ipv4Prefix: String?

        public var natIp: String?

        public var natIpId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4Prefix != nil {
                map["Ipv4Prefix"] = self.ipv4Prefix!
            }
            if self.natIp != nil {
                map["NatIp"] = self.natIp!
            }
            if self.natIpId != nil {
                map["NatIpId"] = self.natIpId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv4Prefix"] as? String {
                self.ipv4Prefix = value
            }
            if let value = dict["NatIp"] as? String {
                self.natIp = value
            }
            if let value = dict["NatIpId"] as? String {
                self.natIpId = value
            }
        }
    }
    public var ipv4Prefix: String?

    public var natIp: String?

    public var natIpId: String?

    public var natIps: [CreateNatIpResponseBody.NatIps]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpId != nil {
            map["NatIpId"] = self.natIpId!
        }
        if self.natIps != nil {
            var tmp : [Any] = []
            for k in self.natIps! {
                tmp.append(k.toMap())
            }
            map["NatIps"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv4Prefix"] as? String {
            self.ipv4Prefix = value
        }
        if let value = dict["NatIp"] as? String {
            self.natIp = value
        }
        if let value = dict["NatIpId"] as? String {
            self.natIpId = value
        }
        if let value = dict["NatIps"] as? [Any?] {
            var tmp : [CreateNatIpResponseBody.NatIps] = []
            for v in value {
                if v != nil {
                    var model = CreateNatIpResponseBody.NatIps()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.natIps = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateNatIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNatIpResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNatIpCidrRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var natIpCidrDescription: String?

    public var natIpCidrName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpCidrDescription != nil {
            map["NatIpCidrDescription"] = self.natIpCidrDescription!
        }
        if self.natIpCidrName != nil {
            map["NatIpCidrName"] = self.natIpCidrName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatIpCidr"] as? String {
            self.natIpCidr = value
        }
        if let value = dict["NatIpCidrDescription"] as? String {
            self.natIpCidrDescription = value
        }
        if let value = dict["NatIpCidrName"] as? String {
            self.natIpCidrName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateNatIpCidrResponseBody : Tea.TeaModel {
    public var natIpCidrId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natIpCidrId != nil {
            map["NatIpCidrId"] = self.natIpCidrId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NatIpCidrId"] as? String {
            self.natIpCidrId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateNatIpCidrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatIpCidrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNatIpCidrResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNetworkAclRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var networkAclName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateNetworkAclRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NetworkAclName"] as? String {
            self.networkAclName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateNetworkAclRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateNetworkAclRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateNetworkAclResponseBody : Tea.TeaModel {
    public class NetworkAclAttribute : Tea.TeaModel {
        public class EgressAclEntries : Tea.TeaModel {
            public class EgressAclEntry : Tea.TeaModel {
                public var description_: String?

                public var destinationCidrIp: String?

                public var networkAclEntryId: String?

                public var networkAclEntryName: String?

                public var policy: String?

                public var port: String?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.destinationCidrIp != nil {
                        map["DestinationCidrIp"] = self.destinationCidrIp!
                    }
                    if self.networkAclEntryId != nil {
                        map["NetworkAclEntryId"] = self.networkAclEntryId!
                    }
                    if self.networkAclEntryName != nil {
                        map["NetworkAclEntryName"] = self.networkAclEntryName!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["DestinationCidrIp"] as? String {
                        self.destinationCidrIp = value
                    }
                    if let value = dict["NetworkAclEntryId"] as? String {
                        self.networkAclEntryId = value
                    }
                    if let value = dict["NetworkAclEntryName"] as? String {
                        self.networkAclEntryName = value
                    }
                    if let value = dict["Policy"] as? String {
                        self.policy = value
                    }
                    if let value = dict["Port"] as? String {
                        self.port = value
                    }
                    if let value = dict["Protocol"] as? String {
                        self.protocol_ = value
                    }
                }
            }
            public var egressAclEntry: [CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.egressAclEntry != nil {
                    var tmp : [Any] = []
                    for k in self.egressAclEntry! {
                        tmp.append(k.toMap())
                    }
                    map["EgressAclEntry"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EgressAclEntry"] as? [Any?] {
                    var tmp : [CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry] = []
                    for v in value {
                        if v != nil {
                            var model = CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.egressAclEntry = tmp
                }
            }
        }
        public class IngressAclEntries : Tea.TeaModel {
            public class IngressAclEntry : Tea.TeaModel {
                public var description_: String?

                public var networkAclEntryId: String?

                public var networkAclEntryName: String?

                public var policy: String?

                public var port: String?

                public var protocol_: String?

                public var sourceCidrIp: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.networkAclEntryId != nil {
                        map["NetworkAclEntryId"] = self.networkAclEntryId!
                    }
                    if self.networkAclEntryName != nil {
                        map["NetworkAclEntryName"] = self.networkAclEntryName!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    if self.sourceCidrIp != nil {
                        map["SourceCidrIp"] = self.sourceCidrIp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["NetworkAclEntryId"] as? String {
                        self.networkAclEntryId = value
                    }
                    if let value = dict["NetworkAclEntryName"] as? String {
                        self.networkAclEntryName = value
                    }
                    if let value = dict["Policy"] as? String {
                        self.policy = value
                    }
                    if let value = dict["Port"] as? String {
                        self.port = value
                    }
                    if let value = dict["Protocol"] as? String {
                        self.protocol_ = value
                    }
                    if let value = dict["SourceCidrIp"] as? String {
                        self.sourceCidrIp = value
                    }
                }
            }
            public var ingressAclEntry: [CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ingressAclEntry != nil {
                    var tmp : [Any] = []
                    for k in self.ingressAclEntry! {
                        tmp.append(k.toMap())
                    }
                    map["IngressAclEntry"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IngressAclEntry"] as? [Any?] {
                    var tmp : [CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry] = []
                    for v in value {
                        if v != nil {
                            var model = CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ingressAclEntry = tmp
                }
            }
        }
        public class Resources : Tea.TeaModel {
            public class Resource : Tea.TeaModel {
                public var resourceId: String?

                public var resourceType: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceId != nil {
                        map["ResourceId"] = self.resourceId!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourceId"] as? String {
                        self.resourceId = value
                    }
                    if let value = dict["ResourceType"] as? String {
                        self.resourceType = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public var resource: [CreateNetworkAclResponseBody.NetworkAclAttribute.Resources.Resource]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resource != nil {
                    var tmp : [Any] = []
                    for k in self.resource! {
                        tmp.append(k.toMap())
                    }
                    map["Resource"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Resource"] as? [Any?] {
                    var tmp : [CreateNetworkAclResponseBody.NetworkAclAttribute.Resources.Resource] = []
                    for v in value {
                        if v != nil {
                            var model = CreateNetworkAclResponseBody.NetworkAclAttribute.Resources.Resource()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.resource = tmp
                }
            }
        }
        public var creationTime: String?

        public var description_: String?

        public var egressAclEntries: CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries?

        public var ingressAclEntries: CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries?

        public var networkAclId: String?

        public var networkAclName: String?

        public var regionId: String?

        public var resources: CreateNetworkAclResponseBody.NetworkAclAttribute.Resources?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.egressAclEntries?.validate()
            try self.ingressAclEntries?.validate()
            try self.resources?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.egressAclEntries != nil {
                map["EgressAclEntries"] = self.egressAclEntries?.toMap()
            }
            if self.ingressAclEntries != nil {
                map["IngressAclEntries"] = self.ingressAclEntries?.toMap()
            }
            if self.networkAclId != nil {
                map["NetworkAclId"] = self.networkAclId!
            }
            if self.networkAclName != nil {
                map["NetworkAclName"] = self.networkAclName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resources != nil {
                map["Resources"] = self.resources?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EgressAclEntries"] as? [String: Any?] {
                var model = CreateNetworkAclResponseBody.NetworkAclAttribute.EgressAclEntries()
                model.fromMap(value)
                self.egressAclEntries = model
            }
            if let value = dict["IngressAclEntries"] as? [String: Any?] {
                var model = CreateNetworkAclResponseBody.NetworkAclAttribute.IngressAclEntries()
                model.fromMap(value)
                self.ingressAclEntries = model
            }
            if let value = dict["NetworkAclId"] as? String {
                self.networkAclId = value
            }
            if let value = dict["NetworkAclName"] as? String {
                self.networkAclName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["Resources"] as? [String: Any?] {
                var model = CreateNetworkAclResponseBody.NetworkAclAttribute.Resources()
                model.fromMap(value)
                self.resources = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var networkAclAttribute: CreateNetworkAclResponseBody.NetworkAclAttribute?

    public var networkAclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAclAttribute?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclAttribute != nil {
            map["NetworkAclAttribute"] = self.networkAclAttribute?.toMap()
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkAclAttribute"] as? [String: Any?] {
            var model = CreateNetworkAclResponseBody.NetworkAclAttribute()
            model.fromMap(value)
            self.networkAclAttribute = model
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNetworkAclResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePhysicalConnectionRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var accessPointId: String?

    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var deviceAdvancedCapacity: [String]?

    public var lineOperator: String?

    public var name: String?

    public var opticalModuleModel: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerLocation: String?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreatePhysicalConnectionRequest.Tag]?

    public var type: String?

    public var bandwidth: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.deviceAdvancedCapacity != nil {
            map["DeviceAdvancedCapacity"] = self.deviceAdvancedCapacity!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.opticalModuleModel != nil {
            map["OpticalModuleModel"] = self.opticalModuleModel!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.bandwidth != nil {
            map["bandwidth"] = self.bandwidth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessPointId"] as? String {
            self.accessPointId = value
        }
        if let value = dict["CircuitCode"] as? String {
            self.circuitCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DeviceAdvancedCapacity"] as? [String] {
            self.deviceAdvancedCapacity = value
        }
        if let value = dict["LineOperator"] as? String {
            self.lineOperator = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OpticalModuleModel"] as? String {
            self.opticalModuleModel = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerLocation"] as? String {
            self.peerLocation = value
        }
        if let value = dict["PortType"] as? String {
            self.portType = value
        }
        if let value = dict["RedundantPhysicalConnectionId"] as? String {
            self.redundantPhysicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreatePhysicalConnectionRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreatePhysicalConnectionRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["bandwidth"] as? Int32 {
            self.bandwidth = value
        }
    }
}

public class CreatePhysicalConnectionResponseBody : Tea.TeaModel {
    public var physicalConnectionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePhysicalConnectionOccupancyOrderRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var clientToken: String?

    public var instanceChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var physicalConnectionId: String?

    public var pricingCycle: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewDuration"] as? Int32 {
            self.autoRenewDuration = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["PricingCycle"] as? String {
            self.pricingCycle = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreatePhysicalConnectionOccupancyOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var orderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OrderId"] as? String {
                self.orderId = value
            }
        }
    }
    public var data: CreatePhysicalConnectionOccupancyOrderResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreatePhysicalConnectionOccupancyOrderResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePhysicalConnectionOccupancyOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePhysicalConnectionOccupancyOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePhysicalConnectionOccupancyOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePhysicalConnectionSetupOrderRequest : Tea.TeaModel {
    public var accessPointId: String?

    public var autoPay: Bool?

    public var clientToken: String?

    public var lineOperator: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessPointId"] as? String {
            self.accessPointId = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["LineOperator"] as? String {
            self.lineOperator = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortType"] as? String {
            self.portType = value
        }
        if let value = dict["RedundantPhysicalConnectionId"] as? String {
            self.redundantPhysicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreatePhysicalConnectionSetupOrderResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var physicalConnectionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePhysicalConnectionSetupOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePhysicalConnectionSetupOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePhysicalConnectionSetupOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePublicIpAddressPoolRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var bizType: String?

    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var isp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionTypes: [String]?

    public var tag: [CreatePublicIpAddressPoolRequest.Tag]?

    public var zones: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionTypes != nil {
            map["SecurityProtectionTypes"] = self.securityProtectionTypes!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zones != nil {
            map["Zones"] = self.zones!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizType"] as? String {
            self.bizType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Isp"] as? String {
            self.isp = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityProtectionTypes"] as? [String] {
            self.securityProtectionTypes = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreatePublicIpAddressPoolRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreatePublicIpAddressPoolRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Zones"] as? [String] {
            self.zones = value
        }
    }
}

public class CreatePublicIpAddressPoolResponseBody : Tea.TeaModel {
    public var publicIpAddressPoolId: String?

    public var pulbicIpAddressPoolId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.pulbicIpAddressPoolId != nil {
            map["PulbicIpAddressPoolId"] = self.pulbicIpAddressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["PulbicIpAddressPoolId"] as? String {
            self.pulbicIpAddressPoolId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class CreatePublicIpAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePublicIpAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePublicIpAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRouteEntriesRequest : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public var description_: String?

        public var dstCidrBlock: String?

        public var ipVersion: Int32?

        public var name: String?

        public var nextHop: String?

        public var nextHopType: String?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dstCidrBlock != nil {
                map["DstCidrBlock"] = self.dstCidrBlock!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DstCidrBlock"] as? String {
                self.dstCidrBlock = value
            }
            if let value = dict["IpVersion"] as? Int32 {
                self.ipVersion = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NextHop"] as? String {
                self.nextHop = value
            }
            if let value = dict["NextHopType"] as? String {
                self.nextHopType = value
            }
            if let value = dict["RouteTableId"] as? String {
                self.routeTableId = value
            }
        }
    }
    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntries: [CreateRouteEntriesRequest.RouteEntries]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntries"] as? [Any?] {
            var tmp : [CreateRouteEntriesRequest.RouteEntries] = []
            for v in value {
                if v != nil {
                    var model = CreateRouteEntriesRequest.RouteEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeEntries = tmp
        }
    }
}

public class CreateRouteEntriesResponseBody : Tea.TeaModel {
    public class FailedRouteEntries : Tea.TeaModel {
        public var dstCidrBlock: String?

        public var failedCode: String?

        public var failedMessage: String?

        public var nextHop: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstCidrBlock != nil {
                map["DstCidrBlock"] = self.dstCidrBlock!
            }
            if self.failedCode != nil {
                map["FailedCode"] = self.failedCode!
            }
            if self.failedMessage != nil {
                map["FailedMessage"] = self.failedMessage!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DstCidrBlock"] as? String {
                self.dstCidrBlock = value
            }
            if let value = dict["FailedCode"] as? String {
                self.failedCode = value
            }
            if let value = dict["FailedMessage"] as? String {
                self.failedMessage = value
            }
            if let value = dict["NextHop"] as? String {
                self.nextHop = value
            }
        }
    }
    public var failedCount: Int32?

    public var failedRouteEntries: [CreateRouteEntriesResponseBody.FailedRouteEntries]?

    public var requestId: String?

    public var routeEntryIds: [String]?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.failedRouteEntries != nil {
            var tmp : [Any] = []
            for k in self.failedRouteEntries! {
                tmp.append(k.toMap())
            }
            map["FailedRouteEntries"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntryIds != nil {
            map["RouteEntryIds"] = self.routeEntryIds!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailedCount"] as? Int32 {
            self.failedCount = value
        }
        if let value = dict["FailedRouteEntries"] as? [Any?] {
            var tmp : [CreateRouteEntriesResponseBody.FailedRouteEntries] = []
            for v in value {
                if v != nil {
                    var model = CreateRouteEntriesResponseBody.FailedRouteEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.failedRouteEntries = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteEntryIds"] as? [String] {
            self.routeEntryIds = value
        }
        if let value = dict["SuccessCount"] as? Int32 {
            self.successCount = value
        }
    }
}

public class CreateRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRouteEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRouteEntryRequest : Tea.TeaModel {
    public class NextHopList : Tea.TeaModel {
        public var nextHopId: String?

        public var nextHopType: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NextHopId"] as? String {
                self.nextHopId = value
            }
            if let value = dict["NextHopType"] as? String {
                self.nextHopType = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destinationCidrBlock: String?

    public var dryRun: Bool?

    public var nextHopId: String?

    public var nextHopList: [CreateRouteEntryRequest.NextHopList]?

    public var nextHopType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryName: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopList != nil {
            var tmp : [Any] = []
            for k in self.nextHopList! {
                tmp.append(k.toMap())
            }
            map["NextHopList"] = tmp
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NextHopId"] as? String {
            self.nextHopId = value
        }
        if let value = dict["NextHopList"] as? [Any?] {
            var tmp : [CreateRouteEntryRequest.NextHopList] = []
            for v in value {
                if v != nil {
                    var model = CreateRouteEntryRequest.NextHopList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nextHopList = tmp
        }
        if let value = dict["NextHopType"] as? String {
            self.nextHopType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntryName"] as? String {
            self.routeEntryName = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
    }
}

public class CreateRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteEntryId"] as? String {
            self.routeEntryId = value
        }
    }
}

public class CreateRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRouteTableRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var associateType: String?

    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableName: String?

    public var tag: [CreateRouteTableRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associateType != nil {
            map["AssociateType"] = self.associateType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AssociateType"] as? String {
            self.associateType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableName"] as? String {
            self.routeTableName = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateRouteTableRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateRouteTableRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateRouteTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
    }
}

public class CreateRouteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRouteTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRouteTargetGroupRequest : Tea.TeaModel {
    public class RouteTargetMemberList : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MemberId"] as? String {
                self.memberId = value
            }
            if let value = dict["MemberType"] as? String {
                self.memberType = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var configMode: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var routeTargetGroupDescription: String?

    public var routeTargetGroupName: String?

    public var routeTargetMemberList: [CreateRouteTargetGroupRequest.RouteTargetMemberList]?

    public var tag: [CreateRouteTargetGroupRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configMode != nil {
            map["ConfigMode"] = self.configMode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.routeTargetGroupDescription != nil {
            map["RouteTargetGroupDescription"] = self.routeTargetGroupDescription!
        }
        if self.routeTargetGroupName != nil {
            map["RouteTargetGroupName"] = self.routeTargetGroupName!
        }
        if self.routeTargetMemberList != nil {
            var tmp : [Any] = []
            for k in self.routeTargetMemberList! {
                tmp.append(k.toMap())
            }
            map["RouteTargetMemberList"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigMode"] as? String {
            self.configMode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["RouteTargetGroupDescription"] as? String {
            self.routeTargetGroupDescription = value
        }
        if let value = dict["RouteTargetGroupName"] as? String {
            self.routeTargetGroupName = value
        }
        if let value = dict["RouteTargetMemberList"] as? [Any?] {
            var tmp : [CreateRouteTargetGroupRequest.RouteTargetMemberList] = []
            for v in value {
                if v != nil {
                    var model = CreateRouteTargetGroupRequest.RouteTargetMemberList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeTargetMemberList = tmp
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateRouteTargetGroupRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateRouteTargetGroupRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateRouteTargetGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeTargetGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTargetGroupId != nil {
            map["RouteTargetGroupId"] = self.routeTargetGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteTargetGroupId"] as? String {
            self.routeTargetGroupId = value
        }
    }
}

public class CreateRouteTargetGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteTargetGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRouteTargetGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRouterInterfaceRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var accessPointId: String?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var clientToken: String?

    public var description_: String?

    public var fastLinkMode: Bool?

    public var healthCheckSourceIp: String?

    public var healthCheckTargetIp: String?

    public var instanceChargeType: String?

    public var name: String?

    public var oppositeAccessPointId: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: String?

    public var oppositeRegionId: String?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var pricingCycle: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var role: String?

    public var routerId: String?

    public var routerType: String?

    public var spec: String?

    public var tags: [CreateRouterInterfaceRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fastLinkMode != nil {
            map["FastLinkMode"] = self.fastLinkMode!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeAccessPointId != nil {
            map["OppositeAccessPointId"] = self.oppositeAccessPointId!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeRegionId != nil {
            map["OppositeRegionId"] = self.oppositeRegionId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessPointId"] as? String {
            self.accessPointId = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FastLinkMode"] as? Bool {
            self.fastLinkMode = value
        }
        if let value = dict["HealthCheckSourceIp"] as? String {
            self.healthCheckSourceIp = value
        }
        if let value = dict["HealthCheckTargetIp"] as? String {
            self.healthCheckTargetIp = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OppositeAccessPointId"] as? String {
            self.oppositeAccessPointId = value
        }
        if let value = dict["OppositeInterfaceId"] as? String {
            self.oppositeInterfaceId = value
        }
        if let value = dict["OppositeInterfaceOwnerId"] as? String {
            self.oppositeInterfaceOwnerId = value
        }
        if let value = dict["OppositeRegionId"] as? String {
            self.oppositeRegionId = value
        }
        if let value = dict["OppositeRouterId"] as? String {
            self.oppositeRouterId = value
        }
        if let value = dict["OppositeRouterType"] as? String {
            self.oppositeRouterType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PricingCycle"] as? String {
            self.pricingCycle = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
        if let value = dict["RouterType"] as? String {
            self.routerType = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [CreateRouterInterfaceRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateRouterInterfaceRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class CreateRouterInterfaceResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public var requestId: String?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class CreateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSnatEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var eipAffinity: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snatEntryName: String?

    public var snatIp: String?

    public var snatTableId: String?

    public var sourceCIDR: String?

    public var sourceVSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.eipAffinity != nil {
            map["EipAffinity"] = self.eipAffinity!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.snatTableId != nil {
            map["SnatTableId"] = self.snatTableId!
        }
        if self.sourceCIDR != nil {
            map["SourceCIDR"] = self.sourceCIDR!
        }
        if self.sourceVSwitchId != nil {
            map["SourceVSwitchId"] = self.sourceVSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EipAffinity"] as? Int32 {
            self.eipAffinity = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnatEntryName"] as? String {
            self.snatEntryName = value
        }
        if let value = dict["SnatIp"] as? String {
            self.snatIp = value
        }
        if let value = dict["SnatTableId"] as? String {
            self.snatTableId = value
        }
        if let value = dict["SourceCIDR"] as? String {
            self.sourceCIDR = value
        }
        if let value = dict["SourceVSwitchId"] as? String {
            self.sourceVSwitchId = value
        }
    }
}

public class CreateSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snatEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnatEntryId"] as? String {
            self.snatEntryId = value
        }
    }
}

public class CreateSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSnatEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSslVpnClientCertRequest : Tea.TeaModel {
    public var clientToken: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslVpnServerId"] as? String {
            self.sslVpnServerId = value
        }
    }
}

public class CreateSslVpnClientCertResponseBody : Tea.TeaModel {
    public var name: String?

    public var requestId: String?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SslVpnClientCertId"] as? String {
            self.sslVpnClientCertId = value
        }
    }
}

public class CreateSslVpnClientCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSslVpnClientCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSslVpnClientCertResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSslVpnServerRequest : Tea.TeaModel {
    public var cipher: String?

    public var clientIpPool: String?

    public var clientToken: String?

    public var compress: Bool?

    public var dryRun: Bool?

    public var enableMultiFactorAuth: Bool?

    public var IDaaSApplicationId: String?

    public var IDaaSInstanceId: String?

    public var IDaaSRegionId: String?

    public var localSubnet: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var port: Int32?

    public var proto: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipher != nil {
            map["Cipher"] = self.cipher!
        }
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compress != nil {
            map["Compress"] = self.compress!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableMultiFactorAuth != nil {
            map["EnableMultiFactorAuth"] = self.enableMultiFactorAuth!
        }
        if self.IDaaSApplicationId != nil {
            map["IDaaSApplicationId"] = self.IDaaSApplicationId!
        }
        if self.IDaaSInstanceId != nil {
            map["IDaaSInstanceId"] = self.IDaaSInstanceId!
        }
        if self.IDaaSRegionId != nil {
            map["IDaaSRegionId"] = self.IDaaSRegionId!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.proto != nil {
            map["Proto"] = self.proto!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cipher"] as? String {
            self.cipher = value
        }
        if let value = dict["ClientIpPool"] as? String {
            self.clientIpPool = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Compress"] as? Bool {
            self.compress = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EnableMultiFactorAuth"] as? Bool {
            self.enableMultiFactorAuth = value
        }
        if let value = dict["IDaaSApplicationId"] as? String {
            self.IDaaSApplicationId = value
        }
        if let value = dict["IDaaSInstanceId"] as? String {
            self.IDaaSInstanceId = value
        }
        if let value = dict["IDaaSRegionId"] as? String {
            self.IDaaSRegionId = value
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
        if let value = dict["Proto"] as? String {
            self.proto = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class CreateSslVpnServerResponseBody : Tea.TeaModel {
    public var name: String?

    public var requestId: String?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SslVpnServerId"] as? String {
            self.sslVpnServerId = value
        }
    }
}

public class CreateSslVpnServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSslVpnServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSslVpnServerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateTrafficMirrorFilterRequest : Tea.TeaModel {
    public class EgressRules : Tea.TeaModel {
        public var action: String?

        public var destinationCidrBlock: String?

        public var destinationPortRange: String?

        public var ipVersion: String?

        public var priority: Int32?

        public var protocol_: String?

        public var sourceCidrBlock: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.destinationPortRange != nil {
                map["DestinationPortRange"] = self.destinationPortRange!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrBlock != nil {
                map["SourceCidrBlock"] = self.sourceCidrBlock!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Action"] as? String {
                self.action = value
            }
            if let value = dict["DestinationCidrBlock"] as? String {
                self.destinationCidrBlock = value
            }
            if let value = dict["DestinationPortRange"] as? String {
                self.destinationPortRange = value
            }
            if let value = dict["IpVersion"] as? String {
                self.ipVersion = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["Protocol"] as? String {
                self.protocol_ = value
            }
            if let value = dict["SourceCidrBlock"] as? String {
                self.sourceCidrBlock = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
        }
    }
    public class IngressRules : Tea.TeaModel {
        public var action: String?

        public var destinationCidrBlock: String?

        public var destinationPortRange: String?

        public var ipVersion: String?

        public var priority: Int32?

        public var protocol_: String?

        public var sourceCidrBlock: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.destinationPortRange != nil {
                map["DestinationPortRange"] = self.destinationPortRange!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrBlock != nil {
                map["SourceCidrBlock"] = self.sourceCidrBlock!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Action"] as? String {
                self.action = value
            }
            if let value = dict["DestinationCidrBlock"] as? String {
                self.destinationCidrBlock = value
            }
            if let value = dict["DestinationPortRange"] as? String {
                self.destinationPortRange = value
            }
            if let value = dict["IpVersion"] as? String {
                self.ipVersion = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["Protocol"] as? String {
                self.protocol_ = value
            }
            if let value = dict["SourceCidrBlock"] as? String {
                self.sourceCidrBlock = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var egressRules: [CreateTrafficMirrorFilterRequest.EgressRules]?

    public var ingressRules: [CreateTrafficMirrorFilterRequest.IngressRules]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateTrafficMirrorFilterRequest.Tag]?

    public var trafficMirrorFilterDescription: String?

    public var trafficMirrorFilterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.egressRules != nil {
            var tmp : [Any] = []
            for k in self.egressRules! {
                tmp.append(k.toMap())
            }
            map["EgressRules"] = tmp
        }
        if self.ingressRules != nil {
            var tmp : [Any] = []
            for k in self.ingressRules! {
                tmp.append(k.toMap())
            }
            map["IngressRules"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.trafficMirrorFilterDescription != nil {
            map["TrafficMirrorFilterDescription"] = self.trafficMirrorFilterDescription!
        }
        if self.trafficMirrorFilterName != nil {
            map["TrafficMirrorFilterName"] = self.trafficMirrorFilterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EgressRules"] as? [Any?] {
            var tmp : [CreateTrafficMirrorFilterRequest.EgressRules] = []
            for v in value {
                if v != nil {
                    var model = CreateTrafficMirrorFilterRequest.EgressRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.egressRules = tmp
        }
        if let value = dict["IngressRules"] as? [Any?] {
            var tmp : [CreateTrafficMirrorFilterRequest.IngressRules] = []
            for v in value {
                if v != nil {
                    var model = CreateTrafficMirrorFilterRequest.IngressRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ingressRules = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateTrafficMirrorFilterRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateTrafficMirrorFilterRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TrafficMirrorFilterDescription"] as? String {
            self.trafficMirrorFilterDescription = value
        }
        if let value = dict["TrafficMirrorFilterName"] as? String {
            self.trafficMirrorFilterName = value
        }
    }
}

public class CreateTrafficMirrorFilterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceGroupId: String?

    public var trafficMirrorFilterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["TrafficMirrorFilterId"] as? String {
            self.trafficMirrorFilterId = value
        }
    }
}

public class CreateTrafficMirrorFilterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTrafficMirrorFilterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateTrafficMirrorFilterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateTrafficMirrorFilterRulesRequest : Tea.TeaModel {
    public class EgressRules : Tea.TeaModel {
        public var action: String?

        public var destinationCidrBlock: String?

        public var destinationPortRange: String?

        public var ipVersion: String?

        public var priority: Int32?

        public var protocol_: String?

        public var sourceCidrBlock: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.destinationPortRange != nil {
                map["DestinationPortRange"] = self.destinationPortRange!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrBlock != nil {
                map["SourceCidrBlock"] = self.sourceCidrBlock!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Action"] as? String {
                self.action = value
            }
            if let value = dict["DestinationCidrBlock"] as? String {
                self.destinationCidrBlock = value
            }
            if let value = dict["DestinationPortRange"] as? String {
                self.destinationPortRange = value
            }
            if let value = dict["IpVersion"] as? String {
                self.ipVersion = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["Protocol"] as? String {
                self.protocol_ = value
            }
            if let value = dict["SourceCidrBlock"] as? String {
                self.sourceCidrBlock = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
        }
    }
    public class IngressRules : Tea.TeaModel {
        public var action: String?

        public var destinationCidrBlock: String?

        public var destinationPortRange: String?

        public var ipVersion: String?

        public var priority: Int32?

        public var protocol_: String?

        public var sourceCidrBlock: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.destinationPortRange != nil {
                map["DestinationPortRange"] = self.destinationPortRange!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrBlock != nil {
                map["SourceCidrBlock"] = self.sourceCidrBlock!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Action"] as? String {
                self.action = value
            }
            if let value = dict["DestinationCidrBlock"] as? String {
                self.destinationCidrBlock = value
            }
            if let value = dict["DestinationPortRange"] as? String {
                self.destinationPortRange = value
            }
            if let value = dict["IpVersion"] as? String {
                self.ipVersion = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["Protocol"] as? String {
                self.protocol_ = value
            }
            if let value = dict["SourceCidrBlock"] as? String {
                self.sourceCidrBlock = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var egressRules: [CreateTrafficMirrorFilterRulesRequest.EgressRules]?

    public var ingressRules: [CreateTrafficMirrorFilterRulesRequest.IngressRules]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.egressRules != nil {
            var tmp : [Any] = []
            for k in self.egressRules! {
                tmp.append(k.toMap())
            }
            map["EgressRules"] = tmp
        }
        if self.ingressRules != nil {
            var tmp : [Any] = []
            for k in self.ingressRules! {
                tmp.append(k.toMap())
            }
            map["IngressRules"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EgressRules"] as? [Any?] {
            var tmp : [CreateTrafficMirrorFilterRulesRequest.EgressRules] = []
            for v in value {
                if v != nil {
                    var model = CreateTrafficMirrorFilterRulesRequest.EgressRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.egressRules = tmp
        }
        if let value = dict["IngressRules"] as? [Any?] {
            var tmp : [CreateTrafficMirrorFilterRulesRequest.IngressRules] = []
            for v in value {
                if v != nil {
                    var model = CreateTrafficMirrorFilterRulesRequest.IngressRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ingressRules = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrafficMirrorFilterId"] as? String {
            self.trafficMirrorFilterId = value
        }
    }
}

public class CreateTrafficMirrorFilterRulesResponseBody : Tea.TeaModel {
    public class EgressRules : Tea.TeaModel {
        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
        }
    }
    public class IngressRules : Tea.TeaModel {
        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
        }
    }
    public var egressRules: [CreateTrafficMirrorFilterRulesResponseBody.EgressRules]?

    public var ingressRules: [CreateTrafficMirrorFilterRulesResponseBody.IngressRules]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.egressRules != nil {
            var tmp : [Any] = []
            for k in self.egressRules! {
                tmp.append(k.toMap())
            }
            map["EgressRules"] = tmp
        }
        if self.ingressRules != nil {
            var tmp : [Any] = []
            for k in self.ingressRules! {
                tmp.append(k.toMap())
            }
            map["IngressRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EgressRules"] as? [Any?] {
            var tmp : [CreateTrafficMirrorFilterRulesResponseBody.EgressRules] = []
            for v in value {
                if v != nil {
                    var model = CreateTrafficMirrorFilterRulesResponseBody.EgressRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.egressRules = tmp
        }
        if let value = dict["IngressRules"] as? [Any?] {
            var tmp : [CreateTrafficMirrorFilterRulesResponseBody.IngressRules] = []
            for v in value {
                if v != nil {
                    var model = CreateTrafficMirrorFilterRulesResponseBody.IngressRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ingressRules = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateTrafficMirrorFilterRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTrafficMirrorFilterRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateTrafficMirrorFilterRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateTrafficMirrorSessionRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var enabled: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var packetLength: Int32?

    public var priority: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateTrafficMirrorSessionRequest.Tag]?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorSessionDescription: String?

    public var trafficMirrorSessionName: String?

    public var trafficMirrorSourceIds: [String]?

    public var trafficMirrorTargetId: String?

    public var trafficMirrorTargetType: String?

    public var virtualNetworkId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.packetLength != nil {
            map["PacketLength"] = self.packetLength!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorSessionDescription != nil {
            map["TrafficMirrorSessionDescription"] = self.trafficMirrorSessionDescription!
        }
        if self.trafficMirrorSessionName != nil {
            map["TrafficMirrorSessionName"] = self.trafficMirrorSessionName!
        }
        if self.trafficMirrorSourceIds != nil {
            map["TrafficMirrorSourceIds"] = self.trafficMirrorSourceIds!
        }
        if self.trafficMirrorTargetId != nil {
            map["TrafficMirrorTargetId"] = self.trafficMirrorTargetId!
        }
        if self.trafficMirrorTargetType != nil {
            map["TrafficMirrorTargetType"] = self.trafficMirrorTargetType!
        }
        if self.virtualNetworkId != nil {
            map["VirtualNetworkId"] = self.virtualNetworkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PacketLength"] as? Int32 {
            self.packetLength = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateTrafficMirrorSessionRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateTrafficMirrorSessionRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TrafficMirrorFilterId"] as? String {
            self.trafficMirrorFilterId = value
        }
        if let value = dict["TrafficMirrorSessionDescription"] as? String {
            self.trafficMirrorSessionDescription = value
        }
        if let value = dict["TrafficMirrorSessionName"] as? String {
            self.trafficMirrorSessionName = value
        }
        if let value = dict["TrafficMirrorSourceIds"] as? [String] {
            self.trafficMirrorSourceIds = value
        }
        if let value = dict["TrafficMirrorTargetId"] as? String {
            self.trafficMirrorTargetId = value
        }
        if let value = dict["TrafficMirrorTargetType"] as? String {
            self.trafficMirrorTargetType = value
        }
        if let value = dict["VirtualNetworkId"] as? Int32 {
            self.virtualNetworkId = value
        }
    }
}

public class CreateTrafficMirrorSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceGroupId: String?

    public var trafficMirrorSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["TrafficMirrorSessionId"] as? String {
            self.trafficMirrorSessionId = value
        }
    }
}

public class CreateTrafficMirrorSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTrafficMirrorSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateTrafficMirrorSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVSwitchRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var cidrBlock: String?

    public var clientToken: String?

    public var description_: String?

    public var ipv6CidrBlock: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateVSwitchRequest.Tag]?

    public var vSwitchName: String?

    public var vpcId: String?

    public var vpcIpv6CidrBlock: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcIpv6CidrBlock != nil {
            map["VpcIpv6CidrBlock"] = self.vpcIpv6CidrBlock!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Ipv6CidrBlock"] as? Int32 {
            self.ipv6CidrBlock = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateVSwitchRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateVSwitchRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VSwitchName"] as? String {
            self.vSwitchName = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpcIpv6CidrBlock"] as? String {
            self.vpcIpv6CidrBlock = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class CreateVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVSwitchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVSwitchCidrReservationRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateVSwitchCidrReservationRequest.Tag]?

    public var vSwitchCidrReservationCidr: String?

    public var vSwitchCidrReservationDescription: String?

    public var vSwitchCidrReservationMask: String?

    public var vSwitchCidrReservationName: String?

    public var vSwitchCidrReservationType: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchCidrReservationCidr != nil {
            map["VSwitchCidrReservationCidr"] = self.vSwitchCidrReservationCidr!
        }
        if self.vSwitchCidrReservationDescription != nil {
            map["VSwitchCidrReservationDescription"] = self.vSwitchCidrReservationDescription!
        }
        if self.vSwitchCidrReservationMask != nil {
            map["VSwitchCidrReservationMask"] = self.vSwitchCidrReservationMask!
        }
        if self.vSwitchCidrReservationName != nil {
            map["VSwitchCidrReservationName"] = self.vSwitchCidrReservationName!
        }
        if self.vSwitchCidrReservationType != nil {
            map["VSwitchCidrReservationType"] = self.vSwitchCidrReservationType!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateVSwitchCidrReservationRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateVSwitchCidrReservationRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VSwitchCidrReservationCidr"] as? String {
            self.vSwitchCidrReservationCidr = value
        }
        if let value = dict["VSwitchCidrReservationDescription"] as? String {
            self.vSwitchCidrReservationDescription = value
        }
        if let value = dict["VSwitchCidrReservationMask"] as? String {
            self.vSwitchCidrReservationMask = value
        }
        if let value = dict["VSwitchCidrReservationName"] as? String {
            self.vSwitchCidrReservationName = value
        }
        if let value = dict["VSwitchCidrReservationType"] as? String {
            self.vSwitchCidrReservationType = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class CreateVSwitchCidrReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchCidrReservationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchCidrReservationId != nil {
            map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VSwitchCidrReservationId"] as? String {
            self.vSwitchCidrReservationId = value
        }
    }
}

public class CreateVSwitchCidrReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVSwitchCidrReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVSwitchCidrReservationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVbrHaRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerVbrId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerVbrId != nil {
            map["PeerVbrId"] = self.peerVbrId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerVbrId"] as? String {
            self.peerVbrId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class CreateVbrHaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vbrHaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vbrHaId != nil {
            map["VbrHaId"] = self.vbrHaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VbrHaId"] as? String {
            self.vbrHaId = value
        }
    }
}

public class CreateVbrHaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVbrHaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVbrHaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVcoRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnConnectionId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class CreateVcoRouteEntryResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var description_: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var requestId: String?

    public var routeDest: String?

    public var state: String?

    public var vpnConnectionId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class CreateVcoRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVcoRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVcoRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVirtualBorderRouterRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var bandwidth: Int64?

    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var enableIpv6: Bool?

    public var localGatewayIp: String?

    public var localIpv6GatewayIp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peerIpv6GatewayIp: String?

    public var peeringIpv6SubnetMask: String?

    public var peeringSubnetMask: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [CreateVirtualBorderRouterRequest.Tags]?

    public var vbrOwnerId: Int64?

    public var vlanId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.localIpv6GatewayIp != nil {
            map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peerIpv6GatewayIp != nil {
            map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
        }
        if self.peeringIpv6SubnetMask != nil {
            map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vbrOwnerId != nil {
            map["VbrOwnerId"] = self.vbrOwnerId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? Int64 {
            self.bandwidth = value
        }
        if let value = dict["CircuitCode"] as? String {
            self.circuitCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableIpv6"] as? Bool {
            self.enableIpv6 = value
        }
        if let value = dict["LocalGatewayIp"] as? String {
            self.localGatewayIp = value
        }
        if let value = dict["LocalIpv6GatewayIp"] as? String {
            self.localIpv6GatewayIp = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerGatewayIp"] as? String {
            self.peerGatewayIp = value
        }
        if let value = dict["PeerIpv6GatewayIp"] as? String {
            self.peerIpv6GatewayIp = value
        }
        if let value = dict["PeeringIpv6SubnetMask"] as? String {
            self.peeringIpv6SubnetMask = value
        }
        if let value = dict["PeeringSubnetMask"] as? String {
            self.peeringSubnetMask = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [CreateVirtualBorderRouterRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateVirtualBorderRouterRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VbrOwnerId"] as? Int64 {
            self.vbrOwnerId = value
        }
        if let value = dict["VlanId"] as? Int32 {
            self.vlanId = value
        }
    }
}

public class CreateVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class CreateVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVirtualPhysicalConnectionRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var description_: String?

    public var dryRun: Bool?

    public var name: String?

    public var orderMode: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var spec: String?

    public var tag: [CreateVirtualPhysicalConnectionRequest.Tag]?

    public var token: String?

    public var vlanId: Int64?

    public var vpconnAliUid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderMode != nil {
            map["OrderMode"] = self.orderMode!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        if self.vpconnAliUid != nil {
            map["VpconnAliUid"] = self.vpconnAliUid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OrderMode"] as? String {
            self.orderMode = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateVirtualPhysicalConnectionRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateVirtualPhysicalConnectionRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Token"] as? String {
            self.token = value
        }
        if let value = dict["VlanId"] as? Int64 {
            self.vlanId = value
        }
        if let value = dict["VpconnAliUid"] as? Int64 {
            self.vpconnAliUid = value
        }
    }
}

public class CreateVirtualPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var virtualPhysicalConnection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.virtualPhysicalConnection != nil {
            map["VirtualPhysicalConnection"] = self.virtualPhysicalConnection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VirtualPhysicalConnection"] as? String {
            self.virtualPhysicalConnection = value
        }
    }
}

public class CreateVirtualPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVirtualPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVirtualPhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpcRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var cidrBlock: String?

    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var enableDnsHostname: Bool?

    public var enableIpv6: Bool?

    public var ipv4CidrMask: Int32?

    public var ipv4IpamPoolId: String?

    public var ipv6CidrBlock: String?

    public var ipv6CidrMask: Int32?

    public var ipv6IpamPoolId: String?

    public var ipv6Isp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateVpcRequest.Tag]?

    public var userCidr: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableDnsHostname != nil {
            map["EnableDnsHostname"] = self.enableDnsHostname!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.ipv4CidrMask != nil {
            map["Ipv4CidrMask"] = self.ipv4CidrMask!
        }
        if self.ipv4IpamPoolId != nil {
            map["Ipv4IpamPoolId"] = self.ipv4IpamPoolId!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ipv6CidrMask != nil {
            map["Ipv6CidrMask"] = self.ipv6CidrMask!
        }
        if self.ipv6IpamPoolId != nil {
            map["Ipv6IpamPoolId"] = self.ipv6IpamPoolId!
        }
        if self.ipv6Isp != nil {
            map["Ipv6Isp"] = self.ipv6Isp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EnableDnsHostname"] as? Bool {
            self.enableDnsHostname = value
        }
        if let value = dict["EnableIpv6"] as? Bool {
            self.enableIpv6 = value
        }
        if let value = dict["Ipv4CidrMask"] as? Int32 {
            self.ipv4CidrMask = value
        }
        if let value = dict["Ipv4IpamPoolId"] as? String {
            self.ipv4IpamPoolId = value
        }
        if let value = dict["Ipv6CidrBlock"] as? String {
            self.ipv6CidrBlock = value
        }
        if let value = dict["Ipv6CidrMask"] as? Int32 {
            self.ipv6CidrMask = value
        }
        if let value = dict["Ipv6IpamPoolId"] as? String {
            self.ipv6IpamPoolId = value
        }
        if let value = dict["Ipv6Isp"] as? String {
            self.ipv6Isp = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateVpcRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateVpcRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["VpcName"] as? String {
            self.vpcName = value
        }
    }
}

public class CreateVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceGroupId: String?

    public var routeTableId: String?

    public var VRouterId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpcGatewayEndpointRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointDescription: String?

    public var endpointName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var policyDocument: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public var tag: [CreateVpcGatewayEndpointRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointDescription != nil {
            map["EndpointDescription"] = self.endpointDescription!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policyDocument != nil {
            map["PolicyDocument"] = self.policyDocument!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EndpointDescription"] as? String {
            self.endpointDescription = value
        }
        if let value = dict["EndpointName"] as? String {
            self.endpointName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PolicyDocument"] as? String {
            self.policyDocument = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServiceName"] as? String {
            self.serviceName = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateVpcGatewayEndpointRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateVpcGatewayEndpointRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateVpcGatewayEndpointResponseBody : Tea.TeaModel {
    public var creationTime: String?

    public var endpointId: String?

    public var endpointName: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["EndpointId"] as? String {
            self.endpointId = value
        }
        if let value = dict["EndpointName"] as? String {
            self.endpointName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ServiceName"] as? String {
            self.serviceName = value
        }
    }
}

public class CreateVpcGatewayEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcGatewayEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpcGatewayEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpcPrefixListRequest : Tea.TeaModel {
    public class PrefixListEntries : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cidr"] as? String {
                self.cidr = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipVersion: String?

    public var maxEntries: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListDescription: String?

    public var prefixListEntries: [CreateVpcPrefixListRequest.PrefixListEntries]?

    public var prefixListName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateVpcPrefixListRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.maxEntries != nil {
            map["MaxEntries"] = self.maxEntries!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListDescription != nil {
            map["PrefixListDescription"] = self.prefixListDescription!
        }
        if self.prefixListEntries != nil {
            var tmp : [Any] = []
            for k in self.prefixListEntries! {
                tmp.append(k.toMap())
            }
            map["PrefixListEntries"] = tmp
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["MaxEntries"] as? Int32 {
            self.maxEntries = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListDescription"] as? String {
            self.prefixListDescription = value
        }
        if let value = dict["PrefixListEntries"] as? [Any?] {
            var tmp : [CreateVpcPrefixListRequest.PrefixListEntries] = []
            for v in value {
                if v != nil {
                    var model = CreateVpcPrefixListRequest.PrefixListEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.prefixListEntries = tmp
        }
        if let value = dict["PrefixListName"] as? String {
            self.prefixListName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateVpcPrefixListRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateVpcPrefixListRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateVpcPrefixListResponseBody : Tea.TeaModel {
    public var prefixListId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class CreateVpcPrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcPrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpcPrefixListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpconnFromVbrRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var orderMode: String?

    public var regionId: String?

    public var token: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.orderMode != nil {
            map["OrderMode"] = self.orderMode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OrderMode"] as? String {
            self.orderMode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Token"] as? String {
            self.token = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class CreateVpconnFromVbrResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var virtualPhysicalConnection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.virtualPhysicalConnection != nil {
            map["VirtualPhysicalConnection"] = self.virtualPhysicalConnection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VirtualPhysicalConnection"] as? String {
            self.virtualPhysicalConnection = value
        }
    }
}

public class CreateVpconnFromVbrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpconnFromVbrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpconnFromVbrResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpnAttachmentRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalAsn"] as? Int64 {
                    self.localAsn = value
                }
                if let value = dict["LocalBgpIp"] as? String {
                    self.localBgpIp = value
                }
                if let value = dict["TunnelCidr"] as? String {
                    self.tunnelCidr = value
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IkeAuthAlg"] as? String {
                    self.ikeAuthAlg = value
                }
                if let value = dict["IkeEncAlg"] as? String {
                    self.ikeEncAlg = value
                }
                if let value = dict["IkeLifetime"] as? Int64 {
                    self.ikeLifetime = value
                }
                if let value = dict["IkeMode"] as? String {
                    self.ikeMode = value
                }
                if let value = dict["IkePfs"] as? String {
                    self.ikePfs = value
                }
                if let value = dict["IkeVersion"] as? String {
                    self.ikeVersion = value
                }
                if let value = dict["LocalId"] as? String {
                    self.localId = value
                }
                if let value = dict["Psk"] as? String {
                    self.psk = value
                }
                if let value = dict["RemoteId"] as? String {
                    self.remoteId = value
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpsecAuthAlg"] as? String {
                    self.ipsecAuthAlg = value
                }
                if let value = dict["IpsecEncAlg"] as? String {
                    self.ipsecEncAlg = value
                }
                if let value = dict["IpsecLifetime"] as? Int64 {
                    self.ipsecLifetime = value
                }
                if let value = dict["IpsecPfs"] as? String {
                    self.ipsecPfs = value
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var tunnelBgpConfig: CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelIkeConfig: CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIndex: Int32?

        public var tunnelIpsecConfig: CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIndex != nil {
                map["TunnelIndex"] = self.tunnelIndex!
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CustomerGatewayId"] as? String {
                self.customerGatewayId = value
            }
            if let value = dict["EnableDpd"] as? Bool {
                self.enableDpd = value
            }
            if let value = dict["EnableNatTraversal"] as? Bool {
                self.enableNatTraversal = value
            }
            if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
                var model = CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(value)
                self.tunnelBgpConfig = model
            }
            if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
                var model = CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(value)
                self.tunnelIkeConfig = model
            }
            if let value = dict["TunnelIndex"] as? Int32 {
                self.tunnelIndex = value
            }
            if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
                var model = CreateVpnAttachmentRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(value)
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var autoConfigRoute: Bool?

    public var bgpConfig: String?

    public var clientToken: String?

    public var customerGatewayId: String?

    public var dryRun: Bool?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var healthCheckConfig: String?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var name: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var remoteCaCert: String?

    public var remoteSubnet: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [CreateVpnAttachmentRequest.Tags]?

    public var tunnelOptionsSpecification: [CreateVpnAttachmentRequest.TunnelOptionsSpecification]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoConfigRoute != nil {
            map["AutoConfigRoute"] = self.autoConfigRoute!
        }
        if self.bgpConfig != nil {
            map["BgpConfig"] = self.bgpConfig!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.healthCheckConfig != nil {
            map["HealthCheckConfig"] = self.healthCheckConfig!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCaCert != nil {
            map["RemoteCaCert"] = self.remoteCaCert!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoConfigRoute"] as? Bool {
            self.autoConfigRoute = value
        }
        if let value = dict["BgpConfig"] as? String {
            self.bgpConfig = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EffectImmediately"] as? Bool {
            self.effectImmediately = value
        }
        if let value = dict["EnableDpd"] as? Bool {
            self.enableDpd = value
        }
        if let value = dict["EnableNatTraversal"] as? Bool {
            self.enableNatTraversal = value
        }
        if let value = dict["EnableTunnelsBgp"] as? Bool {
            self.enableTunnelsBgp = value
        }
        if let value = dict["HealthCheckConfig"] as? String {
            self.healthCheckConfig = value
        }
        if let value = dict["IkeConfig"] as? String {
            self.ikeConfig = value
        }
        if let value = dict["IpsecConfig"] as? String {
            self.ipsecConfig = value
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoteCaCert"] as? String {
            self.remoteCaCert = value
        }
        if let value = dict["RemoteSubnet"] as? String {
            self.remoteSubnet = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [CreateVpnAttachmentRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateVpnAttachmentRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["TunnelOptionsSpecification"] as? [Any?] {
            var tmp : [CreateVpnAttachmentRequest.TunnelOptionsSpecification] = []
            for v in value {
                if v != nil {
                    var model = CreateVpnAttachmentRequest.TunnelOptionsSpecification()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tunnelOptionsSpecification = tmp
        }
    }
}

public class CreateVpnAttachmentResponseBody : Tea.TeaModel {
    public var code: String?

    public var createTime: Int64?

    public var message: String?

    public var name: String?

    public var requestId: String?

    public var success: Bool?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class CreateVpnAttachmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnAttachmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpnAttachmentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpnConnectionRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalAsn"] as? Int64 {
                    self.localAsn = value
                }
                if let value = dict["LocalBgpIp"] as? String {
                    self.localBgpIp = value
                }
                if let value = dict["TunnelCidr"] as? String {
                    self.tunnelCidr = value
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IkeAuthAlg"] as? String {
                    self.ikeAuthAlg = value
                }
                if let value = dict["IkeEncAlg"] as? String {
                    self.ikeEncAlg = value
                }
                if let value = dict["IkeLifetime"] as? Int64 {
                    self.ikeLifetime = value
                }
                if let value = dict["IkeMode"] as? String {
                    self.ikeMode = value
                }
                if let value = dict["IkePfs"] as? String {
                    self.ikePfs = value
                }
                if let value = dict["IkeVersion"] as? String {
                    self.ikeVersion = value
                }
                if let value = dict["LocalId"] as? String {
                    self.localId = value
                }
                if let value = dict["Psk"] as? String {
                    self.psk = value
                }
                if let value = dict["RemoteId"] as? String {
                    self.remoteId = value
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpsecAuthAlg"] as? String {
                    self.ipsecAuthAlg = value
                }
                if let value = dict["IpsecEncAlg"] as? String {
                    self.ipsecEncAlg = value
                }
                if let value = dict["IpsecLifetime"] as? Int64 {
                    self.ipsecLifetime = value
                }
                if let value = dict["IpsecPfs"] as? String {
                    self.ipsecPfs = value
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var remoteCaCertificate: String?

        public var role: String?

        public var tunnelBgpConfig: CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelIkeConfig: CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIpsecConfig: CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.remoteCaCertificate != nil {
                map["RemoteCaCertificate"] = self.remoteCaCertificate!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CustomerGatewayId"] as? String {
                self.customerGatewayId = value
            }
            if let value = dict["EnableDpd"] as? Bool {
                self.enableDpd = value
            }
            if let value = dict["EnableNatTraversal"] as? Bool {
                self.enableNatTraversal = value
            }
            if let value = dict["RemoteCaCertificate"] as? String {
                self.remoteCaCertificate = value
            }
            if let value = dict["Role"] as? String {
                self.role = value
            }
            if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
                var model = CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(value)
                self.tunnelBgpConfig = model
            }
            if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
                var model = CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(value)
                self.tunnelIkeConfig = model
            }
            if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
                var model = CreateVpnConnectionRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(value)
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var autoConfigRoute: Bool?

    public var bgpConfig: String?

    public var clientToken: String?

    public var customerGatewayId: String?

    public var dryRun: Bool?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var healthCheckConfig: String?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var remoteCaCertificate: String?

    public var remoteSubnet: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [CreateVpnConnectionRequest.Tags]?

    public var tunnelOptionsSpecification: [CreateVpnConnectionRequest.TunnelOptionsSpecification]?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoConfigRoute != nil {
            map["AutoConfigRoute"] = self.autoConfigRoute!
        }
        if self.bgpConfig != nil {
            map["BgpConfig"] = self.bgpConfig!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.healthCheckConfig != nil {
            map["HealthCheckConfig"] = self.healthCheckConfig!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCaCertificate != nil {
            map["RemoteCaCertificate"] = self.remoteCaCertificate!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoConfigRoute"] as? Bool {
            self.autoConfigRoute = value
        }
        if let value = dict["BgpConfig"] as? String {
            self.bgpConfig = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EffectImmediately"] as? Bool {
            self.effectImmediately = value
        }
        if let value = dict["EnableDpd"] as? Bool {
            self.enableDpd = value
        }
        if let value = dict["EnableNatTraversal"] as? Bool {
            self.enableNatTraversal = value
        }
        if let value = dict["EnableTunnelsBgp"] as? Bool {
            self.enableTunnelsBgp = value
        }
        if let value = dict["HealthCheckConfig"] as? String {
            self.healthCheckConfig = value
        }
        if let value = dict["IkeConfig"] as? String {
            self.ikeConfig = value
        }
        if let value = dict["IpsecConfig"] as? String {
            self.ipsecConfig = value
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoteCaCertificate"] as? String {
            self.remoteCaCertificate = value
        }
        if let value = dict["RemoteSubnet"] as? String {
            self.remoteSubnet = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [CreateVpnConnectionRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateVpnConnectionRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["TunnelOptionsSpecification"] as? [Any?] {
            var tmp : [CreateVpnConnectionRequest.TunnelOptionsSpecification] = []
            for v in value {
                if v != nil {
                    var model = CreateVpnConnectionRequest.TunnelOptionsSpecification()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tunnelOptionsSpecification = tmp
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class CreateVpnConnectionResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var name: String?

    public var requestId: String?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class CreateVpnConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpnConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpnGatewayRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var bandwidth: Int32?

    public var clientToken: String?

    public var disasterRecoveryVSwitchId: String?

    public var enableIpsec: Bool?

    public var enableSsl: Bool?

    public var instanceChargeType: String?

    public var name: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslConnections: Int32?

    public var vSwitchId: String?

    public var vpcId: String?

    public var vpnType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disasterRecoveryVSwitchId != nil {
            map["DisasterRecoveryVSwitchId"] = self.disasterRecoveryVSwitchId!
        }
        if self.enableIpsec != nil {
            map["EnableIpsec"] = self.enableIpsec!
        }
        if self.enableSsl != nil {
            map["EnableSsl"] = self.enableSsl!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslConnections != nil {
            map["SslConnections"] = self.sslConnections!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpnType != nil {
            map["VpnType"] = self.vpnType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DisasterRecoveryVSwitchId"] as? String {
            self.disasterRecoveryVSwitchId = value
        }
        if let value = dict["EnableIpsec"] as? Bool {
            self.enableIpsec = value
        }
        if let value = dict["EnableSsl"] as? Bool {
            self.enableSsl = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslConnections"] as? Int32 {
            self.sslConnections = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpnType"] as? String {
            self.vpnType = value
        }
    }
}

public class CreateVpnGatewayResponseBody : Tea.TeaModel {
    public var name: String?

    public var orderId: Int64?

    public var requestId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class CreateVpnGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpnGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpnPbrRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var publishVpc: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.publishVpc != nil {
            map["PublishVpc"] = self.publishVpc!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["PublishVpc"] as? Bool {
            self.publishVpc = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["RouteSource"] as? String {
            self.routeSource = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class CreateVpnPbrRouteEntryResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var description_: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var priority: Int32?

    public var requestId: String?

    public var routeDest: String?

    public var routeSource: String?

    public var state: String?

    public var vpnInstanceId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.vpnInstanceId != nil {
            map["VpnInstanceId"] = self.vpnInstanceId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["RouteSource"] as? String {
            self.routeSource = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
        if let value = dict["VpnInstanceId"] as? String {
            self.vpnInstanceId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class CreateVpnPbrRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnPbrRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpnPbrRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpnRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publishVpc: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publishVpc != nil {
            map["PublishVpc"] = self.publishVpc!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PublishVpc"] as? Bool {
            self.publishVpc = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class CreateVpnRouteEntryResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var description_: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var requestId: String?

    public var routeDest: String?

    public var state: String?

    public var vpnInstanceId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.vpnInstanceId != nil {
            map["VpnInstanceId"] = self.vpnInstanceId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
        if let value = dict["VpnInstanceId"] as? String {
            self.vpnInstanceId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class CreateVpnRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpnRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpnRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeactivateRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class DeactivateRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeactivateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeactivateRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeactiveFlowLogRequest : Tea.TeaModel {
    public var flowLogId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FlowLogId"] as? String {
            self.flowLogId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeactiveFlowLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DeactiveFlowLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactiveFlowLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeactiveFlowLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteBgpGroupRequest : Tea.TeaModel {
    public var bgpGroupId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpGroupId"] as? String {
            self.bgpGroupId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteBgpGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteBgpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBgpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBgpGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteBgpNetworkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dstCidrBlock: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dstCidrBlock != nil {
            map["DstCidrBlock"] = self.dstCidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DstCidrBlock"] as? String {
            self.dstCidrBlock = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
    }
}

public class DeleteBgpNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteBgpNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBgpNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBgpNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteBgpPeerRequest : Tea.TeaModel {
    public var bgpPeerId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpPeerId != nil {
            map["BgpPeerId"] = self.bgpPeerId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpPeerId"] as? String {
            self.bgpPeerId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteBgpPeerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteBgpPeerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBgpPeerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBgpPeerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCommonBandwidthPackageRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var force: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["Force"] as? String {
            self.force = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteCommonBandwidthPackageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCommonBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCommonBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCommonBandwidthPackageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCustomerGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var customerGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteCustomerGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCustomerGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomerGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCustomerGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDhcpOptionsSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDhcpOptionsSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDhcpOptionsSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDhcpOptionsSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDhcpOptionsSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteExpressConnectRequest : Tea.TeaModel {
    public var clientToken: String?

    public var force: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class DeleteExpressConnectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteExpressConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExpressConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteExpressConnectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteExpressConnectTrafficQosRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DeleteExpressConnectTrafficQosResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteExpressConnectTrafficQosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExpressConnectTrafficQosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteExpressConnectTrafficQosResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteExpressConnectTrafficQosQueueRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueId"] as? String {
            self.queueId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DeleteExpressConnectTrafficQosQueueResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteExpressConnectTrafficQosQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExpressConnectTrafficQosQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteExpressConnectTrafficQosQueueResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteExpressConnectTrafficQosRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueId"] as? String {
            self.queueId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["RuleId"] as? String {
            self.ruleId = value
        }
    }
}

public class DeleteExpressConnectTrafficQosRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteExpressConnectTrafficQosRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteExpressConnectTrafficQosRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteExpressConnectTrafficQosRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DeleteFailoverTestJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFailoverTestJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFlowLogRequest : Tea.TeaModel {
    public var flowLogId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FlowLogId"] as? String {
            self.flowLogId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteFlowLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DeleteFlowLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFlowLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteForwardEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var forwardEntryId: String?

    public var forwardTableId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ForwardEntryId"] as? String {
            self.forwardEntryId = value
        }
        if let value = dict["ForwardTableId"] as? String {
            self.forwardTableId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteForwardEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFullNatEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var fullNatEntryId: String?

    public var fullNatTableId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.fullNatEntryId != nil {
            map["FullNatEntryId"] = self.fullNatEntryId!
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["FullNatEntryId"] as? String {
            self.fullNatEntryId = value
        }
        if let value = dict["FullNatTableId"] as? String {
            self.fullNatTableId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteFullNatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteFullNatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFullNatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFullNatEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteGlobalAccelerationInstanceRequest : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GlobalAccelerationInstanceId"] as? String {
            self.globalAccelerationInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteGlobalAccelerationInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteGlobalAccelerationInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGlobalAccelerationInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteGlobalAccelerationInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var haVipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteHaVipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIPv6TranslatorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Ipv6TranslatorId"] as? String {
            self.ipv6TranslatorId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteIPv6TranslatorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteIPv6TranslatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIPv6TranslatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIPv6TranslatorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIPv6TranslatorAclListRequest : Tea.TeaModel {
    public var aclId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteIPv6TranslatorAclListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteIPv6TranslatorAclListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIPv6TranslatorAclListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIPv6TranslatorAclListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIPv6TranslatorEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6TranslatorEntryId: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6TranslatorEntryId != nil {
            map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Ipv6TranslatorEntryId"] as? String {
            self.ipv6TranslatorEntryId = value
        }
        if let value = dict["Ipv6TranslatorId"] as? String {
            self.ipv6TranslatorId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteIPv6TranslatorEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteIPv6TranslatorEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIPv6TranslatorEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIPv6TranslatorEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIpsecServerRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: String?

    public var ipsecServerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? String {
            self.dryRun = value
        }
        if let value = dict["IpsecServerId"] as? String {
            self.ipsecServerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteIpsecServerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteIpsecServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpsecServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIpsecServerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIpv4GatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var internetMode: String?

    public var ipv4GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.internetMode != nil {
            map["InternetMode"] = self.internetMode!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InternetMode"] as? String {
            self.internetMode = value
        }
        if let value = dict["Ipv4GatewayId"] as? String {
            self.ipv4GatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteIpv4GatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteIpv4GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpv4GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIpv4GatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIpv6EgressOnlyRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6EgressOnlyRuleId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6EgressOnlyRuleId != nil {
            map["Ipv6EgressOnlyRuleId"] = self.ipv6EgressOnlyRuleId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Ipv6EgressOnlyRuleId"] as? String {
            self.ipv6EgressOnlyRuleId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteIpv6EgressOnlyRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteIpv6EgressOnlyRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpv6EgressOnlyRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIpv6EgressOnlyRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIpv6GatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv6GatewayId"] as? String {
            self.ipv6GatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteIpv6GatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteIpv6GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpv6GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIpv6GatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIpv6InternetBandwidthRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6AddressId: String?

    public var ipv6InternetBandwidthId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ipv6InternetBandwidthId != nil {
            map["Ipv6InternetBandwidthId"] = self.ipv6InternetBandwidthId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv6AddressId"] as? String {
            self.ipv6AddressId = value
        }
        if let value = dict["Ipv6InternetBandwidthId"] as? String {
            self.ipv6InternetBandwidthId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteIpv6InternetBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteIpv6InternetBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpv6InternetBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIpv6InternetBandwidthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNatGatewayRequest : Tea.TeaModel {
    public var force: Bool?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteNatGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNatGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNatIpRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv4Prefix: String?

    public var natGatewayId: String?

    public var natIpId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpId != nil {
            map["NatIpId"] = self.natIpId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv4Prefix"] as? String {
            self.ipv4Prefix = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatIpId"] as? String {
            self.natIpId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteNatIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteNatIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNatIpResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNatIpCidrRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatIpCidr"] as? String {
            self.natIpCidr = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteNatIpCidrResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteNatIpCidrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatIpCidrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNatIpCidrResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNetworkAclRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNetworkAclResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeletePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePublicIpAddressPoolRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeletePublicIpAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePublicIpAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePublicIpAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePublicIpAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePublicIpAddressPoolCidrBlockRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeletePublicIpAddressPoolCidrBlockResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePublicIpAddressPoolCidrBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePublicIpAddressPoolCidrBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePublicIpAddressPoolCidrBlockResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRouteEntriesRequest : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public var dstCidrBlock: String?

        public var nextHop: String?

        public var routeEntryId: String?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstCidrBlock != nil {
                map["DstCidrBlock"] = self.dstCidrBlock!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            if self.routeEntryId != nil {
                map["RouteEntryId"] = self.routeEntryId!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DstCidrBlock"] as? String {
                self.dstCidrBlock = value
            }
            if let value = dict["NextHop"] as? String {
                self.nextHop = value
            }
            if let value = dict["RouteEntryId"] as? String {
                self.routeEntryId = value
            }
            if let value = dict["RouteTableId"] as? String {
                self.routeTableId = value
            }
        }
    }
    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntries: [DeleteRouteEntriesRequest.RouteEntries]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntries"] as? [Any?] {
            var tmp : [DeleteRouteEntriesRequest.RouteEntries] = []
            for v in value {
                if v != nil {
                    var model = DeleteRouteEntriesRequest.RouteEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeEntries = tmp
        }
    }
}

public class DeleteRouteEntriesResponseBody : Tea.TeaModel {
    public class FailedRouteEntries : Tea.TeaModel {
        public var dstCidrBlock: String?

        public var failedCode: String?

        public var failedMessage: String?

        public var nextHop: String?

        public var routeEntryId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstCidrBlock != nil {
                map["DstCidrBlock"] = self.dstCidrBlock!
            }
            if self.failedCode != nil {
                map["FailedCode"] = self.failedCode!
            }
            if self.failedMessage != nil {
                map["FailedMessage"] = self.failedMessage!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            if self.routeEntryId != nil {
                map["RouteEntryId"] = self.routeEntryId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DstCidrBlock"] as? String {
                self.dstCidrBlock = value
            }
            if let value = dict["FailedCode"] as? String {
                self.failedCode = value
            }
            if let value = dict["FailedMessage"] as? String {
                self.failedMessage = value
            }
            if let value = dict["NextHop"] as? String {
                self.nextHop = value
            }
            if let value = dict["RouteEntryId"] as? String {
                self.routeEntryId = value
            }
        }
    }
    public var failedCount: Int32?

    public var failedRouteEntries: [DeleteRouteEntriesResponseBody.FailedRouteEntries]?

    public var requestId: String?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.failedRouteEntries != nil {
            var tmp : [Any] = []
            for k in self.failedRouteEntries! {
                tmp.append(k.toMap())
            }
            map["FailedRouteEntries"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailedCount"] as? Int32 {
            self.failedCount = value
        }
        if let value = dict["FailedRouteEntries"] as? [Any?] {
            var tmp : [DeleteRouteEntriesResponseBody.FailedRouteEntries] = []
            for v in value {
                if v != nil {
                    var model = DeleteRouteEntriesResponseBody.FailedRouteEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.failedRouteEntries = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessCount"] as? Int32 {
            self.successCount = value
        }
    }
}

public class DeleteRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRouteEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRouteEntryRequest : Tea.TeaModel {
    public class NextHopList : Tea.TeaModel {
        public var nextHopId: String?

        public var nextHopType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NextHopId"] as? String {
                self.nextHopId = value
            }
            if let value = dict["NextHopType"] as? String {
                self.nextHopType = value
            }
        }
    }
    public var destinationCidrBlock: String?

    public var dryRun: Bool?

    public var nextHopId: String?

    public var nextHopList: [DeleteRouteEntryRequest.NextHopList]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryId: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopList != nil {
            var tmp : [Any] = []
            for k in self.nextHopList! {
                tmp.append(k.toMap())
            }
            map["NextHopList"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NextHopId"] as? String {
            self.nextHopId = value
        }
        if let value = dict["NextHopList"] as? [Any?] {
            var tmp : [DeleteRouteEntryRequest.NextHopList] = []
            for v in value {
                if v != nil {
                    var model = DeleteRouteEntryRequest.NextHopList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nextHopList = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntryId"] as? String {
            self.routeEntryId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
    }
}

public class DeleteRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRouteTableRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
    }
}

public class DeleteRouteTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRouteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRouteTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRouteTargetGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var regionId: String?

    public var routeTargetGroupId: String?

    public var tag: [DeleteRouteTargetGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.routeTargetGroupId != nil {
            map["RouteTargetGroupId"] = self.routeTargetGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RouteTargetGroupId"] as? String {
            self.routeTargetGroupId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DeleteRouteTargetGroupRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DeleteRouteTargetGroupRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DeleteRouteTargetGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRouteTargetGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteTargetGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRouteTargetGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRouterInterfaceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class DeleteRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSnatEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snatEntryId: String?

    public var snatTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatTableId != nil {
            map["SnatTableId"] = self.snatTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnatEntryId"] as? String {
            self.snatEntryId = value
        }
        if let value = dict["SnatTableId"] as? String {
            self.snatTableId = value
        }
    }
}

public class DeleteSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSnatEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSslVpnClientCertRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslVpnClientCertId"] as? String {
            self.sslVpnClientCertId = value
        }
    }
}

public class DeleteSslVpnClientCertResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSslVpnClientCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSslVpnClientCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSslVpnClientCertResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSslVpnServerRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslVpnServerId"] as? String {
            self.sslVpnServerId = value
        }
    }
}

public class DeleteSslVpnServerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSslVpnServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSslVpnServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSslVpnServerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteTrafficMirrorFilterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrafficMirrorFilterId"] as? String {
            self.trafficMirrorFilterId = value
        }
    }
}

public class DeleteTrafficMirrorFilterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteTrafficMirrorFilterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficMirrorFilterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteTrafficMirrorFilterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteTrafficMirrorFilterRulesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorFilterRuleIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorFilterRuleIds != nil {
            map["TrafficMirrorFilterRuleIds"] = self.trafficMirrorFilterRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrafficMirrorFilterId"] as? String {
            self.trafficMirrorFilterId = value
        }
        if let value = dict["TrafficMirrorFilterRuleIds"] as? [String] {
            self.trafficMirrorFilterRuleIds = value
        }
    }
}

public class DeleteTrafficMirrorFilterRulesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteTrafficMirrorFilterRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficMirrorFilterRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteTrafficMirrorFilterRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteTrafficMirrorSessionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorSessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrafficMirrorSessionId"] as? String {
            self.trafficMirrorSessionId = value
        }
    }
}

public class DeleteTrafficMirrorSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteTrafficMirrorSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficMirrorSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteTrafficMirrorSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVSwitchRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class DeleteVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVSwitchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVSwitchCidrReservationRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchCidrReservationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchCidrReservationId != nil {
            map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchCidrReservationId"] as? String {
            self.vSwitchCidrReservationId = value
        }
    }
}

public class DeleteVSwitchCidrReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVSwitchCidrReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVSwitchCidrReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVSwitchCidrReservationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVbrHaRequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteVbrHaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVbrHaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVbrHaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVbrHaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVcoRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnConnectionId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class DeleteVcoRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVcoRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVcoRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVcoRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class DeleteVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpcRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var forceDelete: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceDelete != nil {
            map["ForceDelete"] = self.forceDelete!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ForceDelete"] as? Bool {
            self.forceDelete = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DeleteVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpcGatewayEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EndpointId"] as? String {
            self.endpointId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteVpcGatewayEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVpcGatewayEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcGatewayEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpcGatewayEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpcPrefixListRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteVpcPrefixListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVpcPrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcPrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpcPrefixListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpnAttachmentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class DeleteVpnAttachmentResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteVpnAttachmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnAttachmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpnAttachmentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpnConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class DeleteVpnConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVpnConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpnConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpnGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DeleteVpnGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVpnGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpnGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpnPbrRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["RouteSource"] as? String {
            self.routeSource = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class DeleteVpnPbrRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVpnPbrRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnPbrRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpnPbrRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpnRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class DeleteVpnRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVpnRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpnRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpnRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletionProtectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var ownerId: Int64?

    public var protectionEnable: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.protectionEnable != nil {
            map["ProtectionEnable"] = self.protectionEnable!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProtectionEnable"] as? Bool {
            self.protectionEnable = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DeletionProtectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletionProtectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletionProtectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletionProtectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class Describe95TrafficRequest : Tea.TeaModel {
    public var day: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.day != nil {
            map["Day"] = self.day!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Day"] as? String {
            self.day = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class Describe95TrafficResponseBody : Tea.TeaModel {
    public class Traffic95Summary : Tea.TeaModel {
        public class Traffic95DetailList : Tea.TeaModel {
            public class Traffic95Detail : Tea.TeaModel {
                public var billBandwidth: String?

                public var inBandwidth: String?

                public var outBandwidth: String?

                public var time: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.billBandwidth != nil {
                        map["BillBandwidth"] = self.billBandwidth!
                    }
                    if self.inBandwidth != nil {
                        map["InBandwidth"] = self.inBandwidth!
                    }
                    if self.outBandwidth != nil {
                        map["OutBandwidth"] = self.outBandwidth!
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BillBandwidth"] as? String {
                        self.billBandwidth = value
                    }
                    if let value = dict["InBandwidth"] as? String {
                        self.inBandwidth = value
                    }
                    if let value = dict["OutBandwidth"] as? String {
                        self.outBandwidth = value
                    }
                    if let value = dict["Time"] as? String {
                        self.time = value
                    }
                }
            }
            public var traffic95Detail: [Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList.Traffic95Detail]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.traffic95Detail != nil {
                    var tmp : [Any] = []
                    for k in self.traffic95Detail! {
                        tmp.append(k.toMap())
                    }
                    map["Traffic95Detail"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Traffic95Detail"] as? [Any?] {
                    var tmp : [Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList.Traffic95Detail] = []
                    for v in value {
                        if v != nil {
                            var model = Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList.Traffic95Detail()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.traffic95Detail = tmp
                }
            }
        }
        public var bandwidth: Int64?

        public var fifthPeakBandwidth: String?

        public var instanceId: String?

        public var internetChargeType: String?

        public var minimumConsumeBandwidth: String?

        public var traffic95DetailList: Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.traffic95DetailList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.fifthPeakBandwidth != nil {
                map["FifthPeakBandwidth"] = self.fifthPeakBandwidth!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.minimumConsumeBandwidth != nil {
                map["MinimumConsumeBandwidth"] = self.minimumConsumeBandwidth!
            }
            if self.traffic95DetailList != nil {
                map["Traffic95DetailList"] = self.traffic95DetailList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Bandwidth"] as? Int64 {
                self.bandwidth = value
            }
            if let value = dict["FifthPeakBandwidth"] as? String {
                self.fifthPeakBandwidth = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InternetChargeType"] as? String {
                self.internetChargeType = value
            }
            if let value = dict["MinimumConsumeBandwidth"] as? String {
                self.minimumConsumeBandwidth = value
            }
            if let value = dict["Traffic95DetailList"] as? [String: Any?] {
                var model = Describe95TrafficResponseBody.Traffic95Summary.Traffic95DetailList()
                model.fromMap(value)
                self.traffic95DetailList = model
            }
        }
    }
    public var requestId: String?

    public var traffic95Summary: Describe95TrafficResponseBody.Traffic95Summary?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.traffic95Summary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traffic95Summary != nil {
            map["Traffic95Summary"] = self.traffic95Summary?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Traffic95Summary"] as? [String: Any?] {
            var model = Describe95TrafficResponseBody.Traffic95Summary()
            model.fromMap(value)
            self.traffic95Summary = model
        }
    }
}

public class Describe95TrafficResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: Describe95TrafficResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = Describe95TrafficResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAccessPointsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeAccessPointsResponseBody : Tea.TeaModel {
    public class AccessPointSet : Tea.TeaModel {
        public class AccessPointType : Tea.TeaModel {
            public class AccessPointFeatureModels : Tea.TeaModel {
                public class AccessPointFeatureModel : Tea.TeaModel {
                    public var featureKey: String?

                    public var featureValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.featureKey != nil {
                            map["FeatureKey"] = self.featureKey!
                        }
                        if self.featureValue != nil {
                            map["FeatureValue"] = self.featureValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["FeatureKey"] as? String {
                            self.featureKey = value
                        }
                        if let value = dict["FeatureValue"] as? String {
                            self.featureValue = value
                        }
                    }
                }
                public var accessPointFeatureModel: [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels.AccessPointFeatureModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessPointFeatureModel != nil {
                        var tmp : [Any] = []
                        for k in self.accessPointFeatureModel! {
                            tmp.append(k.toMap())
                        }
                        map["AccessPointFeatureModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AccessPointFeatureModel"] as? [Any?] {
                        var tmp : [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels.AccessPointFeatureModel] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels.AccessPointFeatureModel()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.accessPointFeatureModel = tmp
                    }
                }
            }
            public var accessPointFeatureModels: DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels?

            public var accessPointId: String?

            public var attachedRegionNo: String?

            public var description_: String?

            public var hostOperator: String?

            public var location: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.accessPointFeatureModels?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointFeatureModels != nil {
                    map["AccessPointFeatureModels"] = self.accessPointFeatureModels?.toMap()
                }
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.attachedRegionNo != nil {
                    map["AttachedRegionNo"] = self.attachedRegionNo!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hostOperator != nil {
                    map["HostOperator"] = self.hostOperator!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessPointFeatureModels"] as? [String: Any?] {
                    var model = DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType.AccessPointFeatureModels()
                    model.fromMap(value)
                    self.accessPointFeatureModels = model
                }
                if let value = dict["AccessPointId"] as? String {
                    self.accessPointId = value
                }
                if let value = dict["AttachedRegionNo"] as? String {
                    self.attachedRegionNo = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["HostOperator"] as? String {
                    self.hostOperator = value
                }
                if let value = dict["Location"] as? String {
                    self.location = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var accessPointType: [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointType != nil {
                var tmp : [Any] = []
                for k in self.accessPointType! {
                    tmp.append(k.toMap())
                }
                map["AccessPointType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessPointType"] as? [Any?] {
                var tmp : [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.accessPointType = tmp
            }
        }
    }
    public var accessPointSet: DescribeAccessPointsResponseBody.AccessPointSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessPointSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointSet != nil {
            map["AccessPointSet"] = self.accessPointSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessPointSet"] as? [String: Any?] {
            var model = DescribeAccessPointsResponseBody.AccessPointSet()
            model.fromMap(value)
            self.accessPointSet = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeAccessPointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccessPointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAccessPointsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBgpGroupsRequest : Tea.TeaModel {
    public var bgpGroupId: String?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpGroupId"] as? String {
            self.bgpGroupId = value
        }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
    }
}

public class DescribeBgpGroupsResponseBody : Tea.TeaModel {
    public class BgpGroups : Tea.TeaModel {
        public class BgpGroup : Tea.TeaModel {
            public var authKey: String?

            public var bgpGroupId: String?

            public var description_: String?

            public var hold: String?

            public var ipVersion: String?

            public var isFake: String?

            public var keepalive: String?

            public var localAsn: String?

            public var name: String?

            public var peerAsn: String?

            public var regionId: String?

            public var routeLimit: String?

            public var routerId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authKey != nil {
                    map["AuthKey"] = self.authKey!
                }
                if self.bgpGroupId != nil {
                    map["BgpGroupId"] = self.bgpGroupId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hold != nil {
                    map["Hold"] = self.hold!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.isFake != nil {
                    map["IsFake"] = self.isFake!
                }
                if self.keepalive != nil {
                    map["Keepalive"] = self.keepalive!
                }
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.peerAsn != nil {
                    map["PeerAsn"] = self.peerAsn!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.routeLimit != nil {
                    map["RouteLimit"] = self.routeLimit!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AuthKey"] as? String {
                    self.authKey = value
                }
                if let value = dict["BgpGroupId"] as? String {
                    self.bgpGroupId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Hold"] as? String {
                    self.hold = value
                }
                if let value = dict["IpVersion"] as? String {
                    self.ipVersion = value
                }
                if let value = dict["IsFake"] as? String {
                    self.isFake = value
                }
                if let value = dict["Keepalive"] as? String {
                    self.keepalive = value
                }
                if let value = dict["LocalAsn"] as? String {
                    self.localAsn = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["PeerAsn"] as? String {
                    self.peerAsn = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RouteLimit"] as? String {
                    self.routeLimit = value
                }
                if let value = dict["RouterId"] as? String {
                    self.routerId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var bgpGroup: [DescribeBgpGroupsResponseBody.BgpGroups.BgpGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bgpGroup != nil {
                var tmp : [Any] = []
                for k in self.bgpGroup! {
                    tmp.append(k.toMap())
                }
                map["BgpGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BgpGroup"] as? [Any?] {
                var tmp : [DescribeBgpGroupsResponseBody.BgpGroups.BgpGroup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBgpGroupsResponseBody.BgpGroups.BgpGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bgpGroup = tmp
            }
        }
    }
    public var bgpGroups: DescribeBgpGroupsResponseBody.BgpGroups?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bgpGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroups != nil {
            map["BgpGroups"] = self.bgpGroups?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpGroups"] as? [String: Any?] {
            var model = DescribeBgpGroupsResponseBody.BgpGroups()
            model.fromMap(value)
            self.bgpGroups = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeBgpGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBgpGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBgpGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBgpNetworksRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
    }
}

public class DescribeBgpNetworksResponseBody : Tea.TeaModel {
    public class BgpNetworks : Tea.TeaModel {
        public class BgpNetwork : Tea.TeaModel {
            public var dstCidrBlock: String?

            public var routerId: String?

            public var status: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dstCidrBlock != nil {
                    map["DstCidrBlock"] = self.dstCidrBlock!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DstCidrBlock"] as? String {
                    self.dstCidrBlock = value
                }
                if let value = dict["RouterId"] as? String {
                    self.routerId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var bgpNetwork: [DescribeBgpNetworksResponseBody.BgpNetworks.BgpNetwork]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bgpNetwork != nil {
                var tmp : [Any] = []
                for k in self.bgpNetwork! {
                    tmp.append(k.toMap())
                }
                map["BgpNetwork"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BgpNetwork"] as? [Any?] {
                var tmp : [DescribeBgpNetworksResponseBody.BgpNetworks.BgpNetwork] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBgpNetworksResponseBody.BgpNetworks.BgpNetwork()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bgpNetwork = tmp
            }
        }
    }
    public var bgpNetworks: DescribeBgpNetworksResponseBody.BgpNetworks?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bgpNetworks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpNetworks != nil {
            map["BgpNetworks"] = self.bgpNetworks?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpNetworks"] as? [String: Any?] {
            var model = DescribeBgpNetworksResponseBody.BgpNetworks()
            model.fromMap(value)
            self.bgpNetworks = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeBgpNetworksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBgpNetworksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBgpNetworksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBgpPeersRequest : Tea.TeaModel {
    public var bgpGroupId: String?

    public var bgpPeerId: String?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.bgpPeerId != nil {
            map["BgpPeerId"] = self.bgpPeerId!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpGroupId"] as? String {
            self.bgpGroupId = value
        }
        if let value = dict["BgpPeerId"] as? String {
            self.bgpPeerId = value
        }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
    }
}

public class DescribeBgpPeersResponseBody : Tea.TeaModel {
    public class BgpPeers : Tea.TeaModel {
        public class BgpPeer : Tea.TeaModel {
            public var advertisedRouteCount: Int32?

            public var authKey: String?

            public var bfdMultiHop: Int32?

            public var bgpGroupId: String?

            public var bgpPeerId: String?

            public var bgpStatus: String?

            public var description_: String?

            public var enableBfd: Bool?

            public var gmtModified: String?

            public var hold: String?

            public var ipVersion: String?

            public var isFake: Bool?

            public var keepalive: String?

            public var localAsn: String?

            public var name: String?

            public var peerAsn: String?

            public var peerIpAddress: String?

            public var receivedRouteCount: Int32?

            public var regionId: String?

            public var routeLimit: String?

            public var routerId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.advertisedRouteCount != nil {
                    map["AdvertisedRouteCount"] = self.advertisedRouteCount!
                }
                if self.authKey != nil {
                    map["AuthKey"] = self.authKey!
                }
                if self.bfdMultiHop != nil {
                    map["BfdMultiHop"] = self.bfdMultiHop!
                }
                if self.bgpGroupId != nil {
                    map["BgpGroupId"] = self.bgpGroupId!
                }
                if self.bgpPeerId != nil {
                    map["BgpPeerId"] = self.bgpPeerId!
                }
                if self.bgpStatus != nil {
                    map["BgpStatus"] = self.bgpStatus!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enableBfd != nil {
                    map["EnableBfd"] = self.enableBfd!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.hold != nil {
                    map["Hold"] = self.hold!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.isFake != nil {
                    map["IsFake"] = self.isFake!
                }
                if self.keepalive != nil {
                    map["Keepalive"] = self.keepalive!
                }
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.peerAsn != nil {
                    map["PeerAsn"] = self.peerAsn!
                }
                if self.peerIpAddress != nil {
                    map["PeerIpAddress"] = self.peerIpAddress!
                }
                if self.receivedRouteCount != nil {
                    map["ReceivedRouteCount"] = self.receivedRouteCount!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.routeLimit != nil {
                    map["RouteLimit"] = self.routeLimit!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AdvertisedRouteCount"] as? Int32 {
                    self.advertisedRouteCount = value
                }
                if let value = dict["AuthKey"] as? String {
                    self.authKey = value
                }
                if let value = dict["BfdMultiHop"] as? Int32 {
                    self.bfdMultiHop = value
                }
                if let value = dict["BgpGroupId"] as? String {
                    self.bgpGroupId = value
                }
                if let value = dict["BgpPeerId"] as? String {
                    self.bgpPeerId = value
                }
                if let value = dict["BgpStatus"] as? String {
                    self.bgpStatus = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnableBfd"] as? Bool {
                    self.enableBfd = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["Hold"] as? String {
                    self.hold = value
                }
                if let value = dict["IpVersion"] as? String {
                    self.ipVersion = value
                }
                if let value = dict["IsFake"] as? Bool {
                    self.isFake = value
                }
                if let value = dict["Keepalive"] as? String {
                    self.keepalive = value
                }
                if let value = dict["LocalAsn"] as? String {
                    self.localAsn = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["PeerAsn"] as? String {
                    self.peerAsn = value
                }
                if let value = dict["PeerIpAddress"] as? String {
                    self.peerIpAddress = value
                }
                if let value = dict["ReceivedRouteCount"] as? Int32 {
                    self.receivedRouteCount = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RouteLimit"] as? String {
                    self.routeLimit = value
                }
                if let value = dict["RouterId"] as? String {
                    self.routerId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var bgpPeer: [DescribeBgpPeersResponseBody.BgpPeers.BgpPeer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bgpPeer != nil {
                var tmp : [Any] = []
                for k in self.bgpPeer! {
                    tmp.append(k.toMap())
                }
                map["BgpPeer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BgpPeer"] as? [Any?] {
                var tmp : [DescribeBgpPeersResponseBody.BgpPeers.BgpPeer] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBgpPeersResponseBody.BgpPeers.BgpPeer()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bgpPeer = tmp
            }
        }
    }
    public var bgpPeers: DescribeBgpPeersResponseBody.BgpPeers?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bgpPeers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpPeers != nil {
            map["BgpPeers"] = self.bgpPeers?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpPeers"] as? [String: Any?] {
            var model = DescribeBgpPeersResponseBody.BgpPeers()
            model.fromMap(value)
            self.bgpPeers = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeBgpPeersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBgpPeersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBgpPeersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCommonBandwidthPackagesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var bandwidthPackageId: String?

    public var dryRun: Bool?

    public var includeReservationData: Bool?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var tag: [DescribeCommonBandwidthPackagesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["IncludeReservationData"] as? Bool {
            self.includeReservationData = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityProtectionEnabled"] as? Bool {
            self.securityProtectionEnabled = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeCommonBandwidthPackagesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeCommonBandwidthPackagesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeCommonBandwidthPackagesResponseBody : Tea.TeaModel {
    public class CommonBandwidthPackages : Tea.TeaModel {
        public class CommonBandwidthPackage : Tea.TeaModel {
            public class PublicIpAddresses : Tea.TeaModel {
                public class PublicIpAddresse : Tea.TeaModel {
                    public var allocationId: String?

                    public var bandwidthPackageIpRelationStatus: String?

                    public var ipAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allocationId != nil {
                            map["AllocationId"] = self.allocationId!
                        }
                        if self.bandwidthPackageIpRelationStatus != nil {
                            map["BandwidthPackageIpRelationStatus"] = self.bandwidthPackageIpRelationStatus!
                        }
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AllocationId"] as? String {
                            self.allocationId = value
                        }
                        if let value = dict["BandwidthPackageIpRelationStatus"] as? String {
                            self.bandwidthPackageIpRelationStatus = value
                        }
                        if let value = dict["IpAddress"] as? String {
                            self.ipAddress = value
                        }
                    }
                }
                public var publicIpAddresse: [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses.PublicIpAddresse]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.publicIpAddresse != nil {
                        var tmp : [Any] = []
                        for k in self.publicIpAddresse! {
                            tmp.append(k.toMap())
                        }
                        map["PublicIpAddresse"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PublicIpAddresse"] as? [Any?] {
                        var tmp : [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses.PublicIpAddresse] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses.PublicIpAddresse()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.publicIpAddresse = tmp
                    }
                }
            }
            public class SecurityProtectionTypes : Tea.TeaModel {
                public var securityProtectionType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityProtectionType != nil {
                        map["SecurityProtectionType"] = self.securityProtectionType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SecurityProtectionType"] as? [String] {
                        self.securityProtectionType = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var bandwidth: String?

            public var bandwidthPackageId: String?

            public var bizType: String?

            public var businessStatus: String?

            public var creationTime: String?

            public var deletionProtection: Bool?

            public var description_: String?

            public var expiredTime: String?

            public var hasReservationData: String?

            public var ISP: String?

            public var instanceChargeType: String?

            public var internetChargeType: String?

            public var name: String?

            public var publicIpAddresses: DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses?

            public var ratio: Int32?

            public var regionId: String?

            public var reservationActiveTime: String?

            public var reservationBandwidth: String?

            public var reservationInternetChargeType: String?

            public var reservationOrderType: String?

            public var resourceGroupId: String?

            public var securityProtectionTypes: DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.SecurityProtectionTypes?

            public var serviceManaged: Int32?

            public var status: String?

            public var tags: DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.publicIpAddresses?.validate()
                try self.securityProtectionTypes?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthPackageId != nil {
                    map["BandwidthPackageId"] = self.bandwidthPackageId!
                }
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.hasReservationData != nil {
                    map["HasReservationData"] = self.hasReservationData!
                }
                if self.ISP != nil {
                    map["ISP"] = self.ISP!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.publicIpAddresses != nil {
                    map["PublicIpAddresses"] = self.publicIpAddresses?.toMap()
                }
                if self.ratio != nil {
                    map["Ratio"] = self.ratio!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservationActiveTime != nil {
                    map["ReservationActiveTime"] = self.reservationActiveTime!
                }
                if self.reservationBandwidth != nil {
                    map["ReservationBandwidth"] = self.reservationBandwidth!
                }
                if self.reservationInternetChargeType != nil {
                    map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                }
                if self.reservationOrderType != nil {
                    map["ReservationOrderType"] = self.reservationOrderType!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityProtectionTypes != nil {
                    map["SecurityProtectionTypes"] = self.securityProtectionTypes?.toMap()
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Bandwidth"] as? String {
                    self.bandwidth = value
                }
                if let value = dict["BandwidthPackageId"] as? String {
                    self.bandwidthPackageId = value
                }
                if let value = dict["BizType"] as? String {
                    self.bizType = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DeletionProtection"] as? Bool {
                    self.deletionProtection = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["HasReservationData"] as? String {
                    self.hasReservationData = value
                }
                if let value = dict["ISP"] as? String {
                    self.ISP = value
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["InternetChargeType"] as? String {
                    self.internetChargeType = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["PublicIpAddresses"] as? [String: Any?] {
                    var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.PublicIpAddresses()
                    model.fromMap(value)
                    self.publicIpAddresses = model
                }
                if let value = dict["Ratio"] as? Int32 {
                    self.ratio = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ReservationActiveTime"] as? String {
                    self.reservationActiveTime = value
                }
                if let value = dict["ReservationBandwidth"] as? String {
                    self.reservationBandwidth = value
                }
                if let value = dict["ReservationInternetChargeType"] as? String {
                    self.reservationInternetChargeType = value
                }
                if let value = dict["ReservationOrderType"] as? String {
                    self.reservationOrderType = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SecurityProtectionTypes"] as? [String: Any?] {
                    var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.SecurityProtectionTypes()
                    model.fromMap(value)
                    self.securityProtectionTypes = model
                }
                if let value = dict["ServiceManaged"] as? Int32 {
                    self.serviceManaged = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["Zone"] as? String {
                    self.zone = value
                }
            }
        }
        public var commonBandwidthPackage: [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commonBandwidthPackage != nil {
                var tmp : [Any] = []
                for k in self.commonBandwidthPackage! {
                    tmp.append(k.toMap())
                }
                map["CommonBandwidthPackage"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CommonBandwidthPackage"] as? [Any?] {
                var tmp : [DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages.CommonBandwidthPackage()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.commonBandwidthPackage = tmp
            }
        }
    }
    public var commonBandwidthPackages: DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonBandwidthPackages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonBandwidthPackages != nil {
            map["CommonBandwidthPackages"] = self.commonBandwidthPackages?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommonBandwidthPackages"] as? [String: Any?] {
            var model = DescribeCommonBandwidthPackagesResponseBody.CommonBandwidthPackages()
            model.fromMap(value)
            self.commonBandwidthPackages = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeCommonBandwidthPackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommonBandwidthPackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCommonBandwidthPackagesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCustomerGatewayRequest : Tea.TeaModel {
    public var customerGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeCustomerGatewayResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var tag: [DescribeCustomerGatewayResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeCustomerGatewayResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCustomerGatewayResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public var asn: Int64?

    public var authKey: String?

    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var tags: DescribeCustomerGatewayResponseBody.Tags?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asn != nil {
            map["Asn"] = self.asn!
        }
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Asn"] as? Int64 {
            self.asn = value
        }
        if let value = dict["AuthKey"] as? String {
            self.authKey = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeCustomerGatewayResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
    }
}

public class DescribeCustomerGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomerGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCustomerGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCustomerGatewaysRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var customerGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeCustomerGatewaysRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeCustomerGatewaysRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeCustomerGatewaysRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeCustomerGatewaysResponseBody : Tea.TeaModel {
    public class CustomerGateways : Tea.TeaModel {
        public class CustomerGateway : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var asn: Int64?

            public var authKey: String?

            public var createTime: Int64?

            public var customerGatewayId: String?

            public var description_: String?

            public var ipAddress: String?

            public var name: String?

            public var resourceGroupId: String?

            public var tags: DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.asn != nil {
                    map["Asn"] = self.asn!
                }
                if self.authKey != nil {
                    map["AuthKey"] = self.authKey!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.customerGatewayId != nil {
                    map["CustomerGatewayId"] = self.customerGatewayId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Asn"] as? Int64 {
                    self.asn = value
                }
                if let value = dict["AuthKey"] as? String {
                    self.authKey = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CustomerGatewayId"] as? String {
                    self.customerGatewayId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["IpAddress"] as? String {
                    self.ipAddress = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var customerGateway: [DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGateway != nil {
                var tmp : [Any] = []
                for k in self.customerGateway! {
                    tmp.append(k.toMap())
                }
                map["CustomerGateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CustomerGateway"] as? [Any?] {
                var tmp : [DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCustomerGatewaysResponseBody.CustomerGateways.CustomerGateway()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.customerGateway = tmp
            }
        }
    }
    public var customerGateways: DescribeCustomerGatewaysResponseBody.CustomerGateways?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customerGateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGateways != nil {
            map["CustomerGateways"] = self.customerGateways?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomerGateways"] as? [String: Any?] {
            var model = DescribeCustomerGatewaysResponseBody.CustomerGateways()
            model.fromMap(value)
            self.customerGateways = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeCustomerGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomerGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCustomerGatewaysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEcGrantRelationRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["VbrRegionNo"] as? String {
            self.vbrRegionNo = value
        }
    }
}

public class DescribeEcGrantRelationResponseBody : Tea.TeaModel {
    public class EcGrantRelations : Tea.TeaModel {
        public var aliUid: Int64?

        public var gmtCreate: String?

        public var grantType: String?

        public var instanceId: String?

        public var instanceName: String?

        public var instanceRouterId: String?

        public var regionNo: String?

        public var status: String?

        public var vbrInstanceId: String?

        public var vbrOwnerUid: Int64?

        public var vbrRegionNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.grantType != nil {
                map["GrantType"] = self.grantType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceRouterId != nil {
                map["InstanceRouterId"] = self.instanceRouterId!
            }
            if self.regionNo != nil {
                map["RegionNo"] = self.regionNo!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vbrInstanceId != nil {
                map["VbrInstanceId"] = self.vbrInstanceId!
            }
            if self.vbrOwnerUid != nil {
                map["VbrOwnerUid"] = self.vbrOwnerUid!
            }
            if self.vbrRegionNo != nil {
                map["VbrRegionNo"] = self.vbrRegionNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliUid"] as? Int64 {
                self.aliUid = value
            }
            if let value = dict["GmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["GrantType"] as? String {
                self.grantType = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["InstanceRouterId"] as? String {
                self.instanceRouterId = value
            }
            if let value = dict["RegionNo"] as? String {
                self.regionNo = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["VbrInstanceId"] as? String {
                self.vbrInstanceId = value
            }
            if let value = dict["VbrOwnerUid"] as? Int64 {
                self.vbrOwnerUid = value
            }
            if let value = dict["VbrRegionNo"] as? String {
                self.vbrRegionNo = value
            }
        }
    }
    public var count: Int32?

    public var ecGrantRelations: [DescribeEcGrantRelationResponseBody.EcGrantRelations]?

    public var page: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.ecGrantRelations != nil {
            var tmp : [Any] = []
            for k in self.ecGrantRelations! {
                tmp.append(k.toMap())
            }
            map["EcGrantRelations"] = tmp
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["EcGrantRelations"] as? [Any?] {
            var tmp : [DescribeEcGrantRelationResponseBody.EcGrantRelations] = []
            for v in value {
                if v != nil {
                    var model = DescribeEcGrantRelationResponseBody.EcGrantRelations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ecGrantRelations = tmp
        }
        if let value = dict["Page"] as? Int32 {
            self.page = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeEcGrantRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEcGrantRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEcGrantRelationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEipAddressesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var filter: [DescribeEipAddressesRequest.Filter]?

    public var allocationId: String?

    public var associatedInstanceId: String?

    public var associatedInstanceType: String?

    public var chargeType: String?

    public var dryRun: Bool?

    public var eipAddress: String?

    public var eipName: String?

    public var ISP: String?

    public var includeReservationData: Bool?

    public var lockReason: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var segmentInstanceId: String?

    public var serviceManaged: Bool?

    public var status: String?

    public var tag: [DescribeEipAddressesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.associatedInstanceId != nil {
            map["AssociatedInstanceId"] = self.associatedInstanceId!
        }
        if self.associatedInstanceType != nil {
            map["AssociatedInstanceType"] = self.associatedInstanceType!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.eipName != nil {
            map["EipName"] = self.eipName!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.segmentInstanceId != nil {
            map["SegmentInstanceId"] = self.segmentInstanceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeEipAddressesRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeEipAddressesRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["AssociatedInstanceId"] as? String {
            self.associatedInstanceId = value
        }
        if let value = dict["AssociatedInstanceType"] as? String {
            self.associatedInstanceType = value
        }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EipAddress"] as? String {
            self.eipAddress = value
        }
        if let value = dict["EipName"] as? String {
            self.eipName = value
        }
        if let value = dict["ISP"] as? String {
            self.ISP = value
        }
        if let value = dict["IncludeReservationData"] as? Bool {
            self.includeReservationData = value
        }
        if let value = dict["LockReason"] as? String {
            self.lockReason = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityProtectionEnabled"] as? Bool {
            self.securityProtectionEnabled = value
        }
        if let value = dict["SegmentInstanceId"] as? String {
            self.segmentInstanceId = value
        }
        if let value = dict["ServiceManaged"] as? Bool {
            self.serviceManaged = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeEipAddressesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeEipAddressesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeEipAddressesResponseBody : Tea.TeaModel {
    public class EipAddresses : Tea.TeaModel {
        public class EipAddress : Tea.TeaModel {
            public class OperationLocks : Tea.TeaModel {
                public class LockReason : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LockReason"] as? String {
                            self.lockReason = value
                        }
                    }
                }
                public var lockReason: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lockReason != nil {
                        var tmp : [Any] = []
                        for k in self.lockReason! {
                            tmp.append(k.toMap())
                        }
                        map["LockReason"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LockReason"] as? [Any?] {
                        var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.lockReason = tmp
                    }
                }
            }
            public class SecurityProtectionTypes : Tea.TeaModel {
                public var securityProtectionType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityProtectionType != nil {
                        map["SecurityProtectionType"] = self.securityProtectionType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SecurityProtectionType"] as? [String] {
                        self.securityProtectionType = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocationId: String?

            public var allocationTime: String?

            public var bandwidth: String?

            public var bandwidthPackageBandwidth: String?

            public var bandwidthPackageId: String?

            public var bandwidthPackageType: String?

            public var bizType: String?

            public var businessStatus: String?

            public var chargeType: String?

            public var deletionProtection: Bool?

            public var description_: String?

            public var eipBandwidth: String?

            public var expiredTime: String?

            public var HDMonitorStatus: String?

            public var hasReservationData: String?

            public var ISP: String?

            public var instanceId: String?

            public var instanceRegionId: String?

            public var instanceType: String?

            public var internetChargeType: String?

            public var ipAddress: String?

            public var mode: String?

            public var name: String?

            public var netmode: String?

            public var operationLocks: DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks?

            public var privateIpAddress: String?

            public var publicIpAddressPoolId: String?

            public var regionId: String?

            public var reservationActiveTime: String?

            public var reservationBandwidth: String?

            public var reservationInternetChargeType: String?

            public var reservationOrderType: String?

            public var resourceGroupId: String?

            public var secondLimited: Bool?

            public var securityProtectionTypes: DescribeEipAddressesResponseBody.EipAddresses.EipAddress.SecurityProtectionTypes?

            public var segmentInstanceId: String?

            public var serviceID: Int64?

            public var serviceManaged: Int32?

            public var status: String?

            public var tags: DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags?

            public var vpcId: String?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.operationLocks?.validate()
                try self.securityProtectionTypes?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationId != nil {
                    map["AllocationId"] = self.allocationId!
                }
                if self.allocationTime != nil {
                    map["AllocationTime"] = self.allocationTime!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthPackageBandwidth != nil {
                    map["BandwidthPackageBandwidth"] = self.bandwidthPackageBandwidth!
                }
                if self.bandwidthPackageId != nil {
                    map["BandwidthPackageId"] = self.bandwidthPackageId!
                }
                if self.bandwidthPackageType != nil {
                    map["BandwidthPackageType"] = self.bandwidthPackageType!
                }
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.HDMonitorStatus != nil {
                    map["HDMonitorStatus"] = self.HDMonitorStatus!
                }
                if self.hasReservationData != nil {
                    map["HasReservationData"] = self.hasReservationData!
                }
                if self.ISP != nil {
                    map["ISP"] = self.ISP!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceRegionId != nil {
                    map["InstanceRegionId"] = self.instanceRegionId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.netmode != nil {
                    map["Netmode"] = self.netmode!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                if self.publicIpAddressPoolId != nil {
                    map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservationActiveTime != nil {
                    map["ReservationActiveTime"] = self.reservationActiveTime!
                }
                if self.reservationBandwidth != nil {
                    map["ReservationBandwidth"] = self.reservationBandwidth!
                }
                if self.reservationInternetChargeType != nil {
                    map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                }
                if self.reservationOrderType != nil {
                    map["ReservationOrderType"] = self.reservationOrderType!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.secondLimited != nil {
                    map["SecondLimited"] = self.secondLimited!
                }
                if self.securityProtectionTypes != nil {
                    map["SecurityProtectionTypes"] = self.securityProtectionTypes?.toMap()
                }
                if self.segmentInstanceId != nil {
                    map["SegmentInstanceId"] = self.segmentInstanceId!
                }
                if self.serviceID != nil {
                    map["ServiceID"] = self.serviceID!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocationId"] as? String {
                    self.allocationId = value
                }
                if let value = dict["AllocationTime"] as? String {
                    self.allocationTime = value
                }
                if let value = dict["Bandwidth"] as? String {
                    self.bandwidth = value
                }
                if let value = dict["BandwidthPackageBandwidth"] as? String {
                    self.bandwidthPackageBandwidth = value
                }
                if let value = dict["BandwidthPackageId"] as? String {
                    self.bandwidthPackageId = value
                }
                if let value = dict["BandwidthPackageType"] as? String {
                    self.bandwidthPackageType = value
                }
                if let value = dict["BizType"] as? String {
                    self.bizType = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["DeletionProtection"] as? Bool {
                    self.deletionProtection = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EipBandwidth"] as? String {
                    self.eipBandwidth = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["HDMonitorStatus"] as? String {
                    self.HDMonitorStatus = value
                }
                if let value = dict["HasReservationData"] as? String {
                    self.hasReservationData = value
                }
                if let value = dict["ISP"] as? String {
                    self.ISP = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceRegionId"] as? String {
                    self.instanceRegionId = value
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["InternetChargeType"] as? String {
                    self.internetChargeType = value
                }
                if let value = dict["IpAddress"] as? String {
                    self.ipAddress = value
                }
                if let value = dict["Mode"] as? String {
                    self.mode = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Netmode"] as? String {
                    self.netmode = value
                }
                if let value = dict["OperationLocks"] as? [String: Any?] {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks()
                    model.fromMap(value)
                    self.operationLocks = model
                }
                if let value = dict["PrivateIpAddress"] as? String {
                    self.privateIpAddress = value
                }
                if let value = dict["PublicIpAddressPoolId"] as? String {
                    self.publicIpAddressPoolId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ReservationActiveTime"] as? String {
                    self.reservationActiveTime = value
                }
                if let value = dict["ReservationBandwidth"] as? String {
                    self.reservationBandwidth = value
                }
                if let value = dict["ReservationInternetChargeType"] as? String {
                    self.reservationInternetChargeType = value
                }
                if let value = dict["ReservationOrderType"] as? String {
                    self.reservationOrderType = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SecondLimited"] as? Bool {
                    self.secondLimited = value
                }
                if let value = dict["SecurityProtectionTypes"] as? [String: Any?] {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.SecurityProtectionTypes()
                    model.fromMap(value)
                    self.securityProtectionTypes = model
                }
                if let value = dict["SegmentInstanceId"] as? String {
                    self.segmentInstanceId = value
                }
                if let value = dict["ServiceID"] as? Int64 {
                    self.serviceID = value
                }
                if let value = dict["ServiceManaged"] as? Int32 {
                    self.serviceManaged = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["Zone"] as? String {
                    self.zone = value
                }
            }
        }
        public var eipAddress: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipAddress != nil {
                var tmp : [Any] = []
                for k in self.eipAddress! {
                    tmp.append(k.toMap())
                }
                map["EipAddress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EipAddress"] as? [Any?] {
                var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eipAddress = tmp
            }
        }
    }
    public var eipAddresses: DescribeEipAddressesResponseBody.EipAddresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipAddresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipAddresses != nil {
            map["EipAddresses"] = self.eipAddresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EipAddresses"] as? [String: Any?] {
            var model = DescribeEipAddressesResponseBody.EipAddresses()
            model.fromMap(value)
            self.eipAddresses = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeEipAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEipAddressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEipGatewayInfoRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeEipGatewayInfoResponseBody : Tea.TeaModel {
    public class EipInfos : Tea.TeaModel {
        public class EipInfo : Tea.TeaModel {
            public var ip: String?

            public var ipGw: String?

            public var ipMask: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.ipGw != nil {
                    map["IpGw"] = self.ipGw!
                }
                if self.ipMask != nil {
                    map["IpMask"] = self.ipMask!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ip"] as? String {
                    self.ip = value
                }
                if let value = dict["IpGw"] as? String {
                    self.ipGw = value
                }
                if let value = dict["IpMask"] as? String {
                    self.ipMask = value
                }
            }
        }
        public var eipInfo: [DescribeEipGatewayInfoResponseBody.EipInfos.EipInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipInfo != nil {
                var tmp : [Any] = []
                for k in self.eipInfo! {
                    tmp.append(k.toMap())
                }
                map["EipInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EipInfo"] as? [Any?] {
                var tmp : [DescribeEipGatewayInfoResponseBody.EipInfos.EipInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEipGatewayInfoResponseBody.EipInfos.EipInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eipInfo = tmp
            }
        }
    }
    public var code: String?

    public var eipInfos: DescribeEipGatewayInfoResponseBody.EipInfos?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.eipInfos != nil {
            map["EipInfos"] = self.eipInfos?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["EipInfos"] as? [String: Any?] {
            var model = DescribeEipGatewayInfoResponseBody.EipInfos()
            model.fromMap(value)
            self.eipInfos = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeEipGatewayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipGatewayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEipGatewayInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEipMonitorDataRequest : Tea.TeaModel {
    public var allocationId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeEipMonitorDataResponseBody : Tea.TeaModel {
    public class EipMonitorDatas : Tea.TeaModel {
        public class EipMonitorData : Tea.TeaModel {
            public var eipBandwidth: Int32?

            public var eipFlow: Int64?

            public var eipPackets: Int32?

            public var eipRX: Int64?

            public var eipTX: Int64?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.eipFlow != nil {
                    map["EipFlow"] = self.eipFlow!
                }
                if self.eipPackets != nil {
                    map["EipPackets"] = self.eipPackets!
                }
                if self.eipRX != nil {
                    map["EipRX"] = self.eipRX!
                }
                if self.eipTX != nil {
                    map["EipTX"] = self.eipTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EipBandwidth"] as? Int32 {
                    self.eipBandwidth = value
                }
                if let value = dict["EipFlow"] as? Int64 {
                    self.eipFlow = value
                }
                if let value = dict["EipPackets"] as? Int32 {
                    self.eipPackets = value
                }
                if let value = dict["EipRX"] as? Int64 {
                    self.eipRX = value
                }
                if let value = dict["EipTX"] as? Int64 {
                    self.eipTX = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var eipMonitorData: [DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipMonitorData != nil {
                var tmp : [Any] = []
                for k in self.eipMonitorData! {
                    tmp.append(k.toMap())
                }
                map["EipMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EipMonitorData"] as? [Any?] {
                var tmp : [DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eipMonitorData = tmp
            }
        }
    }
    public var eipMonitorDatas: DescribeEipMonitorDataResponseBody.EipMonitorDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipMonitorDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipMonitorDatas != nil {
            map["EipMonitorDatas"] = self.eipMonitorDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EipMonitorDatas"] as? [String: Any?] {
            var model = DescribeEipMonitorDataResponseBody.EipMonitorDatas()
            model.fromMap(value)
            self.eipMonitorDatas = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeEipMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEipMonitorDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEipSegmentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var segmentInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.segmentInstanceId != nil {
            map["SegmentInstanceId"] = self.segmentInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SegmentInstanceId"] as? String {
            self.segmentInstanceId = value
        }
    }
}

public class DescribeEipSegmentResponseBody : Tea.TeaModel {
    public class EipSegments : Tea.TeaModel {
        public class EipSegment : Tea.TeaModel {
            public var creationTime: String?

            public var descritpion: String?

            public var instanceId: String?

            public var ipCount: String?

            public var name: String?

            public var regionId: String?

            public var segment: String?

            public var status: String?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.descritpion != nil {
                    map["Descritpion"] = self.descritpion!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipCount != nil {
                    map["IpCount"] = self.ipCount!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.segment != nil {
                    map["Segment"] = self.segment!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Descritpion"] as? String {
                    self.descritpion = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["IpCount"] as? String {
                    self.ipCount = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Segment"] as? String {
                    self.segment = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Zone"] as? String {
                    self.zone = value
                }
            }
        }
        public var eipSegment: [DescribeEipSegmentResponseBody.EipSegments.EipSegment]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipSegment != nil {
                var tmp : [Any] = []
                for k in self.eipSegment! {
                    tmp.append(k.toMap())
                }
                map["EipSegment"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EipSegment"] as? [Any?] {
                var tmp : [DescribeEipSegmentResponseBody.EipSegments.EipSegment] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEipSegmentResponseBody.EipSegments.EipSegment()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eipSegment = tmp
            }
        }
    }
    public var eipSegments: DescribeEipSegmentResponseBody.EipSegments?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipSegments?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipSegments != nil {
            map["EipSegments"] = self.eipSegments?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EipSegments"] as? [String: Any?] {
            var model = DescribeEipSegmentResponseBody.EipSegments()
            model.fromMap(value)
            self.eipSegments = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeEipSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEipSegmentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeExpressConnectTrafficQosRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosIdList: [String]?

    public var qosNameList: [String]?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var tags: [DescribeExpressConnectTrafficQosRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosIdList != nil {
            map["QosIdList"] = self.qosIdList!
        }
        if self.qosNameList != nil {
            map["QosNameList"] = self.qosNameList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosIdList"] as? [String] {
            self.qosIdList = value
        }
        if let value = dict["QosNameList"] as? [String] {
            self.qosNameList = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeExpressConnectTrafficQosRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeExpressConnectTrafficQosRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class DescribeExpressConnectTrafficQosResponseBody : Tea.TeaModel {
    public class QosList : Tea.TeaModel {
        public class AssociatedInstanceList : Tea.TeaModel {
            public var instanceId: String?

            public var instanceProgressing: Int32?

            public var instanceStatus: String?

            public var instanceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceProgressing != nil {
                    map["InstanceProgressing"] = self.instanceProgressing!
                }
                if self.instanceStatus != nil {
                    map["InstanceStatus"] = self.instanceStatus!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceProgressing"] as? Int32 {
                    self.instanceProgressing = value
                }
                if let value = dict["InstanceStatus"] as? String {
                    self.instanceStatus = value
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
            }
        }
        public class QueueList : Tea.TeaModel {
            public var bandwidthPercent: String?

            public var qosId: String?

            public var queueDescription: String?

            public var queueId: String?

            public var queueName: String?

            public var queueType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidthPercent != nil {
                    map["BandwidthPercent"] = self.bandwidthPercent!
                }
                if self.qosId != nil {
                    map["QosId"] = self.qosId!
                }
                if self.queueDescription != nil {
                    map["QueueDescription"] = self.queueDescription!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.queueType != nil {
                    map["QueueType"] = self.queueType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BandwidthPercent"] as? String {
                    self.bandwidthPercent = value
                }
                if let value = dict["QosId"] as? String {
                    self.qosId = value
                }
                if let value = dict["QueueDescription"] as? String {
                    self.queueDescription = value
                }
                if let value = dict["QueueId"] as? String {
                    self.queueId = value
                }
                if let value = dict["QueueName"] as? String {
                    self.queueName = value
                }
                if let value = dict["QueueType"] as? String {
                    self.queueType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var associatedInstanceList: [DescribeExpressConnectTrafficQosResponseBody.QosList.AssociatedInstanceList]?

        public var progressing: Int32?

        public var qosDescription: String?

        public var qosId: String?

        public var qosName: String?

        public var queueList: [DescribeExpressConnectTrafficQosResponseBody.QosList.QueueList]?

        public var resourceGroupId: String?

        public var status: String?

        public var tags: [DescribeExpressConnectTrafficQosResponseBody.QosList.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associatedInstanceList != nil {
                var tmp : [Any] = []
                for k in self.associatedInstanceList! {
                    tmp.append(k.toMap())
                }
                map["AssociatedInstanceList"] = tmp
            }
            if self.progressing != nil {
                map["Progressing"] = self.progressing!
            }
            if self.qosDescription != nil {
                map["QosDescription"] = self.qosDescription!
            }
            if self.qosId != nil {
                map["QosId"] = self.qosId!
            }
            if self.qosName != nil {
                map["QosName"] = self.qosName!
            }
            if self.queueList != nil {
                var tmp : [Any] = []
                for k in self.queueList! {
                    tmp.append(k.toMap())
                }
                map["QueueList"] = tmp
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssociatedInstanceList"] as? [Any?] {
                var tmp : [DescribeExpressConnectTrafficQosResponseBody.QosList.AssociatedInstanceList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeExpressConnectTrafficQosResponseBody.QosList.AssociatedInstanceList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.associatedInstanceList = tmp
            }
            if let value = dict["Progressing"] as? Int32 {
                self.progressing = value
            }
            if let value = dict["QosDescription"] as? String {
                self.qosDescription = value
            }
            if let value = dict["QosId"] as? String {
                self.qosId = value
            }
            if let value = dict["QosName"] as? String {
                self.qosName = value
            }
            if let value = dict["QueueList"] as? [Any?] {
                var tmp : [DescribeExpressConnectTrafficQosResponseBody.QosList.QueueList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeExpressConnectTrafficQosResponseBody.QosList.QueueList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.queueList = tmp
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeExpressConnectTrafficQosResponseBody.QosList.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeExpressConnectTrafficQosResponseBody.QosList.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
        }
    }
    public var count: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var qosList: [DescribeExpressConnectTrafficQosResponseBody.QosList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.qosList != nil {
            var tmp : [Any] = []
            for k in self.qosList! {
                tmp.append(k.toMap())
            }
            map["QosList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? String {
            self.count = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["QosList"] as? [Any?] {
            var tmp : [DescribeExpressConnectTrafficQosResponseBody.QosList] = []
            for v in value {
                if v != nil {
                    var model = DescribeExpressConnectTrafficQosResponseBody.QosList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.qosList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeExpressConnectTrafficQosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExpressConnectTrafficQosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeExpressConnectTrafficQosResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeExpressConnectTrafficQosQueueRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueIdList: [String]?

    public var queueNameList: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueIdList != nil {
            map["QueueIdList"] = self.queueIdList!
        }
        if self.queueNameList != nil {
            map["QueueNameList"] = self.queueNameList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueIdList"] as? [String] {
            self.queueIdList = value
        }
        if let value = dict["QueueNameList"] as? [String] {
            self.queueNameList = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DescribeExpressConnectTrafficQosQueueResponseBody : Tea.TeaModel {
    public class QueueList : Tea.TeaModel {
        public class RuleList : Tea.TeaModel {
            public var dstCidr: String?

            public var dstIPv6Cidr: String?

            public var dstPortRange: String?

            public var matchDscp: Int32?

            public var priority: Int32?

            public var protocol_: String?

            public var qosId: String?

            public var queueId: String?

            public var remarkingDscp: Int32?

            public var ruleDescription: String?

            public var ruleId: String?

            public var ruleName: String?

            public var srcCidr: String?

            public var srcIPv6Cidr: String?

            public var srcPortRange: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dstCidr != nil {
                    map["DstCidr"] = self.dstCidr!
                }
                if self.dstIPv6Cidr != nil {
                    map["DstIPv6Cidr"] = self.dstIPv6Cidr!
                }
                if self.dstPortRange != nil {
                    map["DstPortRange"] = self.dstPortRange!
                }
                if self.matchDscp != nil {
                    map["MatchDscp"] = self.matchDscp!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.qosId != nil {
                    map["QosId"] = self.qosId!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                if self.remarkingDscp != nil {
                    map["RemarkingDscp"] = self.remarkingDscp!
                }
                if self.ruleDescription != nil {
                    map["RuleDescription"] = self.ruleDescription!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.srcCidr != nil {
                    map["SrcCidr"] = self.srcCidr!
                }
                if self.srcIPv6Cidr != nil {
                    map["SrcIPv6Cidr"] = self.srcIPv6Cidr!
                }
                if self.srcPortRange != nil {
                    map["SrcPortRange"] = self.srcPortRange!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DstCidr"] as? String {
                    self.dstCidr = value
                }
                if let value = dict["DstIPv6Cidr"] as? String {
                    self.dstIPv6Cidr = value
                }
                if let value = dict["DstPortRange"] as? String {
                    self.dstPortRange = value
                }
                if let value = dict["MatchDscp"] as? Int32 {
                    self.matchDscp = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["QosId"] as? String {
                    self.qosId = value
                }
                if let value = dict["QueueId"] as? String {
                    self.queueId = value
                }
                if let value = dict["RemarkingDscp"] as? Int32 {
                    self.remarkingDscp = value
                }
                if let value = dict["RuleDescription"] as? String {
                    self.ruleDescription = value
                }
                if let value = dict["RuleId"] as? String {
                    self.ruleId = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["SrcCidr"] as? String {
                    self.srcCidr = value
                }
                if let value = dict["SrcIPv6Cidr"] as? String {
                    self.srcIPv6Cidr = value
                }
                if let value = dict["SrcPortRange"] as? String {
                    self.srcPortRange = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var bandwidthPercent: String?

        public var qosId: String?

        public var queueDescription: String?

        public var queueId: String?

        public var queueName: String?

        public var queueType: String?

        public var ruleList: [DescribeExpressConnectTrafficQosQueueResponseBody.QueueList.RuleList]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidthPercent != nil {
                map["BandwidthPercent"] = self.bandwidthPercent!
            }
            if self.qosId != nil {
                map["QosId"] = self.qosId!
            }
            if self.queueDescription != nil {
                map["QueueDescription"] = self.queueDescription!
            }
            if self.queueId != nil {
                map["QueueId"] = self.queueId!
            }
            if self.queueName != nil {
                map["QueueName"] = self.queueName!
            }
            if self.queueType != nil {
                map["QueueType"] = self.queueType!
            }
            if self.ruleList != nil {
                var tmp : [Any] = []
                for k in self.ruleList! {
                    tmp.append(k.toMap())
                }
                map["RuleList"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BandwidthPercent"] as? String {
                self.bandwidthPercent = value
            }
            if let value = dict["QosId"] as? String {
                self.qosId = value
            }
            if let value = dict["QueueDescription"] as? String {
                self.queueDescription = value
            }
            if let value = dict["QueueId"] as? String {
                self.queueId = value
            }
            if let value = dict["QueueName"] as? String {
                self.queueName = value
            }
            if let value = dict["QueueType"] as? String {
                self.queueType = value
            }
            if let value = dict["RuleList"] as? [Any?] {
                var tmp : [DescribeExpressConnectTrafficQosQueueResponseBody.QueueList.RuleList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeExpressConnectTrafficQosQueueResponseBody.QueueList.RuleList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ruleList = tmp
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var queueList: [DescribeExpressConnectTrafficQosQueueResponseBody.QueueList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.queueList != nil {
            var tmp : [Any] = []
            for k in self.queueList! {
                tmp.append(k.toMap())
            }
            map["QueueList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["QueueList"] as? [Any?] {
            var tmp : [DescribeExpressConnectTrafficQosQueueResponseBody.QueueList] = []
            for v in value {
                if v != nil {
                    var model = DescribeExpressConnectTrafficQosQueueResponseBody.QueueList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.queueList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeExpressConnectTrafficQosQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExpressConnectTrafficQosQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeExpressConnectTrafficQosQueueResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeExpressConnectTrafficQosRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var ruleIdList: [String]?

    public var ruleNameList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.ruleIdList != nil {
            map["RuleIdList"] = self.ruleIdList!
        }
        if self.ruleNameList != nil {
            map["RuleNameList"] = self.ruleNameList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueId"] as? String {
            self.queueId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["RuleIdList"] as? [String] {
            self.ruleIdList = value
        }
        if let value = dict["RuleNameList"] as? [String] {
            self.ruleNameList = value
        }
    }
}

public class DescribeExpressConnectTrafficQosRuleResponseBody : Tea.TeaModel {
    public class RuleList : Tea.TeaModel {
        public var dstCidr: String?

        public var dstIPv6Cidr: String?

        public var dstPortRange: String?

        public var matchDscp: Int32?

        public var priority: Int32?

        public var protocol_: String?

        public var qosId: String?

        public var queueId: String?

        public var remarkingDscp: Int32?

        public var ruleDescription: String?

        public var ruleId: String?

        public var ruleName: String?

        public var srcCidr: String?

        public var srcIPv6Cidr: String?

        public var srcPortRange: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstCidr != nil {
                map["DstCidr"] = self.dstCidr!
            }
            if self.dstIPv6Cidr != nil {
                map["DstIPv6Cidr"] = self.dstIPv6Cidr!
            }
            if self.dstPortRange != nil {
                map["DstPortRange"] = self.dstPortRange!
            }
            if self.matchDscp != nil {
                map["MatchDscp"] = self.matchDscp!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.qosId != nil {
                map["QosId"] = self.qosId!
            }
            if self.queueId != nil {
                map["QueueId"] = self.queueId!
            }
            if self.remarkingDscp != nil {
                map["RemarkingDscp"] = self.remarkingDscp!
            }
            if self.ruleDescription != nil {
                map["RuleDescription"] = self.ruleDescription!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.srcCidr != nil {
                map["SrcCidr"] = self.srcCidr!
            }
            if self.srcIPv6Cidr != nil {
                map["SrcIPv6Cidr"] = self.srcIPv6Cidr!
            }
            if self.srcPortRange != nil {
                map["SrcPortRange"] = self.srcPortRange!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DstCidr"] as? String {
                self.dstCidr = value
            }
            if let value = dict["DstIPv6Cidr"] as? String {
                self.dstIPv6Cidr = value
            }
            if let value = dict["DstPortRange"] as? String {
                self.dstPortRange = value
            }
            if let value = dict["MatchDscp"] as? Int32 {
                self.matchDscp = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["Protocol"] as? String {
                self.protocol_ = value
            }
            if let value = dict["QosId"] as? String {
                self.qosId = value
            }
            if let value = dict["QueueId"] as? String {
                self.queueId = value
            }
            if let value = dict["RemarkingDscp"] as? Int32 {
                self.remarkingDscp = value
            }
            if let value = dict["RuleDescription"] as? String {
                self.ruleDescription = value
            }
            if let value = dict["RuleId"] as? String {
                self.ruleId = value
            }
            if let value = dict["RuleName"] as? String {
                self.ruleName = value
            }
            if let value = dict["SrcCidr"] as? String {
                self.srcCidr = value
            }
            if let value = dict["SrcIPv6Cidr"] as? String {
                self.srcIPv6Cidr = value
            }
            if let value = dict["SrcPortRange"] as? String {
                self.srcPortRange = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var ruleList: [DescribeExpressConnectTrafficQosRuleResponseBody.RuleList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleList != nil {
            var tmp : [Any] = []
            for k in self.ruleList! {
                tmp.append(k.toMap())
            }
            map["RuleList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RuleList"] as? [Any?] {
            var tmp : [DescribeExpressConnectTrafficQosRuleResponseBody.RuleList] = []
            for v in value {
                if v != nil {
                    var model = DescribeExpressConnectTrafficQosRuleResponseBody.RuleList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ruleList = tmp
        }
    }
}

public class DescribeExpressConnectTrafficQosRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExpressConnectTrafficQosRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeExpressConnectTrafficQosRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DescribeFailoverTestJobResponseBody : Tea.TeaModel {
    public class FailoverTestJobModel : Tea.TeaModel {
        public var description_: String?

        public var jobDuration: String?

        public var jobId: String?

        public var jobType: String?

        public var name: String?

        public var resourceId: [String]?

        public var resourceType: String?

        public var startTime: String?

        public var status: String?

        public var stopTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.jobDuration != nil {
                map["JobDuration"] = self.jobDuration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopTime != nil {
                map["StopTime"] = self.stopTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["JobDuration"] as? String {
                self.jobDuration = value
            }
            if let value = dict["JobId"] as? String {
                self.jobId = value
            }
            if let value = dict["JobType"] as? String {
                self.jobType = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ResourceId"] as? [String] {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["StopTime"] as? String {
                self.stopTime = value
            }
        }
    }
    public var failoverTestJobModel: DescribeFailoverTestJobResponseBody.FailoverTestJobModel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failoverTestJobModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failoverTestJobModel != nil {
            map["FailoverTestJobModel"] = self.failoverTestJobModel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailoverTestJobModel"] as? [String: Any?] {
            var model = DescribeFailoverTestJobResponseBody.FailoverTestJobModel()
            model.fromMap(value)
            self.failoverTestJobModel = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeFailoverTestJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeFailoverTestJobsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var filter: [DescribeFailoverTestJobsRequest.Filter]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeFailoverTestJobsRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeFailoverTestJobsRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DescribeFailoverTestJobsResponseBody : Tea.TeaModel {
    public class FailoverTestJobList : Tea.TeaModel {
        public var description_: String?

        public var jobDuration: String?

        public var jobId: String?

        public var jobType: String?

        public var name: String?

        public var resourceId: [String]?

        public var resourceType: String?

        public var startTime: String?

        public var status: String?

        public var stopTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.jobDuration != nil {
                map["JobDuration"] = self.jobDuration!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopTime != nil {
                map["StopTime"] = self.stopTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["JobDuration"] as? String {
                self.jobDuration = value
            }
            if let value = dict["JobId"] as? String {
                self.jobId = value
            }
            if let value = dict["JobType"] as? String {
                self.jobType = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ResourceId"] as? [String] {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["StopTime"] as? String {
                self.stopTime = value
            }
        }
    }
    public var count: Int32?

    public var failoverTestJobList: [DescribeFailoverTestJobsResponseBody.FailoverTestJobList]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.failoverTestJobList != nil {
            var tmp : [Any] = []
            for k in self.failoverTestJobList! {
                tmp.append(k.toMap())
            }
            map["FailoverTestJobList"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["FailoverTestJobList"] as? [Any?] {
            var tmp : [DescribeFailoverTestJobsResponseBody.FailoverTestJobList] = []
            for v in value {
                if v != nil {
                    var model = DescribeFailoverTestJobsResponseBody.FailoverTestJobList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.failoverTestJobList = tmp
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeFailoverTestJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFailoverTestJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeFailoverTestJobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeFlowLogsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var description_: String?

    public var flowLogId: String?

    public var flowLogName: String?

    public var logStoreName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var status: String?

    public var tags: [DescribeFlowLogsRequest.Tags]?

    public var trafficType: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.flowLogName != nil {
            map["FlowLogName"] = self.flowLogName!
        }
        if self.logStoreName != nil {
            map["LogStoreName"] = self.logStoreName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.trafficType != nil {
            map["TrafficType"] = self.trafficType!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FlowLogId"] as? String {
            self.flowLogId = value
        }
        if let value = dict["FlowLogName"] as? String {
            self.flowLogName = value
        }
        if let value = dict["LogStoreName"] as? String {
            self.logStoreName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeFlowLogsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeFlowLogsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["TrafficType"] as? String {
            self.trafficType = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeFlowLogsResponseBody : Tea.TeaModel {
    public class FlowLogs : Tea.TeaModel {
        public class FlowLog : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public class TrafficPath : Tea.TeaModel {
                public var trafficPathList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.trafficPathList != nil {
                        map["TrafficPathList"] = self.trafficPathList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TrafficPathList"] as? [String] {
                        self.trafficPathList = value
                    }
                }
            }
            public var aggregationInterval: Int32?

            public var businessStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var flowLogDeliverErrorMessage: String?

            public var flowLogDeliverStatus: String?

            public var flowLogId: String?

            public var flowLogName: String?

            public var ipVersion: String?

            public var logStoreName: String?

            public var projectName: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var resourceId: String?

            public var resourceType: String?

            public var serviceType: String?

            public var status: String?

            public var tags: DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags?

            public var trafficPath: DescribeFlowLogsResponseBody.FlowLogs.FlowLog.TrafficPath?

            public var trafficType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
                try self.trafficPath?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aggregationInterval != nil {
                    map["AggregationInterval"] = self.aggregationInterval!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.flowLogDeliverErrorMessage != nil {
                    map["FlowLogDeliverErrorMessage"] = self.flowLogDeliverErrorMessage!
                }
                if self.flowLogDeliverStatus != nil {
                    map["FlowLogDeliverStatus"] = self.flowLogDeliverStatus!
                }
                if self.flowLogId != nil {
                    map["FlowLogId"] = self.flowLogId!
                }
                if self.flowLogName != nil {
                    map["FlowLogName"] = self.flowLogName!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.logStoreName != nil {
                    map["LogStoreName"] = self.logStoreName!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.serviceType != nil {
                    map["ServiceType"] = self.serviceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.trafficPath != nil {
                    map["TrafficPath"] = self.trafficPath?.toMap()
                }
                if self.trafficType != nil {
                    map["TrafficType"] = self.trafficType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AggregationInterval"] as? Int32 {
                    self.aggregationInterval = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["FlowLogDeliverErrorMessage"] as? String {
                    self.flowLogDeliverErrorMessage = value
                }
                if let value = dict["FlowLogDeliverStatus"] as? String {
                    self.flowLogDeliverStatus = value
                }
                if let value = dict["FlowLogId"] as? String {
                    self.flowLogId = value
                }
                if let value = dict["FlowLogName"] as? String {
                    self.flowLogName = value
                }
                if let value = dict["IpVersion"] as? String {
                    self.ipVersion = value
                }
                if let value = dict["LogStoreName"] as? String {
                    self.logStoreName = value
                }
                if let value = dict["ProjectName"] as? String {
                    self.projectName = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["ServiceType"] as? String {
                    self.serviceType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeFlowLogsResponseBody.FlowLogs.FlowLog.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TrafficPath"] as? [String: Any?] {
                    var model = DescribeFlowLogsResponseBody.FlowLogs.FlowLog.TrafficPath()
                    model.fromMap(value)
                    self.trafficPath = model
                }
                if let value = dict["TrafficType"] as? String {
                    self.trafficType = value
                }
            }
        }
        public var flowLog: [DescribeFlowLogsResponseBody.FlowLogs.FlowLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flowLog != nil {
                var tmp : [Any] = []
                for k in self.flowLog! {
                    tmp.append(k.toMap())
                }
                map["FlowLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FlowLog"] as? [Any?] {
                var tmp : [DescribeFlowLogsResponseBody.FlowLogs.FlowLog] = []
                for v in value {
                    if v != nil {
                        var model = DescribeFlowLogsResponseBody.FlowLogs.FlowLog()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.flowLog = tmp
            }
        }
    }
    public var flowLogs: DescribeFlowLogsResponseBody.FlowLogs?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var success: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.flowLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowLogs != nil {
            map["FlowLogs"] = self.flowLogs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FlowLogs"] as? [String: Any?] {
            var model = DescribeFlowLogsResponseBody.FlowLogs()
            model.fromMap(value)
            self.flowLogs = model
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeFlowLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeFlowLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeForwardTableEntriesRequest : Tea.TeaModel {
    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryId: String?

    public var forwardEntryName: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExternalIp"] as? String {
            self.externalIp = value
        }
        if let value = dict["ExternalPort"] as? String {
            self.externalPort = value
        }
        if let value = dict["ForwardEntryId"] as? String {
            self.forwardEntryId = value
        }
        if let value = dict["ForwardEntryName"] as? String {
            self.forwardEntryName = value
        }
        if let value = dict["ForwardTableId"] as? String {
            self.forwardTableId = value
        }
        if let value = dict["InternalIp"] as? String {
            self.internalIp = value
        }
        if let value = dict["InternalPort"] as? String {
            self.internalPort = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeForwardTableEntriesResponseBody : Tea.TeaModel {
    public class ForwardTableEntries : Tea.TeaModel {
        public class ForwardTableEntry : Tea.TeaModel {
            public var externalIp: String?

            public var externalPort: String?

            public var forwardEntryId: String?

            public var forwardEntryName: String?

            public var forwardTableId: String?

            public var internalIp: String?

            public var internalPort: String?

            public var ipProtocol: String?

            public var natGatewayId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externalIp != nil {
                    map["ExternalIp"] = self.externalIp!
                }
                if self.externalPort != nil {
                    map["ExternalPort"] = self.externalPort!
                }
                if self.forwardEntryId != nil {
                    map["ForwardEntryId"] = self.forwardEntryId!
                }
                if self.forwardEntryName != nil {
                    map["ForwardEntryName"] = self.forwardEntryName!
                }
                if self.forwardTableId != nil {
                    map["ForwardTableId"] = self.forwardTableId!
                }
                if self.internalIp != nil {
                    map["InternalIp"] = self.internalIp!
                }
                if self.internalPort != nil {
                    map["InternalPort"] = self.internalPort!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExternalIp"] as? String {
                    self.externalIp = value
                }
                if let value = dict["ExternalPort"] as? String {
                    self.externalPort = value
                }
                if let value = dict["ForwardEntryId"] as? String {
                    self.forwardEntryId = value
                }
                if let value = dict["ForwardEntryName"] as? String {
                    self.forwardEntryName = value
                }
                if let value = dict["ForwardTableId"] as? String {
                    self.forwardTableId = value
                }
                if let value = dict["InternalIp"] as? String {
                    self.internalIp = value
                }
                if let value = dict["InternalPort"] as? String {
                    self.internalPort = value
                }
                if let value = dict["IpProtocol"] as? String {
                    self.ipProtocol = value
                }
                if let value = dict["NatGatewayId"] as? String {
                    self.natGatewayId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var forwardTableEntry: [DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardTableEntry != nil {
                var tmp : [Any] = []
                for k in self.forwardTableEntry! {
                    tmp.append(k.toMap())
                }
                map["ForwardTableEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ForwardTableEntry"] as? [Any?] {
                var tmp : [DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry] = []
                for v in value {
                    if v != nil {
                        var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.forwardTableEntry = tmp
            }
        }
    }
    public var forwardTableEntries: DescribeForwardTableEntriesResponseBody.ForwardTableEntries?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forwardTableEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardTableEntries != nil {
            map["ForwardTableEntries"] = self.forwardTableEntries?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForwardTableEntries"] as? [String: Any?] {
            var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries()
            model.fromMap(value)
            self.forwardTableEntries = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeForwardTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeForwardTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeForwardTableEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGlobalAccelerationInstancesRequest : Tea.TeaModel {
    public var bandwidthType: String?

    public var globalAccelerationInstanceId: String?

    public var includeReservationData: Bool?

    public var ipAddress: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serverId: String?

    public var serviceLocation: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthType != nil {
            map["BandwidthType"] = self.bandwidthType!
        }
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        if self.serviceLocation != nil {
            map["ServiceLocation"] = self.serviceLocation!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthType"] as? String {
            self.bandwidthType = value
        }
        if let value = dict["GlobalAccelerationInstanceId"] as? String {
            self.globalAccelerationInstanceId = value
        }
        if let value = dict["IncludeReservationData"] as? Bool {
            self.includeReservationData = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServerId"] as? String {
            self.serverId = value
        }
        if let value = dict["ServiceLocation"] as? String {
            self.serviceLocation = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeGlobalAccelerationInstancesResponseBody : Tea.TeaModel {
    public class GlobalAccelerationInstances : Tea.TeaModel {
        public class GlobalAccelerationInstance : Tea.TeaModel {
            public class BackendServers : Tea.TeaModel {
                public class BackendServer : Tea.TeaModel {
                    public var regionId: String?

                    public var serverId: String?

                    public var serverIpAddress: String?

                    public var serverType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.serverId != nil {
                            map["ServerId"] = self.serverId!
                        }
                        if self.serverIpAddress != nil {
                            map["ServerIpAddress"] = self.serverIpAddress!
                        }
                        if self.serverType != nil {
                            map["ServerType"] = self.serverType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["RegionId"] as? String {
                            self.regionId = value
                        }
                        if let value = dict["ServerId"] as? String {
                            self.serverId = value
                        }
                        if let value = dict["ServerIpAddress"] as? String {
                            self.serverIpAddress = value
                        }
                        if let value = dict["ServerType"] as? String {
                            self.serverType = value
                        }
                    }
                }
                public var backendServer: [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers.BackendServer]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.backendServer != nil {
                        var tmp : [Any] = []
                        for k in self.backendServer! {
                            tmp.append(k.toMap())
                        }
                        map["BackendServer"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BackendServer"] as? [Any?] {
                        var tmp : [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers.BackendServer] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers.BackendServer()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.backendServer = tmp
                    }
                }
            }
            public class PublicIpAddresses : Tea.TeaModel {
                public class PublicIpAddress : Tea.TeaModel {
                    public var allocationId: String?

                    public var ipAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allocationId != nil {
                            map["AllocationId"] = self.allocationId!
                        }
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AllocationId"] as? String {
                            self.allocationId = value
                        }
                        if let value = dict["IpAddress"] as? String {
                            self.ipAddress = value
                        }
                    }
                }
                public var publicIpAddress: [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses.PublicIpAddress]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.publicIpAddress != nil {
                        var tmp : [Any] = []
                        for k in self.publicIpAddress! {
                            tmp.append(k.toMap())
                        }
                        map["PublicIpAddress"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PublicIpAddress"] as? [Any?] {
                        var tmp : [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses.PublicIpAddress] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses.PublicIpAddress()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.publicIpAddress = tmp
                    }
                }
            }
            public var accelerationLocation: String?

            public var backendServers: DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers?

            public var bandwidth: String?

            public var bandwidthType: String?

            public var chargeType: String?

            public var creationTime: String?

            public var description_: String?

            public var expiredTime: String?

            public var globalAccelerationInstanceId: String?

            public var internetChargeType: String?

            public var ipAddress: String?

            public var name: String?

            public var publicIpAddresses: DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses?

            public var regionId: String?

            public var serviceLocation: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.backendServers?.validate()
                try self.publicIpAddresses?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accelerationLocation != nil {
                    map["AccelerationLocation"] = self.accelerationLocation!
                }
                if self.backendServers != nil {
                    map["BackendServers"] = self.backendServers?.toMap()
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthType != nil {
                    map["BandwidthType"] = self.bandwidthType!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.globalAccelerationInstanceId != nil {
                    map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.publicIpAddresses != nil {
                    map["PublicIpAddresses"] = self.publicIpAddresses?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.serviceLocation != nil {
                    map["ServiceLocation"] = self.serviceLocation!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccelerationLocation"] as? String {
                    self.accelerationLocation = value
                }
                if let value = dict["BackendServers"] as? [String: Any?] {
                    var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.BackendServers()
                    model.fromMap(value)
                    self.backendServers = model
                }
                if let value = dict["Bandwidth"] as? String {
                    self.bandwidth = value
                }
                if let value = dict["BandwidthType"] as? String {
                    self.bandwidthType = value
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["GlobalAccelerationInstanceId"] as? String {
                    self.globalAccelerationInstanceId = value
                }
                if let value = dict["InternetChargeType"] as? String {
                    self.internetChargeType = value
                }
                if let value = dict["IpAddress"] as? String {
                    self.ipAddress = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["PublicIpAddresses"] as? [String: Any?] {
                    var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance.PublicIpAddresses()
                    model.fromMap(value)
                    self.publicIpAddresses = model
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ServiceLocation"] as? String {
                    self.serviceLocation = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var globalAccelerationInstance: [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.globalAccelerationInstance != nil {
                var tmp : [Any] = []
                for k in self.globalAccelerationInstance! {
                    tmp.append(k.toMap())
                }
                map["GlobalAccelerationInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GlobalAccelerationInstance"] as? [Any?] {
                var tmp : [DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.globalAccelerationInstance = tmp
            }
        }
    }
    public var globalAccelerationInstances: DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.globalAccelerationInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstances != nil {
            map["GlobalAccelerationInstances"] = self.globalAccelerationInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GlobalAccelerationInstances"] as? [String: Any?] {
            var model = DescribeGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances()
            model.fromMap(value)
            self.globalAccelerationInstances = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeGlobalAccelerationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGlobalAccelerationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGlobalAccelerationInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGrantRulesToCenRequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeGrantRulesToCenResponseBody : Tea.TeaModel {
    public class CenGrantRules : Tea.TeaModel {
        public class CbnGrantRule : Tea.TeaModel {
            public var cenInstanceId: String?

            public var cenOwnerId: Int64?

            public var creationTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cenInstanceId != nil {
                    map["CenInstanceId"] = self.cenInstanceId!
                }
                if self.cenOwnerId != nil {
                    map["CenOwnerId"] = self.cenOwnerId!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CenInstanceId"] as? String {
                    self.cenInstanceId = value
                }
                if let value = dict["CenOwnerId"] as? Int64 {
                    self.cenOwnerId = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
            }
        }
        public var cbnGrantRule: [DescribeGrantRulesToCenResponseBody.CenGrantRules.CbnGrantRule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cbnGrantRule != nil {
                var tmp : [Any] = []
                for k in self.cbnGrantRule! {
                    tmp.append(k.toMap())
                }
                map["CbnGrantRule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CbnGrantRule"] as? [Any?] {
                var tmp : [DescribeGrantRulesToCenResponseBody.CenGrantRules.CbnGrantRule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGrantRulesToCenResponseBody.CenGrantRules.CbnGrantRule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.cbnGrantRule = tmp
            }
        }
    }
    public var cenGrantRules: DescribeGrantRulesToCenResponseBody.CenGrantRules?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cenGrantRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cenGrantRules != nil {
            map["CenGrantRules"] = self.cenGrantRules?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CenGrantRules"] as? [String: Any?] {
            var model = DescribeGrantRulesToCenResponseBody.CenGrantRules()
            model.fromMap(value)
            self.cenGrantRules = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeGrantRulesToCenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGrantRulesToCenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGrantRulesToCenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGrantRulesToEcrRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [DescribeGrantRulesToEcrRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeGrantRulesToEcrRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeGrantRulesToEcrRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class DescribeGrantRulesToEcrResponseBody : Tea.TeaModel {
    public class EcrGrantRules : Tea.TeaModel {
        public var createTime: String?

        public var ecrInstanceId: String?

        public var ecrUid: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.ecrInstanceId != nil {
                map["EcrInstanceId"] = self.ecrInstanceId!
            }
            if self.ecrUid != nil {
                map["EcrUid"] = self.ecrUid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["EcrInstanceId"] as? String {
                self.ecrInstanceId = value
            }
            if let value = dict["EcrUid"] as? Int64 {
                self.ecrUid = value
            }
        }
    }
    public var count: Int32?

    public var ecrGrantRules: [DescribeGrantRulesToEcrResponseBody.EcrGrantRules]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.ecrGrantRules != nil {
            var tmp : [Any] = []
            for k in self.ecrGrantRules! {
                tmp.append(k.toMap())
            }
            map["EcrGrantRules"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["EcrGrantRules"] as? [Any?] {
            var tmp : [DescribeGrantRulesToEcrResponseBody.EcrGrantRules] = []
            for v in value {
                if v != nil {
                    var model = DescribeGrantRulesToEcrResponseBody.EcrGrantRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ecrGrantRules = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeGrantRulesToEcrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGrantRulesToEcrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGrantRulesToEcrResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHaVipsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var filter: [DescribeHaVipsRequest.Filter]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribeHaVipsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeHaVipsRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeHaVipsRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeHaVipsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeHaVipsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class DescribeHaVipsResponseBody : Tea.TeaModel {
    public class HaVips : Tea.TeaModel {
        public class HaVip : Tea.TeaModel {
            public class AssociatedEipAddresses : Tea.TeaModel {
                public var associatedEipAddresse: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedEipAddresse != nil {
                        map["associatedEipAddresse"] = self.associatedEipAddresse!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["associatedEipAddresse"] as? [String] {
                        self.associatedEipAddresse = value
                    }
                }
            }
            public class AssociatedInstances : Tea.TeaModel {
                public var associatedInstance: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedInstance != nil {
                        map["associatedInstance"] = self.associatedInstance!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["associatedInstance"] as? [String] {
                        self.associatedInstance = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeHaVipsResponseBody.HaVips.HaVip.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeHaVipsResponseBody.HaVips.HaVip.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeHaVipsResponseBody.HaVips.HaVip.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var associatedEipAddresses: DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedEipAddresses?

            public var associatedInstanceType: String?

            public var associatedInstances: DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedInstances?

            public var chargeType: String?

            public var createTime: String?

            public var description_: String?

            public var haVipId: String?

            public var ipAddress: String?

            public var masterInstanceId: String?

            public var name: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var status: String?

            public var tags: DescribeHaVipsResponseBody.HaVips.HaVip.Tags?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedEipAddresses?.validate()
                try self.associatedInstances?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedEipAddresses != nil {
                    map["AssociatedEipAddresses"] = self.associatedEipAddresses?.toMap()
                }
                if self.associatedInstanceType != nil {
                    map["AssociatedInstanceType"] = self.associatedInstanceType!
                }
                if self.associatedInstances != nil {
                    map["AssociatedInstances"] = self.associatedInstances?.toMap()
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.haVipId != nil {
                    map["HaVipId"] = self.haVipId!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.masterInstanceId != nil {
                    map["MasterInstanceId"] = self.masterInstanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssociatedEipAddresses"] as? [String: Any?] {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedEipAddresses()
                    model.fromMap(value)
                    self.associatedEipAddresses = model
                }
                if let value = dict["AssociatedInstanceType"] as? String {
                    self.associatedInstanceType = value
                }
                if let value = dict["AssociatedInstances"] as? [String: Any?] {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedInstances()
                    model.fromMap(value)
                    self.associatedInstances = model
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["HaVipId"] as? String {
                    self.haVipId = value
                }
                if let value = dict["IpAddress"] as? String {
                    self.ipAddress = value
                }
                if let value = dict["MasterInstanceId"] as? String {
                    self.masterInstanceId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var haVip: [DescribeHaVipsResponseBody.HaVips.HaVip]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.haVip != nil {
                var tmp : [Any] = []
                for k in self.haVip! {
                    tmp.append(k.toMap())
                }
                map["HaVip"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HaVip"] as? [Any?] {
                var tmp : [DescribeHaVipsResponseBody.HaVips.HaVip] = []
                for v in value {
                    if v != nil {
                        var model = DescribeHaVipsResponseBody.HaVips.HaVip()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.haVip = tmp
            }
        }
    }
    public var haVips: DescribeHaVipsResponseBody.HaVips?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.haVips?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVips != nil {
            map["HaVips"] = self.haVips?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HaVips"] as? [String: Any?] {
            var model = DescribeHaVipsResponseBody.HaVips()
            model.fromMap(value)
            self.haVips = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeHaVipsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHaVipsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHaVipsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHighDefinitionMonitorLogAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeHighDefinitionMonitorLogAttributeResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var logProject: String?

    public var logStore: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.logProject != nil {
            map["LogProject"] = self.logProject!
        }
        if self.logStore != nil {
            map["LogStore"] = self.logStore!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["LogProject"] as? String {
            self.logProject = value
        }
        if let value = dict["LogStore"] as? String {
            self.logStore = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DescribeHighDefinitionMonitorLogAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHighDefinitionMonitorLogAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHighDefinitionMonitorLogAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIPv6TranslatorAclListAttributesRequest : Tea.TeaModel {
    public var aclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeIPv6TranslatorAclListAttributesResponseBody : Tea.TeaModel {
    public class AclEntries : Tea.TeaModel {
        public class AclEntry : Tea.TeaModel {
            public var aclEntryComment: String?

            public var aclEntryId: String?

            public var aclEntryIp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclEntryComment != nil {
                    map["AclEntryComment"] = self.aclEntryComment!
                }
                if self.aclEntryId != nil {
                    map["AclEntryId"] = self.aclEntryId!
                }
                if self.aclEntryIp != nil {
                    map["AclEntryIp"] = self.aclEntryIp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AclEntryComment"] as? String {
                    self.aclEntryComment = value
                }
                if let value = dict["AclEntryId"] as? String {
                    self.aclEntryId = value
                }
                if let value = dict["AclEntryIp"] as? String {
                    self.aclEntryIp = value
                }
            }
        }
        public var aclEntry: [DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries.AclEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclEntry != nil {
                var tmp : [Any] = []
                for k in self.aclEntry! {
                    tmp.append(k.toMap())
                }
                map["AclEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AclEntry"] as? [Any?] {
                var tmp : [DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries.AclEntry] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries.AclEntry()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.aclEntry = tmp
            }
        }
    }
    public var aclEntries: DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries?

    public var aclId: String?

    public var aclName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aclEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntries != nil {
            map["AclEntries"] = self.aclEntries?.toMap()
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclEntries"] as? [String: Any?] {
            var model = DescribeIPv6TranslatorAclListAttributesResponseBody.AclEntries()
            model.fromMap(value)
            self.aclEntries = model
        }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["AclName"] as? String {
            self.aclName = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeIPv6TranslatorAclListAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIPv6TranslatorAclListAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIPv6TranslatorAclListAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIPv6TranslatorAclListsRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["AclName"] as? String {
            self.aclName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeIPv6TranslatorAclListsResponseBody : Tea.TeaModel {
    public class Ipv6TranslatorAcls : Tea.TeaModel {
        public class IPv6TranslatorAcl : Tea.TeaModel {
            public var aclId: String?

            public var aclName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclId != nil {
                    map["AclId"] = self.aclId!
                }
                if self.aclName != nil {
                    map["AclName"] = self.aclName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AclId"] as? String {
                    self.aclId = value
                }
                if let value = dict["AclName"] as? String {
                    self.aclName = value
                }
            }
        }
        public var IPv6TranslatorAcl: [DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls.IPv6TranslatorAcl]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IPv6TranslatorAcl != nil {
                var tmp : [Any] = []
                for k in self.IPv6TranslatorAcl! {
                    tmp.append(k.toMap())
                }
                map["IPv6TranslatorAcl"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IPv6TranslatorAcl"] as? [Any?] {
                var tmp : [DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls.IPv6TranslatorAcl] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls.IPv6TranslatorAcl()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.IPv6TranslatorAcl = tmp
            }
        }
    }
    public var ipv6TranslatorAcls: DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6TranslatorAcls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6TranslatorAcls != nil {
            map["Ipv6TranslatorAcls"] = self.ipv6TranslatorAcls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6TranslatorAcls"] as? [String: Any?] {
            var model = DescribeIPv6TranslatorAclListsResponseBody.Ipv6TranslatorAcls()
            model.fromMap(value)
            self.ipv6TranslatorAcls = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeIPv6TranslatorAclListsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIPv6TranslatorAclListsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIPv6TranslatorAclListsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIPv6TranslatorEntriesRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclStatus: String?

    public var aclType: String?

    public var allocateIpv6Addr: String?

    public var allocateIpv6Port: Int32?

    public var backendIpv4Addr: String?

    public var backendIpv4Port: Int32?

    public var clientToken: String?

    public var entryName: String?

    public var ipv6TranslatorEntryId: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var transProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclStatus != nil {
            map["AclStatus"] = self.aclStatus!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.allocateIpv6Addr != nil {
            map["AllocateIpv6Addr"] = self.allocateIpv6Addr!
        }
        if self.allocateIpv6Port != nil {
            map["AllocateIpv6Port"] = self.allocateIpv6Port!
        }
        if self.backendIpv4Addr != nil {
            map["BackendIpv4Addr"] = self.backendIpv4Addr!
        }
        if self.backendIpv4Port != nil {
            map["BackendIpv4Port"] = self.backendIpv4Port!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.entryName != nil {
            map["EntryName"] = self.entryName!
        }
        if self.ipv6TranslatorEntryId != nil {
            map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.transProtocol != nil {
            map["TransProtocol"] = self.transProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["AclStatus"] as? String {
            self.aclStatus = value
        }
        if let value = dict["AclType"] as? String {
            self.aclType = value
        }
        if let value = dict["AllocateIpv6Addr"] as? String {
            self.allocateIpv6Addr = value
        }
        if let value = dict["AllocateIpv6Port"] as? Int32 {
            self.allocateIpv6Port = value
        }
        if let value = dict["BackendIpv4Addr"] as? String {
            self.backendIpv4Addr = value
        }
        if let value = dict["BackendIpv4Port"] as? Int32 {
            self.backendIpv4Port = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EntryName"] as? String {
            self.entryName = value
        }
        if let value = dict["Ipv6TranslatorEntryId"] as? String {
            self.ipv6TranslatorEntryId = value
        }
        if let value = dict["Ipv6TranslatorId"] as? String {
            self.ipv6TranslatorId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TransProtocol"] as? String {
            self.transProtocol = value
        }
    }
}

public class DescribeIPv6TranslatorEntriesResponseBody : Tea.TeaModel {
    public class Ipv6TranslatorEntries : Tea.TeaModel {
        public class Ipv6TranslatorEntry : Tea.TeaModel {
            public var aclId: String?

            public var aclStatus: String?

            public var aclType: String?

            public var allocateIpv6Addr: String?

            public var allocateIpv6Port: Int32?

            public var backendIpv4Addr: String?

            public var backendIpv4Port: String?

            public var entryBandwidth: String?

            public var entryDescription: String?

            public var entryName: String?

            public var entryStatus: String?

            public var ipv6TranslatorEntryId: String?

            public var ipv6TranslatorId: String?

            public var regionId: String?

            public var transProtocol: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclId != nil {
                    map["AclId"] = self.aclId!
                }
                if self.aclStatus != nil {
                    map["AclStatus"] = self.aclStatus!
                }
                if self.aclType != nil {
                    map["AclType"] = self.aclType!
                }
                if self.allocateIpv6Addr != nil {
                    map["AllocateIpv6Addr"] = self.allocateIpv6Addr!
                }
                if self.allocateIpv6Port != nil {
                    map["AllocateIpv6Port"] = self.allocateIpv6Port!
                }
                if self.backendIpv4Addr != nil {
                    map["BackendIpv4Addr"] = self.backendIpv4Addr!
                }
                if self.backendIpv4Port != nil {
                    map["BackendIpv4Port"] = self.backendIpv4Port!
                }
                if self.entryBandwidth != nil {
                    map["EntryBandwidth"] = self.entryBandwidth!
                }
                if self.entryDescription != nil {
                    map["EntryDescription"] = self.entryDescription!
                }
                if self.entryName != nil {
                    map["EntryName"] = self.entryName!
                }
                if self.entryStatus != nil {
                    map["EntryStatus"] = self.entryStatus!
                }
                if self.ipv6TranslatorEntryId != nil {
                    map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
                }
                if self.ipv6TranslatorId != nil {
                    map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.transProtocol != nil {
                    map["TransProtocol"] = self.transProtocol!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AclId"] as? String {
                    self.aclId = value
                }
                if let value = dict["AclStatus"] as? String {
                    self.aclStatus = value
                }
                if let value = dict["AclType"] as? String {
                    self.aclType = value
                }
                if let value = dict["AllocateIpv6Addr"] as? String {
                    self.allocateIpv6Addr = value
                }
                if let value = dict["AllocateIpv6Port"] as? Int32 {
                    self.allocateIpv6Port = value
                }
                if let value = dict["BackendIpv4Addr"] as? String {
                    self.backendIpv4Addr = value
                }
                if let value = dict["BackendIpv4Port"] as? String {
                    self.backendIpv4Port = value
                }
                if let value = dict["EntryBandwidth"] as? String {
                    self.entryBandwidth = value
                }
                if let value = dict["EntryDescription"] as? String {
                    self.entryDescription = value
                }
                if let value = dict["EntryName"] as? String {
                    self.entryName = value
                }
                if let value = dict["EntryStatus"] as? String {
                    self.entryStatus = value
                }
                if let value = dict["Ipv6TranslatorEntryId"] as? String {
                    self.ipv6TranslatorEntryId = value
                }
                if let value = dict["Ipv6TranslatorId"] as? String {
                    self.ipv6TranslatorId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["TransProtocol"] as? String {
                    self.transProtocol = value
                }
            }
        }
        public var ipv6TranslatorEntry: [DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries.Ipv6TranslatorEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6TranslatorEntry != nil {
                var tmp : [Any] = []
                for k in self.ipv6TranslatorEntry! {
                    tmp.append(k.toMap())
                }
                map["Ipv6TranslatorEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6TranslatorEntry"] as? [Any?] {
                var tmp : [DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries.Ipv6TranslatorEntry] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries.Ipv6TranslatorEntry()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6TranslatorEntry = tmp
            }
        }
    }
    public var ipv6TranslatorEntries: DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6TranslatorEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6TranslatorEntries != nil {
            map["Ipv6TranslatorEntries"] = self.ipv6TranslatorEntries?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6TranslatorEntries"] as? [String: Any?] {
            var model = DescribeIPv6TranslatorEntriesResponseBody.Ipv6TranslatorEntries()
            model.fromMap(value)
            self.ipv6TranslatorEntries = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeIPv6TranslatorEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIPv6TranslatorEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIPv6TranslatorEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIPv6TranslatorsRequest : Tea.TeaModel {
    public var allocateIpv4Addr: String?

    public var allocateIpv6Addr: String?

    public var businessStatus: String?

    public var ipv6TranslatorId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var payType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocateIpv4Addr != nil {
            map["AllocateIpv4Addr"] = self.allocateIpv4Addr!
        }
        if self.allocateIpv6Addr != nil {
            map["AllocateIpv6Addr"] = self.allocateIpv6Addr!
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocateIpv4Addr"] as? String {
            self.allocateIpv4Addr = value
        }
        if let value = dict["AllocateIpv6Addr"] as? String {
            self.allocateIpv6Addr = value
        }
        if let value = dict["BusinessStatus"] as? String {
            self.businessStatus = value
        }
        if let value = dict["Ipv6TranslatorId"] as? String {
            self.ipv6TranslatorId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeIPv6TranslatorsResponseBody : Tea.TeaModel {
    public class Ipv6Translators : Tea.TeaModel {
        public class Ipv6Translator : Tea.TeaModel {
            public class Ipv6TranslatorEntryIds : Tea.TeaModel {
                public var ipv6TranslatorEntryId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6TranslatorEntryId != nil {
                        map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ipv6TranslatorEntryId"] as? [String] {
                        self.ipv6TranslatorEntryId = value
                    }
                }
            }
            public var allocateIpv4Addr: String?

            public var allocateIpv6Addr: String?

            public var availableBandwidth: String?

            public var bandwidth: Int32?

            public var businessStatus: String?

            public var createTime: Int64?

            public var description_: String?

            public var endTime: Int64?

            public var ipv6TranslatorEntryIds: DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator.Ipv6TranslatorEntryIds?

            public var ipv6TranslatorId: String?

            public var name: String?

            public var payType: String?

            public var regionId: String?

            public var spec: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ipv6TranslatorEntryIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocateIpv4Addr != nil {
                    map["AllocateIpv4Addr"] = self.allocateIpv4Addr!
                }
                if self.allocateIpv6Addr != nil {
                    map["AllocateIpv6Addr"] = self.allocateIpv6Addr!
                }
                if self.availableBandwidth != nil {
                    map["AvailableBandwidth"] = self.availableBandwidth!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.ipv6TranslatorEntryIds != nil {
                    map["Ipv6TranslatorEntryIds"] = self.ipv6TranslatorEntryIds?.toMap()
                }
                if self.ipv6TranslatorId != nil {
                    map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocateIpv4Addr"] as? String {
                    self.allocateIpv4Addr = value
                }
                if let value = dict["AllocateIpv6Addr"] as? String {
                    self.allocateIpv6Addr = value
                }
                if let value = dict["AvailableBandwidth"] as? String {
                    self.availableBandwidth = value
                }
                if let value = dict["Bandwidth"] as? Int32 {
                    self.bandwidth = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EndTime"] as? Int64 {
                    self.endTime = value
                }
                if let value = dict["Ipv6TranslatorEntryIds"] as? [String: Any?] {
                    var model = DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator.Ipv6TranslatorEntryIds()
                    model.fromMap(value)
                    self.ipv6TranslatorEntryIds = model
                }
                if let value = dict["Ipv6TranslatorId"] as? String {
                    self.ipv6TranslatorId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["PayType"] as? String {
                    self.payType = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Spec"] as? String {
                    self.spec = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var ipv6Translator: [DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Translator != nil {
                var tmp : [Any] = []
                for k in self.ipv6Translator! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Translator"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6Translator"] as? [Any?] {
                var tmp : [DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIPv6TranslatorsResponseBody.Ipv6Translators.Ipv6Translator()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6Translator = tmp
            }
        }
    }
    public var ipv6Translators: DescribeIPv6TranslatorsResponseBody.Ipv6Translators?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6Translators?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Translators != nil {
            map["Ipv6Translators"] = self.ipv6Translators?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6Translators"] as? [String: Any?] {
            var model = DescribeIPv6TranslatorsResponseBody.Ipv6Translators()
            model.fromMap(value)
            self.ipv6Translators = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeIPv6TranslatorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIPv6TranslatorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIPv6TranslatorsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIpv6AddressesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var addressType: String?

    public var associatedInstanceId: String?

    public var associatedInstanceType: String?

    public var includeReservationData: Bool?

    public var ipv6Address: String?

    public var ipv6AddressId: String?

    public var ipv6InternetBandwidthId: String?

    public var name: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceManaged: Bool?

    public var tag: [DescribeIpv6AddressesRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressType != nil {
            map["AddressType"] = self.addressType!
        }
        if self.associatedInstanceId != nil {
            map["AssociatedInstanceId"] = self.associatedInstanceId!
        }
        if self.associatedInstanceType != nil {
            map["AssociatedInstanceType"] = self.associatedInstanceType!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ipv6InternetBandwidthId != nil {
            map["Ipv6InternetBandwidthId"] = self.ipv6InternetBandwidthId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressType"] as? String {
            self.addressType = value
        }
        if let value = dict["AssociatedInstanceId"] as? String {
            self.associatedInstanceId = value
        }
        if let value = dict["AssociatedInstanceType"] as? String {
            self.associatedInstanceType = value
        }
        if let value = dict["IncludeReservationData"] as? Bool {
            self.includeReservationData = value
        }
        if let value = dict["Ipv6Address"] as? String {
            self.ipv6Address = value
        }
        if let value = dict["Ipv6AddressId"] as? String {
            self.ipv6AddressId = value
        }
        if let value = dict["Ipv6InternetBandwidthId"] as? String {
            self.ipv6InternetBandwidthId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServiceManaged"] as? Bool {
            self.serviceManaged = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeIpv6AddressesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeIpv6AddressesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeIpv6AddressesResponseBody : Tea.TeaModel {
    public class Ipv6Addresses : Tea.TeaModel {
        public class Ipv6Address : Tea.TeaModel {
            public class Ipv6InternetBandwidth : Tea.TeaModel {
                public var bandwidth: Int32?

                public var businessStatus: String?

                public var hasReservationData: Bool?

                public var instanceChargeType: String?

                public var internetChargeType: String?

                public var ipv6InternetBandwidthId: String?

                public var reservationActiveTime: String?

                public var reservationBandwidth: Int64?

                public var reservationInternetChargeType: String?

                public var reservationOrderType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandwidth != nil {
                        map["Bandwidth"] = self.bandwidth!
                    }
                    if self.businessStatus != nil {
                        map["BusinessStatus"] = self.businessStatus!
                    }
                    if self.hasReservationData != nil {
                        map["HasReservationData"] = self.hasReservationData!
                    }
                    if self.instanceChargeType != nil {
                        map["InstanceChargeType"] = self.instanceChargeType!
                    }
                    if self.internetChargeType != nil {
                        map["InternetChargeType"] = self.internetChargeType!
                    }
                    if self.ipv6InternetBandwidthId != nil {
                        map["Ipv6InternetBandwidthId"] = self.ipv6InternetBandwidthId!
                    }
                    if self.reservationActiveTime != nil {
                        map["ReservationActiveTime"] = self.reservationActiveTime!
                    }
                    if self.reservationBandwidth != nil {
                        map["ReservationBandwidth"] = self.reservationBandwidth!
                    }
                    if self.reservationInternetChargeType != nil {
                        map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                    }
                    if self.reservationOrderType != nil {
                        map["ReservationOrderType"] = self.reservationOrderType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Bandwidth"] as? Int32 {
                        self.bandwidth = value
                    }
                    if let value = dict["BusinessStatus"] as? String {
                        self.businessStatus = value
                    }
                    if let value = dict["HasReservationData"] as? Bool {
                        self.hasReservationData = value
                    }
                    if let value = dict["InstanceChargeType"] as? String {
                        self.instanceChargeType = value
                    }
                    if let value = dict["InternetChargeType"] as? String {
                        self.internetChargeType = value
                    }
                    if let value = dict["Ipv6InternetBandwidthId"] as? String {
                        self.ipv6InternetBandwidthId = value
                    }
                    if let value = dict["ReservationActiveTime"] as? String {
                        self.reservationActiveTime = value
                    }
                    if let value = dict["ReservationBandwidth"] as? Int64 {
                        self.reservationBandwidth = value
                    }
                    if let value = dict["ReservationInternetChargeType"] as? String {
                        self.reservationInternetChargeType = value
                    }
                    if let value = dict["ReservationOrderType"] as? String {
                        self.reservationOrderType = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var addressType: String?

            public var allocationTime: String?

            public var associatedInstanceId: String?

            public var associatedInstanceType: String?

            public var ipv6Address: String?

            public var ipv6AddressDescription: String?

            public var ipv6AddressId: String?

            public var ipv6AddressName: String?

            public var ipv6GatewayId: String?

            public var ipv6InternetBandwidth: DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Ipv6InternetBandwidth?

            public var ipv6Isp: String?

            public var networkType: String?

            public var realBandwidth: Int32?

            public var resourceGroupId: String?

            public var serviceManaged: Int32?

            public var status: String?

            public var tags: DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ipv6InternetBandwidth?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressType != nil {
                    map["AddressType"] = self.addressType!
                }
                if self.allocationTime != nil {
                    map["AllocationTime"] = self.allocationTime!
                }
                if self.associatedInstanceId != nil {
                    map["AssociatedInstanceId"] = self.associatedInstanceId!
                }
                if self.associatedInstanceType != nil {
                    map["AssociatedInstanceType"] = self.associatedInstanceType!
                }
                if self.ipv6Address != nil {
                    map["Ipv6Address"] = self.ipv6Address!
                }
                if self.ipv6AddressDescription != nil {
                    map["Ipv6AddressDescription"] = self.ipv6AddressDescription!
                }
                if self.ipv6AddressId != nil {
                    map["Ipv6AddressId"] = self.ipv6AddressId!
                }
                if self.ipv6AddressName != nil {
                    map["Ipv6AddressName"] = self.ipv6AddressName!
                }
                if self.ipv6GatewayId != nil {
                    map["Ipv6GatewayId"] = self.ipv6GatewayId!
                }
                if self.ipv6InternetBandwidth != nil {
                    map["Ipv6InternetBandwidth"] = self.ipv6InternetBandwidth?.toMap()
                }
                if self.ipv6Isp != nil {
                    map["Ipv6Isp"] = self.ipv6Isp!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.realBandwidth != nil {
                    map["RealBandwidth"] = self.realBandwidth!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddressType"] as? String {
                    self.addressType = value
                }
                if let value = dict["AllocationTime"] as? String {
                    self.allocationTime = value
                }
                if let value = dict["AssociatedInstanceId"] as? String {
                    self.associatedInstanceId = value
                }
                if let value = dict["AssociatedInstanceType"] as? String {
                    self.associatedInstanceType = value
                }
                if let value = dict["Ipv6Address"] as? String {
                    self.ipv6Address = value
                }
                if let value = dict["Ipv6AddressDescription"] as? String {
                    self.ipv6AddressDescription = value
                }
                if let value = dict["Ipv6AddressId"] as? String {
                    self.ipv6AddressId = value
                }
                if let value = dict["Ipv6AddressName"] as? String {
                    self.ipv6AddressName = value
                }
                if let value = dict["Ipv6GatewayId"] as? String {
                    self.ipv6GatewayId = value
                }
                if let value = dict["Ipv6InternetBandwidth"] as? [String: Any?] {
                    var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Ipv6InternetBandwidth()
                    model.fromMap(value)
                    self.ipv6InternetBandwidth = model
                }
                if let value = dict["Ipv6Isp"] as? String {
                    self.ipv6Isp = value
                }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["RealBandwidth"] as? Int32 {
                    self.realBandwidth = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["ServiceManaged"] as? Int32 {
                    self.serviceManaged = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var ipv6Address: [DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Address != nil {
                var tmp : [Any] = []
                for k in self.ipv6Address! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Address"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6Address"] as? [Any?] {
                var tmp : [DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses.Ipv6Address()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6Address = tmp
            }
        }
    }
    public var ipv6Addresses: DescribeIpv6AddressesResponseBody.Ipv6Addresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6Addresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Addresses != nil {
            map["Ipv6Addresses"] = self.ipv6Addresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6Addresses"] as? [String: Any?] {
            var model = DescribeIpv6AddressesResponseBody.Ipv6Addresses()
            model.fromMap(value)
            self.ipv6Addresses = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeIpv6AddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpv6AddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIpv6AddressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIpv6EgressOnlyRulesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var ipv6EgressOnlyRuleId: String?

    public var ipv6GatewayId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ipv6EgressOnlyRuleId != nil {
            map["Ipv6EgressOnlyRuleId"] = self.ipv6EgressOnlyRuleId!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["Ipv6EgressOnlyRuleId"] as? String {
            self.ipv6EgressOnlyRuleId = value
        }
        if let value = dict["Ipv6GatewayId"] as? String {
            self.ipv6GatewayId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeIpv6EgressOnlyRulesResponseBody : Tea.TeaModel {
    public class Ipv6EgressOnlyRules : Tea.TeaModel {
        public class Ipv6EgressOnlyRule : Tea.TeaModel {
            public var description_: String?

            public var instanceId: String?

            public var instanceType: String?

            public var ipv6EgressOnlyRuleId: String?

            public var name: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ipv6EgressOnlyRuleId != nil {
                    map["Ipv6EgressOnlyRuleId"] = self.ipv6EgressOnlyRuleId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["Ipv6EgressOnlyRuleId"] as? String {
                    self.ipv6EgressOnlyRuleId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var ipv6EgressOnlyRule: [DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules.Ipv6EgressOnlyRule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6EgressOnlyRule != nil {
                var tmp : [Any] = []
                for k in self.ipv6EgressOnlyRule! {
                    tmp.append(k.toMap())
                }
                map["Ipv6EgressOnlyRule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6EgressOnlyRule"] as? [Any?] {
                var tmp : [DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules.Ipv6EgressOnlyRule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules.Ipv6EgressOnlyRule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6EgressOnlyRule = tmp
            }
        }
    }
    public var ipv6EgressOnlyRules: DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6EgressOnlyRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6EgressOnlyRules != nil {
            map["Ipv6EgressOnlyRules"] = self.ipv6EgressOnlyRules?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6EgressOnlyRules"] as? [String: Any?] {
            var model = DescribeIpv6EgressOnlyRulesResponseBody.Ipv6EgressOnlyRules()
            model.fromMap(value)
            self.ipv6EgressOnlyRules = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeIpv6EgressOnlyRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpv6EgressOnlyRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIpv6EgressOnlyRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIpv6GatewayAttributeRequest : Tea.TeaModel {
    public var ipv6GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6GatewayId"] as? String {
            self.ipv6GatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeIpv6GatewayAttributeResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var tag: [DescribeIpv6GatewayAttributeResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeIpv6GatewayAttributeResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIpv6GatewayAttributeResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public var businessStatus: String?

    public var creationTime: String?

    public var description_: String?

    public var expiredTime: String?

    public var gatewayRouteTableId: String?

    public var instanceChargeType: String?

    public var ipv6GatewayId: String?

    public var name: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var status: String?

    public var tags: DescribeIpv6GatewayAttributeResponseBody.Tags?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.gatewayRouteTableId != nil {
            map["GatewayRouteTableId"] = self.gatewayRouteTableId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessStatus"] as? String {
            self.businessStatus = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExpiredTime"] as? String {
            self.expiredTime = value
        }
        if let value = dict["GatewayRouteTableId"] as? String {
            self.gatewayRouteTableId = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["Ipv6GatewayId"] as? String {
            self.ipv6GatewayId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeIpv6GatewayAttributeResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeIpv6GatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpv6GatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIpv6GatewayAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIpv6GatewaysRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ipv6GatewayId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribeIpv6GatewaysRequest.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6GatewayId"] as? String {
            self.ipv6GatewayId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeIpv6GatewaysRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeIpv6GatewaysRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeIpv6GatewaysResponseBody : Tea.TeaModel {
    public class Ipv6Gateways : Tea.TeaModel {
        public class Ipv6Gateway : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var businessStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var expiredTime: String?

            public var instanceChargeType: String?

            public var ipv6GatewayId: String?

            public var name: String?

            public var ownerId: Int64?

            public var regionId: String?

            public var resourceGroupId: String?

            public var status: String?

            public var tags: DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.ipv6GatewayId != nil {
                    map["Ipv6GatewayId"] = self.ipv6GatewayId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["Ipv6GatewayId"] as? String {
                    self.ipv6GatewayId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["OwnerId"] as? Int64 {
                    self.ownerId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var ipv6Gateway: [DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Gateway != nil {
                var tmp : [Any] = []
                for k in self.ipv6Gateway! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Gateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6Gateway"] as? [Any?] {
                var tmp : [DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIpv6GatewaysResponseBody.Ipv6Gateways.Ipv6Gateway()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6Gateway = tmp
            }
        }
    }
    public var ipv6Gateways: DescribeIpv6GatewaysResponseBody.Ipv6Gateways?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6Gateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Gateways != nil {
            map["Ipv6Gateways"] = self.ipv6Gateways?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6Gateways"] as? [String: Any?] {
            var model = DescribeIpv6GatewaysResponseBody.Ipv6Gateways()
            model.fromMap(value)
            self.ipv6Gateways = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeIpv6GatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpv6GatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIpv6GatewaysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNatGatewayAssociateNetworkInterfacesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var filter: [DescribeNatGatewayAssociateNetworkInterfacesRequest.Filter]?

    public var maxResults: Int32?

    public var natGatewayId: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeNatGatewayAssociateNetworkInterfacesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeNatGatewayAssociateNetworkInterfacesRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeNatGatewayAssociateNetworkInterfacesRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeNatGatewayAssociateNetworkInterfacesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeNatGatewayAssociateNetworkInterfacesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeNatGatewayAssociateNetworkInterfacesResponseBody : Tea.TeaModel {
    public class AssociateNetworkInterfaces : Tea.TeaModel {
        public class AssociateNetworkInterface : Tea.TeaModel {
            public class IPv4Sets : Tea.TeaModel {
                public class IPv4Set : Tea.TeaModel {
                    public var IPv4Address: String?

                    public var primary: Bool?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.IPv4Address != nil {
                            map["IPv4Address"] = self.IPv4Address!
                        }
                        if self.primary != nil {
                            map["Primary"] = self.primary!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["IPv4Address"] as? String {
                            self.IPv4Address = value
                        }
                        if let value = dict["Primary"] as? Bool {
                            self.primary = value
                        }
                    }
                }
                public var IPv4Set: [DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets.IPv4Set]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.IPv4Set != nil {
                        var tmp : [Any] = []
                        for k in self.IPv4Set! {
                            tmp.append(k.toMap())
                        }
                        map["IPv4Set"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IPv4Set"] as? [Any?] {
                        var tmp : [DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets.IPv4Set] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets.IPv4Set()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.IPv4Set = tmp
                    }
                }
            }
            public var IPv4Sets: DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets?

            public var networkInterfaceId: String?

            public var resourceId: String?

            public var resourceOwnerId: String?

            public var resourceType: String?

            public var resourceVpcId: String?

            public var tunnelIndex: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.IPv4Sets?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.IPv4Sets != nil {
                    map["IPv4Sets"] = self.IPv4Sets?.toMap()
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceOwnerId != nil {
                    map["ResourceOwnerId"] = self.resourceOwnerId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.resourceVpcId != nil {
                    map["ResourceVpcId"] = self.resourceVpcId!
                }
                if self.tunnelIndex != nil {
                    map["TunnelIndex"] = self.tunnelIndex!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IPv4Sets"] as? [String: Any?] {
                    var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface.IPv4Sets()
                    model.fromMap(value)
                    self.IPv4Sets = model
                }
                if let value = dict["NetworkInterfaceId"] as? String {
                    self.networkInterfaceId = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceOwnerId"] as? String {
                    self.resourceOwnerId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["ResourceVpcId"] as? String {
                    self.resourceVpcId = value
                }
                if let value = dict["TunnelIndex"] as? String {
                    self.tunnelIndex = value
                }
            }
        }
        public var associateNetworkInterface: [DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associateNetworkInterface != nil {
                var tmp : [Any] = []
                for k in self.associateNetworkInterface! {
                    tmp.append(k.toMap())
                }
                map["AssociateNetworkInterface"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssociateNetworkInterface"] as? [Any?] {
                var tmp : [DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces.AssociateNetworkInterface()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.associateNetworkInterface = tmp
            }
        }
    }
    public var associateNetworkInterfaces: DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces?

    public var count: Int32?

    public var maxResults: Int32?

    public var natGatewayId: String?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.associateNetworkInterfaces?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associateNetworkInterfaces != nil {
            map["AssociateNetworkInterfaces"] = self.associateNetworkInterfaces?.toMap()
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AssociateNetworkInterfaces"] as? [String: Any?] {
            var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody.AssociateNetworkInterfaces()
            model.fromMap(value)
            self.associateNetworkInterfaces = model
        }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeNatGatewayAssociateNetworkInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNatGatewayAssociateNetworkInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNatGatewayAssociateNetworkInterfacesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNatGatewaysRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dryRun: Bool?

    public var instanceChargeType: String?

    public var name: String?

    public var natGatewayId: String?

    public var natType: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public var status: String?

    public var tag: [DescribeNatGatewaysRequest.Tag]?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatType"] as? String {
            self.natType = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeNatGatewaysRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeNatGatewaysRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeNatGatewaysResponseBody : Tea.TeaModel {
    public class NatGateways : Tea.TeaModel {
        public class NatGateway : Tea.TeaModel {
            public class AccessMode : Tea.TeaModel {
                public var modeValue: String?

                public var tunnelType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.modeValue != nil {
                        map["ModeValue"] = self.modeValue!
                    }
                    if self.tunnelType != nil {
                        map["TunnelType"] = self.tunnelType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ModeValue"] as? String {
                        self.modeValue = value
                    }
                    if let value = dict["TunnelType"] as? String {
                        self.tunnelType = value
                    }
                }
            }
            public class ForwardTableIds : Tea.TeaModel {
                public var forwardTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.forwardTableId != nil {
                        map["ForwardTableId"] = self.forwardTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ForwardTableId"] as? [String] {
                        self.forwardTableId = value
                    }
                }
            }
            public class FullNatTableIds : Tea.TeaModel {
                public var fullNatTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fullNatTableId != nil {
                        map["FullNatTableId"] = self.fullNatTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FullNatTableId"] as? [String] {
                        self.fullNatTableId = value
                    }
                }
            }
            public class IpLists : Tea.TeaModel {
                public class IpList : Tea.TeaModel {
                    public var allocationId: String?

                    public var ipAddress: String?

                    public var privateIpAddress: String?

                    public var snatEntryEnabled: Bool?

                    public var usingStatus: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allocationId != nil {
                            map["AllocationId"] = self.allocationId!
                        }
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        if self.privateIpAddress != nil {
                            map["PrivateIpAddress"] = self.privateIpAddress!
                        }
                        if self.snatEntryEnabled != nil {
                            map["SnatEntryEnabled"] = self.snatEntryEnabled!
                        }
                        if self.usingStatus != nil {
                            map["UsingStatus"] = self.usingStatus!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AllocationId"] as? String {
                            self.allocationId = value
                        }
                        if let value = dict["IpAddress"] as? String {
                            self.ipAddress = value
                        }
                        if let value = dict["PrivateIpAddress"] as? String {
                            self.privateIpAddress = value
                        }
                        if let value = dict["SnatEntryEnabled"] as? Bool {
                            self.snatEntryEnabled = value
                        }
                        if let value = dict["UsingStatus"] as? String {
                            self.usingStatus = value
                        }
                    }
                }
                public var ipList: [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists.IpList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipList != nil {
                        var tmp : [Any] = []
                        for k in self.ipList! {
                            tmp.append(k.toMap())
                        }
                        map["IpList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IpList"] as? [Any?] {
                        var tmp : [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists.IpList] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists.IpList()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ipList = tmp
                    }
                }
            }
            public class IpPrefixList : Tea.TeaModel {
                public class IpPrefixList : Tea.TeaModel {
                    public var ipPrefix: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipPrefix != nil {
                            map["IpPrefix"] = self.ipPrefix!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["IpPrefix"] as? String {
                            self.ipPrefix = value
                        }
                    }
                }
                public var ipPrefixList: [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpPrefixList.IpPrefixList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipPrefixList != nil {
                        var tmp : [Any] = []
                        for k in self.ipPrefixList! {
                            tmp.append(k.toMap())
                        }
                        map["IpPrefixList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IpPrefixList"] as? [Any?] {
                        var tmp : [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpPrefixList.IpPrefixList] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpPrefixList.IpPrefixList()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ipPrefixList = tmp
                    }
                }
            }
            public class NatGatewayPrivateInfo : Tea.TeaModel {
                public var eniInstanceId: String?

                public var eniType: String?

                public var izNo: String?

                public var maxBandwidth: Int32?

                public var maxSessionEstablishRate: Int32?

                public var maxSessionQuota: Int32?

                public var privateIpAddress: String?

                public var vswitchId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eniInstanceId != nil {
                        map["EniInstanceId"] = self.eniInstanceId!
                    }
                    if self.eniType != nil {
                        map["EniType"] = self.eniType!
                    }
                    if self.izNo != nil {
                        map["IzNo"] = self.izNo!
                    }
                    if self.maxBandwidth != nil {
                        map["MaxBandwidth"] = self.maxBandwidth!
                    }
                    if self.maxSessionEstablishRate != nil {
                        map["MaxSessionEstablishRate"] = self.maxSessionEstablishRate!
                    }
                    if self.maxSessionQuota != nil {
                        map["MaxSessionQuota"] = self.maxSessionQuota!
                    }
                    if self.privateIpAddress != nil {
                        map["PrivateIpAddress"] = self.privateIpAddress!
                    }
                    if self.vswitchId != nil {
                        map["VswitchId"] = self.vswitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EniInstanceId"] as? String {
                        self.eniInstanceId = value
                    }
                    if let value = dict["EniType"] as? String {
                        self.eniType = value
                    }
                    if let value = dict["IzNo"] as? String {
                        self.izNo = value
                    }
                    if let value = dict["MaxBandwidth"] as? Int32 {
                        self.maxBandwidth = value
                    }
                    if let value = dict["MaxSessionEstablishRate"] as? Int32 {
                        self.maxSessionEstablishRate = value
                    }
                    if let value = dict["MaxSessionQuota"] as? Int32 {
                        self.maxSessionQuota = value
                    }
                    if let value = dict["PrivateIpAddress"] as? String {
                        self.privateIpAddress = value
                    }
                    if let value = dict["VswitchId"] as? String {
                        self.vswitchId = value
                    }
                }
            }
            public class SnatTableIds : Tea.TeaModel {
                public var snatTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snatTableId != nil {
                        map["SnatTableId"] = self.snatTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SnatTableId"] as? [String] {
                        self.snatTableId = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var accessMode: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.AccessMode?

            public var autoPay: Bool?

            public var businessStatus: String?

            public var creationTime: String?

            public var deletionProtection: Bool?

            public var description_: String?

            public var ecsMetricEnabled: Bool?

            public var eipBindMode: String?

            public var enableSessionLog: String?

            public var expiredTime: String?

            public var forwardTableIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.ForwardTableIds?

            public var fullNatTableIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.FullNatTableIds?

            public var icmpReplyEnabled: Bool?

            public var instanceChargeType: String?

            public var internetChargeType: String?

            public var ipLists: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists?

            public var ipPrefixList: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpPrefixList?

            public var name: String?

            public var natGatewayId: String?

            public var natGatewayPrivateInfo: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.NatGatewayPrivateInfo?

            public var natType: String?

            public var networkType: String?

            public var privateLinkEnabled: Bool?

            public var privateLinkMode: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var securityProtectionEnabled: Bool?

            public var snatTableIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.SnatTableIds?

            public var spec: String?

            public var status: String?

            public var tags: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.accessMode?.validate()
                try self.forwardTableIds?.validate()
                try self.fullNatTableIds?.validate()
                try self.ipLists?.validate()
                try self.ipPrefixList?.validate()
                try self.natGatewayPrivateInfo?.validate()
                try self.snatTableIds?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessMode != nil {
                    map["AccessMode"] = self.accessMode?.toMap()
                }
                if self.autoPay != nil {
                    map["AutoPay"] = self.autoPay!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ecsMetricEnabled != nil {
                    map["EcsMetricEnabled"] = self.ecsMetricEnabled!
                }
                if self.eipBindMode != nil {
                    map["EipBindMode"] = self.eipBindMode!
                }
                if self.enableSessionLog != nil {
                    map["EnableSessionLog"] = self.enableSessionLog!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.forwardTableIds != nil {
                    map["ForwardTableIds"] = self.forwardTableIds?.toMap()
                }
                if self.fullNatTableIds != nil {
                    map["FullNatTableIds"] = self.fullNatTableIds?.toMap()
                }
                if self.icmpReplyEnabled != nil {
                    map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipLists != nil {
                    map["IpLists"] = self.ipLists?.toMap()
                }
                if self.ipPrefixList != nil {
                    map["IpPrefixList"] = self.ipPrefixList?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.natGatewayPrivateInfo != nil {
                    map["NatGatewayPrivateInfo"] = self.natGatewayPrivateInfo?.toMap()
                }
                if self.natType != nil {
                    map["NatType"] = self.natType!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.privateLinkEnabled != nil {
                    map["PrivateLinkEnabled"] = self.privateLinkEnabled!
                }
                if self.privateLinkMode != nil {
                    map["PrivateLinkMode"] = self.privateLinkMode!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityProtectionEnabled != nil {
                    map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
                }
                if self.snatTableIds != nil {
                    map["SnatTableIds"] = self.snatTableIds?.toMap()
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessMode"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.AccessMode()
                    model.fromMap(value)
                    self.accessMode = model
                }
                if let value = dict["AutoPay"] as? Bool {
                    self.autoPay = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DeletionProtection"] as? Bool {
                    self.deletionProtection = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EcsMetricEnabled"] as? Bool {
                    self.ecsMetricEnabled = value
                }
                if let value = dict["EipBindMode"] as? String {
                    self.eipBindMode = value
                }
                if let value = dict["EnableSessionLog"] as? String {
                    self.enableSessionLog = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["ForwardTableIds"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.ForwardTableIds()
                    model.fromMap(value)
                    self.forwardTableIds = model
                }
                if let value = dict["FullNatTableIds"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.FullNatTableIds()
                    model.fromMap(value)
                    self.fullNatTableIds = model
                }
                if let value = dict["IcmpReplyEnabled"] as? Bool {
                    self.icmpReplyEnabled = value
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["InternetChargeType"] as? String {
                    self.internetChargeType = value
                }
                if let value = dict["IpLists"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpLists()
                    model.fromMap(value)
                    self.ipLists = model
                }
                if let value = dict["IpPrefixList"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.IpPrefixList()
                    model.fromMap(value)
                    self.ipPrefixList = model
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NatGatewayId"] as? String {
                    self.natGatewayId = value
                }
                if let value = dict["NatGatewayPrivateInfo"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.NatGatewayPrivateInfo()
                    model.fromMap(value)
                    self.natGatewayPrivateInfo = model
                }
                if let value = dict["NatType"] as? String {
                    self.natType = value
                }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["PrivateLinkEnabled"] as? Bool {
                    self.privateLinkEnabled = value
                }
                if let value = dict["PrivateLinkMode"] as? String {
                    self.privateLinkMode = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SecurityProtectionEnabled"] as? Bool {
                    self.securityProtectionEnabled = value
                }
                if let value = dict["SnatTableIds"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.SnatTableIds()
                    model.fromMap(value)
                    self.snatTableIds = model
                }
                if let value = dict["Spec"] as? String {
                    self.spec = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var natGateway: [DescribeNatGatewaysResponseBody.NatGateways.NatGateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natGateway != nil {
                var tmp : [Any] = []
                for k in self.natGateway! {
                    tmp.append(k.toMap())
                }
                map["NatGateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NatGateway"] as? [Any?] {
                var tmp : [DescribeNatGatewaysResponseBody.NatGateways.NatGateway] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.natGateway = tmp
            }
        }
    }
    public var natGateways: DescribeNatGatewaysResponseBody.NatGateways?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.natGateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGateways != nil {
            map["NatGateways"] = self.natGateways?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NatGateways"] as? [String: Any?] {
            var model = DescribeNatGatewaysResponseBody.NatGateways()
            model.fromMap(value)
            self.natGateways = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeNatGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNatGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNatGatewaysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNetworkAclAttributesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeNetworkAclAttributesResponseBody : Tea.TeaModel {
    public class NetworkAclAttribute : Tea.TeaModel {
        public class EgressAclEntries : Tea.TeaModel {
            public class EgressAclEntry : Tea.TeaModel {
                public var description_: String?

                public var destinationCidrIp: String?

                public var entryType: String?

                public var ipVersion: String?

                public var networkAclEntryId: String?

                public var networkAclEntryName: String?

                public var policy: String?

                public var port: String?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.destinationCidrIp != nil {
                        map["DestinationCidrIp"] = self.destinationCidrIp!
                    }
                    if self.entryType != nil {
                        map["EntryType"] = self.entryType!
                    }
                    if self.ipVersion != nil {
                        map["IpVersion"] = self.ipVersion!
                    }
                    if self.networkAclEntryId != nil {
                        map["NetworkAclEntryId"] = self.networkAclEntryId!
                    }
                    if self.networkAclEntryName != nil {
                        map["NetworkAclEntryName"] = self.networkAclEntryName!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["DestinationCidrIp"] as? String {
                        self.destinationCidrIp = value
                    }
                    if let value = dict["EntryType"] as? String {
                        self.entryType = value
                    }
                    if let value = dict["IpVersion"] as? String {
                        self.ipVersion = value
                    }
                    if let value = dict["NetworkAclEntryId"] as? String {
                        self.networkAclEntryId = value
                    }
                    if let value = dict["NetworkAclEntryName"] as? String {
                        self.networkAclEntryName = value
                    }
                    if let value = dict["Policy"] as? String {
                        self.policy = value
                    }
                    if let value = dict["Port"] as? String {
                        self.port = value
                    }
                    if let value = dict["Protocol"] as? String {
                        self.protocol_ = value
                    }
                }
            }
            public var egressAclEntry: [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.egressAclEntry != nil {
                    var tmp : [Any] = []
                    for k in self.egressAclEntry! {
                        tmp.append(k.toMap())
                    }
                    map["EgressAclEntry"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EgressAclEntry"] as? [Any?] {
                    var tmp : [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries.EgressAclEntry()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.egressAclEntry = tmp
                }
            }
        }
        public class IngressAclEntries : Tea.TeaModel {
            public class IngressAclEntry : Tea.TeaModel {
                public var description_: String?

                public var entryType: String?

                public var ipVersion: String?

                public var networkAclEntryId: String?

                public var networkAclEntryName: String?

                public var policy: String?

                public var port: String?

                public var protocol_: String?

                public var sourceCidrIp: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.entryType != nil {
                        map["EntryType"] = self.entryType!
                    }
                    if self.ipVersion != nil {
                        map["IpVersion"] = self.ipVersion!
                    }
                    if self.networkAclEntryId != nil {
                        map["NetworkAclEntryId"] = self.networkAclEntryId!
                    }
                    if self.networkAclEntryName != nil {
                        map["NetworkAclEntryName"] = self.networkAclEntryName!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    if self.sourceCidrIp != nil {
                        map["SourceCidrIp"] = self.sourceCidrIp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["EntryType"] as? String {
                        self.entryType = value
                    }
                    if let value = dict["IpVersion"] as? String {
                        self.ipVersion = value
                    }
                    if let value = dict["NetworkAclEntryId"] as? String {
                        self.networkAclEntryId = value
                    }
                    if let value = dict["NetworkAclEntryName"] as? String {
                        self.networkAclEntryName = value
                    }
                    if let value = dict["Policy"] as? String {
                        self.policy = value
                    }
                    if let value = dict["Port"] as? String {
                        self.port = value
                    }
                    if let value = dict["Protocol"] as? String {
                        self.protocol_ = value
                    }
                    if let value = dict["SourceCidrIp"] as? String {
                        self.sourceCidrIp = value
                    }
                }
            }
            public var ingressAclEntry: [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ingressAclEntry != nil {
                    var tmp : [Any] = []
                    for k in self.ingressAclEntry! {
                        tmp.append(k.toMap())
                    }
                    map["IngressAclEntry"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IngressAclEntry"] as? [Any?] {
                    var tmp : [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries.IngressAclEntry()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ingressAclEntry = tmp
                }
            }
        }
        public class Resources : Tea.TeaModel {
            public class Resource : Tea.TeaModel {
                public var resourceId: String?

                public var resourceType: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceId != nil {
                        map["ResourceId"] = self.resourceId!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourceId"] as? String {
                        self.resourceId = value
                    }
                    if let value = dict["ResourceType"] as? String {
                        self.resourceType = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public var resource: [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources.Resource]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resource != nil {
                    var tmp : [Any] = []
                    for k in self.resource! {
                        tmp.append(k.toMap())
                    }
                    map["Resource"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Resource"] as? [Any?] {
                    var tmp : [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources.Resource] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources.Resource()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.resource = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public class Tag : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var tag: [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags.Tag]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    var tmp : [Any] = []
                    for k in self.tag! {
                        tmp.append(k.toMap())
                    }
                    map["Tag"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Tag"] as? [Any?] {
                    var tmp : [DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags.Tag] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tag = tmp
                }
            }
        }
        public var creationTime: String?

        public var description_: String?

        public var egressAclEntries: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries?

        public var ingressAclEntries: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries?

        public var networkAclId: String?

        public var networkAclName: String?

        public var ownerId: Int64?

        public var regionId: String?

        public var resources: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources?

        public var status: String?

        public var tags: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.egressAclEntries?.validate()
            try self.ingressAclEntries?.validate()
            try self.resources?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.egressAclEntries != nil {
                map["EgressAclEntries"] = self.egressAclEntries?.toMap()
            }
            if self.ingressAclEntries != nil {
                map["IngressAclEntries"] = self.ingressAclEntries?.toMap()
            }
            if self.networkAclId != nil {
                map["NetworkAclId"] = self.networkAclId!
            }
            if self.networkAclName != nil {
                map["NetworkAclName"] = self.networkAclName!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resources != nil {
                map["Resources"] = self.resources?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EgressAclEntries"] as? [String: Any?] {
                var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.EgressAclEntries()
                model.fromMap(value)
                self.egressAclEntries = model
            }
            if let value = dict["IngressAclEntries"] as? [String: Any?] {
                var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.IngressAclEntries()
                model.fromMap(value)
                self.ingressAclEntries = model
            }
            if let value = dict["NetworkAclId"] as? String {
                self.networkAclId = value
            }
            if let value = dict["NetworkAclName"] as? String {
                self.networkAclName = value
            }
            if let value = dict["OwnerId"] as? Int64 {
                self.ownerId = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["Resources"] as? [String: Any?] {
                var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Resources()
                model.fromMap(value)
                self.resources = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [String: Any?] {
                var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute.Tags()
                model.fromMap(value)
                self.tags = model
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var networkAclAttribute: DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAclAttribute?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclAttribute != nil {
            map["NetworkAclAttribute"] = self.networkAclAttribute?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkAclAttribute"] as? [String: Any?] {
            var model = DescribeNetworkAclAttributesResponseBody.NetworkAclAttribute()
            model.fromMap(value)
            self.networkAclAttribute = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeNetworkAclAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkAclAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNetworkAclAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNetworkAclsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var networkAclId: String?

    public var networkAclName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tags: [DescribeNetworkAclsRequest.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["NetworkAclName"] as? String {
            self.networkAclName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeNetworkAclsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeNetworkAclsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeNetworkAclsResponseBody : Tea.TeaModel {
    public class NetworkAcls : Tea.TeaModel {
        public class NetworkAcl : Tea.TeaModel {
            public class EgressAclEntries : Tea.TeaModel {
                public class EgressAclEntry : Tea.TeaModel {
                    public var description_: String?

                    public var destinationCidrIp: String?

                    public var entryType: String?

                    public var ipVersion: String?

                    public var networkAclEntryId: String?

                    public var networkAclEntryName: String?

                    public var policy: String?

                    public var port: String?

                    public var protocol_: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.destinationCidrIp != nil {
                            map["DestinationCidrIp"] = self.destinationCidrIp!
                        }
                        if self.entryType != nil {
                            map["EntryType"] = self.entryType!
                        }
                        if self.ipVersion != nil {
                            map["IpVersion"] = self.ipVersion!
                        }
                        if self.networkAclEntryId != nil {
                            map["NetworkAclEntryId"] = self.networkAclEntryId!
                        }
                        if self.networkAclEntryName != nil {
                            map["NetworkAclEntryName"] = self.networkAclEntryName!
                        }
                        if self.policy != nil {
                            map["Policy"] = self.policy!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.protocol_ != nil {
                            map["Protocol"] = self.protocol_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Description"] as? String {
                            self.description_ = value
                        }
                        if let value = dict["DestinationCidrIp"] as? String {
                            self.destinationCidrIp = value
                        }
                        if let value = dict["EntryType"] as? String {
                            self.entryType = value
                        }
                        if let value = dict["IpVersion"] as? String {
                            self.ipVersion = value
                        }
                        if let value = dict["NetworkAclEntryId"] as? String {
                            self.networkAclEntryId = value
                        }
                        if let value = dict["NetworkAclEntryName"] as? String {
                            self.networkAclEntryName = value
                        }
                        if let value = dict["Policy"] as? String {
                            self.policy = value
                        }
                        if let value = dict["Port"] as? String {
                            self.port = value
                        }
                        if let value = dict["Protocol"] as? String {
                            self.protocol_ = value
                        }
                    }
                }
                public var egressAclEntry: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries.EgressAclEntry]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.egressAclEntry != nil {
                        var tmp : [Any] = []
                        for k in self.egressAclEntry! {
                            tmp.append(k.toMap())
                        }
                        map["EgressAclEntry"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EgressAclEntry"] as? [Any?] {
                        var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries.EgressAclEntry] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries.EgressAclEntry()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.egressAclEntry = tmp
                    }
                }
            }
            public class IngressAclEntries : Tea.TeaModel {
                public class IngressAclEntry : Tea.TeaModel {
                    public var description_: String?

                    public var entryType: String?

                    public var ipVersion: String?

                    public var networkAclEntryId: String?

                    public var networkAclEntryName: String?

                    public var policy: String?

                    public var port: String?

                    public var protocol_: String?

                    public var sourceCidrIp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.entryType != nil {
                            map["EntryType"] = self.entryType!
                        }
                        if self.ipVersion != nil {
                            map["IpVersion"] = self.ipVersion!
                        }
                        if self.networkAclEntryId != nil {
                            map["NetworkAclEntryId"] = self.networkAclEntryId!
                        }
                        if self.networkAclEntryName != nil {
                            map["NetworkAclEntryName"] = self.networkAclEntryName!
                        }
                        if self.policy != nil {
                            map["Policy"] = self.policy!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.protocol_ != nil {
                            map["Protocol"] = self.protocol_!
                        }
                        if self.sourceCidrIp != nil {
                            map["SourceCidrIp"] = self.sourceCidrIp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Description"] as? String {
                            self.description_ = value
                        }
                        if let value = dict["EntryType"] as? String {
                            self.entryType = value
                        }
                        if let value = dict["IpVersion"] as? String {
                            self.ipVersion = value
                        }
                        if let value = dict["NetworkAclEntryId"] as? String {
                            self.networkAclEntryId = value
                        }
                        if let value = dict["NetworkAclEntryName"] as? String {
                            self.networkAclEntryName = value
                        }
                        if let value = dict["Policy"] as? String {
                            self.policy = value
                        }
                        if let value = dict["Port"] as? String {
                            self.port = value
                        }
                        if let value = dict["Protocol"] as? String {
                            self.protocol_ = value
                        }
                        if let value = dict["SourceCidrIp"] as? String {
                            self.sourceCidrIp = value
                        }
                    }
                }
                public var ingressAclEntry: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries.IngressAclEntry]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ingressAclEntry != nil {
                        var tmp : [Any] = []
                        for k in self.ingressAclEntry! {
                            tmp.append(k.toMap())
                        }
                        map["IngressAclEntry"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IngressAclEntry"] as? [Any?] {
                        var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries.IngressAclEntry] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries.IngressAclEntry()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ingressAclEntry = tmp
                    }
                }
            }
            public class Resources : Tea.TeaModel {
                public class Resource : Tea.TeaModel {
                    public var resourceId: String?

                    public var resourceType: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.resourceId != nil {
                            map["ResourceId"] = self.resourceId!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ResourceId"] as? String {
                            self.resourceId = value
                        }
                        if let value = dict["ResourceType"] as? String {
                            self.resourceType = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                    }
                }
                public var resource: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources.Resource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resource != nil {
                        var tmp : [Any] = []
                        for k in self.resource! {
                            tmp.append(k.toMap())
                        }
                        map["Resource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Resource"] as? [Any?] {
                        var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources.Resource] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources.Resource()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.resource = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var egressAclEntries: DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries?

            public var ingressAclEntries: DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries?

            public var networkAclId: String?

            public var networkAclName: String?

            public var ownerId: Int64?

            public var regionId: String?

            public var resources: DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources?

            public var status: String?

            public var tags: DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.egressAclEntries?.validate()
                try self.ingressAclEntries?.validate()
                try self.resources?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.egressAclEntries != nil {
                    map["EgressAclEntries"] = self.egressAclEntries?.toMap()
                }
                if self.ingressAclEntries != nil {
                    map["IngressAclEntries"] = self.ingressAclEntries?.toMap()
                }
                if self.networkAclId != nil {
                    map["NetworkAclId"] = self.networkAclId!
                }
                if self.networkAclName != nil {
                    map["NetworkAclName"] = self.networkAclName!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resources != nil {
                    map["Resources"] = self.resources?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EgressAclEntries"] as? [String: Any?] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.EgressAclEntries()
                    model.fromMap(value)
                    self.egressAclEntries = model
                }
                if let value = dict["IngressAclEntries"] as? [String: Any?] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.IngressAclEntries()
                    model.fromMap(value)
                    self.ingressAclEntries = model
                }
                if let value = dict["NetworkAclId"] as? String {
                    self.networkAclId = value
                }
                if let value = dict["NetworkAclName"] as? String {
                    self.networkAclName = value
                }
                if let value = dict["OwnerId"] as? Int64 {
                    self.ownerId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Resources"] as? [String: Any?] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Resources()
                    model.fromMap(value)
                    self.resources = model
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var networkAcl: [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkAcl != nil {
                var tmp : [Any] = []
                for k in self.networkAcl! {
                    tmp.append(k.toMap())
                }
                map["NetworkAcl"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NetworkAcl"] as? [Any?] {
                var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNetworkAclsResponseBody.NetworkAcls.NetworkAcl()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.networkAcl = tmp
            }
        }
    }
    public var networkAcls: DescribeNetworkAclsResponseBody.NetworkAcls?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAcls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAcls != nil {
            map["NetworkAcls"] = self.networkAcls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkAcls"] as? [String: Any?] {
            var model = DescribeNetworkAclsResponseBody.NetworkAcls()
            model.fromMap(value)
            self.networkAcls = model
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeNetworkAclsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkAclsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNetworkAclsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePhysicalConnectionLOARequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribePhysicalConnectionLOAResponseBody : Tea.TeaModel {
    public class PhysicalConnectionLOAType : Tea.TeaModel {
        public class PMInfo : Tea.TeaModel {
            public class PMInfo : Tea.TeaModel {
                public var PMCertificateNo: String?

                public var PMCertificateType: String?

                public var PMContactInfo: String?

                public var PMGender: String?

                public var PMName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.PMCertificateNo != nil {
                        map["PMCertificateNo"] = self.PMCertificateNo!
                    }
                    if self.PMCertificateType != nil {
                        map["PMCertificateType"] = self.PMCertificateType!
                    }
                    if self.PMContactInfo != nil {
                        map["PMContactInfo"] = self.PMContactInfo!
                    }
                    if self.PMGender != nil {
                        map["PMGender"] = self.PMGender!
                    }
                    if self.PMName != nil {
                        map["PMName"] = self.PMName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PMCertificateNo"] as? String {
                        self.PMCertificateNo = value
                    }
                    if let value = dict["PMCertificateType"] as? String {
                        self.PMCertificateType = value
                    }
                    if let value = dict["PMContactInfo"] as? String {
                        self.PMContactInfo = value
                    }
                    if let value = dict["PMGender"] as? String {
                        self.PMGender = value
                    }
                    if let value = dict["PMName"] as? String {
                        self.PMName = value
                    }
                }
            }
            public var PMInfo: [DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo.PMInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.PMInfo != nil {
                    var tmp : [Any] = []
                    for k in self.PMInfo! {
                        tmp.append(k.toMap())
                    }
                    map["PMInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PMInfo"] as? [Any?] {
                    var tmp : [DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo.PMInfo] = []
                    for v in value {
                        if v != nil {
                            var model = DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo.PMInfo()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.PMInfo = tmp
                }
            }
        }
        public var companyLocalizedName: String?

        public var companyName: String?

        public var constructionTime: String?

        public var instanceId: String?

        public var lineCode: String?

        public var lineLabel: String?

        public var lineSPContactInfo: String?

        public var lineServiceProvider: String?

        public var lineType: String?

        public var loaUrl: String?

        public var PMInfo: DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo?

        public var SI: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.PMInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.companyLocalizedName != nil {
                map["CompanyLocalizedName"] = self.companyLocalizedName!
            }
            if self.companyName != nil {
                map["CompanyName"] = self.companyName!
            }
            if self.constructionTime != nil {
                map["ConstructionTime"] = self.constructionTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lineCode != nil {
                map["LineCode"] = self.lineCode!
            }
            if self.lineLabel != nil {
                map["LineLabel"] = self.lineLabel!
            }
            if self.lineSPContactInfo != nil {
                map["LineSPContactInfo"] = self.lineSPContactInfo!
            }
            if self.lineServiceProvider != nil {
                map["LineServiceProvider"] = self.lineServiceProvider!
            }
            if self.lineType != nil {
                map["LineType"] = self.lineType!
            }
            if self.loaUrl != nil {
                map["LoaUrl"] = self.loaUrl!
            }
            if self.PMInfo != nil {
                map["PMInfo"] = self.PMInfo?.toMap()
            }
            if self.SI != nil {
                map["SI"] = self.SI!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CompanyLocalizedName"] as? String {
                self.companyLocalizedName = value
            }
            if let value = dict["CompanyName"] as? String {
                self.companyName = value
            }
            if let value = dict["ConstructionTime"] as? String {
                self.constructionTime = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LineCode"] as? String {
                self.lineCode = value
            }
            if let value = dict["LineLabel"] as? String {
                self.lineLabel = value
            }
            if let value = dict["LineSPContactInfo"] as? String {
                self.lineSPContactInfo = value
            }
            if let value = dict["LineServiceProvider"] as? String {
                self.lineServiceProvider = value
            }
            if let value = dict["LineType"] as? String {
                self.lineType = value
            }
            if let value = dict["LoaUrl"] as? String {
                self.loaUrl = value
            }
            if let value = dict["PMInfo"] as? [String: Any?] {
                var model = DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType.PMInfo()
                model.fromMap(value)
                self.PMInfo = model
            }
            if let value = dict["SI"] as? String {
                self.SI = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var physicalConnectionLOAType: DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.physicalConnectionLOAType?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.physicalConnectionLOAType != nil {
            map["PhysicalConnectionLOAType"] = self.physicalConnectionLOAType?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PhysicalConnectionLOAType"] as? [String: Any?] {
            var model = DescribePhysicalConnectionLOAResponseBody.PhysicalConnectionLOAType()
            model.fromMap(value)
            self.physicalConnectionLOAType = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePhysicalConnectionLOAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePhysicalConnectionLOAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePhysicalConnectionLOAResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePhysicalConnectionsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var filter: [DescribePhysicalConnectionsRequest.Filter]?

    public var includeReservationData: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribePhysicalConnectionsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribePhysicalConnectionsRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribePhysicalConnectionsRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["IncludeReservationData"] as? Bool {
            self.includeReservationData = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribePhysicalConnectionsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribePhysicalConnectionsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class DescribePhysicalConnectionsResponseBody : Tea.TeaModel {
    public class PhysicalConnectionSet : Tea.TeaModel {
        public class PhysicalConnectionType : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tags: [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags.Tags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tags != nil {
                        var tmp : [Any] = []
                        for k in self.tags! {
                            tmp.append(k.toMap())
                        }
                        map["tags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["tags"] as? [Any?] {
                        var tmp : [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags.Tags] = []
                        for v in value {
                            if v != nil {
                                var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags.Tags()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tags = tmp
                    }
                }
            }
            public var accessPointId: String?

            public var accessPointType: String?

            public var adDetailLocation: String?

            public var adLocation: String?

            public var bandwidth: Int64?

            public var businessStatus: String?

            public var chargeType: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var description_: String?

            public var enabledTime: String?

            public var endTime: String?

            public var expectSpec: String?

            public var hasReservationData: String?

            public var lineOperator: String?

            public var loaStatus: String?

            public var name: String?

            public var opticalModuleModel: String?

            public var orderMode: String?

            public var parentPhysicalConnectionAliUid: Int64?

            public var parentPhysicalConnectionId: String?

            public var peerLocation: String?

            public var physicalConnectionId: String?

            public var portNumber: String?

            public var portType: String?

            public var productType: String?

            public var qosId: String?

            public var redundantPhysicalConnectionId: String?

            public var reservationActiveTime: String?

            public var reservationInternetChargeType: String?

            public var reservationOrderType: String?

            public var resourceGroupId: String?

            public var spec: String?

            public var status: String?

            public var tags: DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags?

            public var type: String?

            public var virtualPhysicalConnectionCount: Int32?

            public var vlanId: String?

            public var vpconnStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.accessPointType != nil {
                    map["AccessPointType"] = self.accessPointType!
                }
                if self.adDetailLocation != nil {
                    map["AdDetailLocation"] = self.adDetailLocation!
                }
                if self.adLocation != nil {
                    map["AdLocation"] = self.adLocation!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabledTime != nil {
                    map["EnabledTime"] = self.enabledTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.expectSpec != nil {
                    map["ExpectSpec"] = self.expectSpec!
                }
                if self.hasReservationData != nil {
                    map["HasReservationData"] = self.hasReservationData!
                }
                if self.lineOperator != nil {
                    map["LineOperator"] = self.lineOperator!
                }
                if self.loaStatus != nil {
                    map["LoaStatus"] = self.loaStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.opticalModuleModel != nil {
                    map["OpticalModuleModel"] = self.opticalModuleModel!
                }
                if self.orderMode != nil {
                    map["OrderMode"] = self.orderMode!
                }
                if self.parentPhysicalConnectionAliUid != nil {
                    map["ParentPhysicalConnectionAliUid"] = self.parentPhysicalConnectionAliUid!
                }
                if self.parentPhysicalConnectionId != nil {
                    map["ParentPhysicalConnectionId"] = self.parentPhysicalConnectionId!
                }
                if self.peerLocation != nil {
                    map["PeerLocation"] = self.peerLocation!
                }
                if self.physicalConnectionId != nil {
                    map["PhysicalConnectionId"] = self.physicalConnectionId!
                }
                if self.portNumber != nil {
                    map["PortNumber"] = self.portNumber!
                }
                if self.portType != nil {
                    map["PortType"] = self.portType!
                }
                if self.productType != nil {
                    map["ProductType"] = self.productType!
                }
                if self.qosId != nil {
                    map["QosId"] = self.qosId!
                }
                if self.redundantPhysicalConnectionId != nil {
                    map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
                }
                if self.reservationActiveTime != nil {
                    map["ReservationActiveTime"] = self.reservationActiveTime!
                }
                if self.reservationInternetChargeType != nil {
                    map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                }
                if self.reservationOrderType != nil {
                    map["ReservationOrderType"] = self.reservationOrderType!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.virtualPhysicalConnectionCount != nil {
                    map["VirtualPhysicalConnectionCount"] = self.virtualPhysicalConnectionCount!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                if self.vpconnStatus != nil {
                    map["VpconnStatus"] = self.vpconnStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessPointId"] as? String {
                    self.accessPointId = value
                }
                if let value = dict["AccessPointType"] as? String {
                    self.accessPointType = value
                }
                if let value = dict["AdDetailLocation"] as? String {
                    self.adDetailLocation = value
                }
                if let value = dict["AdLocation"] as? String {
                    self.adLocation = value
                }
                if let value = dict["Bandwidth"] as? Int64 {
                    self.bandwidth = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["CircuitCode"] as? String {
                    self.circuitCode = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnabledTime"] as? String {
                    self.enabledTime = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["ExpectSpec"] as? String {
                    self.expectSpec = value
                }
                if let value = dict["HasReservationData"] as? String {
                    self.hasReservationData = value
                }
                if let value = dict["LineOperator"] as? String {
                    self.lineOperator = value
                }
                if let value = dict["LoaStatus"] as? String {
                    self.loaStatus = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["OpticalModuleModel"] as? String {
                    self.opticalModuleModel = value
                }
                if let value = dict["OrderMode"] as? String {
                    self.orderMode = value
                }
                if let value = dict["ParentPhysicalConnectionAliUid"] as? Int64 {
                    self.parentPhysicalConnectionAliUid = value
                }
                if let value = dict["ParentPhysicalConnectionId"] as? String {
                    self.parentPhysicalConnectionId = value
                }
                if let value = dict["PeerLocation"] as? String {
                    self.peerLocation = value
                }
                if let value = dict["PhysicalConnectionId"] as? String {
                    self.physicalConnectionId = value
                }
                if let value = dict["PortNumber"] as? String {
                    self.portNumber = value
                }
                if let value = dict["PortType"] as? String {
                    self.portType = value
                }
                if let value = dict["ProductType"] as? String {
                    self.productType = value
                }
                if let value = dict["QosId"] as? String {
                    self.qosId = value
                }
                if let value = dict["RedundantPhysicalConnectionId"] as? String {
                    self.redundantPhysicalConnectionId = value
                }
                if let value = dict["ReservationActiveTime"] as? String {
                    self.reservationActiveTime = value
                }
                if let value = dict["ReservationInternetChargeType"] as? String {
                    self.reservationInternetChargeType = value
                }
                if let value = dict["ReservationOrderType"] as? String {
                    self.reservationOrderType = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Spec"] as? String {
                    self.spec = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["VirtualPhysicalConnectionCount"] as? Int32 {
                    self.virtualPhysicalConnectionCount = value
                }
                if let value = dict["VlanId"] as? String {
                    self.vlanId = value
                }
                if let value = dict["VpconnStatus"] as? String {
                    self.vpconnStatus = value
                }
            }
        }
        public var physicalConnectionType: [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.physicalConnectionType != nil {
                var tmp : [Any] = []
                for k in self.physicalConnectionType! {
                    tmp.append(k.toMap())
                }
                map["PhysicalConnectionType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PhysicalConnectionType"] as? [Any?] {
                var tmp : [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType] = []
                for v in value {
                    if v != nil {
                        var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.physicalConnectionType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var physicalConnectionSet: DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.physicalConnectionSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.physicalConnectionSet != nil {
            map["PhysicalConnectionSet"] = self.physicalConnectionSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PhysicalConnectionSet"] as? [String: Any?] {
            var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet()
            model.fromMap(value)
            self.physicalConnectionSet = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribePhysicalConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePhysicalConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePhysicalConnectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePublicIpAddressRequest : Tea.TeaModel {
    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribePublicIpAddressResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var publicIpAddress: [String]?

    public var regionId: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.publicIpAddress != nil {
            map["PublicIpAddress"] = self.publicIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PublicIpAddress"] as? [String] {
            self.publicIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribePublicIpAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePublicIpAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePublicIpAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var productType: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProductType"] as? String {
            self.productType = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class Region : Tea.TeaModel {
            public var localName: String?

            public var regionEndpoint: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalName"] as? String {
                    self.localName = value
                }
                if let value = dict["RegionEndpoint"] as? String {
                    self.regionEndpoint = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
            }
        }
        public var region: [DescribeRegionsResponseBody.Regions.Region]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                var tmp : [Any] = []
                for k in self.region! {
                    tmp.append(k.toMap())
                }
                map["Region"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Region"] as? [Any?] {
                var tmp : [DescribeRegionsResponseBody.Regions.Region] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRegionsResponseBody.Regions.Region()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.region = tmp
            }
        }
    }
    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(value)
            self.regions = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRouteEntryListRequest : Tea.TeaModel {
    public var destCidrBlockList: [String]?

    public var destinationCidrBlock: String?

    public var ipVersion: String?

    public var maxResult: Int32?

    public var nextHopId: String?

    public var nextHopType: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryId: String?

    public var routeEntryName: String?

    public var routeEntryType: String?

    public var routeTableId: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destCidrBlockList != nil {
            map["DestCidrBlockList"] = self.destCidrBlockList!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.maxResult != nil {
            map["MaxResult"] = self.maxResult!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestCidrBlockList"] as? [String] {
            self.destCidrBlockList = value
        }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["MaxResult"] as? Int32 {
            self.maxResult = value
        }
        if let value = dict["NextHopId"] as? String {
            self.nextHopId = value
        }
        if let value = dict["NextHopType"] as? String {
            self.nextHopType = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntryId"] as? String {
            self.routeEntryId = value
        }
        if let value = dict["RouteEntryName"] as? String {
            self.routeEntryName = value
        }
        if let value = dict["RouteEntryType"] as? String {
            self.routeEntryType = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["ServiceType"] as? String {
            self.serviceType = value
        }
    }
}

public class DescribeRouteEntryListResponseBody : Tea.TeaModel {
    public class RouteEntrys : Tea.TeaModel {
        public class RouteEntry : Tea.TeaModel {
            public class NextHops : Tea.TeaModel {
                public class NextHop : Tea.TeaModel {
                    public class NextHopRelatedInfo : Tea.TeaModel {
                        public var instanceId: String?

                        public var instanceType: String?

                        public var regionId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.instanceId != nil {
                                map["InstanceId"] = self.instanceId!
                            }
                            if self.instanceType != nil {
                                map["InstanceType"] = self.instanceType!
                            }
                            if self.regionId != nil {
                                map["RegionId"] = self.regionId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["InstanceId"] as? String {
                                self.instanceId = value
                            }
                            if let value = dict["InstanceType"] as? String {
                                self.instanceType = value
                            }
                            if let value = dict["RegionId"] as? String {
                                self.regionId = value
                            }
                        }
                    }
                    public var enabled: Int32?

                    public var nextHopId: String?

                    public var nextHopRegionId: String?

                    public var nextHopRelatedInfo: DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop.NextHopRelatedInfo?

                    public var nextHopType: String?

                    public var weight: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.nextHopRelatedInfo?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.enabled != nil {
                            map["Enabled"] = self.enabled!
                        }
                        if self.nextHopId != nil {
                            map["NextHopId"] = self.nextHopId!
                        }
                        if self.nextHopRegionId != nil {
                            map["NextHopRegionId"] = self.nextHopRegionId!
                        }
                        if self.nextHopRelatedInfo != nil {
                            map["NextHopRelatedInfo"] = self.nextHopRelatedInfo?.toMap()
                        }
                        if self.nextHopType != nil {
                            map["NextHopType"] = self.nextHopType!
                        }
                        if self.weight != nil {
                            map["Weight"] = self.weight!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Enabled"] as? Int32 {
                            self.enabled = value
                        }
                        if let value = dict["NextHopId"] as? String {
                            self.nextHopId = value
                        }
                        if let value = dict["NextHopRegionId"] as? String {
                            self.nextHopRegionId = value
                        }
                        if let value = dict["NextHopRelatedInfo"] as? [String: Any?] {
                            var model = DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop.NextHopRelatedInfo()
                            model.fromMap(value)
                            self.nextHopRelatedInfo = model
                        }
                        if let value = dict["NextHopType"] as? String {
                            self.nextHopType = value
                        }
                        if let value = dict["Weight"] as? Int32 {
                            self.weight = value
                        }
                    }
                }
                public var nextHop: [DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nextHop != nil {
                        var tmp : [Any] = []
                        for k in self.nextHop! {
                            tmp.append(k.toMap())
                        }
                        map["NextHop"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NextHop"] as? [Any?] {
                        var tmp : [DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops.NextHop()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.nextHop = tmp
                    }
                }
            }
            public var description_: String?

            public var destinationCidrBlock: String?

            public var gmtModified: String?

            public var ipVersion: String?

            public var nextHops: DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops?

            public var origin: String?

            public var routeEntryId: String?

            public var routeEntryName: String?

            public var routeTableId: String?

            public var serviceType: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.nextHops?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.destinationCidrBlock != nil {
                    map["DestinationCidrBlock"] = self.destinationCidrBlock!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.nextHops != nil {
                    map["NextHops"] = self.nextHops?.toMap()
                }
                if self.origin != nil {
                    map["Origin"] = self.origin!
                }
                if self.routeEntryId != nil {
                    map["RouteEntryId"] = self.routeEntryId!
                }
                if self.routeEntryName != nil {
                    map["RouteEntryName"] = self.routeEntryName!
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.serviceType != nil {
                    map["ServiceType"] = self.serviceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DestinationCidrBlock"] as? String {
                    self.destinationCidrBlock = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["IpVersion"] as? String {
                    self.ipVersion = value
                }
                if let value = dict["NextHops"] as? [String: Any?] {
                    var model = DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry.NextHops()
                    model.fromMap(value)
                    self.nextHops = model
                }
                if let value = dict["Origin"] as? String {
                    self.origin = value
                }
                if let value = dict["RouteEntryId"] as? String {
                    self.routeEntryId = value
                }
                if let value = dict["RouteEntryName"] as? String {
                    self.routeEntryName = value
                }
                if let value = dict["RouteTableId"] as? String {
                    self.routeTableId = value
                }
                if let value = dict["ServiceType"] as? String {
                    self.serviceType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var routeEntry: [DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeEntry != nil {
                var tmp : [Any] = []
                for k in self.routeEntry! {
                    tmp.append(k.toMap())
                }
                map["RouteEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RouteEntry"] as? [Any?] {
                var tmp : [DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRouteEntryListResponseBody.RouteEntrys.RouteEntry()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.routeEntry = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var routeEntrys: DescribeRouteEntryListResponseBody.RouteEntrys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeEntrys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntrys != nil {
            map["RouteEntrys"] = self.routeEntrys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteEntrys"] as? [String: Any?] {
            var model = DescribeRouteEntryListResponseBody.RouteEntrys()
            model.fromMap(value)
            self.routeEntrys = model
        }
    }
}

public class DescribeRouteEntryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouteEntryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRouteEntryListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRouteTableListRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var routeTableName: String?

    public var routeTableType: String?

    public var routerId: String?

    public var routerType: String?

    public var tag: [DescribeRouteTableListRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        if self.routeTableType != nil {
            map["RouteTableType"] = self.routeTableType!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["RouteTableName"] as? String {
            self.routeTableName = value
        }
        if let value = dict["RouteTableType"] as? String {
            self.routeTableType = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
        if let value = dict["RouterType"] as? String {
            self.routerType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeRouteTableListRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeRouteTableListRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeRouteTableListResponseBody : Tea.TeaModel {
    public class RouterTableList : Tea.TeaModel {
        public class RouterTableListType : Tea.TeaModel {
            public class GatewayIds : Tea.TeaModel {
                public var gatewayIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gatewayIds != nil {
                        map["GatewayIds"] = self.gatewayIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["GatewayIds"] as? [String] {
                        self.gatewayIds = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VSwitchId"] as? [String] {
                        self.vSwitchId = value
                    }
                }
            }
            public var associateType: String?

            public var creationTime: String?

            public var description_: String?

            public var gatewayIds: DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.GatewayIds?

            public var ownerId: Int64?

            public var resourceGroupId: String?

            public var routePropagationEnable: Bool?

            public var routeTableId: String?

            public var routeTableName: String?

            public var routeTableType: String?

            public var routerId: String?

            public var routerType: String?

            public var status: String?

            public var tags: DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags?

            public var vSwitchIds: DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.VSwitchIds?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.gatewayIds?.validate()
                try self.tags?.validate()
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associateType != nil {
                    map["AssociateType"] = self.associateType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gatewayIds != nil {
                    map["GatewayIds"] = self.gatewayIds?.toMap()
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routePropagationEnable != nil {
                    map["RoutePropagationEnable"] = self.routePropagationEnable!
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.routeTableName != nil {
                    map["RouteTableName"] = self.routeTableName!
                }
                if self.routeTableType != nil {
                    map["RouteTableType"] = self.routeTableType!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.routerType != nil {
                    map["RouterType"] = self.routerType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssociateType"] as? String {
                    self.associateType = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["GatewayIds"] as? [String: Any?] {
                    var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.GatewayIds()
                    model.fromMap(value)
                    self.gatewayIds = model
                }
                if let value = dict["OwnerId"] as? Int64 {
                    self.ownerId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RoutePropagationEnable"] as? Bool {
                    self.routePropagationEnable = value
                }
                if let value = dict["RouteTableId"] as? String {
                    self.routeTableId = value
                }
                if let value = dict["RouteTableName"] as? String {
                    self.routeTableName = value
                }
                if let value = dict["RouteTableType"] as? String {
                    self.routeTableType = value
                }
                if let value = dict["RouterId"] as? String {
                    self.routerId = value
                }
                if let value = dict["RouterType"] as? String {
                    self.routerType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VSwitchIds"] as? [String: Any?] {
                    var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType.VSwitchIds()
                    model.fromMap(value)
                    self.vSwitchIds = model
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var routerTableListType: [DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routerTableListType != nil {
                var tmp : [Any] = []
                for k in self.routerTableListType! {
                    tmp.append(k.toMap())
                }
                map["RouterTableListType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RouterTableListType"] as? [Any?] {
                var tmp : [DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRouteTableListResponseBody.RouterTableList.RouterTableListType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.routerTableListType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routerTableList: DescribeRouteTableListResponseBody.RouterTableList?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routerTableList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerTableList != nil {
            map["RouterTableList"] = self.routerTableList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouterTableList"] as? [String: Any?] {
            var model = DescribeRouteTableListResponseBody.RouterTableList()
            model.fromMap(value)
            self.routerTableList = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeRouteTableListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouteTableListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRouteTableListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRouteTablesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var routeTableName: String?

    public var routerId: String?

    public var routerType: String?

    public var type: String?

    public var VRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["RouteTableName"] as? String {
            self.routeTableName = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
        if let value = dict["RouterType"] as? String {
            self.routerType = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
    }
}

public class DescribeRouteTablesResponseBody : Tea.TeaModel {
    public class RouteTables : Tea.TeaModel {
        public class RouteTable : Tea.TeaModel {
            public class RouteEntrys : Tea.TeaModel {
                public class RouteEntry : Tea.TeaModel {
                    public class NextHops : Tea.TeaModel {
                        public class NextHop : Tea.TeaModel {
                            public var enabled: Int32?

                            public var nextHopId: String?

                            public var nextHopType: String?

                            public var weight: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.enabled != nil {
                                    map["Enabled"] = self.enabled!
                                }
                                if self.nextHopId != nil {
                                    map["NextHopId"] = self.nextHopId!
                                }
                                if self.nextHopType != nil {
                                    map["NextHopType"] = self.nextHopType!
                                }
                                if self.weight != nil {
                                    map["Weight"] = self.weight!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Enabled"] as? Int32 {
                                    self.enabled = value
                                }
                                if let value = dict["NextHopId"] as? String {
                                    self.nextHopId = value
                                }
                                if let value = dict["NextHopType"] as? String {
                                    self.nextHopType = value
                                }
                                if let value = dict["Weight"] as? Int32 {
                                    self.weight = value
                                }
                            }
                        }
                        public var nextHop: [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.nextHop != nil {
                                var tmp : [Any] = []
                                for k in self.nextHop! {
                                    tmp.append(k.toMap())
                                }
                                map["NextHop"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["NextHop"] as? [Any?] {
                                var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.nextHop = tmp
                            }
                        }
                    }
                    public var description_: String?

                    public var destinationCidrBlock: String?

                    public var instanceId: String?

                    public var nextHopType: String?

                    public var nextHops: DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops?

                    public var routeEntryId: String?

                    public var routeEntryName: String?

                    public var routeTableId: String?

                    public var status: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.nextHops?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.destinationCidrBlock != nil {
                            map["DestinationCidrBlock"] = self.destinationCidrBlock!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.nextHopType != nil {
                            map["NextHopType"] = self.nextHopType!
                        }
                        if self.nextHops != nil {
                            map["NextHops"] = self.nextHops?.toMap()
                        }
                        if self.routeEntryId != nil {
                            map["RouteEntryId"] = self.routeEntryId!
                        }
                        if self.routeEntryName != nil {
                            map["RouteEntryName"] = self.routeEntryName!
                        }
                        if self.routeTableId != nil {
                            map["RouteTableId"] = self.routeTableId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Description"] as? String {
                            self.description_ = value
                        }
                        if let value = dict["DestinationCidrBlock"] as? String {
                            self.destinationCidrBlock = value
                        }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                        if let value = dict["NextHopType"] as? String {
                            self.nextHopType = value
                        }
                        if let value = dict["NextHops"] as? [String: Any?] {
                            var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops()
                            model.fromMap(value)
                            self.nextHops = model
                        }
                        if let value = dict["RouteEntryId"] as? String {
                            self.routeEntryId = value
                        }
                        if let value = dict["RouteEntryName"] as? String {
                            self.routeEntryName = value
                        }
                        if let value = dict["RouteTableId"] as? String {
                            self.routeTableId = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var routeEntry: [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeEntry != nil {
                        var tmp : [Any] = []
                        for k in self.routeEntry! {
                            tmp.append(k.toMap())
                        }
                        map["RouteEntry"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RouteEntry"] as? [Any?] {
                        var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.routeEntry = tmp
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VSwitchId"] as? [String] {
                        self.vSwitchId = value
                    }
                }
            }
            public var creationTime: String?

            public var resourceGroupId: String?

            public var routeEntrys: DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys?

            public var routeTableId: String?

            public var routeTableType: String?

            public var status: String?

            public var VRouterId: String?

            public var vSwitchIds: DescribeRouteTablesResponseBody.RouteTables.RouteTable.VSwitchIds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeEntrys?.validate()
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routeEntrys != nil {
                    map["RouteEntrys"] = self.routeEntrys?.toMap()
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.routeTableType != nil {
                    map["RouteTableType"] = self.routeTableType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RouteEntrys"] as? [String: Any?] {
                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys()
                    model.fromMap(value)
                    self.routeEntrys = model
                }
                if let value = dict["RouteTableId"] as? String {
                    self.routeTableId = value
                }
                if let value = dict["RouteTableType"] as? String {
                    self.routeTableType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["VRouterId"] as? String {
                    self.VRouterId = value
                }
                if let value = dict["VSwitchIds"] as? [String: Any?] {
                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.VSwitchIds()
                    model.fromMap(value)
                    self.vSwitchIds = model
                }
            }
        }
        public var routeTable: [DescribeRouteTablesResponseBody.RouteTables.RouteTable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeTable != nil {
                var tmp : [Any] = []
                for k in self.routeTable! {
                    tmp.append(k.toMap())
                }
                map["RouteTable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RouteTable"] as? [Any?] {
                var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.routeTable = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routeTables: DescribeRouteTablesResponseBody.RouteTables?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeTables?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTables != nil {
            map["RouteTables"] = self.routeTables?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteTables"] as? [String: Any?] {
            var model = DescribeRouteTablesResponseBody.RouteTables()
            model.fromMap(value)
            self.routeTables = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeRouteTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouteTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRouteTablesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRouterInterfaceAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeRouterInterfaceAttributeResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var tags: [DescribeRouterInterfaceAttributeResponseBody.Tags.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeRouterInterfaceAttributeResponseBody.Tags.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRouterInterfaceAttributeResponseBody.Tags.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
        }
    }
    public var accessPointId: String?

    public var bandwidth: Int32?

    public var businessStatus: String?

    public var chargeType: String?

    public var code: String?

    public var connectedTime: String?

    public var creationTime: String?

    public var crossBorder: Bool?

    public var description_: String?

    public var endTime: String?

    public var fastLinkMode: String?

    public var gmtModified: String?

    public var hasReservationData: String?

    public var hcRate: Int32?

    public var hcThreshold: Int32?

    public var healthCheckSourceIp: String?

    public var healthCheckStatus: String?

    public var healthCheckTargetIp: String?

    public var message: String?

    public var name: String?

    public var oppositeAccessPointId: String?

    public var oppositeBandwidth: Int32?

    public var oppositeInterfaceBusinessStatus: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: String?

    public var oppositeInterfaceSpec: String?

    public var oppositeInterfaceStatus: String?

    public var oppositeRegionId: String?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var oppositeVpcInstanceId: String?

    public var requestId: String?

    public var reservationActiveTime: String?

    public var reservationBandwidth: String?

    public var reservationInternetChargeType: String?

    public var reservationOrderType: String?

    public var resourceGroupId: String?

    public var role: String?

    public var routerId: String?

    public var routerInterfaceId: String?

    public var routerType: String?

    public var spec: String?

    public var status: String?

    public var success: Bool?

    public var tags: DescribeRouterInterfaceAttributeResponseBody.Tags?

    public var vpcInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.connectedTime != nil {
            map["ConnectedTime"] = self.connectedTime!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.crossBorder != nil {
            map["CrossBorder"] = self.crossBorder!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.fastLinkMode != nil {
            map["FastLinkMode"] = self.fastLinkMode!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.hasReservationData != nil {
            map["HasReservationData"] = self.hasReservationData!
        }
        if self.hcRate != nil {
            map["HcRate"] = self.hcRate!
        }
        if self.hcThreshold != nil {
            map["HcThreshold"] = self.hcThreshold!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckStatus != nil {
            map["HealthCheckStatus"] = self.healthCheckStatus!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeAccessPointId != nil {
            map["OppositeAccessPointId"] = self.oppositeAccessPointId!
        }
        if self.oppositeBandwidth != nil {
            map["OppositeBandwidth"] = self.oppositeBandwidth!
        }
        if self.oppositeInterfaceBusinessStatus != nil {
            map["OppositeInterfaceBusinessStatus"] = self.oppositeInterfaceBusinessStatus!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeInterfaceSpec != nil {
            map["OppositeInterfaceSpec"] = self.oppositeInterfaceSpec!
        }
        if self.oppositeInterfaceStatus != nil {
            map["OppositeInterfaceStatus"] = self.oppositeInterfaceStatus!
        }
        if self.oppositeRegionId != nil {
            map["OppositeRegionId"] = self.oppositeRegionId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.oppositeVpcInstanceId != nil {
            map["OppositeVpcInstanceId"] = self.oppositeVpcInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservationActiveTime != nil {
            map["ReservationActiveTime"] = self.reservationActiveTime!
        }
        if self.reservationBandwidth != nil {
            map["ReservationBandwidth"] = self.reservationBandwidth!
        }
        if self.reservationInternetChargeType != nil {
            map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
        }
        if self.reservationOrderType != nil {
            map["ReservationOrderType"] = self.reservationOrderType!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.vpcInstanceId != nil {
            map["VpcInstanceId"] = self.vpcInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessPointId"] as? String {
            self.accessPointId = value
        }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["BusinessStatus"] as? String {
            self.businessStatus = value
        }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ConnectedTime"] as? String {
            self.connectedTime = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["CrossBorder"] as? Bool {
            self.crossBorder = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FastLinkMode"] as? String {
            self.fastLinkMode = value
        }
        if let value = dict["GmtModified"] as? String {
            self.gmtModified = value
        }
        if let value = dict["HasReservationData"] as? String {
            self.hasReservationData = value
        }
        if let value = dict["HcRate"] as? Int32 {
            self.hcRate = value
        }
        if let value = dict["HcThreshold"] as? Int32 {
            self.hcThreshold = value
        }
        if let value = dict["HealthCheckSourceIp"] as? String {
            self.healthCheckSourceIp = value
        }
        if let value = dict["HealthCheckStatus"] as? String {
            self.healthCheckStatus = value
        }
        if let value = dict["HealthCheckTargetIp"] as? String {
            self.healthCheckTargetIp = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OppositeAccessPointId"] as? String {
            self.oppositeAccessPointId = value
        }
        if let value = dict["OppositeBandwidth"] as? Int32 {
            self.oppositeBandwidth = value
        }
        if let value = dict["OppositeInterfaceBusinessStatus"] as? String {
            self.oppositeInterfaceBusinessStatus = value
        }
        if let value = dict["OppositeInterfaceId"] as? String {
            self.oppositeInterfaceId = value
        }
        if let value = dict["OppositeInterfaceOwnerId"] as? String {
            self.oppositeInterfaceOwnerId = value
        }
        if let value = dict["OppositeInterfaceSpec"] as? String {
            self.oppositeInterfaceSpec = value
        }
        if let value = dict["OppositeInterfaceStatus"] as? String {
            self.oppositeInterfaceStatus = value
        }
        if let value = dict["OppositeRegionId"] as? String {
            self.oppositeRegionId = value
        }
        if let value = dict["OppositeRouterId"] as? String {
            self.oppositeRouterId = value
        }
        if let value = dict["OppositeRouterType"] as? String {
            self.oppositeRouterType = value
        }
        if let value = dict["OppositeVpcInstanceId"] as? String {
            self.oppositeVpcInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ReservationActiveTime"] as? String {
            self.reservationActiveTime = value
        }
        if let value = dict["ReservationBandwidth"] as? String {
            self.reservationBandwidth = value
        }
        if let value = dict["ReservationInternetChargeType"] as? String {
            self.reservationInternetChargeType = value
        }
        if let value = dict["ReservationOrderType"] as? String {
            self.reservationOrderType = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
        if let value = dict["RouterType"] as? String {
            self.routerType = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeRouterInterfaceAttributeResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["VpcInstanceId"] as? String {
            self.vpcInstanceId = value
        }
    }
}

public class DescribeRouterInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouterInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRouterInterfaceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRouterInterfacesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var filter: [DescribeRouterInterfacesRequest.Filter]?

    public var includeReservationData: Bool?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribeRouterInterfacesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeRouterInterfacesRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeRouterInterfacesRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["IncludeReservationData"] as? Bool {
            self.includeReservationData = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeRouterInterfacesRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeRouterInterfacesRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class DescribeRouterInterfacesResponseBody : Tea.TeaModel {
    public class RouterInterfaceSet : Tea.TeaModel {
        public class RouterInterfaceType : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tags: [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags.Tags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tags != nil {
                        var tmp : [Any] = []
                        for k in self.tags! {
                            tmp.append(k.toMap())
                        }
                        map["Tags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tags"] as? [Any?] {
                        var tmp : [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags.Tags] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags.Tags()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tags = tmp
                    }
                }
            }
            public var accessPointId: String?

            public var bandwidth: Int32?

            public var businessStatus: String?

            public var chargeType: String?

            public var connectedTime: String?

            public var creationTime: String?

            public var crossBorder: Bool?

            public var description_: String?

            public var endTime: String?

            public var fastLinkMode: Bool?

            public var hasReservationData: String?

            public var hcRate: Int32?

            public var hcThreshold: Int32?

            public var healthCheckSourceIp: String?

            public var healthCheckTargetIp: String?

            public var ipv6Status: String?

            public var name: String?

            public var oppositeAccessPointId: String?

            public var oppositeBandwidth: Int32?

            public var oppositeInterfaceBusinessStatus: String?

            public var oppositeInterfaceId: String?

            public var oppositeInterfaceOwnerId: String?

            public var oppositeInterfaceSpec: String?

            public var oppositeInterfaceStatus: String?

            public var oppositeRegionId: String?

            public var oppositeRouterId: String?

            public var oppositeRouterType: String?

            public var oppositeVpcInstanceId: String?

            public var reservationActiveTime: String?

            public var reservationBandwidth: String?

            public var reservationInternetChargeType: String?

            public var reservationOrderType: String?

            public var resourceGroupId: String?

            public var role: String?

            public var routerId: String?

            public var routerInterfaceId: String?

            public var routerType: String?

            public var spec: String?

            public var status: String?

            public var tags: DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags?

            public var vpcInstanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.connectedTime != nil {
                    map["ConnectedTime"] = self.connectedTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.crossBorder != nil {
                    map["CrossBorder"] = self.crossBorder!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.fastLinkMode != nil {
                    map["FastLinkMode"] = self.fastLinkMode!
                }
                if self.hasReservationData != nil {
                    map["HasReservationData"] = self.hasReservationData!
                }
                if self.hcRate != nil {
                    map["HcRate"] = self.hcRate!
                }
                if self.hcThreshold != nil {
                    map["HcThreshold"] = self.hcThreshold!
                }
                if self.healthCheckSourceIp != nil {
                    map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
                }
                if self.healthCheckTargetIp != nil {
                    map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
                }
                if self.ipv6Status != nil {
                    map["Ipv6Status"] = self.ipv6Status!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.oppositeAccessPointId != nil {
                    map["OppositeAccessPointId"] = self.oppositeAccessPointId!
                }
                if self.oppositeBandwidth != nil {
                    map["OppositeBandwidth"] = self.oppositeBandwidth!
                }
                if self.oppositeInterfaceBusinessStatus != nil {
                    map["OppositeInterfaceBusinessStatus"] = self.oppositeInterfaceBusinessStatus!
                }
                if self.oppositeInterfaceId != nil {
                    map["OppositeInterfaceId"] = self.oppositeInterfaceId!
                }
                if self.oppositeInterfaceOwnerId != nil {
                    map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
                }
                if self.oppositeInterfaceSpec != nil {
                    map["OppositeInterfaceSpec"] = self.oppositeInterfaceSpec!
                }
                if self.oppositeInterfaceStatus != nil {
                    map["OppositeInterfaceStatus"] = self.oppositeInterfaceStatus!
                }
                if self.oppositeRegionId != nil {
                    map["OppositeRegionId"] = self.oppositeRegionId!
                }
                if self.oppositeRouterId != nil {
                    map["OppositeRouterId"] = self.oppositeRouterId!
                }
                if self.oppositeRouterType != nil {
                    map["OppositeRouterType"] = self.oppositeRouterType!
                }
                if self.oppositeVpcInstanceId != nil {
                    map["OppositeVpcInstanceId"] = self.oppositeVpcInstanceId!
                }
                if self.reservationActiveTime != nil {
                    map["ReservationActiveTime"] = self.reservationActiveTime!
                }
                if self.reservationBandwidth != nil {
                    map["ReservationBandwidth"] = self.reservationBandwidth!
                }
                if self.reservationInternetChargeType != nil {
                    map["ReservationInternetChargeType"] = self.reservationInternetChargeType!
                }
                if self.reservationOrderType != nil {
                    map["ReservationOrderType"] = self.reservationOrderType!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.routerInterfaceId != nil {
                    map["RouterInterfaceId"] = self.routerInterfaceId!
                }
                if self.routerType != nil {
                    map["RouterType"] = self.routerType!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcInstanceId != nil {
                    map["VpcInstanceId"] = self.vpcInstanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessPointId"] as? String {
                    self.accessPointId = value
                }
                if let value = dict["Bandwidth"] as? Int32 {
                    self.bandwidth = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["ConnectedTime"] as? String {
                    self.connectedTime = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["CrossBorder"] as? Bool {
                    self.crossBorder = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["FastLinkMode"] as? Bool {
                    self.fastLinkMode = value
                }
                if let value = dict["HasReservationData"] as? String {
                    self.hasReservationData = value
                }
                if let value = dict["HcRate"] as? Int32 {
                    self.hcRate = value
                }
                if let value = dict["HcThreshold"] as? Int32 {
                    self.hcThreshold = value
                }
                if let value = dict["HealthCheckSourceIp"] as? String {
                    self.healthCheckSourceIp = value
                }
                if let value = dict["HealthCheckTargetIp"] as? String {
                    self.healthCheckTargetIp = value
                }
                if let value = dict["Ipv6Status"] as? String {
                    self.ipv6Status = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["OppositeAccessPointId"] as? String {
                    self.oppositeAccessPointId = value
                }
                if let value = dict["OppositeBandwidth"] as? Int32 {
                    self.oppositeBandwidth = value
                }
                if let value = dict["OppositeInterfaceBusinessStatus"] as? String {
                    self.oppositeInterfaceBusinessStatus = value
                }
                if let value = dict["OppositeInterfaceId"] as? String {
                    self.oppositeInterfaceId = value
                }
                if let value = dict["OppositeInterfaceOwnerId"] as? String {
                    self.oppositeInterfaceOwnerId = value
                }
                if let value = dict["OppositeInterfaceSpec"] as? String {
                    self.oppositeInterfaceSpec = value
                }
                if let value = dict["OppositeInterfaceStatus"] as? String {
                    self.oppositeInterfaceStatus = value
                }
                if let value = dict["OppositeRegionId"] as? String {
                    self.oppositeRegionId = value
                }
                if let value = dict["OppositeRouterId"] as? String {
                    self.oppositeRouterId = value
                }
                if let value = dict["OppositeRouterType"] as? String {
                    self.oppositeRouterType = value
                }
                if let value = dict["OppositeVpcInstanceId"] as? String {
                    self.oppositeVpcInstanceId = value
                }
                if let value = dict["ReservationActiveTime"] as? String {
                    self.reservationActiveTime = value
                }
                if let value = dict["ReservationBandwidth"] as? String {
                    self.reservationBandwidth = value
                }
                if let value = dict["ReservationInternetChargeType"] as? String {
                    self.reservationInternetChargeType = value
                }
                if let value = dict["ReservationOrderType"] as? String {
                    self.reservationOrderType = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Role"] as? String {
                    self.role = value
                }
                if let value = dict["RouterId"] as? String {
                    self.routerId = value
                }
                if let value = dict["RouterInterfaceId"] as? String {
                    self.routerInterfaceId = value
                }
                if let value = dict["RouterType"] as? String {
                    self.routerType = value
                }
                if let value = dict["Spec"] as? String {
                    self.spec = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VpcInstanceId"] as? String {
                    self.vpcInstanceId = value
                }
            }
        }
        public var routerInterfaceType: [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routerInterfaceType != nil {
                var tmp : [Any] = []
                for k in self.routerInterfaceType! {
                    tmp.append(k.toMap())
                }
                map["RouterInterfaceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RouterInterfaceType"] as? [Any?] {
                var tmp : [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.routerInterfaceType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routerInterfaceSet: DescribeRouterInterfacesResponseBody.RouterInterfaceSet?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routerInterfaceSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerInterfaceSet != nil {
            map["RouterInterfaceSet"] = self.routerInterfaceSet?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouterInterfaceSet"] as? [String: Any?] {
            var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet()
            model.fromMap(value)
            self.routerInterfaceSet = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeRouterInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouterInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRouterInterfacesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeServerRelatedGlobalAccelerationInstancesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serverId: String?

    public var serverType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        if self.serverType != nil {
            map["ServerType"] = self.serverType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServerId"] as? String {
            self.serverId = value
        }
        if let value = dict["ServerType"] as? String {
            self.serverType = value
        }
    }
}

public class DescribeServerRelatedGlobalAccelerationInstancesResponseBody : Tea.TeaModel {
    public class GlobalAccelerationInstances : Tea.TeaModel {
        public class GlobalAccelerationInstance : Tea.TeaModel {
            public var globalAccelerationInstanceId: String?

            public var ipAddress: String?

            public var regionId: String?

            public var serverIpAddress: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.globalAccelerationInstanceId != nil {
                    map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.serverIpAddress != nil {
                    map["ServerIpAddress"] = self.serverIpAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["GlobalAccelerationInstanceId"] as? String {
                    self.globalAccelerationInstanceId = value
                }
                if let value = dict["IpAddress"] as? String {
                    self.ipAddress = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ServerIpAddress"] as? String {
                    self.serverIpAddress = value
                }
            }
        }
        public var globalAccelerationInstance: [DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.globalAccelerationInstance != nil {
                var tmp : [Any] = []
                for k in self.globalAccelerationInstance! {
                    tmp.append(k.toMap())
                }
                map["GlobalAccelerationInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GlobalAccelerationInstance"] as? [Any?] {
                var tmp : [DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances.GlobalAccelerationInstance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.globalAccelerationInstance = tmp
            }
        }
    }
    public var globalAccelerationInstances: DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.globalAccelerationInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstances != nil {
            map["GlobalAccelerationInstances"] = self.globalAccelerationInstances?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GlobalAccelerationInstances"] as? [String: Any?] {
            var model = DescribeServerRelatedGlobalAccelerationInstancesResponseBody.GlobalAccelerationInstances()
            model.fromMap(value)
            self.globalAccelerationInstances = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeServerRelatedGlobalAccelerationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServerRelatedGlobalAccelerationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeServerRelatedGlobalAccelerationInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSnatTableEntriesRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var networkInterfaceIds: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snatEntryId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public var snatTableId: String?

    public var sourceCIDR: String?

    public var sourceVSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.networkInterfaceIds != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.snatTableId != nil {
            map["SnatTableId"] = self.snatTableId!
        }
        if self.sourceCIDR != nil {
            map["SourceCIDR"] = self.sourceCIDR!
        }
        if self.sourceVSwitchId != nil {
            map["SourceVSwitchId"] = self.sourceVSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NetworkInterfaceIds"] as? [String] {
            self.networkInterfaceIds = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnatEntryId"] as? String {
            self.snatEntryId = value
        }
        if let value = dict["SnatEntryName"] as? String {
            self.snatEntryName = value
        }
        if let value = dict["SnatIp"] as? String {
            self.snatIp = value
        }
        if let value = dict["SnatTableId"] as? String {
            self.snatTableId = value
        }
        if let value = dict["SourceCIDR"] as? String {
            self.sourceCIDR = value
        }
        if let value = dict["SourceVSwitchId"] as? String {
            self.sourceVSwitchId = value
        }
    }
}

public class DescribeSnatTableEntriesResponseBody : Tea.TeaModel {
    public class SnatTableEntries : Tea.TeaModel {
        public class SnatTableEntry : Tea.TeaModel {
            public var eipAffinity: String?

            public var natGatewayId: String?

            public var networkInterfaceId: String?

            public var snatEntryId: String?

            public var snatEntryName: String?

            public var snatIp: String?

            public var snatTableId: String?

            public var sourceCIDR: String?

            public var sourceVSwitchId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eipAffinity != nil {
                    map["EipAffinity"] = self.eipAffinity!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.snatEntryId != nil {
                    map["SnatEntryId"] = self.snatEntryId!
                }
                if self.snatEntryName != nil {
                    map["SnatEntryName"] = self.snatEntryName!
                }
                if self.snatIp != nil {
                    map["SnatIp"] = self.snatIp!
                }
                if self.snatTableId != nil {
                    map["SnatTableId"] = self.snatTableId!
                }
                if self.sourceCIDR != nil {
                    map["SourceCIDR"] = self.sourceCIDR!
                }
                if self.sourceVSwitchId != nil {
                    map["SourceVSwitchId"] = self.sourceVSwitchId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EipAffinity"] as? String {
                    self.eipAffinity = value
                }
                if let value = dict["NatGatewayId"] as? String {
                    self.natGatewayId = value
                }
                if let value = dict["NetworkInterfaceId"] as? String {
                    self.networkInterfaceId = value
                }
                if let value = dict["SnatEntryId"] as? String {
                    self.snatEntryId = value
                }
                if let value = dict["SnatEntryName"] as? String {
                    self.snatEntryName = value
                }
                if let value = dict["SnatIp"] as? String {
                    self.snatIp = value
                }
                if let value = dict["SnatTableId"] as? String {
                    self.snatTableId = value
                }
                if let value = dict["SourceCIDR"] as? String {
                    self.sourceCIDR = value
                }
                if let value = dict["SourceVSwitchId"] as? String {
                    self.sourceVSwitchId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var snatTableEntry: [DescribeSnatTableEntriesResponseBody.SnatTableEntries.SnatTableEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snatTableEntry != nil {
                var tmp : [Any] = []
                for k in self.snatTableEntry! {
                    tmp.append(k.toMap())
                }
                map["SnatTableEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SnatTableEntry"] as? [Any?] {
                var tmp : [DescribeSnatTableEntriesResponseBody.SnatTableEntries.SnatTableEntry] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSnatTableEntriesResponseBody.SnatTableEntries.SnatTableEntry()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.snatTableEntry = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snatTableEntries: DescribeSnatTableEntriesResponseBody.SnatTableEntries?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snatTableEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatTableEntries != nil {
            map["SnatTableEntries"] = self.snatTableEntries?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnatTableEntries"] as? [String: Any?] {
            var model = DescribeSnatTableEntriesResponseBody.SnatTableEntries()
            model.fromMap(value)
            self.snatTableEntries = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSnatTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnatTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSnatTableEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSslVpnClientCertRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslVpnClientCertId"] as? String {
            self.sslVpnClientCertId = value
        }
    }
}

public class DescribeSslVpnClientCertResponseBody : Tea.TeaModel {
    public var caCert: String?

    public var clientCert: String?

    public var clientConfig: String?

    public var clientKey: String?

    public var createTime: Int64?

    public var endTime: Int64?

    public var name: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var sslVpnClientCertId: String?

    public var sslVpnServerId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.caCert != nil {
            map["CaCert"] = self.caCert!
        }
        if self.clientCert != nil {
            map["ClientCert"] = self.clientCert!
        }
        if self.clientConfig != nil {
            map["ClientConfig"] = self.clientConfig!
        }
        if self.clientKey != nil {
            map["ClientKey"] = self.clientKey!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CaCert"] as? String {
            self.caCert = value
        }
        if let value = dict["ClientCert"] as? String {
            self.clientCert = value
        }
        if let value = dict["ClientConfig"] as? String {
            self.clientConfig = value
        }
        if let value = dict["ClientKey"] as? String {
            self.clientKey = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SslVpnClientCertId"] as? String {
            self.sslVpnClientCertId = value
        }
        if let value = dict["SslVpnServerId"] as? String {
            self.sslVpnServerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeSslVpnClientCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSslVpnClientCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSslVpnClientCertResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSslVpnClientCertsRequest : Tea.TeaModel {
    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslVpnClientCertId"] as? String {
            self.sslVpnClientCertId = value
        }
        if let value = dict["SslVpnServerId"] as? String {
            self.sslVpnServerId = value
        }
    }
}

public class DescribeSslVpnClientCertsResponseBody : Tea.TeaModel {
    public class SslVpnClientCertKeys : Tea.TeaModel {
        public class SslVpnClientCertKey : Tea.TeaModel {
            public var createTime: Int64?

            public var endTime: Int64?

            public var name: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var sslVpnClientCertId: String?

            public var sslVpnServerId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.sslVpnClientCertId != nil {
                    map["SslVpnClientCertId"] = self.sslVpnClientCertId!
                }
                if self.sslVpnServerId != nil {
                    map["SslVpnServerId"] = self.sslVpnServerId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["EndTime"] as? Int64 {
                    self.endTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SslVpnClientCertId"] as? String {
                    self.sslVpnClientCertId = value
                }
                if let value = dict["SslVpnServerId"] as? String {
                    self.sslVpnServerId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var sslVpnClientCertKey: [DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys.SslVpnClientCertKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sslVpnClientCertKey != nil {
                var tmp : [Any] = []
                for k in self.sslVpnClientCertKey! {
                    tmp.append(k.toMap())
                }
                map["SslVpnClientCertKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SslVpnClientCertKey"] as? [Any?] {
                var tmp : [DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys.SslVpnClientCertKey] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys.SslVpnClientCertKey()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sslVpnClientCertKey = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sslVpnClientCertKeys: DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sslVpnClientCertKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnClientCertKeys != nil {
            map["SslVpnClientCertKeys"] = self.sslVpnClientCertKeys?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SslVpnClientCertKeys"] as? [String: Any?] {
            var model = DescribeSslVpnClientCertsResponseBody.SslVpnClientCertKeys()
            model.fromMap(value)
            self.sslVpnClientCertKeys = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSslVpnClientCertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSslVpnClientCertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSslVpnClientCertsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSslVpnClientsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DescribeSslVpnClientsResponseBody : Tea.TeaModel {
    public class ClientInfoList : Tea.TeaModel {
        public var commonName: String?

        public var connectedTime: Int64?

        public var ip: String?

        public var port: String?

        public var privateIp: String?

        public var receiveBytes: Int64?

        public var sendBytes: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commonName != nil {
                map["CommonName"] = self.commonName!
            }
            if self.connectedTime != nil {
                map["ConnectedTime"] = self.connectedTime!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.privateIp != nil {
                map["PrivateIp"] = self.privateIp!
            }
            if self.receiveBytes != nil {
                map["ReceiveBytes"] = self.receiveBytes!
            }
            if self.sendBytes != nil {
                map["SendBytes"] = self.sendBytes!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CommonName"] as? String {
                self.commonName = value
            }
            if let value = dict["ConnectedTime"] as? Int64 {
                self.connectedTime = value
            }
            if let value = dict["Ip"] as? String {
                self.ip = value
            }
            if let value = dict["Port"] as? String {
                self.port = value
            }
            if let value = dict["PrivateIp"] as? String {
                self.privateIp = value
            }
            if let value = dict["ReceiveBytes"] as? Int64 {
                self.receiveBytes = value
            }
            if let value = dict["SendBytes"] as? Int64 {
                self.sendBytes = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var clientInfoList: [DescribeSslVpnClientsResponseBody.ClientInfoList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientInfoList != nil {
            var tmp : [Any] = []
            for k in self.clientInfoList! {
                tmp.append(k.toMap())
            }
            map["ClientInfoList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientInfoList"] as? [Any?] {
            var tmp : [DescribeSslVpnClientsResponseBody.ClientInfoList] = []
            for v in value {
                if v != nil {
                    var model = DescribeSslVpnClientsResponseBody.ClientInfoList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.clientInfoList = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DescribeSslVpnClientsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSslVpnClientsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSslVpnClientsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSslVpnServersRequest : Tea.TeaModel {
    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnServerId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslVpnServerId"] as? String {
            self.sslVpnServerId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DescribeSslVpnServersResponseBody : Tea.TeaModel {
    public class SslVpnServers : Tea.TeaModel {
        public class SslVpnServer : Tea.TeaModel {
            public var cipher: String?

            public var clientIpPool: String?

            public var compress: Bool?

            public var connections: Int32?

            public var createTime: Int64?

            public var enableMultiFactorAuth: Bool?

            public var IDaaSApplicationId: String?

            public var IDaaSInstanceId: String?

            public var IDaaSInstanceVersion: String?

            public var IDaaSRegionId: String?

            public var internetIp: String?

            public var localSubnet: String?

            public var maxConnections: Int32?

            public var name: String?

            public var port: Int32?

            public var proto: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var sslVpnServerId: String?

            public var vpnGatewayId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cipher != nil {
                    map["Cipher"] = self.cipher!
                }
                if self.clientIpPool != nil {
                    map["ClientIpPool"] = self.clientIpPool!
                }
                if self.compress != nil {
                    map["Compress"] = self.compress!
                }
                if self.connections != nil {
                    map["Connections"] = self.connections!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.enableMultiFactorAuth != nil {
                    map["EnableMultiFactorAuth"] = self.enableMultiFactorAuth!
                }
                if self.IDaaSApplicationId != nil {
                    map["IDaaSApplicationId"] = self.IDaaSApplicationId!
                }
                if self.IDaaSInstanceId != nil {
                    map["IDaaSInstanceId"] = self.IDaaSInstanceId!
                }
                if self.IDaaSInstanceVersion != nil {
                    map["IDaaSInstanceVersion"] = self.IDaaSInstanceVersion!
                }
                if self.IDaaSRegionId != nil {
                    map["IDaaSRegionId"] = self.IDaaSRegionId!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.localSubnet != nil {
                    map["LocalSubnet"] = self.localSubnet!
                }
                if self.maxConnections != nil {
                    map["MaxConnections"] = self.maxConnections!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.proto != nil {
                    map["Proto"] = self.proto!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.sslVpnServerId != nil {
                    map["SslVpnServerId"] = self.sslVpnServerId!
                }
                if self.vpnGatewayId != nil {
                    map["VpnGatewayId"] = self.vpnGatewayId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cipher"] as? String {
                    self.cipher = value
                }
                if let value = dict["ClientIpPool"] as? String {
                    self.clientIpPool = value
                }
                if let value = dict["Compress"] as? Bool {
                    self.compress = value
                }
                if let value = dict["Connections"] as? Int32 {
                    self.connections = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["EnableMultiFactorAuth"] as? Bool {
                    self.enableMultiFactorAuth = value
                }
                if let value = dict["IDaaSApplicationId"] as? String {
                    self.IDaaSApplicationId = value
                }
                if let value = dict["IDaaSInstanceId"] as? String {
                    self.IDaaSInstanceId = value
                }
                if let value = dict["IDaaSInstanceVersion"] as? String {
                    self.IDaaSInstanceVersion = value
                }
                if let value = dict["IDaaSRegionId"] as? String {
                    self.IDaaSRegionId = value
                }
                if let value = dict["InternetIp"] as? String {
                    self.internetIp = value
                }
                if let value = dict["LocalSubnet"] as? String {
                    self.localSubnet = value
                }
                if let value = dict["MaxConnections"] as? Int32 {
                    self.maxConnections = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Proto"] as? String {
                    self.proto = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SslVpnServerId"] as? String {
                    self.sslVpnServerId = value
                }
                if let value = dict["VpnGatewayId"] as? String {
                    self.vpnGatewayId = value
                }
            }
        }
        public var sslVpnServer: [DescribeSslVpnServersResponseBody.SslVpnServers.SslVpnServer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sslVpnServer != nil {
                var tmp : [Any] = []
                for k in self.sslVpnServer! {
                    tmp.append(k.toMap())
                }
                map["SslVpnServer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SslVpnServer"] as? [Any?] {
                var tmp : [DescribeSslVpnServersResponseBody.SslVpnServers.SslVpnServer] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSslVpnServersResponseBody.SslVpnServers.SslVpnServer()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sslVpnServer = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var sslVpnServers: DescribeSslVpnServersResponseBody.SslVpnServers?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sslVpnServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnServers != nil {
            map["SslVpnServers"] = self.sslVpnServers?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SslVpnServers"] as? [String: Any?] {
            var model = DescribeSslVpnServersResponseBody.SslVpnServers()
            model.fromMap(value)
            self.sslVpnServers = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSslVpnServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSslVpnServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSslVpnServersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTagKeysRequest : Tea.TeaModel {
    public var keyword: String?

    public var maxResult: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.maxResult != nil {
            map["MaxResult"] = self.maxResult!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["MaxResult"] as? Int32 {
            self.maxResult = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class DescribeTagKeysResponseBody : Tea.TeaModel {
    public class TagKeys : Tea.TeaModel {
        public class TagKey : Tea.TeaModel {
            public var tagKey: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var tagKey: [DescribeTagKeysResponseBody.TagKeys.TagKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                var tmp : [Any] = []
                for k in self.tagKey! {
                    tmp.append(k.toMap())
                }
                map["TagKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? [Any?] {
                var tmp : [DescribeTagKeysResponseBody.TagKeys.TagKey] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTagKeysResponseBody.TagKeys.TagKey()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagKey = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagKeys: DescribeTagKeysResponseBody.TagKeys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagKeys"] as? [String: Any?] {
            var model = DescribeTagKeysResponseBody.TagKeys()
            model.fromMap(value)
            self.tagKeys = model
        }
    }
}

public class DescribeTagKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTagKeysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTagKeysForExpressConnectRequest : Tea.TeaModel {
    public var keyword: String?

    public var maxResult: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.maxResult != nil {
            map["MaxResult"] = self.maxResult!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["MaxResult"] as? Int32 {
            self.maxResult = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class DescribeTagKeysForExpressConnectResponseBody : Tea.TeaModel {
    public class TagKeys : Tea.TeaModel {
        public class TagKey : Tea.TeaModel {
            public var tagKey: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var tagKey: [DescribeTagKeysForExpressConnectResponseBody.TagKeys.TagKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                var tmp : [Any] = []
                for k in self.tagKey! {
                    tmp.append(k.toMap())
                }
                map["TagKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? [Any?] {
                var tmp : [DescribeTagKeysForExpressConnectResponseBody.TagKeys.TagKey] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTagKeysForExpressConnectResponseBody.TagKeys.TagKey()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagKey = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagKeys: DescribeTagKeysForExpressConnectResponseBody.TagKeys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagKeys"] as? [String: Any?] {
            var model = DescribeTagKeysForExpressConnectResponseBody.TagKeys()
            model.fromMap(value)
            self.tagKeys = model
        }
    }
}

public class DescribeTagKeysForExpressConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagKeysForExpressConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTagKeysForExpressConnectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var maxResult: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [DescribeTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResult != nil {
            map["MaxResult"] = self.maxResult!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResult"] as? Int32 {
            self.maxResult = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeTagsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeTagsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeTagsResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [DescribeTagsResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [DescribeTagsResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTagsResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: DescribeTagsResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = DescribeTagsResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class DescribeTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVRoutersRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
    }
}

public class DescribeVRoutersResponseBody : Tea.TeaModel {
    public class VRouters : Tea.TeaModel {
        public class VRouter : Tea.TeaModel {
            public class RouteTableIds : Tea.TeaModel {
                public var routeTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeTableId != nil {
                        map["RouteTableId"] = self.routeTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RouteTableId"] as? [String] {
                        self.routeTableId = value
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var regionId: String?

            public var routeTableIds: DescribeVRoutersResponseBody.VRouters.VRouter.RouteTableIds?

            public var VRouterId: String?

            public var VRouterName: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeTableIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.routeTableIds != nil {
                    map["RouteTableIds"] = self.routeTableIds?.toMap()
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.VRouterName != nil {
                    map["VRouterName"] = self.VRouterName!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RouteTableIds"] as? [String: Any?] {
                    var model = DescribeVRoutersResponseBody.VRouters.VRouter.RouteTableIds()
                    model.fromMap(value)
                    self.routeTableIds = model
                }
                if let value = dict["VRouterId"] as? String {
                    self.VRouterId = value
                }
                if let value = dict["VRouterName"] as? String {
                    self.VRouterName = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var VRouter: [DescribeVRoutersResponseBody.VRouters.VRouter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.VRouter != nil {
                var tmp : [Any] = []
                for k in self.VRouter! {
                    tmp.append(k.toMap())
                }
                map["VRouter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VRouter"] as? [Any?] {
                var tmp : [DescribeVRoutersResponseBody.VRouters.VRouter] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVRoutersResponseBody.VRouters.VRouter()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.VRouter = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var VRouters: DescribeVRoutersResponseBody.VRouters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.VRouters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.VRouters != nil {
            map["VRouters"] = self.VRouters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VRouters"] as? [String: Any?] {
            var model = DescribeVRoutersResponseBody.VRouters()
            model.fromMap(value)
            self.VRouters = model
        }
    }
}

public class DescribeVRoutersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVRoutersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVRoutersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVSwitchAttributesRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class DescribeVSwitchAttributesResponseBody : Tea.TeaModel {
    public class RouteTable : Tea.TeaModel {
        public var routeTableId: String?

        public var routeTableType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            if self.routeTableType != nil {
                map["RouteTableType"] = self.routeTableType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RouteTableId"] as? String {
                self.routeTableId = value
            }
            if let value = dict["RouteTableType"] as? String {
                self.routeTableType = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var tag: [DescribeVSwitchAttributesResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeVSwitchAttributesResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVSwitchAttributesResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public var availableIpAddressCount: Int64?

    public var cidrBlock: String?

    public var creationTime: String?

    public var description_: String?

    public var enabledIpv6: Bool?

    public var ipv6CidrBlock: String?

    public var isDefault: Bool?

    public var networkAclId: String?

    public var ownerId: Int64?

    public var requestId: String?

    public var resourceGroupId: String?

    public var routeTable: DescribeVSwitchAttributesResponseBody.RouteTable?

    public var shareType: String?

    public var status: String?

    public var tags: DescribeVSwitchAttributesResponseBody.Tags?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeTable?.validate()
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableIpAddressCount != nil {
            map["AvailableIpAddressCount"] = self.availableIpAddressCount!
        }
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabledIpv6 != nil {
            map["EnabledIpv6"] = self.enabledIpv6!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.routeTable != nil {
            map["RouteTable"] = self.routeTable?.toMap()
        }
        if self.shareType != nil {
            map["ShareType"] = self.shareType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvailableIpAddressCount"] as? Int64 {
            self.availableIpAddressCount = value
        }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnabledIpv6"] as? Bool {
            self.enabledIpv6 = value
        }
        if let value = dict["Ipv6CidrBlock"] as? String {
            self.ipv6CidrBlock = value
        }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["RouteTable"] as? [String: Any?] {
            var model = DescribeVSwitchAttributesResponseBody.RouteTable()
            model.fromMap(value)
            self.routeTable = model
        }
        if let value = dict["ShareType"] as? String {
            self.shareType = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeVSwitchAttributesResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VSwitchName"] as? String {
            self.vSwitchName = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeVSwitchAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVSwitchAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVSwitchesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dryRun: Bool?

    public var enableIpv6: Bool?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var tag: [DescribeVSwitchesRequest.Tag]?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public var vSwitchOwnerId: Int64?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vSwitchOwnerId != nil {
            map["VSwitchOwnerId"] = self.vSwitchOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EnableIpv6"] as? Bool {
            self.enableIpv6 = value
        }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeVSwitchesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeVSwitchesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VSwitchName"] as? String {
            self.vSwitchName = value
        }
        if let value = dict["VSwitchOwnerId"] as? Int64 {
            self.vSwitchOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeVSwitchesResponseBody : Tea.TeaModel {
    public class VSwitches : Tea.TeaModel {
        public class VSwitch : Tea.TeaModel {
            public class RouteTable : Tea.TeaModel {
                public var routeTableId: String?

                public var routeTableType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeTableId != nil {
                        map["RouteTableId"] = self.routeTableId!
                    }
                    if self.routeTableType != nil {
                        map["RouteTableType"] = self.routeTableType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RouteTableId"] as? String {
                        self.routeTableId = value
                    }
                    if let value = dict["RouteTableType"] as? String {
                        self.routeTableType = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var availableIpAddressCount: Int64?

            public var cidrBlock: String?

            public var creationTime: String?

            public var description_: String?

            public var enabledIpv6: Bool?

            public var ipv6CidrBlock: String?

            public var isDefault: Bool?

            public var networkAclId: String?

            public var ownerId: Int64?

            public var resourceGroupId: String?

            public var routeTable: DescribeVSwitchesResponseBody.VSwitches.VSwitch.RouteTable?

            public var shareType: String?

            public var status: String?

            public var tags: DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags?

            public var vSwitchId: String?

            public var vSwitchName: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeTable?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableIpAddressCount != nil {
                    map["AvailableIpAddressCount"] = self.availableIpAddressCount!
                }
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabledIpv6 != nil {
                    map["EnabledIpv6"] = self.enabledIpv6!
                }
                if self.ipv6CidrBlock != nil {
                    map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.networkAclId != nil {
                    map["NetworkAclId"] = self.networkAclId!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routeTable != nil {
                    map["RouteTable"] = self.routeTable?.toMap()
                }
                if self.shareType != nil {
                    map["ShareType"] = self.shareType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vSwitchName != nil {
                    map["VSwitchName"] = self.vSwitchName!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableIpAddressCount"] as? Int64 {
                    self.availableIpAddressCount = value
                }
                if let value = dict["CidrBlock"] as? String {
                    self.cidrBlock = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnabledIpv6"] as? Bool {
                    self.enabledIpv6 = value
                }
                if let value = dict["Ipv6CidrBlock"] as? String {
                    self.ipv6CidrBlock = value
                }
                if let value = dict["IsDefault"] as? Bool {
                    self.isDefault = value
                }
                if let value = dict["NetworkAclId"] as? String {
                    self.networkAclId = value
                }
                if let value = dict["OwnerId"] as? Int64 {
                    self.ownerId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RouteTable"] as? [String: Any?] {
                    var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch.RouteTable()
                    model.fromMap(value)
                    self.routeTable = model
                }
                if let value = dict["ShareType"] as? String {
                    self.shareType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VSwitchName"] as? String {
                    self.vSwitchName = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var vSwitch: [DescribeVSwitchesResponseBody.VSwitches.VSwitch]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitch != nil {
                var tmp : [Any] = []
                for k in self.vSwitch! {
                    tmp.append(k.toMap())
                }
                map["VSwitch"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VSwitch"] as? [Any?] {
                var tmp : [DescribeVSwitchesResponseBody.VSwitches.VSwitch] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vSwitch = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vSwitches: DescribeVSwitchesResponseBody.VSwitches?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vSwitches?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vSwitches != nil {
            map["VSwitches"] = self.vSwitches?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VSwitches"] as? [String: Any?] {
            var model = DescribeVSwitchesResponseBody.VSwitches()
            model.fromMap(value)
            self.vSwitches = model
        }
    }
}

public class DescribeVSwitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVSwitchesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVbrHaRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrHaId: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrHaId != nil {
            map["VbrHaId"] = self.vbrHaId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VbrHaId"] as? String {
            self.vbrHaId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class DescribeVbrHaResponseBody : Tea.TeaModel {
    public var creationTime: String?

    public var description_: String?

    public var name: String?

    public var peerVbrId: String?

    public var regionId: String?

    public var requestId: String?

    public var status: String?

    public var vbrHaId: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.peerVbrId != nil {
            map["PeerVbrId"] = self.peerVbrId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vbrHaId != nil {
            map["VbrHaId"] = self.vbrHaId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PeerVbrId"] as? String {
            self.peerVbrId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["VbrHaId"] as? String {
            self.vbrHaId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class DescribeVbrHaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVbrHaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVbrHaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVcoRouteEntriesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryType: String?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntryType"] as? String {
            self.routeEntryType = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class DescribeVcoRouteEntriesResponseBody : Tea.TeaModel {
    public class VcoRouteEntries : Tea.TeaModel {
        public var asPath: String?

        public var community: String?

        public var createTime: Int64?

        public var nextHop: String?

        public var nextHopTunnelIdList: [String]?

        public var routeDest: String?

        public var routeEntryType: String?

        public var source: String?

        public var state: String?

        public var vpnConnectionId: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asPath != nil {
                map["AsPath"] = self.asPath!
            }
            if self.community != nil {
                map["Community"] = self.community!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.nextHop != nil {
                map["NextHop"] = self.nextHop!
            }
            if self.nextHopTunnelIdList != nil {
                map["NextHopTunnelIdList"] = self.nextHopTunnelIdList!
            }
            if self.routeDest != nil {
                map["RouteDest"] = self.routeDest!
            }
            if self.routeEntryType != nil {
                map["RouteEntryType"] = self.routeEntryType!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.vpnConnectionId != nil {
                map["VpnConnectionId"] = self.vpnConnectionId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AsPath"] as? String {
                self.asPath = value
            }
            if let value = dict["Community"] as? String {
                self.community = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["NextHop"] as? String {
                self.nextHop = value
            }
            if let value = dict["NextHopTunnelIdList"] as? [String] {
                self.nextHopTunnelIdList = value
            }
            if let value = dict["RouteDest"] as? String {
                self.routeDest = value
            }
            if let value = dict["RouteEntryType"] as? String {
                self.routeEntryType = value
            }
            if let value = dict["Source"] as? String {
                self.source = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["VpnConnectionId"] as? String {
                self.vpnConnectionId = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public class VpnRouteCounts : Tea.TeaModel {
        public var routeCount: Int32?

        public var routeEntryType: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeCount != nil {
                map["RouteCount"] = self.routeCount!
            }
            if self.routeEntryType != nil {
                map["RouteEntryType"] = self.routeEntryType!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RouteCount"] as? Int32 {
                self.routeCount = value
            }
            if let value = dict["RouteEntryType"] as? String {
                self.routeEntryType = value
            }
            if let value = dict["Source"] as? String {
                self.source = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vcoRouteEntries: [DescribeVcoRouteEntriesResponseBody.VcoRouteEntries]?

    public var vpnRouteCounts: [DescribeVcoRouteEntriesResponseBody.VpnRouteCounts]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vcoRouteEntries != nil {
            var tmp : [Any] = []
            for k in self.vcoRouteEntries! {
                tmp.append(k.toMap())
            }
            map["VcoRouteEntries"] = tmp
        }
        if self.vpnRouteCounts != nil {
            var tmp : [Any] = []
            for k in self.vpnRouteCounts! {
                tmp.append(k.toMap())
            }
            map["VpnRouteCounts"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VcoRouteEntries"] as? [Any?] {
            var tmp : [DescribeVcoRouteEntriesResponseBody.VcoRouteEntries] = []
            for v in value {
                if v != nil {
                    var model = DescribeVcoRouteEntriesResponseBody.VcoRouteEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.vcoRouteEntries = tmp
        }
        if let value = dict["VpnRouteCounts"] as? [Any?] {
            var tmp : [DescribeVcoRouteEntriesResponseBody.VpnRouteCounts] = []
            for v in value {
                if v != nil {
                    var model = DescribeVcoRouteEntriesResponseBody.VpnRouteCounts()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.vpnRouteCounts = tmp
        }
    }
}

public class DescribeVcoRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVcoRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVcoRouteEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVirtualBorderRoutersRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var filter: [DescribeVirtualBorderRoutersRequest.Filter]?

    public var includeCrossAccountVbr: Bool?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribeVirtualBorderRoutersRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.includeCrossAccountVbr != nil {
            map["IncludeCrossAccountVbr"] = self.includeCrossAccountVbr!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeVirtualBorderRoutersRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeVirtualBorderRoutersRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["IncludeCrossAccountVbr"] as? Bool {
            self.includeCrossAccountVbr = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeVirtualBorderRoutersRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeVirtualBorderRoutersRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class DescribeVirtualBorderRoutersResponseBody : Tea.TeaModel {
    public class VirtualBorderRouterSet : Tea.TeaModel {
        public class VirtualBorderRouterType : Tea.TeaModel {
            public class AssociatedCens : Tea.TeaModel {
                public class AssociatedCen : Tea.TeaModel {
                    public var cenId: String?

                    public var cenOwnerId: Int64?

                    public var cenStatus: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cenId != nil {
                            map["CenId"] = self.cenId!
                        }
                        if self.cenOwnerId != nil {
                            map["CenOwnerId"] = self.cenOwnerId!
                        }
                        if self.cenStatus != nil {
                            map["CenStatus"] = self.cenStatus!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CenId"] as? String {
                            self.cenId = value
                        }
                        if let value = dict["CenOwnerId"] as? Int64 {
                            self.cenOwnerId = value
                        }
                        if let value = dict["CenStatus"] as? String {
                            self.cenStatus = value
                        }
                    }
                }
                public var associatedCen: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens.AssociatedCen]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedCen != nil {
                        var tmp : [Any] = []
                        for k in self.associatedCen! {
                            tmp.append(k.toMap())
                        }
                        map["AssociatedCen"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AssociatedCen"] as? [Any?] {
                        var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens.AssociatedCen] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens.AssociatedCen()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.associatedCen = tmp
                    }
                }
            }
            public class AssociatedPhysicalConnections : Tea.TeaModel {
                public class AssociatedPhysicalConnection : Tea.TeaModel {
                    public var circuitCode: String?

                    public var enableIpv6: Bool?

                    public var localGatewayIp: String?

                    public var localIpv6GatewayIp: String?

                    public var peerGatewayIp: String?

                    public var peerIpv6GatewayIp: String?

                    public var peeringIpv6SubnetMask: String?

                    public var peeringSubnetMask: String?

                    public var physicalConnectionBusinessStatus: String?

                    public var physicalConnectionId: String?

                    public var physicalConnectionOwnerUid: String?

                    public var physicalConnectionStatus: String?

                    public var status: String?

                    public var vlanId: String?

                    public var vlanInterfaceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.circuitCode != nil {
                            map["CircuitCode"] = self.circuitCode!
                        }
                        if self.enableIpv6 != nil {
                            map["EnableIpv6"] = self.enableIpv6!
                        }
                        if self.localGatewayIp != nil {
                            map["LocalGatewayIp"] = self.localGatewayIp!
                        }
                        if self.localIpv6GatewayIp != nil {
                            map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
                        }
                        if self.peerGatewayIp != nil {
                            map["PeerGatewayIp"] = self.peerGatewayIp!
                        }
                        if self.peerIpv6GatewayIp != nil {
                            map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
                        }
                        if self.peeringIpv6SubnetMask != nil {
                            map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
                        }
                        if self.peeringSubnetMask != nil {
                            map["PeeringSubnetMask"] = self.peeringSubnetMask!
                        }
                        if self.physicalConnectionBusinessStatus != nil {
                            map["PhysicalConnectionBusinessStatus"] = self.physicalConnectionBusinessStatus!
                        }
                        if self.physicalConnectionId != nil {
                            map["PhysicalConnectionId"] = self.physicalConnectionId!
                        }
                        if self.physicalConnectionOwnerUid != nil {
                            map["PhysicalConnectionOwnerUid"] = self.physicalConnectionOwnerUid!
                        }
                        if self.physicalConnectionStatus != nil {
                            map["PhysicalConnectionStatus"] = self.physicalConnectionStatus!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.vlanId != nil {
                            map["VlanId"] = self.vlanId!
                        }
                        if self.vlanInterfaceId != nil {
                            map["VlanInterfaceId"] = self.vlanInterfaceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CircuitCode"] as? String {
                            self.circuitCode = value
                        }
                        if let value = dict["EnableIpv6"] as? Bool {
                            self.enableIpv6 = value
                        }
                        if let value = dict["LocalGatewayIp"] as? String {
                            self.localGatewayIp = value
                        }
                        if let value = dict["LocalIpv6GatewayIp"] as? String {
                            self.localIpv6GatewayIp = value
                        }
                        if let value = dict["PeerGatewayIp"] as? String {
                            self.peerGatewayIp = value
                        }
                        if let value = dict["PeerIpv6GatewayIp"] as? String {
                            self.peerIpv6GatewayIp = value
                        }
                        if let value = dict["PeeringIpv6SubnetMask"] as? String {
                            self.peeringIpv6SubnetMask = value
                        }
                        if let value = dict["PeeringSubnetMask"] as? String {
                            self.peeringSubnetMask = value
                        }
                        if let value = dict["PhysicalConnectionBusinessStatus"] as? String {
                            self.physicalConnectionBusinessStatus = value
                        }
                        if let value = dict["PhysicalConnectionId"] as? String {
                            self.physicalConnectionId = value
                        }
                        if let value = dict["PhysicalConnectionOwnerUid"] as? String {
                            self.physicalConnectionOwnerUid = value
                        }
                        if let value = dict["PhysicalConnectionStatus"] as? String {
                            self.physicalConnectionStatus = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                        if let value = dict["VlanId"] as? String {
                            self.vlanId = value
                        }
                        if let value = dict["VlanInterfaceId"] as? String {
                            self.vlanInterfaceId = value
                        }
                    }
                }
                public var associatedPhysicalConnection: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections.AssociatedPhysicalConnection]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedPhysicalConnection != nil {
                        var tmp : [Any] = []
                        for k in self.associatedPhysicalConnection! {
                            tmp.append(k.toMap())
                        }
                        map["AssociatedPhysicalConnection"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AssociatedPhysicalConnection"] as? [Any?] {
                        var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections.AssociatedPhysicalConnection] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections.AssociatedPhysicalConnection()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.associatedPhysicalConnection = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tags: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags.Tags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tags != nil {
                        var tmp : [Any] = []
                        for k in self.tags! {
                            tmp.append(k.toMap())
                        }
                        map["Tags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tags"] as? [Any?] {
                        var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags.Tags] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags.Tags()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tags = tmp
                    }
                }
            }
            public var accessPointId: String?

            public var activationTime: String?

            public var associatedCens: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens?

            public var associatedPhysicalConnections: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections?

            public var bandwidth: Int32?

            public var circuitCode: String?

            public var cloudBoxInstanceId: String?

            public var creationTime: String?

            public var description_: String?

            public var detectMultiplier: Int64?

            public var eccId: String?

            public var ecrAttatchStatus: String?

            public var ecrId: String?

            public var ecrOwnerId: String?

            public var enableIpv6: Bool?

            public var localGatewayIp: String?

            public var localIpv6GatewayIp: String?

            public var minRxInterval: Int64?

            public var minTxInterval: Int64?

            public var mtu: Int32?

            public var name: String?

            public var PConnVbrChargeType: String?

            public var PConnVbrExpireTime: String?

            public var peerGatewayIp: String?

            public var peerIpv6GatewayIp: String?

            public var peeringIpv6SubnetMask: String?

            public var peeringSubnetMask: String?

            public var physicalConnectionBusinessStatus: String?

            public var physicalConnectionId: String?

            public var physicalConnectionOwnerUid: String?

            public var physicalConnectionStatus: String?

            public var recoveryTime: String?

            public var resourceGroupId: String?

            public var routeTableId: String?

            public var sitelinkEnable: Bool?

            public var status: String?

            public var tags: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags?

            public var terminationTime: String?

            public var type: String?

            public var vbrId: String?

            public var vlanId: Int32?

            public var vlanInterfaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedCens?.validate()
                try self.associatedPhysicalConnections?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.activationTime != nil {
                    map["ActivationTime"] = self.activationTime!
                }
                if self.associatedCens != nil {
                    map["AssociatedCens"] = self.associatedCens?.toMap()
                }
                if self.associatedPhysicalConnections != nil {
                    map["AssociatedPhysicalConnections"] = self.associatedPhysicalConnections?.toMap()
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.cloudBoxInstanceId != nil {
                    map["CloudBoxInstanceId"] = self.cloudBoxInstanceId!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.detectMultiplier != nil {
                    map["DetectMultiplier"] = self.detectMultiplier!
                }
                if self.eccId != nil {
                    map["EccId"] = self.eccId!
                }
                if self.ecrAttatchStatus != nil {
                    map["EcrAttatchStatus"] = self.ecrAttatchStatus!
                }
                if self.ecrId != nil {
                    map["EcrId"] = self.ecrId!
                }
                if self.ecrOwnerId != nil {
                    map["EcrOwnerId"] = self.ecrOwnerId!
                }
                if self.enableIpv6 != nil {
                    map["EnableIpv6"] = self.enableIpv6!
                }
                if self.localGatewayIp != nil {
                    map["LocalGatewayIp"] = self.localGatewayIp!
                }
                if self.localIpv6GatewayIp != nil {
                    map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
                }
                if self.minRxInterval != nil {
                    map["MinRxInterval"] = self.minRxInterval!
                }
                if self.minTxInterval != nil {
                    map["MinTxInterval"] = self.minTxInterval!
                }
                if self.mtu != nil {
                    map["Mtu"] = self.mtu!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.PConnVbrChargeType != nil {
                    map["PConnVbrChargeType"] = self.PConnVbrChargeType!
                }
                if self.PConnVbrExpireTime != nil {
                    map["PConnVbrExpireTime"] = self.PConnVbrExpireTime!
                }
                if self.peerGatewayIp != nil {
                    map["PeerGatewayIp"] = self.peerGatewayIp!
                }
                if self.peerIpv6GatewayIp != nil {
                    map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
                }
                if self.peeringIpv6SubnetMask != nil {
                    map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
                }
                if self.peeringSubnetMask != nil {
                    map["PeeringSubnetMask"] = self.peeringSubnetMask!
                }
                if self.physicalConnectionBusinessStatus != nil {
                    map["PhysicalConnectionBusinessStatus"] = self.physicalConnectionBusinessStatus!
                }
                if self.physicalConnectionId != nil {
                    map["PhysicalConnectionId"] = self.physicalConnectionId!
                }
                if self.physicalConnectionOwnerUid != nil {
                    map["PhysicalConnectionOwnerUid"] = self.physicalConnectionOwnerUid!
                }
                if self.physicalConnectionStatus != nil {
                    map["PhysicalConnectionStatus"] = self.physicalConnectionStatus!
                }
                if self.recoveryTime != nil {
                    map["RecoveryTime"] = self.recoveryTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.sitelinkEnable != nil {
                    map["SitelinkEnable"] = self.sitelinkEnable!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.terminationTime != nil {
                    map["TerminationTime"] = self.terminationTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.vbrId != nil {
                    map["VbrId"] = self.vbrId!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                if self.vlanInterfaceId != nil {
                    map["VlanInterfaceId"] = self.vlanInterfaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessPointId"] as? String {
                    self.accessPointId = value
                }
                if let value = dict["ActivationTime"] as? String {
                    self.activationTime = value
                }
                if let value = dict["AssociatedCens"] as? [String: Any?] {
                    var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedCens()
                    model.fromMap(value)
                    self.associatedCens = model
                }
                if let value = dict["AssociatedPhysicalConnections"] as? [String: Any?] {
                    var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.AssociatedPhysicalConnections()
                    model.fromMap(value)
                    self.associatedPhysicalConnections = model
                }
                if let value = dict["Bandwidth"] as? Int32 {
                    self.bandwidth = value
                }
                if let value = dict["CircuitCode"] as? String {
                    self.circuitCode = value
                }
                if let value = dict["CloudBoxInstanceId"] as? String {
                    self.cloudBoxInstanceId = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DetectMultiplier"] as? Int64 {
                    self.detectMultiplier = value
                }
                if let value = dict["EccId"] as? String {
                    self.eccId = value
                }
                if let value = dict["EcrAttatchStatus"] as? String {
                    self.ecrAttatchStatus = value
                }
                if let value = dict["EcrId"] as? String {
                    self.ecrId = value
                }
                if let value = dict["EcrOwnerId"] as? String {
                    self.ecrOwnerId = value
                }
                if let value = dict["EnableIpv6"] as? Bool {
                    self.enableIpv6 = value
                }
                if let value = dict["LocalGatewayIp"] as? String {
                    self.localGatewayIp = value
                }
                if let value = dict["LocalIpv6GatewayIp"] as? String {
                    self.localIpv6GatewayIp = value
                }
                if let value = dict["MinRxInterval"] as? Int64 {
                    self.minRxInterval = value
                }
                if let value = dict["MinTxInterval"] as? Int64 {
                    self.minTxInterval = value
                }
                if let value = dict["Mtu"] as? Int32 {
                    self.mtu = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["PConnVbrChargeType"] as? String {
                    self.PConnVbrChargeType = value
                }
                if let value = dict["PConnVbrExpireTime"] as? String {
                    self.PConnVbrExpireTime = value
                }
                if let value = dict["PeerGatewayIp"] as? String {
                    self.peerGatewayIp = value
                }
                if let value = dict["PeerIpv6GatewayIp"] as? String {
                    self.peerIpv6GatewayIp = value
                }
                if let value = dict["PeeringIpv6SubnetMask"] as? String {
                    self.peeringIpv6SubnetMask = value
                }
                if let value = dict["PeeringSubnetMask"] as? String {
                    self.peeringSubnetMask = value
                }
                if let value = dict["PhysicalConnectionBusinessStatus"] as? String {
                    self.physicalConnectionBusinessStatus = value
                }
                if let value = dict["PhysicalConnectionId"] as? String {
                    self.physicalConnectionId = value
                }
                if let value = dict["PhysicalConnectionOwnerUid"] as? String {
                    self.physicalConnectionOwnerUid = value
                }
                if let value = dict["PhysicalConnectionStatus"] as? String {
                    self.physicalConnectionStatus = value
                }
                if let value = dict["RecoveryTime"] as? String {
                    self.recoveryTime = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RouteTableId"] as? String {
                    self.routeTableId = value
                }
                if let value = dict["SitelinkEnable"] as? Bool {
                    self.sitelinkEnable = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TerminationTime"] as? String {
                    self.terminationTime = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["VbrId"] as? String {
                    self.vbrId = value
                }
                if let value = dict["VlanId"] as? Int32 {
                    self.vlanId = value
                }
                if let value = dict["VlanInterfaceId"] as? String {
                    self.vlanInterfaceId = value
                }
            }
        }
        public var virtualBorderRouterType: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.virtualBorderRouterType != nil {
                var tmp : [Any] = []
                for k in self.virtualBorderRouterType! {
                    tmp.append(k.toMap())
                }
                map["VirtualBorderRouterType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VirtualBorderRouterType"] as? [Any?] {
                var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.virtualBorderRouterType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualBorderRouterSet: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.virtualBorderRouterSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualBorderRouterSet != nil {
            map["VirtualBorderRouterSet"] = self.virtualBorderRouterSet?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VirtualBorderRouterSet"] as? [String: Any?] {
            var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet()
            model.fromMap(value)
            self.virtualBorderRouterSet = model
        }
    }
}

public class DescribeVirtualBorderRoutersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVirtualBorderRoutersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVirtualBorderRoutersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public var filter: [DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody : Tea.TeaModel {
    public class VirtualBorderRouterForPhysicalConnectionSet : Tea.TeaModel {
        public class VirtualBorderRouterForPhysicalConnectionType : Tea.TeaModel {
            public var activationTime: String?

            public var bandwidth: String?

            public var bandwidthStatus: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var eccId: String?

            public var enableIpv6: Bool?

            public var localGatewayIp: String?

            public var localIpv6GatewayIp: String?

            public var PConnVbrBussinessStatus: String?

            public var PConnVbrChargeType: String?

            public var PConnVbrExpireTime: String?

            public var peerGatewayIp: String?

            public var peerIpv6GatewayIp: String?

            public var peeringIpv6SubnetMask: String?

            public var peeringSubnetMask: String?

            public var recoveryTime: String?

            public var status: String?

            public var terminationTime: String?

            public var type: String?

            public var vbrId: String?

            public var vbrOwnerUid: Int64?

            public var vlanId: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activationTime != nil {
                    map["ActivationTime"] = self.activationTime!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthStatus != nil {
                    map["BandwidthStatus"] = self.bandwidthStatus!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.eccId != nil {
                    map["EccId"] = self.eccId!
                }
                if self.enableIpv6 != nil {
                    map["EnableIpv6"] = self.enableIpv6!
                }
                if self.localGatewayIp != nil {
                    map["LocalGatewayIp"] = self.localGatewayIp!
                }
                if self.localIpv6GatewayIp != nil {
                    map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
                }
                if self.PConnVbrBussinessStatus != nil {
                    map["PConnVbrBussinessStatus"] = self.PConnVbrBussinessStatus!
                }
                if self.PConnVbrChargeType != nil {
                    map["PConnVbrChargeType"] = self.PConnVbrChargeType!
                }
                if self.PConnVbrExpireTime != nil {
                    map["PConnVbrExpireTime"] = self.PConnVbrExpireTime!
                }
                if self.peerGatewayIp != nil {
                    map["PeerGatewayIp"] = self.peerGatewayIp!
                }
                if self.peerIpv6GatewayIp != nil {
                    map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
                }
                if self.peeringIpv6SubnetMask != nil {
                    map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
                }
                if self.peeringSubnetMask != nil {
                    map["PeeringSubnetMask"] = self.peeringSubnetMask!
                }
                if self.recoveryTime != nil {
                    map["RecoveryTime"] = self.recoveryTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.terminationTime != nil {
                    map["TerminationTime"] = self.terminationTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.vbrId != nil {
                    map["VbrId"] = self.vbrId!
                }
                if self.vbrOwnerUid != nil {
                    map["VbrOwnerUid"] = self.vbrOwnerUid!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActivationTime"] as? String {
                    self.activationTime = value
                }
                if let value = dict["Bandwidth"] as? String {
                    self.bandwidth = value
                }
                if let value = dict["BandwidthStatus"] as? String {
                    self.bandwidthStatus = value
                }
                if let value = dict["CircuitCode"] as? String {
                    self.circuitCode = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["EccId"] as? String {
                    self.eccId = value
                }
                if let value = dict["EnableIpv6"] as? Bool {
                    self.enableIpv6 = value
                }
                if let value = dict["LocalGatewayIp"] as? String {
                    self.localGatewayIp = value
                }
                if let value = dict["LocalIpv6GatewayIp"] as? String {
                    self.localIpv6GatewayIp = value
                }
                if let value = dict["PConnVbrBussinessStatus"] as? String {
                    self.PConnVbrBussinessStatus = value
                }
                if let value = dict["PConnVbrChargeType"] as? String {
                    self.PConnVbrChargeType = value
                }
                if let value = dict["PConnVbrExpireTime"] as? String {
                    self.PConnVbrExpireTime = value
                }
                if let value = dict["PeerGatewayIp"] as? String {
                    self.peerGatewayIp = value
                }
                if let value = dict["PeerIpv6GatewayIp"] as? String {
                    self.peerIpv6GatewayIp = value
                }
                if let value = dict["PeeringIpv6SubnetMask"] as? String {
                    self.peeringIpv6SubnetMask = value
                }
                if let value = dict["PeeringSubnetMask"] as? String {
                    self.peeringSubnetMask = value
                }
                if let value = dict["RecoveryTime"] as? String {
                    self.recoveryTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TerminationTime"] as? String {
                    self.terminationTime = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["VbrId"] as? String {
                    self.vbrId = value
                }
                if let value = dict["VbrOwnerUid"] as? Int64 {
                    self.vbrOwnerUid = value
                }
                if let value = dict["VlanId"] as? Int32 {
                    self.vlanId = value
                }
            }
        }
        public var virtualBorderRouterForPhysicalConnectionType: [DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.virtualBorderRouterForPhysicalConnectionType != nil {
                var tmp : [Any] = []
                for k in self.virtualBorderRouterForPhysicalConnectionType! {
                    tmp.append(k.toMap())
                }
                map["VirtualBorderRouterForPhysicalConnectionType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VirtualBorderRouterForPhysicalConnectionType"] as? [Any?] {
                var tmp : [DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.virtualBorderRouterForPhysicalConnectionType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualBorderRouterForPhysicalConnectionSet: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.virtualBorderRouterForPhysicalConnectionSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualBorderRouterForPhysicalConnectionSet != nil {
            map["VirtualBorderRouterForPhysicalConnectionSet"] = self.virtualBorderRouterForPhysicalConnectionSet?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VirtualBorderRouterForPhysicalConnectionSet"] as? [String: Any?] {
            var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet()
            model.fromMap(value)
            self.virtualBorderRouterForPhysicalConnectionSet = model
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpcAttributeRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeVpcAttributeResponseBody : Tea.TeaModel {
    public class AssociatedCens : Tea.TeaModel {
        public class AssociatedCen : Tea.TeaModel {
            public var cenId: String?

            public var cenOwnerId: Int64?

            public var cenStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cenId != nil {
                    map["CenId"] = self.cenId!
                }
                if self.cenOwnerId != nil {
                    map["CenOwnerId"] = self.cenOwnerId!
                }
                if self.cenStatus != nil {
                    map["CenStatus"] = self.cenStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CenId"] as? String {
                    self.cenId = value
                }
                if let value = dict["CenOwnerId"] as? Int64 {
                    self.cenOwnerId = value
                }
                if let value = dict["CenStatus"] as? String {
                    self.cenStatus = value
                }
            }
        }
        public var associatedCen: [DescribeVpcAttributeResponseBody.AssociatedCens.AssociatedCen]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associatedCen != nil {
                var tmp : [Any] = []
                for k in self.associatedCen! {
                    tmp.append(k.toMap())
                }
                map["AssociatedCen"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssociatedCen"] as? [Any?] {
                var tmp : [DescribeVpcAttributeResponseBody.AssociatedCens.AssociatedCen] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpcAttributeResponseBody.AssociatedCens.AssociatedCen()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.associatedCen = tmp
            }
        }
    }
    public class AssociatedPropagationSources : Tea.TeaModel {
        public class AssociatedPropagationSources : Tea.TeaModel {
            public var routePropagated: Bool?

            public var sourceInstanceId: String?

            public var sourceOwnerId: Int64?

            public var sourceType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.routePropagated != nil {
                    map["RoutePropagated"] = self.routePropagated!
                }
                if self.sourceInstanceId != nil {
                    map["SourceInstanceId"] = self.sourceInstanceId!
                }
                if self.sourceOwnerId != nil {
                    map["SourceOwnerId"] = self.sourceOwnerId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RoutePropagated"] as? Bool {
                    self.routePropagated = value
                }
                if let value = dict["SourceInstanceId"] as? String {
                    self.sourceInstanceId = value
                }
                if let value = dict["SourceOwnerId"] as? Int64 {
                    self.sourceOwnerId = value
                }
                if let value = dict["SourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var associatedPropagationSources: [DescribeVpcAttributeResponseBody.AssociatedPropagationSources.AssociatedPropagationSources]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associatedPropagationSources != nil {
                var tmp : [Any] = []
                for k in self.associatedPropagationSources! {
                    tmp.append(k.toMap())
                }
                map["AssociatedPropagationSources"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssociatedPropagationSources"] as? [Any?] {
                var tmp : [DescribeVpcAttributeResponseBody.AssociatedPropagationSources.AssociatedPropagationSources] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpcAttributeResponseBody.AssociatedPropagationSources.AssociatedPropagationSources()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.associatedPropagationSources = tmp
            }
        }
    }
    public class CloudResources : Tea.TeaModel {
        public class CloudResourceSetType : Tea.TeaModel {
            public var resourceCount: Int32?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceCount != nil {
                    map["ResourceCount"] = self.resourceCount!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceCount"] as? Int32 {
                    self.resourceCount = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
            }
        }
        public var cloudResourceSetType: [DescribeVpcAttributeResponseBody.CloudResources.CloudResourceSetType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cloudResourceSetType != nil {
                var tmp : [Any] = []
                for k in self.cloudResourceSetType! {
                    tmp.append(k.toMap())
                }
                map["CloudResourceSetType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CloudResourceSetType"] as? [Any?] {
                var tmp : [DescribeVpcAttributeResponseBody.CloudResources.CloudResourceSetType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpcAttributeResponseBody.CloudResources.CloudResourceSetType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.cloudResourceSetType = tmp
            }
        }
    }
    public class Ipv6CidrBlocks : Tea.TeaModel {
        public class Ipv6CidrBlock : Tea.TeaModel {
            public var ipv6CidrBlock: String?

            public var ipv6Isp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6CidrBlock != nil {
                    map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
                }
                if self.ipv6Isp != nil {
                    map["Ipv6Isp"] = self.ipv6Isp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ipv6CidrBlock"] as? String {
                    self.ipv6CidrBlock = value
                }
                if let value = dict["Ipv6Isp"] as? String {
                    self.ipv6Isp = value
                }
            }
        }
        public var ipv6CidrBlock: [DescribeVpcAttributeResponseBody.Ipv6CidrBlocks.Ipv6CidrBlock]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6CidrBlock != nil {
                var tmp : [Any] = []
                for k in self.ipv6CidrBlock! {
                    tmp.append(k.toMap())
                }
                map["Ipv6CidrBlock"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6CidrBlock"] as? [Any?] {
                var tmp : [DescribeVpcAttributeResponseBody.Ipv6CidrBlocks.Ipv6CidrBlock] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpcAttributeResponseBody.Ipv6CidrBlocks.Ipv6CidrBlock()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6CidrBlock = tmp
            }
        }
    }
    public class SecondaryCidrBlocks : Tea.TeaModel {
        public var secondaryCidrBlock: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secondaryCidrBlock != nil {
                map["SecondaryCidrBlock"] = self.secondaryCidrBlock!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecondaryCidrBlock"] as? [String] {
                self.secondaryCidrBlock = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var tag: [DescribeVpcAttributeResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeVpcAttributeResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpcAttributeResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public class UserCidrs : Tea.TeaModel {
        public var userCidr: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userCidr != nil {
                map["UserCidr"] = self.userCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["UserCidr"] as? [String] {
                self.userCidr = value
            }
        }
    }
    public class VSwitchIds : Tea.TeaModel {
        public var vSwitchId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VSwitchId"] as? [String] {
                self.vSwitchId = value
            }
        }
    }
    public var associatedCens: DescribeVpcAttributeResponseBody.AssociatedCens?

    public var associatedPropagationSources: DescribeVpcAttributeResponseBody.AssociatedPropagationSources?

    public var cidrBlock: String?

    public var classicLinkEnabled: Bool?

    public var cloudResources: DescribeVpcAttributeResponseBody.CloudResources?

    public var creationTime: String?

    public var description_: String?

    public var dhcpOptionsSetId: String?

    public var dhcpOptionsSetStatus: String?

    public var dnsHostnameStatus: String?

    public var enabledIpv6: Bool?

    public var ipv4GatewayId: String?

    public var ipv6CidrBlock: String?

    public var ipv6CidrBlocks: DescribeVpcAttributeResponseBody.Ipv6CidrBlocks?

    public var isDefault: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var secondaryCidrBlocks: DescribeVpcAttributeResponseBody.SecondaryCidrBlocks?

    public var status: String?

    public var supportIpv4Gateway: Bool?

    public var tags: DescribeVpcAttributeResponseBody.Tags?

    public var userCidrs: DescribeVpcAttributeResponseBody.UserCidrs?

    public var VRouterId: String?

    public var vSwitchIds: DescribeVpcAttributeResponseBody.VSwitchIds?

    public var vpcId: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.associatedCens?.validate()
        try self.associatedPropagationSources?.validate()
        try self.cloudResources?.validate()
        try self.ipv6CidrBlocks?.validate()
        try self.secondaryCidrBlocks?.validate()
        try self.tags?.validate()
        try self.userCidrs?.validate()
        try self.vSwitchIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associatedCens != nil {
            map["AssociatedCens"] = self.associatedCens?.toMap()
        }
        if self.associatedPropagationSources != nil {
            map["AssociatedPropagationSources"] = self.associatedPropagationSources?.toMap()
        }
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.classicLinkEnabled != nil {
            map["ClassicLinkEnabled"] = self.classicLinkEnabled!
        }
        if self.cloudResources != nil {
            map["CloudResources"] = self.cloudResources?.toMap()
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dhcpOptionsSetStatus != nil {
            map["DhcpOptionsSetStatus"] = self.dhcpOptionsSetStatus!
        }
        if self.dnsHostnameStatus != nil {
            map["DnsHostnameStatus"] = self.dnsHostnameStatus!
        }
        if self.enabledIpv6 != nil {
            map["EnabledIpv6"] = self.enabledIpv6!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ipv6CidrBlocks != nil {
            map["Ipv6CidrBlocks"] = self.ipv6CidrBlocks?.toMap()
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.secondaryCidrBlocks != nil {
            map["SecondaryCidrBlocks"] = self.secondaryCidrBlocks?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.supportIpv4Gateway != nil {
            map["SupportIpv4Gateway"] = self.supportIpv4Gateway!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.userCidrs != nil {
            map["UserCidrs"] = self.userCidrs?.toMap()
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds?.toMap()
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AssociatedCens"] as? [String: Any?] {
            var model = DescribeVpcAttributeResponseBody.AssociatedCens()
            model.fromMap(value)
            self.associatedCens = model
        }
        if let value = dict["AssociatedPropagationSources"] as? [String: Any?] {
            var model = DescribeVpcAttributeResponseBody.AssociatedPropagationSources()
            model.fromMap(value)
            self.associatedPropagationSources = model
        }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["ClassicLinkEnabled"] as? Bool {
            self.classicLinkEnabled = value
        }
        if let value = dict["CloudResources"] as? [String: Any?] {
            var model = DescribeVpcAttributeResponseBody.CloudResources()
            model.fromMap(value)
            self.cloudResources = model
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["DhcpOptionsSetStatus"] as? String {
            self.dhcpOptionsSetStatus = value
        }
        if let value = dict["DnsHostnameStatus"] as? String {
            self.dnsHostnameStatus = value
        }
        if let value = dict["EnabledIpv6"] as? Bool {
            self.enabledIpv6 = value
        }
        if let value = dict["Ipv4GatewayId"] as? String {
            self.ipv4GatewayId = value
        }
        if let value = dict["Ipv6CidrBlock"] as? String {
            self.ipv6CidrBlock = value
        }
        if let value = dict["Ipv6CidrBlocks"] as? [String: Any?] {
            var model = DescribeVpcAttributeResponseBody.Ipv6CidrBlocks()
            model.fromMap(value)
            self.ipv6CidrBlocks = model
        }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecondaryCidrBlocks"] as? [String: Any?] {
            var model = DescribeVpcAttributeResponseBody.SecondaryCidrBlocks()
            model.fromMap(value)
            self.secondaryCidrBlocks = model
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["SupportIpv4Gateway"] as? Bool {
            self.supportIpv4Gateway = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeVpcAttributeResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["UserCidrs"] as? [String: Any?] {
            var model = DescribeVpcAttributeResponseBody.UserCidrs()
            model.fromMap(value)
            self.userCidrs = model
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
        if let value = dict["VSwitchIds"] as? [String: Any?] {
            var model = DescribeVpcAttributeResponseBody.VSwitchIds()
            model.fromMap(value)
            self.vSwitchIds = model
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpcName"] as? String {
            self.vpcName = value
        }
    }
}

public class DescribeVpcAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpcAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpcGrantRulesToEcrRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ecrInstanceId: String?

    public var ecrOwnerId: Int64?

    public var instanceId: String?

    public var instanceType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [DescribeVpcGrantRulesToEcrRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ecrInstanceId != nil {
            map["EcrInstanceId"] = self.ecrInstanceId!
        }
        if self.ecrOwnerId != nil {
            map["EcrOwnerId"] = self.ecrOwnerId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EcrInstanceId"] as? String {
            self.ecrInstanceId = value
        }
        if let value = dict["EcrOwnerId"] as? Int64 {
            self.ecrOwnerId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeVpcGrantRulesToEcrRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeVpcGrantRulesToEcrRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class DescribeVpcGrantRulesToEcrResponseBody : Tea.TeaModel {
    public class GrantRuleModels : Tea.TeaModel {
        public var creationTime: String?

        public var ecrId: String?

        public var ecrOwnerId: Int64?

        public var instanceId: String?

        public var instanceUid: Int64?

        public var regionNo: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ecrId != nil {
                map["EcrId"] = self.ecrId!
            }
            if self.ecrOwnerId != nil {
                map["EcrOwnerId"] = self.ecrOwnerId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceUid != nil {
                map["InstanceUid"] = self.instanceUid!
            }
            if self.regionNo != nil {
                map["RegionNo"] = self.regionNo!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["EcrId"] as? String {
                self.ecrId = value
            }
            if let value = dict["EcrOwnerId"] as? Int64 {
                self.ecrOwnerId = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceUid"] as? Int64 {
                self.instanceUid = value
            }
            if let value = dict["RegionNo"] as? String {
                self.regionNo = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var grantRuleModels: [DescribeVpcGrantRulesToEcrResponseBody.GrantRuleModels]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grantRuleModels != nil {
            var tmp : [Any] = []
            for k in self.grantRuleModels! {
                tmp.append(k.toMap())
            }
            map["GrantRuleModels"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GrantRuleModels"] as? [Any?] {
            var tmp : [DescribeVpcGrantRulesToEcrResponseBody.GrantRuleModels] = []
            for v in value {
                if v != nil {
                    var model = DescribeVpcGrantRulesToEcrResponseBody.GrantRuleModels()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.grantRuleModels = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeVpcGrantRulesToEcrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcGrantRulesToEcrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpcGrantRulesToEcrResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpcsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var enableIpv6: Bool?

    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeVpcsRequest.Tag]?

    public var vpcId: String?

    public var vpcName: String?

    public var vpcOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        if self.vpcOwnerId != nil {
            map["VpcOwnerId"] = self.vpcOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EnableIpv6"] as? Bool {
            self.enableIpv6 = value
        }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeVpcsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeVpcsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpcName"] as? String {
            self.vpcName = value
        }
        if let value = dict["VpcOwnerId"] as? Int64 {
            self.vpcOwnerId = value
        }
    }
}

public class DescribeVpcsResponseBody : Tea.TeaModel {
    public class Vpcs : Tea.TeaModel {
        public class Vpc : Tea.TeaModel {
            public class Ipv6CidrBlocks : Tea.TeaModel {
                public class Ipv6CidrBlock : Tea.TeaModel {
                    public var ipv6CidrBlock: String?

                    public var ipv6Isp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv6CidrBlock != nil {
                            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
                        }
                        if self.ipv6Isp != nil {
                            map["Ipv6Isp"] = self.ipv6Isp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Ipv6CidrBlock"] as? String {
                            self.ipv6CidrBlock = value
                        }
                        if let value = dict["Ipv6Isp"] as? String {
                            self.ipv6Isp = value
                        }
                    }
                }
                public var ipv6CidrBlock: [DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks.Ipv6CidrBlock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6CidrBlock != nil {
                        var tmp : [Any] = []
                        for k in self.ipv6CidrBlock! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv6CidrBlock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ipv6CidrBlock"] as? [Any?] {
                        var tmp : [DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks.Ipv6CidrBlock] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks.Ipv6CidrBlock()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ipv6CidrBlock = tmp
                    }
                }
            }
            public class NatGatewayIds : Tea.TeaModel {
                public var natGatewayIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.natGatewayIds != nil {
                        map["NatGatewayIds"] = self.natGatewayIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NatGatewayIds"] as? [String] {
                        self.natGatewayIds = value
                    }
                }
            }
            public class RouterTableIds : Tea.TeaModel {
                public var routerTableIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routerTableIds != nil {
                        map["RouterTableIds"] = self.routerTableIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RouterTableIds"] as? [String] {
                        self.routerTableIds = value
                    }
                }
            }
            public class SecondaryCidrBlocks : Tea.TeaModel {
                public var secondaryCidrBlock: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.secondaryCidrBlock != nil {
                        map["SecondaryCidrBlock"] = self.secondaryCidrBlock!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SecondaryCidrBlock"] as? [String] {
                        self.secondaryCidrBlock = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeVpcsResponseBody.Vpcs.Vpc.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeVpcsResponseBody.Vpcs.Vpc.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeVpcsResponseBody.Vpcs.Vpc.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public class UserCidrs : Tea.TeaModel {
                public var userCidr: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.userCidr != nil {
                        map["UserCidr"] = self.userCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["UserCidr"] as? [String] {
                        self.userCidr = value
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VSwitchId"] as? [String] {
                        self.vSwitchId = value
                    }
                }
            }
            public var cenStatus: String?

            public var cidrBlock: String?

            public var creationTime: String?

            public var description_: String?

            public var dhcpOptionsSetId: String?

            public var dhcpOptionsSetStatus: String?

            public var dnsHostnameStatus: String?

            public var enabledIpv6: Bool?

            public var ipv6CidrBlock: String?

            public var ipv6CidrBlocks: DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks?

            public var isDefault: Bool?

            public var natGatewayIds: DescribeVpcsResponseBody.Vpcs.Vpc.NatGatewayIds?

            public var ownerId: Int64?

            public var regionId: String?

            public var resourceGroupId: String?

            public var routerTableIds: DescribeVpcsResponseBody.Vpcs.Vpc.RouterTableIds?

            public var secondaryCidrBlocks: DescribeVpcsResponseBody.Vpcs.Vpc.SecondaryCidrBlocks?

            public var status: String?

            public var tags: DescribeVpcsResponseBody.Vpcs.Vpc.Tags?

            public var userCidrs: DescribeVpcsResponseBody.Vpcs.Vpc.UserCidrs?

            public var VRouterId: String?

            public var vSwitchIds: DescribeVpcsResponseBody.Vpcs.Vpc.VSwitchIds?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ipv6CidrBlocks?.validate()
                try self.natGatewayIds?.validate()
                try self.routerTableIds?.validate()
                try self.secondaryCidrBlocks?.validate()
                try self.tags?.validate()
                try self.userCidrs?.validate()
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cenStatus != nil {
                    map["CenStatus"] = self.cenStatus!
                }
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dhcpOptionsSetId != nil {
                    map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
                }
                if self.dhcpOptionsSetStatus != nil {
                    map["DhcpOptionsSetStatus"] = self.dhcpOptionsSetStatus!
                }
                if self.dnsHostnameStatus != nil {
                    map["DnsHostnameStatus"] = self.dnsHostnameStatus!
                }
                if self.enabledIpv6 != nil {
                    map["EnabledIpv6"] = self.enabledIpv6!
                }
                if self.ipv6CidrBlock != nil {
                    map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
                }
                if self.ipv6CidrBlocks != nil {
                    map["Ipv6CidrBlocks"] = self.ipv6CidrBlocks?.toMap()
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.natGatewayIds != nil {
                    map["NatGatewayIds"] = self.natGatewayIds?.toMap()
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routerTableIds != nil {
                    map["RouterTableIds"] = self.routerTableIds?.toMap()
                }
                if self.secondaryCidrBlocks != nil {
                    map["SecondaryCidrBlocks"] = self.secondaryCidrBlocks?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.userCidrs != nil {
                    map["UserCidrs"] = self.userCidrs?.toMap()
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CenStatus"] as? String {
                    self.cenStatus = value
                }
                if let value = dict["CidrBlock"] as? String {
                    self.cidrBlock = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DhcpOptionsSetId"] as? String {
                    self.dhcpOptionsSetId = value
                }
                if let value = dict["DhcpOptionsSetStatus"] as? String {
                    self.dhcpOptionsSetStatus = value
                }
                if let value = dict["DnsHostnameStatus"] as? String {
                    self.dnsHostnameStatus = value
                }
                if let value = dict["EnabledIpv6"] as? Bool {
                    self.enabledIpv6 = value
                }
                if let value = dict["Ipv6CidrBlock"] as? String {
                    self.ipv6CidrBlock = value
                }
                if let value = dict["Ipv6CidrBlocks"] as? [String: Any?] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.Ipv6CidrBlocks()
                    model.fromMap(value)
                    self.ipv6CidrBlocks = model
                }
                if let value = dict["IsDefault"] as? Bool {
                    self.isDefault = value
                }
                if let value = dict["NatGatewayIds"] as? [String: Any?] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.NatGatewayIds()
                    model.fromMap(value)
                    self.natGatewayIds = model
                }
                if let value = dict["OwnerId"] as? Int64 {
                    self.ownerId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RouterTableIds"] as? [String: Any?] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.RouterTableIds()
                    model.fromMap(value)
                    self.routerTableIds = model
                }
                if let value = dict["SecondaryCidrBlocks"] as? [String: Any?] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.SecondaryCidrBlocks()
                    model.fromMap(value)
                    self.secondaryCidrBlocks = model
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["UserCidrs"] as? [String: Any?] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.UserCidrs()
                    model.fromMap(value)
                    self.userCidrs = model
                }
                if let value = dict["VRouterId"] as? String {
                    self.VRouterId = value
                }
                if let value = dict["VSwitchIds"] as? [String: Any?] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.VSwitchIds()
                    model.fromMap(value)
                    self.vSwitchIds = model
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["VpcName"] as? String {
                    self.vpcName = value
                }
            }
        }
        public var vpc: [DescribeVpcsResponseBody.Vpcs.Vpc]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpc != nil {
                var tmp : [Any] = []
                for k in self.vpc! {
                    tmp.append(k.toMap())
                }
                map["Vpc"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Vpc"] as? [Any?] {
                var tmp : [DescribeVpcsResponseBody.Vpcs.Vpc] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpcsResponseBody.Vpcs.Vpc()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vpc = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpcs: DescribeVpcsResponseBody.Vpcs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpcs != nil {
            map["Vpcs"] = self.vpcs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["Vpcs"] as? [String: Any?] {
            var model = DescribeVpcsResponseBody.Vpcs()
            model.fromMap(value)
            self.vpcs = model
        }
    }
}

public class DescribeVpcsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpcsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnAttachmentsRequest : Tea.TeaModel {
    public var attachType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachType != nil {
            map["AttachType"] = self.attachType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttachType"] as? String {
            self.attachType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class DescribeVpnAttachmentsResponseBody : Tea.TeaModel {
    public class VpnAttachments : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var attachType: String?

        public var crossAccountAuthorized: Bool?

        public var description_: String?

        public var instanceId: String?

        public var name: String?

        public var tag: String?

        public var tags: [DescribeVpnAttachmentsResponseBody.VpnAttachments.Tags]?

        public var transitRouterId: String?

        public var transitRouterName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachType != nil {
                map["AttachType"] = self.attachType!
            }
            if self.crossAccountAuthorized != nil {
                map["CrossAccountAuthorized"] = self.crossAccountAuthorized!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.transitRouterId != nil {
                map["TransitRouterId"] = self.transitRouterId!
            }
            if self.transitRouterName != nil {
                map["TransitRouterName"] = self.transitRouterName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AttachType"] as? String {
                self.attachType = value
            }
            if let value = dict["CrossAccountAuthorized"] as? Bool {
                self.crossAccountAuthorized = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Tag"] as? String {
                self.tag = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeVpnAttachmentsResponseBody.VpnAttachments.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpnAttachmentsResponseBody.VpnAttachments.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TransitRouterId"] as? String {
                self.transitRouterId = value
            }
            if let value = dict["TransitRouterName"] as? String {
                self.transitRouterName = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnAttachments: [DescribeVpnAttachmentsResponseBody.VpnAttachments]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnAttachments != nil {
            var tmp : [Any] = []
            for k in self.vpnAttachments! {
                tmp.append(k.toMap())
            }
            map["VpnAttachments"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VpnAttachments"] as? [Any?] {
            var tmp : [DescribeVpnAttachmentsResponseBody.VpnAttachments] = []
            for v in value {
                if v != nil {
                    var model = DescribeVpnAttachmentsResponseBody.VpnAttachments()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.vpnAttachments = tmp
        }
    }
}

public class DescribeVpnAttachmentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnAttachmentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnAttachmentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnConnectionRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class DescribeVpnConnectionResponseBody : Tea.TeaModel {
    public class IkeConfig : Tea.TeaModel {
        public var ikeAuthAlg: String?

        public var ikeEncAlg: String?

        public var ikeLifetime: Int64?

        public var ikeMode: String?

        public var ikePfs: String?

        public var ikeVersion: String?

        public var localId: String?

        public var psk: String?

        public var remoteId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ikeAuthAlg != nil {
                map["IkeAuthAlg"] = self.ikeAuthAlg!
            }
            if self.ikeEncAlg != nil {
                map["IkeEncAlg"] = self.ikeEncAlg!
            }
            if self.ikeLifetime != nil {
                map["IkeLifetime"] = self.ikeLifetime!
            }
            if self.ikeMode != nil {
                map["IkeMode"] = self.ikeMode!
            }
            if self.ikePfs != nil {
                map["IkePfs"] = self.ikePfs!
            }
            if self.ikeVersion != nil {
                map["IkeVersion"] = self.ikeVersion!
            }
            if self.localId != nil {
                map["LocalId"] = self.localId!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.remoteId != nil {
                map["RemoteId"] = self.remoteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IkeAuthAlg"] as? String {
                self.ikeAuthAlg = value
            }
            if let value = dict["IkeEncAlg"] as? String {
                self.ikeEncAlg = value
            }
            if let value = dict["IkeLifetime"] as? Int64 {
                self.ikeLifetime = value
            }
            if let value = dict["IkeMode"] as? String {
                self.ikeMode = value
            }
            if let value = dict["IkePfs"] as? String {
                self.ikePfs = value
            }
            if let value = dict["IkeVersion"] as? String {
                self.ikeVersion = value
            }
            if let value = dict["LocalId"] as? String {
                self.localId = value
            }
            if let value = dict["Psk"] as? String {
                self.psk = value
            }
            if let value = dict["RemoteId"] as? String {
                self.remoteId = value
            }
        }
    }
    public class IpsecConfig : Tea.TeaModel {
        public var ipsecAuthAlg: String?

        public var ipsecEncAlg: String?

        public var ipsecLifetime: Int64?

        public var ipsecPfs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipsecAuthAlg != nil {
                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
            }
            if self.ipsecEncAlg != nil {
                map["IpsecEncAlg"] = self.ipsecEncAlg!
            }
            if self.ipsecLifetime != nil {
                map["IpsecLifetime"] = self.ipsecLifetime!
            }
            if self.ipsecPfs != nil {
                map["IpsecPfs"] = self.ipsecPfs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IpsecAuthAlg"] as? String {
                self.ipsecAuthAlg = value
            }
            if let value = dict["IpsecEncAlg"] as? String {
                self.ipsecEncAlg = value
            }
            if let value = dict["IpsecLifetime"] as? Int64 {
                self.ipsecLifetime = value
            }
            if let value = dict["IpsecPfs"] as? String {
                self.ipsecPfs = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var tag: [DescribeVpnConnectionResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeVpnConnectionResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpnConnectionResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelOptions : Tea.TeaModel {
            public class TunnelBgpConfig : Tea.TeaModel {
                public var bgpStatus: String?

                public var localAsn: String?

                public var localBgpIp: String?

                public var peerAsn: String?

                public var peerBgpIp: String?

                public var tunnelCidr: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bgpStatus != nil {
                        map["BgpStatus"] = self.bgpStatus!
                    }
                    if self.localAsn != nil {
                        map["LocalAsn"] = self.localAsn!
                    }
                    if self.localBgpIp != nil {
                        map["LocalBgpIp"] = self.localBgpIp!
                    }
                    if self.peerAsn != nil {
                        map["PeerAsn"] = self.peerAsn!
                    }
                    if self.peerBgpIp != nil {
                        map["PeerBgpIp"] = self.peerBgpIp!
                    }
                    if self.tunnelCidr != nil {
                        map["TunnelCidr"] = self.tunnelCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BgpStatus"] as? String {
                        self.bgpStatus = value
                    }
                    if let value = dict["LocalAsn"] as? String {
                        self.localAsn = value
                    }
                    if let value = dict["LocalBgpIp"] as? String {
                        self.localBgpIp = value
                    }
                    if let value = dict["PeerAsn"] as? String {
                        self.peerAsn = value
                    }
                    if let value = dict["PeerBgpIp"] as? String {
                        self.peerBgpIp = value
                    }
                    if let value = dict["TunnelCidr"] as? String {
                        self.tunnelCidr = value
                    }
                }
            }
            public class TunnelIkeConfig : Tea.TeaModel {
                public var ikeAuthAlg: String?

                public var ikeEncAlg: String?

                public var ikeLifetime: String?

                public var ikeMode: String?

                public var ikePfs: String?

                public var ikeVersion: String?

                public var localId: String?

                public var psk: String?

                public var remoteId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ikeAuthAlg != nil {
                        map["IkeAuthAlg"] = self.ikeAuthAlg!
                    }
                    if self.ikeEncAlg != nil {
                        map["IkeEncAlg"] = self.ikeEncAlg!
                    }
                    if self.ikeLifetime != nil {
                        map["IkeLifetime"] = self.ikeLifetime!
                    }
                    if self.ikeMode != nil {
                        map["IkeMode"] = self.ikeMode!
                    }
                    if self.ikePfs != nil {
                        map["IkePfs"] = self.ikePfs!
                    }
                    if self.ikeVersion != nil {
                        map["IkeVersion"] = self.ikeVersion!
                    }
                    if self.localId != nil {
                        map["LocalId"] = self.localId!
                    }
                    if self.psk != nil {
                        map["Psk"] = self.psk!
                    }
                    if self.remoteId != nil {
                        map["RemoteId"] = self.remoteId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IkeAuthAlg"] as? String {
                        self.ikeAuthAlg = value
                    }
                    if let value = dict["IkeEncAlg"] as? String {
                        self.ikeEncAlg = value
                    }
                    if let value = dict["IkeLifetime"] as? String {
                        self.ikeLifetime = value
                    }
                    if let value = dict["IkeMode"] as? String {
                        self.ikeMode = value
                    }
                    if let value = dict["IkePfs"] as? String {
                        self.ikePfs = value
                    }
                    if let value = dict["IkeVersion"] as? String {
                        self.ikeVersion = value
                    }
                    if let value = dict["LocalId"] as? String {
                        self.localId = value
                    }
                    if let value = dict["Psk"] as? String {
                        self.psk = value
                    }
                    if let value = dict["RemoteId"] as? String {
                        self.remoteId = value
                    }
                }
            }
            public class TunnelIpsecConfig : Tea.TeaModel {
                public var ipsecAuthAlg: String?

                public var ipsecEncAlg: String?

                public var ipsecLifetime: String?

                public var ipsecPfs: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipsecAuthAlg != nil {
                        map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                    }
                    if self.ipsecEncAlg != nil {
                        map["IpsecEncAlg"] = self.ipsecEncAlg!
                    }
                    if self.ipsecLifetime != nil {
                        map["IpsecLifetime"] = self.ipsecLifetime!
                    }
                    if self.ipsecPfs != nil {
                        map["IpsecPfs"] = self.ipsecPfs!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IpsecAuthAlg"] as? String {
                        self.ipsecAuthAlg = value
                    }
                    if let value = dict["IpsecEncAlg"] as? String {
                        self.ipsecEncAlg = value
                    }
                    if let value = dict["IpsecLifetime"] as? String {
                        self.ipsecLifetime = value
                    }
                    if let value = dict["IpsecPfs"] as? String {
                        self.ipsecPfs = value
                    }
                }
            }
            public var customerGatewayId: String?

            public var enableDpd: String?

            public var enableNatTraversal: String?

            public var internetIp: String?

            public var remoteCaCertificate: String?

            public var role: String?

            public var state: String?

            public var status: String?

            public var tunnelBgpConfig: DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig?

            public var tunnelId: String?

            public var tunnelIkeConfig: DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig?

            public var tunnelIndex: Int32?

            public var tunnelIpsecConfig: DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig?

            public var zoneNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tunnelBgpConfig?.validate()
                try self.tunnelIkeConfig?.validate()
                try self.tunnelIpsecConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customerGatewayId != nil {
                    map["CustomerGatewayId"] = self.customerGatewayId!
                }
                if self.enableDpd != nil {
                    map["EnableDpd"] = self.enableDpd!
                }
                if self.enableNatTraversal != nil {
                    map["EnableNatTraversal"] = self.enableNatTraversal!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.remoteCaCertificate != nil {
                    map["RemoteCaCertificate"] = self.remoteCaCertificate!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tunnelBgpConfig != nil {
                    map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
                }
                if self.tunnelId != nil {
                    map["TunnelId"] = self.tunnelId!
                }
                if self.tunnelIkeConfig != nil {
                    map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
                }
                if self.tunnelIndex != nil {
                    map["TunnelIndex"] = self.tunnelIndex!
                }
                if self.tunnelIpsecConfig != nil {
                    map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
                }
                if self.zoneNo != nil {
                    map["ZoneNo"] = self.zoneNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CustomerGatewayId"] as? String {
                    self.customerGatewayId = value
                }
                if let value = dict["EnableDpd"] as? String {
                    self.enableDpd = value
                }
                if let value = dict["EnableNatTraversal"] as? String {
                    self.enableNatTraversal = value
                }
                if let value = dict["InternetIp"] as? String {
                    self.internetIp = value
                }
                if let value = dict["RemoteCaCertificate"] as? String {
                    self.remoteCaCertificate = value
                }
                if let value = dict["Role"] as? String {
                    self.role = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
                    var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig()
                    model.fromMap(value)
                    self.tunnelBgpConfig = model
                }
                if let value = dict["TunnelId"] as? String {
                    self.tunnelId = value
                }
                if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
                    var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig()
                    model.fromMap(value)
                    self.tunnelIkeConfig = model
                }
                if let value = dict["TunnelIndex"] as? Int32 {
                    self.tunnelIndex = value
                }
                if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
                    var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig()
                    model.fromMap(value)
                    self.tunnelIpsecConfig = model
                }
                if let value = dict["ZoneNo"] as? String {
                    self.zoneNo = value
                }
            }
        }
        public var tunnelOptions: [DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tunnelOptions != nil {
                var tmp : [Any] = []
                for k in self.tunnelOptions! {
                    tmp.append(k.toMap())
                }
                map["TunnelOptions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TunnelOptions"] as? [Any?] {
                var tmp : [DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification.TunnelOptions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tunnelOptions = tmp
            }
        }
    }
    public class VcoHealthCheck : Tea.TeaModel {
        public var dip: String?

        public var enable: String?

        public var interval: Int32?

        public var policy: String?

        public var retry: Int32?

        public var sip: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dip != nil {
                map["Dip"] = self.dip!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.retry != nil {
                map["Retry"] = self.retry!
            }
            if self.sip != nil {
                map["Sip"] = self.sip!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Dip"] as? String {
                self.dip = value
            }
            if let value = dict["Enable"] as? String {
                self.enable = value
            }
            if let value = dict["Interval"] as? Int32 {
                self.interval = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["Retry"] as? Int32 {
                self.retry = value
            }
            if let value = dict["Sip"] as? String {
                self.sip = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public class VpnBgpConfig : Tea.TeaModel {
        public var authKey: String?

        public var enableBgp: String?

        public var localAsn: Int64?

        public var localBgpIp: String?

        public var peerAsn: Int64?

        public var peerBgpIp: String?

        public var status: String?

        public var tunnelCidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authKey != nil {
                map["AuthKey"] = self.authKey!
            }
            if self.enableBgp != nil {
                map["EnableBgp"] = self.enableBgp!
            }
            if self.localAsn != nil {
                map["LocalAsn"] = self.localAsn!
            }
            if self.localBgpIp != nil {
                map["LocalBgpIp"] = self.localBgpIp!
            }
            if self.peerAsn != nil {
                map["PeerAsn"] = self.peerAsn!
            }
            if self.peerBgpIp != nil {
                map["PeerBgpIp"] = self.peerBgpIp!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tunnelCidr != nil {
                map["TunnelCidr"] = self.tunnelCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AuthKey"] as? String {
                self.authKey = value
            }
            if let value = dict["EnableBgp"] as? String {
                self.enableBgp = value
            }
            if let value = dict["LocalAsn"] as? Int64 {
                self.localAsn = value
            }
            if let value = dict["LocalBgpIp"] as? String {
                self.localBgpIp = value
            }
            if let value = dict["PeerAsn"] as? Int64 {
                self.peerAsn = value
            }
            if let value = dict["PeerBgpIp"] as? String {
                self.peerBgpIp = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TunnelCidr"] as? String {
                self.tunnelCidr = value
            }
        }
    }
    public var attachInstanceId: String?

    public var attachType: String?

    public var createTime: Int64?

    public var crossAccountAuthorized: Bool?

    public var customerGatewayId: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var ikeConfig: DescribeVpnConnectionResponseBody.IkeConfig?

    public var internetIp: String?

    public var ipsecConfig: DescribeVpnConnectionResponseBody.IpsecConfig?

    public var localSubnet: String?

    public var name: String?

    public var networkType: String?

    public var remoteCaCertificate: String?

    public var remoteSubnet: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var spec: String?

    public var state: String?

    public var status: String?

    public var tags: DescribeVpnConnectionResponseBody.Tags?

    public var transitRouterId: String?

    public var transitRouterName: String?

    public var tunnelOptionsSpecification: DescribeVpnConnectionResponseBody.TunnelOptionsSpecification?

    public var vcoHealthCheck: DescribeVpnConnectionResponseBody.VcoHealthCheck?

    public var vpnBgpConfig: DescribeVpnConnectionResponseBody.VpnBgpConfig?

    public var vpnConnectionId: String?

    public var vpnGatewayId: String?

    public var zoneNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ikeConfig?.validate()
        try self.ipsecConfig?.validate()
        try self.tags?.validate()
        try self.tunnelOptionsSpecification?.validate()
        try self.vcoHealthCheck?.validate()
        try self.vpnBgpConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachInstanceId != nil {
            map["AttachInstanceId"] = self.attachInstanceId!
        }
        if self.attachType != nil {
            map["AttachType"] = self.attachType!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.crossAccountAuthorized != nil {
            map["CrossAccountAuthorized"] = self.crossAccountAuthorized!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig?.toMap()
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig?.toMap()
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.remoteCaCertificate != nil {
            map["RemoteCaCertificate"] = self.remoteCaCertificate!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.transitRouterId != nil {
            map["TransitRouterId"] = self.transitRouterId!
        }
        if self.transitRouterName != nil {
            map["TransitRouterName"] = self.transitRouterName!
        }
        if self.tunnelOptionsSpecification != nil {
            map["TunnelOptionsSpecification"] = self.tunnelOptionsSpecification?.toMap()
        }
        if self.vcoHealthCheck != nil {
            map["VcoHealthCheck"] = self.vcoHealthCheck?.toMap()
        }
        if self.vpnBgpConfig != nil {
            map["VpnBgpConfig"] = self.vpnBgpConfig?.toMap()
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.zoneNo != nil {
            map["ZoneNo"] = self.zoneNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttachInstanceId"] as? String {
            self.attachInstanceId = value
        }
        if let value = dict["AttachType"] as? String {
            self.attachType = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["CrossAccountAuthorized"] as? Bool {
            self.crossAccountAuthorized = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["EffectImmediately"] as? Bool {
            self.effectImmediately = value
        }
        if let value = dict["EnableDpd"] as? Bool {
            self.enableDpd = value
        }
        if let value = dict["EnableNatTraversal"] as? Bool {
            self.enableNatTraversal = value
        }
        if let value = dict["EnableTunnelsBgp"] as? Bool {
            self.enableTunnelsBgp = value
        }
        if let value = dict["IkeConfig"] as? [String: Any?] {
            var model = DescribeVpnConnectionResponseBody.IkeConfig()
            model.fromMap(value)
            self.ikeConfig = model
        }
        if let value = dict["InternetIp"] as? String {
            self.internetIp = value
        }
        if let value = dict["IpsecConfig"] as? [String: Any?] {
            var model = DescribeVpnConnectionResponseBody.IpsecConfig()
            model.fromMap(value)
            self.ipsecConfig = model
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["RemoteCaCertificate"] as? String {
            self.remoteCaCertificate = value
        }
        if let value = dict["RemoteSubnet"] as? String {
            self.remoteSubnet = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeVpnConnectionResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["TransitRouterId"] as? String {
            self.transitRouterId = value
        }
        if let value = dict["TransitRouterName"] as? String {
            self.transitRouterName = value
        }
        if let value = dict["TunnelOptionsSpecification"] as? [String: Any?] {
            var model = DescribeVpnConnectionResponseBody.TunnelOptionsSpecification()
            model.fromMap(value)
            self.tunnelOptionsSpecification = model
        }
        if let value = dict["VcoHealthCheck"] as? [String: Any?] {
            var model = DescribeVpnConnectionResponseBody.VcoHealthCheck()
            model.fromMap(value)
            self.vcoHealthCheck = model
        }
        if let value = dict["VpnBgpConfig"] as? [String: Any?] {
            var model = DescribeVpnConnectionResponseBody.VpnBgpConfig()
            model.fromMap(value)
            self.vpnBgpConfig = model
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["ZoneNo"] as? String {
            self.zoneNo = value
        }
    }
}

public class DescribeVpnConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnConnectionLogsRequest : Tea.TeaModel {
    public var from: Int32?

    public var minutePeriod: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var to: Int32?

    public var tunnelId: String?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.minutePeriod != nil {
            map["MinutePeriod"] = self.minutePeriod!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        if self.tunnelId != nil {
            map["TunnelId"] = self.tunnelId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["From"] as? Int32 {
            self.from = value
        }
        if let value = dict["MinutePeriod"] as? Int32 {
            self.minutePeriod = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["To"] as? Int32 {
            self.to = value
        }
        if let value = dict["TunnelId"] as? String {
            self.tunnelId = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class DescribeVpnConnectionLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var logs: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logs != nil {
                map["Logs"] = self.logs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Logs"] as? [String] {
                self.logs = value
            }
        }
    }
    public var count: Int32?

    public var data: DescribeVpnConnectionLogsResponseBody.Data?

    public var isCompleted: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.isCompleted != nil {
            map["IsCompleted"] = self.isCompleted!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeVpnConnectionLogsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["IsCompleted"] as? Bool {
            self.isCompleted = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeVpnConnectionLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnConnectionLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnConnectionLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnConnectionsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var customerGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeVpnConnectionsRequest.Tag]?

    public var vpnConnectionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeVpnConnectionsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeVpnConnectionsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DescribeVpnConnectionsResponseBody : Tea.TeaModel {
    public class VpnConnections : Tea.TeaModel {
        public class VpnConnection : Tea.TeaModel {
            public class IkeConfig : Tea.TeaModel {
                public var ikeAuthAlg: String?

                public var ikeEncAlg: String?

                public var ikeLifetime: Int64?

                public var ikeMode: String?

                public var ikePfs: String?

                public var ikeVersion: String?

                public var localId: String?

                public var psk: String?

                public var remoteId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ikeAuthAlg != nil {
                        map["IkeAuthAlg"] = self.ikeAuthAlg!
                    }
                    if self.ikeEncAlg != nil {
                        map["IkeEncAlg"] = self.ikeEncAlg!
                    }
                    if self.ikeLifetime != nil {
                        map["IkeLifetime"] = self.ikeLifetime!
                    }
                    if self.ikeMode != nil {
                        map["IkeMode"] = self.ikeMode!
                    }
                    if self.ikePfs != nil {
                        map["IkePfs"] = self.ikePfs!
                    }
                    if self.ikeVersion != nil {
                        map["IkeVersion"] = self.ikeVersion!
                    }
                    if self.localId != nil {
                        map["LocalId"] = self.localId!
                    }
                    if self.psk != nil {
                        map["Psk"] = self.psk!
                    }
                    if self.remoteId != nil {
                        map["RemoteId"] = self.remoteId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IkeAuthAlg"] as? String {
                        self.ikeAuthAlg = value
                    }
                    if let value = dict["IkeEncAlg"] as? String {
                        self.ikeEncAlg = value
                    }
                    if let value = dict["IkeLifetime"] as? Int64 {
                        self.ikeLifetime = value
                    }
                    if let value = dict["IkeMode"] as? String {
                        self.ikeMode = value
                    }
                    if let value = dict["IkePfs"] as? String {
                        self.ikePfs = value
                    }
                    if let value = dict["IkeVersion"] as? String {
                        self.ikeVersion = value
                    }
                    if let value = dict["LocalId"] as? String {
                        self.localId = value
                    }
                    if let value = dict["Psk"] as? String {
                        self.psk = value
                    }
                    if let value = dict["RemoteId"] as? String {
                        self.remoteId = value
                    }
                }
            }
            public class IpsecConfig : Tea.TeaModel {
                public var ipsecAuthAlg: String?

                public var ipsecEncAlg: String?

                public var ipsecLifetime: Int64?

                public var ipsecPfs: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipsecAuthAlg != nil {
                        map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                    }
                    if self.ipsecEncAlg != nil {
                        map["IpsecEncAlg"] = self.ipsecEncAlg!
                    }
                    if self.ipsecLifetime != nil {
                        map["IpsecLifetime"] = self.ipsecLifetime!
                    }
                    if self.ipsecPfs != nil {
                        map["IpsecPfs"] = self.ipsecPfs!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IpsecAuthAlg"] as? String {
                        self.ipsecAuthAlg = value
                    }
                    if let value = dict["IpsecEncAlg"] as? String {
                        self.ipsecEncAlg = value
                    }
                    if let value = dict["IpsecLifetime"] as? Int64 {
                        self.ipsecLifetime = value
                    }
                    if let value = dict["IpsecPfs"] as? String {
                        self.ipsecPfs = value
                    }
                }
            }
            public class Tag : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public class TunnelOptionsSpecification : Tea.TeaModel {
                public class TunnelOptions : Tea.TeaModel {
                    public class TunnelBgpConfig : Tea.TeaModel {
                        public var bgpStatus: String?

                        public var localAsn: String?

                        public var localBgpIp: String?

                        public var peerAsn: String?

                        public var peerBgpIp: String?

                        public var tunnelCidr: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bgpStatus != nil {
                                map["BgpStatus"] = self.bgpStatus!
                            }
                            if self.localAsn != nil {
                                map["LocalAsn"] = self.localAsn!
                            }
                            if self.localBgpIp != nil {
                                map["LocalBgpIp"] = self.localBgpIp!
                            }
                            if self.peerAsn != nil {
                                map["PeerAsn"] = self.peerAsn!
                            }
                            if self.peerBgpIp != nil {
                                map["PeerBgpIp"] = self.peerBgpIp!
                            }
                            if self.tunnelCidr != nil {
                                map["TunnelCidr"] = self.tunnelCidr!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["BgpStatus"] as? String {
                                self.bgpStatus = value
                            }
                            if let value = dict["LocalAsn"] as? String {
                                self.localAsn = value
                            }
                            if let value = dict["LocalBgpIp"] as? String {
                                self.localBgpIp = value
                            }
                            if let value = dict["PeerAsn"] as? String {
                                self.peerAsn = value
                            }
                            if let value = dict["PeerBgpIp"] as? String {
                                self.peerBgpIp = value
                            }
                            if let value = dict["TunnelCidr"] as? String {
                                self.tunnelCidr = value
                            }
                        }
                    }
                    public class TunnelIkeConfig : Tea.TeaModel {
                        public var ikeAuthAlg: String?

                        public var ikeEncAlg: String?

                        public var ikeLifetime: String?

                        public var ikeMode: String?

                        public var ikePfs: String?

                        public var ikeVersion: String?

                        public var localId: String?

                        public var psk: String?

                        public var remoteId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ikeAuthAlg != nil {
                                map["IkeAuthAlg"] = self.ikeAuthAlg!
                            }
                            if self.ikeEncAlg != nil {
                                map["IkeEncAlg"] = self.ikeEncAlg!
                            }
                            if self.ikeLifetime != nil {
                                map["IkeLifetime"] = self.ikeLifetime!
                            }
                            if self.ikeMode != nil {
                                map["IkeMode"] = self.ikeMode!
                            }
                            if self.ikePfs != nil {
                                map["IkePfs"] = self.ikePfs!
                            }
                            if self.ikeVersion != nil {
                                map["IkeVersion"] = self.ikeVersion!
                            }
                            if self.localId != nil {
                                map["LocalId"] = self.localId!
                            }
                            if self.psk != nil {
                                map["Psk"] = self.psk!
                            }
                            if self.remoteId != nil {
                                map["RemoteId"] = self.remoteId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["IkeAuthAlg"] as? String {
                                self.ikeAuthAlg = value
                            }
                            if let value = dict["IkeEncAlg"] as? String {
                                self.ikeEncAlg = value
                            }
                            if let value = dict["IkeLifetime"] as? String {
                                self.ikeLifetime = value
                            }
                            if let value = dict["IkeMode"] as? String {
                                self.ikeMode = value
                            }
                            if let value = dict["IkePfs"] as? String {
                                self.ikePfs = value
                            }
                            if let value = dict["IkeVersion"] as? String {
                                self.ikeVersion = value
                            }
                            if let value = dict["LocalId"] as? String {
                                self.localId = value
                            }
                            if let value = dict["Psk"] as? String {
                                self.psk = value
                            }
                            if let value = dict["RemoteId"] as? String {
                                self.remoteId = value
                            }
                        }
                    }
                    public class TunnelIpsecConfig : Tea.TeaModel {
                        public var ipsecAuthAlg: String?

                        public var ipsecEncAlg: String?

                        public var ipsecLifetime: String?

                        public var ipsecPfs: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ipsecAuthAlg != nil {
                                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                            }
                            if self.ipsecEncAlg != nil {
                                map["IpsecEncAlg"] = self.ipsecEncAlg!
                            }
                            if self.ipsecLifetime != nil {
                                map["IpsecLifetime"] = self.ipsecLifetime!
                            }
                            if self.ipsecPfs != nil {
                                map["IpsecPfs"] = self.ipsecPfs!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["IpsecAuthAlg"] as? String {
                                self.ipsecAuthAlg = value
                            }
                            if let value = dict["IpsecEncAlg"] as? String {
                                self.ipsecEncAlg = value
                            }
                            if let value = dict["IpsecLifetime"] as? String {
                                self.ipsecLifetime = value
                            }
                            if let value = dict["IpsecPfs"] as? String {
                                self.ipsecPfs = value
                            }
                        }
                    }
                    public var customerGatewayId: String?

                    public var enableDpd: String?

                    public var enableNatTraversal: String?

                    public var internetIp: String?

                    public var remoteCaCertificate: String?

                    public var role: String?

                    public var state: String?

                    public var status: String?

                    public var tunnelBgpConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig?

                    public var tunnelId: String?

                    public var tunnelIkeConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig?

                    public var tunnelIndex: Int32?

                    public var tunnelIpsecConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig?

                    public var zoneNo: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.tunnelBgpConfig?.validate()
                        try self.tunnelIkeConfig?.validate()
                        try self.tunnelIpsecConfig?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.customerGatewayId != nil {
                            map["CustomerGatewayId"] = self.customerGatewayId!
                        }
                        if self.enableDpd != nil {
                            map["EnableDpd"] = self.enableDpd!
                        }
                        if self.enableNatTraversal != nil {
                            map["EnableNatTraversal"] = self.enableNatTraversal!
                        }
                        if self.internetIp != nil {
                            map["InternetIp"] = self.internetIp!
                        }
                        if self.remoteCaCertificate != nil {
                            map["RemoteCaCertificate"] = self.remoteCaCertificate!
                        }
                        if self.role != nil {
                            map["Role"] = self.role!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.tunnelBgpConfig != nil {
                            map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
                        }
                        if self.tunnelId != nil {
                            map["TunnelId"] = self.tunnelId!
                        }
                        if self.tunnelIkeConfig != nil {
                            map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
                        }
                        if self.tunnelIndex != nil {
                            map["TunnelIndex"] = self.tunnelIndex!
                        }
                        if self.tunnelIpsecConfig != nil {
                            map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
                        }
                        if self.zoneNo != nil {
                            map["ZoneNo"] = self.zoneNo!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CustomerGatewayId"] as? String {
                            self.customerGatewayId = value
                        }
                        if let value = dict["EnableDpd"] as? String {
                            self.enableDpd = value
                        }
                        if let value = dict["EnableNatTraversal"] as? String {
                            self.enableNatTraversal = value
                        }
                        if let value = dict["InternetIp"] as? String {
                            self.internetIp = value
                        }
                        if let value = dict["RemoteCaCertificate"] as? String {
                            self.remoteCaCertificate = value
                        }
                        if let value = dict["Role"] as? String {
                            self.role = value
                        }
                        if let value = dict["State"] as? String {
                            self.state = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                        if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
                            var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig()
                            model.fromMap(value)
                            self.tunnelBgpConfig = model
                        }
                        if let value = dict["TunnelId"] as? String {
                            self.tunnelId = value
                        }
                        if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
                            var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig()
                            model.fromMap(value)
                            self.tunnelIkeConfig = model
                        }
                        if let value = dict["TunnelIndex"] as? Int32 {
                            self.tunnelIndex = value
                        }
                        if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
                            var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig()
                            model.fromMap(value)
                            self.tunnelIpsecConfig = model
                        }
                        if let value = dict["ZoneNo"] as? String {
                            self.zoneNo = value
                        }
                    }
                }
                public var tunnelOptions: [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tunnelOptions != nil {
                        var tmp : [Any] = []
                        for k in self.tunnelOptions! {
                            tmp.append(k.toMap())
                        }
                        map["TunnelOptions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TunnelOptions"] as? [Any?] {
                        var tmp : [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification.TunnelOptions()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tunnelOptions = tmp
                    }
                }
            }
            public class VcoHealthCheck : Tea.TeaModel {
                public var dip: String?

                public var enable: String?

                public var interval: Int32?

                public var policy: String?

                public var retry: Int32?

                public var sip: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dip != nil {
                        map["Dip"] = self.dip!
                    }
                    if self.enable != nil {
                        map["Enable"] = self.enable!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.retry != nil {
                        map["Retry"] = self.retry!
                    }
                    if self.sip != nil {
                        map["Sip"] = self.sip!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Dip"] as? String {
                        self.dip = value
                    }
                    if let value = dict["Enable"] as? String {
                        self.enable = value
                    }
                    if let value = dict["Interval"] as? Int32 {
                        self.interval = value
                    }
                    if let value = dict["Policy"] as? String {
                        self.policy = value
                    }
                    if let value = dict["Retry"] as? Int32 {
                        self.retry = value
                    }
                    if let value = dict["Sip"] as? String {
                        self.sip = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public class VpnBgpConfig : Tea.TeaModel {
                public var authKey: String?

                public var localAsn: Int64?

                public var localBgpIp: String?

                public var peerAsn: Int64?

                public var peerBgpIp: String?

                public var status: String?

                public var tunnelCidr: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.authKey != nil {
                        map["AuthKey"] = self.authKey!
                    }
                    if self.localAsn != nil {
                        map["LocalAsn"] = self.localAsn!
                    }
                    if self.localBgpIp != nil {
                        map["LocalBgpIp"] = self.localBgpIp!
                    }
                    if self.peerAsn != nil {
                        map["PeerAsn"] = self.peerAsn!
                    }
                    if self.peerBgpIp != nil {
                        map["PeerBgpIp"] = self.peerBgpIp!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tunnelCidr != nil {
                        map["TunnelCidr"] = self.tunnelCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AuthKey"] as? String {
                        self.authKey = value
                    }
                    if let value = dict["LocalAsn"] as? Int64 {
                        self.localAsn = value
                    }
                    if let value = dict["LocalBgpIp"] as? String {
                        self.localBgpIp = value
                    }
                    if let value = dict["PeerAsn"] as? Int64 {
                        self.peerAsn = value
                    }
                    if let value = dict["PeerBgpIp"] as? String {
                        self.peerBgpIp = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["TunnelCidr"] as? String {
                        self.tunnelCidr = value
                    }
                }
            }
            public var attachInstanceId: String?

            public var attachType: String?

            public var createTime: Int64?

            public var crossAccountAuthorized: Bool?

            public var customerGatewayId: String?

            public var effectImmediately: Bool?

            public var enableDpd: Bool?

            public var enableNatTraversal: Bool?

            public var enableTunnelsBgp: Bool?

            public var ikeConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.IkeConfig?

            public var internetIp: String?

            public var ipsecConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.IpsecConfig?

            public var localSubnet: String?

            public var name: String?

            public var networkType: String?

            public var remoteCaCertificate: String?

            public var remoteSubnet: String?

            public var resourceGroupId: String?

            public var spec: String?

            public var state: String?

            public var status: String?

            public var tag: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag?

            public var transitRouterId: String?

            public var transitRouterName: String?

            public var tunnelOptionsSpecification: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification?

            public var vcoHealthCheck: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.VcoHealthCheck?

            public var vpnBgpConfig: DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.VpnBgpConfig?

            public var vpnConnectionId: String?

            public var vpnGatewayId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ikeConfig?.validate()
                try self.ipsecConfig?.validate()
                try self.tag?.validate()
                try self.tunnelOptionsSpecification?.validate()
                try self.vcoHealthCheck?.validate()
                try self.vpnBgpConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attachInstanceId != nil {
                    map["AttachInstanceId"] = self.attachInstanceId!
                }
                if self.attachType != nil {
                    map["AttachType"] = self.attachType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.crossAccountAuthorized != nil {
                    map["CrossAccountAuthorized"] = self.crossAccountAuthorized!
                }
                if self.customerGatewayId != nil {
                    map["CustomerGatewayId"] = self.customerGatewayId!
                }
                if self.effectImmediately != nil {
                    map["EffectImmediately"] = self.effectImmediately!
                }
                if self.enableDpd != nil {
                    map["EnableDpd"] = self.enableDpd!
                }
                if self.enableNatTraversal != nil {
                    map["EnableNatTraversal"] = self.enableNatTraversal!
                }
                if self.enableTunnelsBgp != nil {
                    map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
                }
                if self.ikeConfig != nil {
                    map["IkeConfig"] = self.ikeConfig?.toMap()
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.ipsecConfig != nil {
                    map["IpsecConfig"] = self.ipsecConfig?.toMap()
                }
                if self.localSubnet != nil {
                    map["LocalSubnet"] = self.localSubnet!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.remoteCaCertificate != nil {
                    map["RemoteCaCertificate"] = self.remoteCaCertificate!
                }
                if self.remoteSubnet != nil {
                    map["RemoteSubnet"] = self.remoteSubnet!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag?.toMap()
                }
                if self.transitRouterId != nil {
                    map["TransitRouterId"] = self.transitRouterId!
                }
                if self.transitRouterName != nil {
                    map["TransitRouterName"] = self.transitRouterName!
                }
                if self.tunnelOptionsSpecification != nil {
                    map["TunnelOptionsSpecification"] = self.tunnelOptionsSpecification?.toMap()
                }
                if self.vcoHealthCheck != nil {
                    map["VcoHealthCheck"] = self.vcoHealthCheck?.toMap()
                }
                if self.vpnBgpConfig != nil {
                    map["VpnBgpConfig"] = self.vpnBgpConfig?.toMap()
                }
                if self.vpnConnectionId != nil {
                    map["VpnConnectionId"] = self.vpnConnectionId!
                }
                if self.vpnGatewayId != nil {
                    map["VpnGatewayId"] = self.vpnGatewayId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AttachInstanceId"] as? String {
                    self.attachInstanceId = value
                }
                if let value = dict["AttachType"] as? String {
                    self.attachType = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CrossAccountAuthorized"] as? Bool {
                    self.crossAccountAuthorized = value
                }
                if let value = dict["CustomerGatewayId"] as? String {
                    self.customerGatewayId = value
                }
                if let value = dict["EffectImmediately"] as? Bool {
                    self.effectImmediately = value
                }
                if let value = dict["EnableDpd"] as? Bool {
                    self.enableDpd = value
                }
                if let value = dict["EnableNatTraversal"] as? Bool {
                    self.enableNatTraversal = value
                }
                if let value = dict["EnableTunnelsBgp"] as? Bool {
                    self.enableTunnelsBgp = value
                }
                if let value = dict["IkeConfig"] as? [String: Any?] {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.IkeConfig()
                    model.fromMap(value)
                    self.ikeConfig = model
                }
                if let value = dict["InternetIp"] as? String {
                    self.internetIp = value
                }
                if let value = dict["IpsecConfig"] as? [String: Any?] {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.IpsecConfig()
                    model.fromMap(value)
                    self.ipsecConfig = model
                }
                if let value = dict["LocalSubnet"] as? String {
                    self.localSubnet = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["RemoteCaCertificate"] as? String {
                    self.remoteCaCertificate = value
                }
                if let value = dict["RemoteSubnet"] as? String {
                    self.remoteSubnet = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Spec"] as? String {
                    self.spec = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tag"] as? [String: Any?] {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.Tag()
                    model.fromMap(value)
                    self.tag = model
                }
                if let value = dict["TransitRouterId"] as? String {
                    self.transitRouterId = value
                }
                if let value = dict["TransitRouterName"] as? String {
                    self.transitRouterName = value
                }
                if let value = dict["TunnelOptionsSpecification"] as? [String: Any?] {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.TunnelOptionsSpecification()
                    model.fromMap(value)
                    self.tunnelOptionsSpecification = model
                }
                if let value = dict["VcoHealthCheck"] as? [String: Any?] {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.VcoHealthCheck()
                    model.fromMap(value)
                    self.vcoHealthCheck = model
                }
                if let value = dict["VpnBgpConfig"] as? [String: Any?] {
                    var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection.VpnBgpConfig()
                    model.fromMap(value)
                    self.vpnBgpConfig = model
                }
                if let value = dict["VpnConnectionId"] as? String {
                    self.vpnConnectionId = value
                }
                if let value = dict["VpnGatewayId"] as? String {
                    self.vpnGatewayId = value
                }
            }
        }
        public var vpnConnection: [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnConnection != nil {
                var tmp : [Any] = []
                for k in self.vpnConnection! {
                    tmp.append(k.toMap())
                }
                map["VpnConnection"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VpnConnection"] as? [Any?] {
                var tmp : [DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpnConnectionsResponseBody.VpnConnections.VpnConnection()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vpnConnection = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnConnections: DescribeVpnConnectionsResponseBody.VpnConnections?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnConnections?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnConnections != nil {
            map["VpnConnections"] = self.vpnConnections?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VpnConnections"] as? [String: Any?] {
            var model = DescribeVpnConnectionsResponseBody.VpnConnections()
            model.fromMap(value)
            self.vpnConnections = model
        }
    }
}

public class DescribeVpnConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnConnectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnCrossAccountAuthorizationsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class DescribeVpnCrossAccountAuthorizationsResponseBody : Tea.TeaModel {
    public class CrossAccountAuthorizations : Tea.TeaModel {
        public var aliUid: Int64?

        public var bindInstance: String?

        public var bindProduct: String?

        public var bindUid: Int64?

        public var creationTime: Int64?

        public var vpnConnectionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.bindInstance != nil {
                map["BindInstance"] = self.bindInstance!
            }
            if self.bindProduct != nil {
                map["BindProduct"] = self.bindProduct!
            }
            if self.bindUid != nil {
                map["BindUid"] = self.bindUid!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.vpnConnectionId != nil {
                map["VpnConnectionId"] = self.vpnConnectionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliUid"] as? Int64 {
                self.aliUid = value
            }
            if let value = dict["BindInstance"] as? String {
                self.bindInstance = value
            }
            if let value = dict["BindProduct"] as? String {
                self.bindProduct = value
            }
            if let value = dict["BindUid"] as? Int64 {
                self.bindUid = value
            }
            if let value = dict["CreationTime"] as? Int64 {
                self.creationTime = value
            }
            if let value = dict["VpnConnectionId"] as? String {
                self.vpnConnectionId = value
            }
        }
    }
    public var crossAccountAuthorizations: [DescribeVpnCrossAccountAuthorizationsResponseBody.CrossAccountAuthorizations]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.crossAccountAuthorizations != nil {
            var tmp : [Any] = []
            for k in self.crossAccountAuthorizations! {
                tmp.append(k.toMap())
            }
            map["CrossAccountAuthorizations"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CrossAccountAuthorizations"] as? [Any?] {
            var tmp : [DescribeVpnCrossAccountAuthorizationsResponseBody.CrossAccountAuthorizations] = []
            for v in value {
                if v != nil {
                    var model = DescribeVpnCrossAccountAuthorizationsResponseBody.CrossAccountAuthorizations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.crossAccountAuthorizations = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeVpnCrossAccountAuthorizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnCrossAccountAuthorizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnCrossAccountAuthorizationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnGatewayRequest : Tea.TeaModel {
    public var includeReservationData: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IncludeReservationData"] as? Bool {
            self.includeReservationData = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DescribeVpnGatewayResponseBody : Tea.TeaModel {
    public class EniInstanceIds : Tea.TeaModel {
        public var eniInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eniInstanceId != nil {
                map["EniInstanceId"] = self.eniInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EniInstanceId"] as? [String] {
                self.eniInstanceId = value
            }
        }
    }
    public class ReservationData : Tea.TeaModel {
        public var reservationEndTime: String?

        public var reservationIpsec: String?

        public var reservationMaxConnections: Int32?

        public var reservationOrderType: String?

        public var reservationSpec: String?

        public var reservationSsl: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservationEndTime != nil {
                map["ReservationEndTime"] = self.reservationEndTime!
            }
            if self.reservationIpsec != nil {
                map["ReservationIpsec"] = self.reservationIpsec!
            }
            if self.reservationMaxConnections != nil {
                map["ReservationMaxConnections"] = self.reservationMaxConnections!
            }
            if self.reservationOrderType != nil {
                map["ReservationOrderType"] = self.reservationOrderType!
            }
            if self.reservationSpec != nil {
                map["ReservationSpec"] = self.reservationSpec!
            }
            if self.reservationSsl != nil {
                map["ReservationSsl"] = self.reservationSsl!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReservationEndTime"] as? String {
                self.reservationEndTime = value
            }
            if let value = dict["ReservationIpsec"] as? String {
                self.reservationIpsec = value
            }
            if let value = dict["ReservationMaxConnections"] as? Int32 {
                self.reservationMaxConnections = value
            }
            if let value = dict["ReservationOrderType"] as? String {
                self.reservationOrderType = value
            }
            if let value = dict["ReservationSpec"] as? String {
                self.reservationSpec = value
            }
            if let value = dict["ReservationSsl"] as? String {
                self.reservationSsl = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var tag: [DescribeVpnGatewayResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeVpnGatewayResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpnGatewayResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public var autoPropagate: Bool?

    public var businessStatus: String?

    public var chargeType: String?

    public var createTime: Int64?

    public var description_: String?

    public var disasterRecoveryInternetIp: String?

    public var disasterRecoveryVSwitchId: String?

    public var enableBgp: Bool?

    public var endTime: Int64?

    public var eniInstanceIds: DescribeVpnGatewayResponseBody.EniInstanceIds?

    public var internetIp: String?

    public var ipsecVpn: String?

    public var name: String?

    public var networkType: String?

    public var requestId: String?

    public var reservationData: DescribeVpnGatewayResponseBody.ReservationData?

    public var resourceGroupId: String?

    public var spec: String?

    public var sslMaxConnections: Int64?

    public var sslVpn: String?

    public var sslVpnInternetIp: String?

    public var status: String?

    public var tag: String?

    public var tags: DescribeVpnGatewayResponseBody.Tags?

    public var vSwitchId: String?

    public var vpcId: String?

    public var vpnGatewayId: String?

    public var vpnType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eniInstanceIds?.validate()
        try self.reservationData?.validate()
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPropagate != nil {
            map["AutoPropagate"] = self.autoPropagate!
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disasterRecoveryInternetIp != nil {
            map["DisasterRecoveryInternetIp"] = self.disasterRecoveryInternetIp!
        }
        if self.disasterRecoveryVSwitchId != nil {
            map["DisasterRecoveryVSwitchId"] = self.disasterRecoveryVSwitchId!
        }
        if self.enableBgp != nil {
            map["EnableBgp"] = self.enableBgp!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eniInstanceIds != nil {
            map["EniInstanceIds"] = self.eniInstanceIds?.toMap()
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.ipsecVpn != nil {
            map["IpsecVpn"] = self.ipsecVpn!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservationData != nil {
            map["ReservationData"] = self.reservationData?.toMap()
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.sslMaxConnections != nil {
            map["SslMaxConnections"] = self.sslMaxConnections!
        }
        if self.sslVpn != nil {
            map["SslVpn"] = self.sslVpn!
        }
        if self.sslVpnInternetIp != nil {
            map["SslVpnInternetIp"] = self.sslVpnInternetIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.vpnType != nil {
            map["VpnType"] = self.vpnType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPropagate"] as? Bool {
            self.autoPropagate = value
        }
        if let value = dict["BusinessStatus"] as? String {
            self.businessStatus = value
        }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DisasterRecoveryInternetIp"] as? String {
            self.disasterRecoveryInternetIp = value
        }
        if let value = dict["DisasterRecoveryVSwitchId"] as? String {
            self.disasterRecoveryVSwitchId = value
        }
        if let value = dict["EnableBgp"] as? Bool {
            self.enableBgp = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["EniInstanceIds"] as? [String: Any?] {
            var model = DescribeVpnGatewayResponseBody.EniInstanceIds()
            model.fromMap(value)
            self.eniInstanceIds = model
        }
        if let value = dict["InternetIp"] as? String {
            self.internetIp = value
        }
        if let value = dict["IpsecVpn"] as? String {
            self.ipsecVpn = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ReservationData"] as? [String: Any?] {
            var model = DescribeVpnGatewayResponseBody.ReservationData()
            model.fromMap(value)
            self.reservationData = model
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["SslMaxConnections"] as? Int64 {
            self.sslMaxConnections = value
        }
        if let value = dict["SslVpn"] as? String {
            self.sslVpn = value
        }
        if let value = dict["SslVpnInternetIp"] as? String {
            self.sslVpnInternetIp = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? String {
            self.tag = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeVpnGatewayResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["VpnType"] as? String {
            self.vpnType = value
        }
    }
}

public class DescribeVpnGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnGatewayAvailableZonesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class DescribeVpnGatewayAvailableZonesResponseBody : Tea.TeaModel {
    public class AvailableZoneIdList : Tea.TeaModel {
        public var zoneId: String?

        public var zoneName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            if self.zoneName != nil {
                map["ZoneName"] = self.zoneName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
            if let value = dict["ZoneName"] as? String {
                self.zoneName = value
            }
        }
    }
    public var availableZoneIdList: [DescribeVpnGatewayAvailableZonesResponseBody.AvailableZoneIdList]?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableZoneIdList != nil {
            var tmp : [Any] = []
            for k in self.availableZoneIdList! {
                tmp.append(k.toMap())
            }
            map["AvailableZoneIdList"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvailableZoneIdList"] as? [Any?] {
            var tmp : [DescribeVpnGatewayAvailableZonesResponseBody.AvailableZoneIdList] = []
            for v in value {
                if v != nil {
                    var model = DescribeVpnGatewayAvailableZonesResponseBody.AvailableZoneIdList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.availableZoneIdList = tmp
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeVpnGatewayAvailableZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnGatewayAvailableZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnGatewayAvailableZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnGatewaysRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var businessStatus: String?

    public var includeReservationData: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeVpnGatewaysRequest.Tag]?

    public var vpcId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.includeReservationData != nil {
            map["IncludeReservationData"] = self.includeReservationData!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessStatus"] as? String {
            self.businessStatus = value
        }
        if let value = dict["IncludeReservationData"] as? Bool {
            self.includeReservationData = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeVpnGatewaysRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeVpnGatewaysRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DescribeVpnGatewaysResponseBody : Tea.TeaModel {
    public class VpnGateways : Tea.TeaModel {
        public class VpnGateway : Tea.TeaModel {
            public class EniInstanceIds : Tea.TeaModel {
                public var eniInstanceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eniInstanceId != nil {
                        map["EniInstanceId"] = self.eniInstanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EniInstanceId"] as? [String] {
                        self.eniInstanceId = value
                    }
                }
            }
            public class ReservationData : Tea.TeaModel {
                public var reservationEndTime: String?

                public var reservationIpsec: String?

                public var reservationMaxConnections: Int32?

                public var reservationOrderType: String?

                public var reservationSpec: String?

                public var reservationSsl: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.reservationEndTime != nil {
                        map["ReservationEndTime"] = self.reservationEndTime!
                    }
                    if self.reservationIpsec != nil {
                        map["ReservationIpsec"] = self.reservationIpsec!
                    }
                    if self.reservationMaxConnections != nil {
                        map["ReservationMaxConnections"] = self.reservationMaxConnections!
                    }
                    if self.reservationOrderType != nil {
                        map["ReservationOrderType"] = self.reservationOrderType!
                    }
                    if self.reservationSpec != nil {
                        map["ReservationSpec"] = self.reservationSpec!
                    }
                    if self.reservationSsl != nil {
                        map["ReservationSsl"] = self.reservationSsl!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReservationEndTime"] as? String {
                        self.reservationEndTime = value
                    }
                    if let value = dict["ReservationIpsec"] as? String {
                        self.reservationIpsec = value
                    }
                    if let value = dict["ReservationMaxConnections"] as? Int32 {
                        self.reservationMaxConnections = value
                    }
                    if let value = dict["ReservationOrderType"] as? String {
                        self.reservationOrderType = value
                    }
                    if let value = dict["ReservationSpec"] as? String {
                        self.reservationSpec = value
                    }
                    if let value = dict["ReservationSsl"] as? String {
                        self.reservationSsl = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var autoPropagate: Bool?

            public var businessStatus: String?

            public var chargeType: String?

            public var createTime: Int64?

            public var description_: String?

            public var disasterRecoveryInternetIp: String?

            public var disasterRecoveryVSwitchId: String?

            public var enableBgp: Bool?

            public var endTime: Int64?

            public var eniInstanceIds: DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.EniInstanceIds?

            public var internetIp: String?

            public var ipsecVpn: String?

            public var name: String?

            public var networkType: String?

            public var reservationData: DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.ReservationData?

            public var resourceGroupId: String?

            public var spec: String?

            public var sslMaxConnections: Int64?

            public var sslVpn: String?

            public var sslVpnInternetIp: String?

            public var status: String?

            public var tag: String?

            public var tags: DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags?

            public var vSwitchId: String?

            public var vpcId: String?

            public var vpnGatewayId: String?

            public var vpnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.eniInstanceIds?.validate()
                try self.reservationData?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoPropagate != nil {
                    map["AutoPropagate"] = self.autoPropagate!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.disasterRecoveryInternetIp != nil {
                    map["DisasterRecoveryInternetIp"] = self.disasterRecoveryInternetIp!
                }
                if self.disasterRecoveryVSwitchId != nil {
                    map["DisasterRecoveryVSwitchId"] = self.disasterRecoveryVSwitchId!
                }
                if self.enableBgp != nil {
                    map["EnableBgp"] = self.enableBgp!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.eniInstanceIds != nil {
                    map["EniInstanceIds"] = self.eniInstanceIds?.toMap()
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.ipsecVpn != nil {
                    map["IpsecVpn"] = self.ipsecVpn!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.reservationData != nil {
                    map["ReservationData"] = self.reservationData?.toMap()
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.sslMaxConnections != nil {
                    map["SslMaxConnections"] = self.sslMaxConnections!
                }
                if self.sslVpn != nil {
                    map["SslVpn"] = self.sslVpn!
                }
                if self.sslVpnInternetIp != nil {
                    map["SslVpnInternetIp"] = self.sslVpnInternetIp!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpnGatewayId != nil {
                    map["VpnGatewayId"] = self.vpnGatewayId!
                }
                if self.vpnType != nil {
                    map["VpnType"] = self.vpnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoPropagate"] as? Bool {
                    self.autoPropagate = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DisasterRecoveryInternetIp"] as? String {
                    self.disasterRecoveryInternetIp = value
                }
                if let value = dict["DisasterRecoveryVSwitchId"] as? String {
                    self.disasterRecoveryVSwitchId = value
                }
                if let value = dict["EnableBgp"] as? Bool {
                    self.enableBgp = value
                }
                if let value = dict["EndTime"] as? Int64 {
                    self.endTime = value
                }
                if let value = dict["EniInstanceIds"] as? [String: Any?] {
                    var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.EniInstanceIds()
                    model.fromMap(value)
                    self.eniInstanceIds = model
                }
                if let value = dict["InternetIp"] as? String {
                    self.internetIp = value
                }
                if let value = dict["IpsecVpn"] as? String {
                    self.ipsecVpn = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["ReservationData"] as? [String: Any?] {
                    var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.ReservationData()
                    model.fromMap(value)
                    self.reservationData = model
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Spec"] as? String {
                    self.spec = value
                }
                if let value = dict["SslMaxConnections"] as? Int64 {
                    self.sslMaxConnections = value
                }
                if let value = dict["SslVpn"] as? String {
                    self.sslVpn = value
                }
                if let value = dict["SslVpnInternetIp"] as? String {
                    self.sslVpnInternetIp = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tag"] as? String {
                    self.tag = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["VpnGatewayId"] as? String {
                    self.vpnGatewayId = value
                }
                if let value = dict["VpnType"] as? String {
                    self.vpnType = value
                }
            }
        }
        public var vpnGateway: [DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnGateway != nil {
                var tmp : [Any] = []
                for k in self.vpnGateway! {
                    tmp.append(k.toMap())
                }
                map["VpnGateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VpnGateway"] as? [Any?] {
                var tmp : [DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpnGatewaysResponseBody.VpnGateways.VpnGateway()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vpnGateway = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnGateways: DescribeVpnGatewaysResponseBody.VpnGateways?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnGateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnGateways != nil {
            map["VpnGateways"] = self.vpnGateways?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VpnGateways"] as? [String: Any?] {
            var model = DescribeVpnGatewaysResponseBody.VpnGateways()
            model.fromMap(value)
            self.vpnGateways = model
        }
    }
}

public class DescribeVpnGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnGatewaysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnPbrRouteEntriesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DescribeVpnPbrRouteEntriesResponseBody : Tea.TeaModel {
    public class VpnPbrRouteEntries : Tea.TeaModel {
        public class VpnPbrRouteEntry : Tea.TeaModel {
            public var createTime: Int64?

            public var nextHop: String?

            public var nextHopTunnelId: String?

            public var priority: Int32?

            public var routeDest: String?

            public var routeSource: String?

            public var state: String?

            public var vpnInstanceId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.nextHop != nil {
                    map["NextHop"] = self.nextHop!
                }
                if self.nextHopTunnelId != nil {
                    map["NextHopTunnelId"] = self.nextHopTunnelId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.routeDest != nil {
                    map["RouteDest"] = self.routeDest!
                }
                if self.routeSource != nil {
                    map["RouteSource"] = self.routeSource!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.vpnInstanceId != nil {
                    map["VpnInstanceId"] = self.vpnInstanceId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["NextHop"] as? String {
                    self.nextHop = value
                }
                if let value = dict["NextHopTunnelId"] as? String {
                    self.nextHopTunnelId = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["RouteDest"] as? String {
                    self.routeDest = value
                }
                if let value = dict["RouteSource"] as? String {
                    self.routeSource = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["VpnInstanceId"] as? String {
                    self.vpnInstanceId = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public var vpnPbrRouteEntry: [DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries.VpnPbrRouteEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnPbrRouteEntry != nil {
                var tmp : [Any] = []
                for k in self.vpnPbrRouteEntry! {
                    tmp.append(k.toMap())
                }
                map["VpnPbrRouteEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VpnPbrRouteEntry"] as? [Any?] {
                var tmp : [DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries.VpnPbrRouteEntry] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries.VpnPbrRouteEntry()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vpnPbrRouteEntry = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnPbrRouteEntries: DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnPbrRouteEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnPbrRouteEntries != nil {
            map["VpnPbrRouteEntries"] = self.vpnPbrRouteEntries?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VpnPbrRouteEntries"] as? [String: Any?] {
            var model = DescribeVpnPbrRouteEntriesResponseBody.VpnPbrRouteEntries()
            model.fromMap(value)
            self.vpnPbrRouteEntries = model
        }
    }
}

public class DescribeVpnPbrRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnPbrRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnPbrRouteEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnRouteEntriesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryType: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntryType"] as? String {
            self.routeEntryType = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DescribeVpnRouteEntriesResponseBody : Tea.TeaModel {
    public class VpnRouteCounts : Tea.TeaModel {
        public class VpnRouteCount : Tea.TeaModel {
            public var routeCount: Int32?

            public var routeEntryType: String?

            public var source: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.routeCount != nil {
                    map["RouteCount"] = self.routeCount!
                }
                if self.routeEntryType != nil {
                    map["RouteEntryType"] = self.routeEntryType!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RouteCount"] as? Int32 {
                    self.routeCount = value
                }
                if let value = dict["RouteEntryType"] as? String {
                    self.routeEntryType = value
                }
                if let value = dict["Source"] as? String {
                    self.source = value
                }
            }
        }
        public var vpnRouteCount: [DescribeVpnRouteEntriesResponseBody.VpnRouteCounts.VpnRouteCount]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnRouteCount != nil {
                var tmp : [Any] = []
                for k in self.vpnRouteCount! {
                    tmp.append(k.toMap())
                }
                map["VpnRouteCount"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VpnRouteCount"] as? [Any?] {
                var tmp : [DescribeVpnRouteEntriesResponseBody.VpnRouteCounts.VpnRouteCount] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpnRouteEntriesResponseBody.VpnRouteCounts.VpnRouteCount()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vpnRouteCount = tmp
            }
        }
    }
    public class VpnRouteEntries : Tea.TeaModel {
        public class VpnRouteEntry : Tea.TeaModel {
            public var asPath: String?

            public var community: String?

            public var createTime: Int64?

            public var nextHop: String?

            public var nextHopTunnelId: String?

            public var routeDest: String?

            public var routeEntryType: String?

            public var source: String?

            public var state: String?

            public var vpnInstanceId: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.asPath != nil {
                    map["AsPath"] = self.asPath!
                }
                if self.community != nil {
                    map["Community"] = self.community!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.nextHop != nil {
                    map["NextHop"] = self.nextHop!
                }
                if self.nextHopTunnelId != nil {
                    map["NextHopTunnelId"] = self.nextHopTunnelId!
                }
                if self.routeDest != nil {
                    map["RouteDest"] = self.routeDest!
                }
                if self.routeEntryType != nil {
                    map["RouteEntryType"] = self.routeEntryType!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.vpnInstanceId != nil {
                    map["VpnInstanceId"] = self.vpnInstanceId!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AsPath"] as? String {
                    self.asPath = value
                }
                if let value = dict["Community"] as? String {
                    self.community = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["NextHop"] as? String {
                    self.nextHop = value
                }
                if let value = dict["NextHopTunnelId"] as? String {
                    self.nextHopTunnelId = value
                }
                if let value = dict["RouteDest"] as? String {
                    self.routeDest = value
                }
                if let value = dict["RouteEntryType"] as? String {
                    self.routeEntryType = value
                }
                if let value = dict["Source"] as? String {
                    self.source = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["VpnInstanceId"] as? String {
                    self.vpnInstanceId = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public var vpnRouteEntry: [DescribeVpnRouteEntriesResponseBody.VpnRouteEntries.VpnRouteEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpnRouteEntry != nil {
                var tmp : [Any] = []
                for k in self.vpnRouteEntry! {
                    tmp.append(k.toMap())
                }
                map["VpnRouteEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VpnRouteEntry"] as? [Any?] {
                var tmp : [DescribeVpnRouteEntriesResponseBody.VpnRouteEntries.VpnRouteEntry] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpnRouteEntriesResponseBody.VpnRouteEntries.VpnRouteEntry()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vpnRouteEntry = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnRouteCounts: DescribeVpnRouteEntriesResponseBody.VpnRouteCounts?

    public var vpnRouteEntries: DescribeVpnRouteEntriesResponseBody.VpnRouteEntries?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnRouteCounts?.validate()
        try self.vpnRouteEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnRouteCounts != nil {
            map["VpnRouteCounts"] = self.vpnRouteCounts?.toMap()
        }
        if self.vpnRouteEntries != nil {
            map["VpnRouteEntries"] = self.vpnRouteEntries?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VpnRouteCounts"] as? [String: Any?] {
            var model = DescribeVpnRouteEntriesResponseBody.VpnRouteCounts()
            model.fromMap(value)
            self.vpnRouteCounts = model
        }
        if let value = dict["VpnRouteEntries"] as? [String: Any?] {
            var model = DescribeVpnRouteEntriesResponseBody.VpnRouteEntries()
            model.fromMap(value)
            self.vpnRouteEntries = model
        }
    }
}

public class DescribeVpnRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnRouteEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpnSslServerLogsRequest : Tea.TeaModel {
    public var from: Int32?

    public var minutePeriod: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public var to: Int32?

    public var vpnSslServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.minutePeriod != nil {
            map["MinutePeriod"] = self.minutePeriod!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        if self.vpnSslServerId != nil {
            map["VpnSslServerId"] = self.vpnSslServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["From"] as? Int32 {
            self.from = value
        }
        if let value = dict["MinutePeriod"] as? Int32 {
            self.minutePeriod = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslVpnClientCertId"] as? String {
            self.sslVpnClientCertId = value
        }
        if let value = dict["To"] as? Int32 {
            self.to = value
        }
        if let value = dict["VpnSslServerId"] as? String {
            self.vpnSslServerId = value
        }
    }
}

public class DescribeVpnSslServerLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var logs: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logs != nil {
                map["Logs"] = self.logs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Logs"] as? [String] {
                self.logs = value
            }
        }
    }
    public var count: Int32?

    public var data: DescribeVpnSslServerLogsResponseBody.Data?

    public var isCompleted: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.isCompleted != nil {
            map["IsCompleted"] = self.isCompleted!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeVpnSslServerLogsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["IsCompleted"] as? Bool {
            self.isCompleted = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeVpnSslServerLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpnSslServerLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpnSslServerLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeZonesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneType != nil {
            map["ZoneType"] = self.zoneType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneType"] as? String {
            self.zoneType = value
        }
    }
}

public class DescribeZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public class Zone : Tea.TeaModel {
            public var localName: String?

            public var zoneId: String?

            public var zoneType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneType != nil {
                    map["ZoneType"] = self.zoneType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalName"] as? String {
                    self.localName = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
                if let value = dict["ZoneType"] as? String {
                    self.zoneType = value
                }
            }
        }
        public var zone: [DescribeZonesResponseBody.Zones.Zone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zone != nil {
                var tmp : [Any] = []
                for k in self.zone! {
                    tmp.append(k.toMap())
                }
                map["Zone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Zone"] as? [Any?] {
                var tmp : [DescribeZonesResponseBody.Zones.Zone] = []
                for v in value {
                    if v != nil {
                        var model = DescribeZonesResponseBody.Zones.Zone()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.zone = tmp
            }
        }
    }
    public var requestId: String?

    public var zones: DescribeZonesResponseBody.Zones?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.zones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            map["Zones"] = self.zones?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Zones"] as? [String: Any?] {
            var model = DescribeZonesResponseBody.Zones()
            model.fromMap(value)
            self.zones = model
        }
    }
}

public class DescribeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachDhcpOptionsSetFromVpcRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DetachDhcpOptionsSetFromVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachDhcpOptionsSetFromVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDhcpOptionsSetFromVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachDhcpOptionsSetFromVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DiagnoseVpnConnectionsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var tunnelIds: [String]?

    public var vpnConnectionIds: [String]?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tunnelIds != nil {
            map["TunnelIds"] = self.tunnelIds!
        }
        if self.vpnConnectionIds != nil {
            map["VpnConnectionIds"] = self.vpnConnectionIds!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TunnelIds"] as? [String] {
            self.tunnelIds = value
        }
        if let value = dict["VpnConnectionIds"] as? [String] {
            self.vpnConnectionIds = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DiagnoseVpnConnectionsResponseBody : Tea.TeaModel {
    public class VpnConnections : Tea.TeaModel {
        public var failedReason: String?

        public var failedReasonCode: String?

        public var failedTime: Int64?

        public var mismatchLocalParam: String?

        public var mismatchRemoteParam: String?

        public var severity: String?

        public var sourceLog: String?

        public var tunnelId: String?

        public var vpnConnectionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedReason != nil {
                map["FailedReason"] = self.failedReason!
            }
            if self.failedReasonCode != nil {
                map["FailedReasonCode"] = self.failedReasonCode!
            }
            if self.failedTime != nil {
                map["FailedTime"] = self.failedTime!
            }
            if self.mismatchLocalParam != nil {
                map["MismatchLocalParam"] = self.mismatchLocalParam!
            }
            if self.mismatchRemoteParam != nil {
                map["MismatchRemoteParam"] = self.mismatchRemoteParam!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.sourceLog != nil {
                map["SourceLog"] = self.sourceLog!
            }
            if self.tunnelId != nil {
                map["TunnelId"] = self.tunnelId!
            }
            if self.vpnConnectionId != nil {
                map["VpnConnectionId"] = self.vpnConnectionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FailedReason"] as? String {
                self.failedReason = value
            }
            if let value = dict["FailedReasonCode"] as? String {
                self.failedReasonCode = value
            }
            if let value = dict["FailedTime"] as? Int64 {
                self.failedTime = value
            }
            if let value = dict["MismatchLocalParam"] as? String {
                self.mismatchLocalParam = value
            }
            if let value = dict["MismatchRemoteParam"] as? String {
                self.mismatchRemoteParam = value
            }
            if let value = dict["Severity"] as? String {
                self.severity = value
            }
            if let value = dict["SourceLog"] as? String {
                self.sourceLog = value
            }
            if let value = dict["TunnelId"] as? String {
                self.tunnelId = value
            }
            if let value = dict["VpnConnectionId"] as? String {
                self.vpnConnectionId = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnConnections: [DiagnoseVpnConnectionsResponseBody.VpnConnections]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnConnections != nil {
            var tmp : [Any] = []
            for k in self.vpnConnections! {
                tmp.append(k.toMap())
            }
            map["VpnConnections"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VpnConnections"] as? [Any?] {
            var tmp : [DiagnoseVpnConnectionsResponseBody.VpnConnections] = []
            for v in value {
                if v != nil {
                    var model = DiagnoseVpnConnectionsResponseBody.VpnConnections()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.vpnConnections = tmp
        }
    }
}

public class DiagnoseVpnConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DiagnoseVpnConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DiagnoseVpnConnectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DiagnoseVpnGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var IPsecExtendInfo: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceType: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.IPsecExtendInfo != nil {
            map["IPsecExtendInfo"] = self.IPsecExtendInfo!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["IPsecExtendInfo"] as? String {
            self.IPsecExtendInfo = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DiagnoseVpnGatewayResponseBody : Tea.TeaModel {
    public var diagnoseId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiagnoseId"] as? String {
            self.diagnoseId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DiagnoseVpnGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DiagnoseVpnGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DiagnoseVpnGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableNatGatewayEcsMetricRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var natGatewayId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DisableNatGatewayEcsMetricResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableNatGatewayEcsMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableNatGatewayEcsMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableNatGatewayEcsMetricResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableVpcClassicLinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DisableVpcClassicLinkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableVpcClassicLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableVpcClassicLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableVpcClassicLinkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DissociateRouteTableFromGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var gatewayId: String?

    public var gatewayType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayType != nil {
            map["GatewayType"] = self.gatewayType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["GatewayId"] as? String {
            self.gatewayId = value
        }
        if let value = dict["GatewayType"] as? String {
            self.gatewayType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
    }
}

public class DissociateRouteTableFromGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DissociateRouteTableFromGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateRouteTableFromGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DissociateRouteTableFromGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DissociateRouteTablesFromVpcGatewayEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableIds != nil {
            map["RouteTableIds"] = self.routeTableIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EndpointId"] as? String {
            self.endpointId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableIds"] as? [String] {
            self.routeTableIds = value
        }
    }
}

public class DissociateRouteTablesFromVpcGatewayEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DissociateRouteTablesFromVpcGatewayEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateRouteTablesFromVpcGatewayEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DissociateRouteTablesFromVpcGatewayEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DissociateVpnGatewayWithCertificateRequest : Tea.TeaModel {
    public var certificateId: String?

    public var certificateType: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.certificateType != nil {
            map["CertificateType"] = self.certificateType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertificateId"] as? String {
            self.certificateId = value
        }
        if let value = dict["CertificateType"] as? String {
            self.certificateType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class DissociateVpnGatewayWithCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DissociateVpnGatewayWithCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateVpnGatewayWithCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DissociateVpnGatewayWithCertificateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DownloadVpnConnectionConfigRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class DownloadVpnConnectionConfigResponseBody : Tea.TeaModel {
    public class VpnConnectionConfig : Tea.TeaModel {
        public class BgpConfigs : Tea.TeaModel {
            public class BgpConfig : Tea.TeaModel {
                public var localAsn: String?

                public var localBgpIp: String?

                public var peerAsn: String?

                public var peerBgpIp: String?

                public var tunnelCidr: String?

                public var tunnelId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.localAsn != nil {
                        map["LocalAsn"] = self.localAsn!
                    }
                    if self.localBgpIp != nil {
                        map["LocalBgpIp"] = self.localBgpIp!
                    }
                    if self.peerAsn != nil {
                        map["PeerAsn"] = self.peerAsn!
                    }
                    if self.peerBgpIp != nil {
                        map["PeerBgpIp"] = self.peerBgpIp!
                    }
                    if self.tunnelCidr != nil {
                        map["TunnelCidr"] = self.tunnelCidr!
                    }
                    if self.tunnelId != nil {
                        map["TunnelId"] = self.tunnelId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LocalAsn"] as? String {
                        self.localAsn = value
                    }
                    if let value = dict["LocalBgpIp"] as? String {
                        self.localBgpIp = value
                    }
                    if let value = dict["PeerAsn"] as? String {
                        self.peerAsn = value
                    }
                    if let value = dict["PeerBgpIp"] as? String {
                        self.peerBgpIp = value
                    }
                    if let value = dict["TunnelCidr"] as? String {
                        self.tunnelCidr = value
                    }
                    if let value = dict["TunnelId"] as? String {
                        self.tunnelId = value
                    }
                }
            }
            public var bgpConfig: [DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.BgpConfigs.BgpConfig]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bgpConfig != nil {
                    var tmp : [Any] = []
                    for k in self.bgpConfig! {
                        tmp.append(k.toMap())
                    }
                    map["BgpConfig"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BgpConfig"] as? [Any?] {
                    var tmp : [DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.BgpConfigs.BgpConfig] = []
                    for v in value {
                        if v != nil {
                            var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.BgpConfigs.BgpConfig()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.bgpConfig = tmp
                }
            }
        }
        public class IkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IkeAuthAlg"] as? String {
                    self.ikeAuthAlg = value
                }
                if let value = dict["IkeEncAlg"] as? String {
                    self.ikeEncAlg = value
                }
                if let value = dict["IkeLifetime"] as? Int64 {
                    self.ikeLifetime = value
                }
                if let value = dict["IkeMode"] as? String {
                    self.ikeMode = value
                }
                if let value = dict["IkePfs"] as? String {
                    self.ikePfs = value
                }
                if let value = dict["IkeVersion"] as? String {
                    self.ikeVersion = value
                }
                if let value = dict["LocalId"] as? String {
                    self.localId = value
                }
                if let value = dict["Psk"] as? String {
                    self.psk = value
                }
                if let value = dict["RemoteId"] as? String {
                    self.remoteId = value
                }
            }
        }
        public class IpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpsecAuthAlg"] as? String {
                    self.ipsecAuthAlg = value
                }
                if let value = dict["IpsecEncAlg"] as? String {
                    self.ipsecEncAlg = value
                }
                if let value = dict["IpsecLifetime"] as? Int64 {
                    self.ipsecLifetime = value
                }
                if let value = dict["IpsecPfs"] as? String {
                    self.ipsecPfs = value
                }
            }
        }
        public class TunnelsConfig : Tea.TeaModel {
            public class TunnelConfig : Tea.TeaModel {
                public class IkeConfig : Tea.TeaModel {
                    public var ikeAuthAlg: String?

                    public var ikeEncAlg: String?

                    public var ikeLifetime: Int64?

                    public var ikeMode: String?

                    public var ikePfs: String?

                    public var ikeVersion: String?

                    public var localId: String?

                    public var psk: String?

                    public var remoteId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ikeAuthAlg != nil {
                            map["IkeAuthAlg"] = self.ikeAuthAlg!
                        }
                        if self.ikeEncAlg != nil {
                            map["IkeEncAlg"] = self.ikeEncAlg!
                        }
                        if self.ikeLifetime != nil {
                            map["IkeLifetime"] = self.ikeLifetime!
                        }
                        if self.ikeMode != nil {
                            map["IkeMode"] = self.ikeMode!
                        }
                        if self.ikePfs != nil {
                            map["IkePfs"] = self.ikePfs!
                        }
                        if self.ikeVersion != nil {
                            map["IkeVersion"] = self.ikeVersion!
                        }
                        if self.localId != nil {
                            map["LocalId"] = self.localId!
                        }
                        if self.psk != nil {
                            map["Psk"] = self.psk!
                        }
                        if self.remoteId != nil {
                            map["RemoteId"] = self.remoteId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["IkeAuthAlg"] as? String {
                            self.ikeAuthAlg = value
                        }
                        if let value = dict["IkeEncAlg"] as? String {
                            self.ikeEncAlg = value
                        }
                        if let value = dict["IkeLifetime"] as? Int64 {
                            self.ikeLifetime = value
                        }
                        if let value = dict["IkeMode"] as? String {
                            self.ikeMode = value
                        }
                        if let value = dict["IkePfs"] as? String {
                            self.ikePfs = value
                        }
                        if let value = dict["IkeVersion"] as? String {
                            self.ikeVersion = value
                        }
                        if let value = dict["LocalId"] as? String {
                            self.localId = value
                        }
                        if let value = dict["Psk"] as? String {
                            self.psk = value
                        }
                        if let value = dict["RemoteId"] as? String {
                            self.remoteId = value
                        }
                    }
                }
                public class IpsecConfig : Tea.TeaModel {
                    public var ipsecAuthAlg: String?

                    public var ipsecEncAlg: String?

                    public var ipsecLifetime: Int64?

                    public var ipsecPfs: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipsecAuthAlg != nil {
                            map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                        }
                        if self.ipsecEncAlg != nil {
                            map["IpsecEncAlg"] = self.ipsecEncAlg!
                        }
                        if self.ipsecLifetime != nil {
                            map["IpsecLifetime"] = self.ipsecLifetime!
                        }
                        if self.ipsecPfs != nil {
                            map["IpsecPfs"] = self.ipsecPfs!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["IpsecAuthAlg"] as? String {
                            self.ipsecAuthAlg = value
                        }
                        if let value = dict["IpsecEncAlg"] as? String {
                            self.ipsecEncAlg = value
                        }
                        if let value = dict["IpsecLifetime"] as? Int64 {
                            self.ipsecLifetime = value
                        }
                        if let value = dict["IpsecPfs"] as? String {
                            self.ipsecPfs = value
                        }
                    }
                }
                public var ikeConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig.IkeConfig?

                public var ipsecConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig.IpsecConfig?

                public var local: String?

                public var remote: String?

                public var tunnelId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.ikeConfig?.validate()
                    try self.ipsecConfig?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ikeConfig != nil {
                        map["IkeConfig"] = self.ikeConfig?.toMap()
                    }
                    if self.ipsecConfig != nil {
                        map["IpsecConfig"] = self.ipsecConfig?.toMap()
                    }
                    if self.local != nil {
                        map["Local"] = self.local!
                    }
                    if self.remote != nil {
                        map["Remote"] = self.remote!
                    }
                    if self.tunnelId != nil {
                        map["TunnelId"] = self.tunnelId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IkeConfig"] as? [String: Any?] {
                        var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig.IkeConfig()
                        model.fromMap(value)
                        self.ikeConfig = model
                    }
                    if let value = dict["IpsecConfig"] as? [String: Any?] {
                        var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig.IpsecConfig()
                        model.fromMap(value)
                        self.ipsecConfig = model
                    }
                    if let value = dict["Local"] as? String {
                        self.local = value
                    }
                    if let value = dict["Remote"] as? String {
                        self.remote = value
                    }
                    if let value = dict["TunnelId"] as? String {
                        self.tunnelId = value
                    }
                }
            }
            public var tunnelConfig: [DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tunnelConfig != nil {
                    var tmp : [Any] = []
                    for k in self.tunnelConfig! {
                        tmp.append(k.toMap())
                    }
                    map["TunnelConfig"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TunnelConfig"] as? [Any?] {
                    var tmp : [DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig] = []
                    for v in value {
                        if v != nil {
                            var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig.TunnelConfig()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tunnelConfig = tmp
                }
            }
        }
        public var bgpConfigs: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.BgpConfigs?

        public var ikeConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.IkeConfig?

        public var ipsecConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.IpsecConfig?

        public var local: String?

        public var localSubnet: String?

        public var remote: String?

        public var remoteSubnet: String?

        public var tunnelsConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bgpConfigs?.validate()
            try self.ikeConfig?.validate()
            try self.ipsecConfig?.validate()
            try self.tunnelsConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bgpConfigs != nil {
                map["BgpConfigs"] = self.bgpConfigs?.toMap()
            }
            if self.ikeConfig != nil {
                map["IkeConfig"] = self.ikeConfig?.toMap()
            }
            if self.ipsecConfig != nil {
                map["IpsecConfig"] = self.ipsecConfig?.toMap()
            }
            if self.local != nil {
                map["Local"] = self.local!
            }
            if self.localSubnet != nil {
                map["LocalSubnet"] = self.localSubnet!
            }
            if self.remote != nil {
                map["Remote"] = self.remote!
            }
            if self.remoteSubnet != nil {
                map["RemoteSubnet"] = self.remoteSubnet!
            }
            if self.tunnelsConfig != nil {
                map["TunnelsConfig"] = self.tunnelsConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BgpConfigs"] as? [String: Any?] {
                var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.BgpConfigs()
                model.fromMap(value)
                self.bgpConfigs = model
            }
            if let value = dict["IkeConfig"] as? [String: Any?] {
                var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.IkeConfig()
                model.fromMap(value)
                self.ikeConfig = model
            }
            if let value = dict["IpsecConfig"] as? [String: Any?] {
                var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.IpsecConfig()
                model.fromMap(value)
                self.ipsecConfig = model
            }
            if let value = dict["Local"] as? String {
                self.local = value
            }
            if let value = dict["LocalSubnet"] as? String {
                self.localSubnet = value
            }
            if let value = dict["Remote"] as? String {
                self.remote = value
            }
            if let value = dict["RemoteSubnet"] as? String {
                self.remoteSubnet = value
            }
            if let value = dict["TunnelsConfig"] as? [String: Any?] {
                var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig.TunnelsConfig()
                model.fromMap(value)
                self.tunnelsConfig = model
            }
        }
    }
    public var requestId: String?

    public var vpnConnectionConfig: DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpnConnectionConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpnConnectionConfig != nil {
            map["VpnConnectionConfig"] = self.vpnConnectionConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VpnConnectionConfig"] as? [String: Any?] {
            var model = DownloadVpnConnectionConfigResponseBody.VpnConnectionConfig()
            model.fromMap(value)
            self.vpnConnectionConfig = model
        }
    }
}

public class DownloadVpnConnectionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadVpnConnectionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DownloadVpnConnectionConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableNatGatewayEcsMetricRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var natGatewayId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class EnableNatGatewayEcsMetricResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableNatGatewayEcsMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableNatGatewayEcsMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableNatGatewayEcsMetricResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnablePhysicalConnectionRequest : Tea.TeaModel {
    public var byPassSp: Bool?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.byPassSp != nil {
            map["ByPassSp"] = self.byPassSp!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ByPassSp"] as? Bool {
            self.byPassSp = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class EnablePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnablePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnablePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnablePhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableVpcClassicLinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class EnableVpcClassicLinkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableVpcClassicLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableVpcClassicLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableVpcClassicLinkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableVpcIpv4GatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv4GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableList != nil {
            map["RouteTableList"] = self.routeTableList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv4GatewayId"] as? String {
            self.ipv4GatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableList"] as? [String] {
            self.routeTableList = value
        }
    }
}

public class EnableVpcIpv4GatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableVpcIpv4GatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableVpcIpv4GatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableVpcIpv4GatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDhcpOptionsSetRequest : Tea.TeaModel {
    public var dhcpOptionsSetId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetDhcpOptionsSetResponseBody : Tea.TeaModel {
    public class AssociateVpcs : Tea.TeaModel {
        public var associateStatus: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associateStatus != nil {
                map["AssociateStatus"] = self.associateStatus!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssociateStatus"] as? String {
                self.associateStatus = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public class DhcpOptions : Tea.TeaModel {
        public var domainName: String?

        public var domainNameServers: String?

        public var ipv6LeaseTime: String?

        public var leaseTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameServers != nil {
                map["DomainNameServers"] = self.domainNameServers!
            }
            if self.ipv6LeaseTime != nil {
                map["Ipv6LeaseTime"] = self.ipv6LeaseTime!
            }
            if self.leaseTime != nil {
                map["LeaseTime"] = self.leaseTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["DomainNameServers"] as? String {
                self.domainNameServers = value
            }
            if let value = dict["Ipv6LeaseTime"] as? String {
                self.ipv6LeaseTime = value
            }
            if let value = dict["LeaseTime"] as? String {
                self.leaseTime = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var associateVpcs: [GetDhcpOptionsSetResponseBody.AssociateVpcs]?

    public var creationTime: String?

    public var dhcpOptions: GetDhcpOptionsSetResponseBody.DhcpOptions?

    public var dhcpOptionsSetDescription: String?

    public var dhcpOptionsSetId: String?

    public var dhcpOptionsSetName: String?

    public var ownerId: Int64?

    public var requestId: String?

    public var resourceGroupId: String?

    public var status: String?

    public var tags: [GetDhcpOptionsSetResponseBody.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dhcpOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associateVpcs != nil {
            var tmp : [Any] = []
            for k in self.associateVpcs! {
                tmp.append(k.toMap())
            }
            map["AssociateVpcs"] = tmp
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.dhcpOptions != nil {
            map["DhcpOptions"] = self.dhcpOptions?.toMap()
        }
        if self.dhcpOptionsSetDescription != nil {
            map["DhcpOptionsSetDescription"] = self.dhcpOptionsSetDescription!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dhcpOptionsSetName != nil {
            map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AssociateVpcs"] as? [Any?] {
            var tmp : [GetDhcpOptionsSetResponseBody.AssociateVpcs] = []
            for v in value {
                if v != nil {
                    var model = GetDhcpOptionsSetResponseBody.AssociateVpcs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.associateVpcs = tmp
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["DhcpOptions"] as? [String: Any?] {
            var model = GetDhcpOptionsSetResponseBody.DhcpOptions()
            model.fromMap(value)
            self.dhcpOptions = model
        }
        if let value = dict["DhcpOptionsSetDescription"] as? String {
            self.dhcpOptionsSetDescription = value
        }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["DhcpOptionsSetName"] as? String {
            self.dhcpOptionsSetName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [GetDhcpOptionsSetResponseBody.Tags] = []
            for v in value {
                if v != nil {
                    var model = GetDhcpOptionsSetResponseBody.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class GetDhcpOptionsSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDhcpOptionsSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDhcpOptionsSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFlowLogServiceStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetFlowLogServiceStatusResponseBody : Tea.TeaModel {
    public var enabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetFlowLogServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFlowLogServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFlowLogServiceStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetIpv4GatewayAttributeRequest : Tea.TeaModel {
    public var ipv4GatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv4GatewayId"] as? String {
            self.ipv4GatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetIpv4GatewayAttributeResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var createTime: String?

    public var enabled: Bool?

    public var ipv4GatewayDescription: String?

    public var ipv4GatewayId: String?

    public var ipv4GatewayName: String?

    public var ipv4GatewayRouteTableId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var status: String?

    public var tags: [GetIpv4GatewayAttributeResponseBody.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ipv4GatewayDescription != nil {
            map["Ipv4GatewayDescription"] = self.ipv4GatewayDescription!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ipv4GatewayName != nil {
            map["Ipv4GatewayName"] = self.ipv4GatewayName!
        }
        if self.ipv4GatewayRouteTableId != nil {
            map["Ipv4GatewayRouteTableId"] = self.ipv4GatewayRouteTableId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["Ipv4GatewayDescription"] as? String {
            self.ipv4GatewayDescription = value
        }
        if let value = dict["Ipv4GatewayId"] as? String {
            self.ipv4GatewayId = value
        }
        if let value = dict["Ipv4GatewayName"] as? String {
            self.ipv4GatewayName = value
        }
        if let value = dict["Ipv4GatewayRouteTableId"] as? String {
            self.ipv4GatewayRouteTableId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [GetIpv4GatewayAttributeResponseBody.Tags] = []
            for v in value {
                if v != nil {
                    var model = GetIpv4GatewayAttributeResponseBody.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class GetIpv4GatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIpv4GatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetIpv4GatewayAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNatGatewayAttributeRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetNatGatewayAttributeResponseBody : Tea.TeaModel {
    public class AccessMode : Tea.TeaModel {
        public var modeValue: String?

        public var tunnelType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modeValue != nil {
                map["ModeValue"] = self.modeValue!
            }
            if self.tunnelType != nil {
                map["TunnelType"] = self.tunnelType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ModeValue"] as? String {
                self.modeValue = value
            }
            if let value = dict["TunnelType"] as? String {
                self.tunnelType = value
            }
        }
    }
    public class BillingConfig : Tea.TeaModel {
        public var autoPay: String?

        public var instanceChargeType: String?

        public var internetChargeType: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoPay != nil {
                map["AutoPay"] = self.autoPay!
            }
            if self.instanceChargeType != nil {
                map["InstanceChargeType"] = self.instanceChargeType!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoPay"] as? String {
                self.autoPay = value
            }
            if let value = dict["InstanceChargeType"] as? String {
                self.instanceChargeType = value
            }
            if let value = dict["InternetChargeType"] as? String {
                self.internetChargeType = value
            }
            if let value = dict["Spec"] as? String {
                self.spec = value
            }
        }
    }
    public class DeletionProtectionInfo : Tea.TeaModel {
        public var enabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
        }
    }
    public class ForwardTable : Tea.TeaModel {
        public var forwardEntryCount: Int32?

        public var forwardTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardEntryCount != nil {
                map["ForwardEntryCount"] = self.forwardEntryCount!
            }
            if self.forwardTableId != nil {
                map["ForwardTableId"] = self.forwardTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ForwardEntryCount"] as? Int32 {
                self.forwardEntryCount = value
            }
            if let value = dict["ForwardTableId"] as? String {
                self.forwardTableId = value
            }
        }
    }
    public class FullNatTable : Tea.TeaModel {
        public var fullNatEntryCount: Int64?

        public var fullNatTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fullNatEntryCount != nil {
                map["FullNatEntryCount"] = self.fullNatEntryCount!
            }
            if self.fullNatTableId != nil {
                map["FullNatTableId"] = self.fullNatTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FullNatEntryCount"] as? Int64 {
                self.fullNatEntryCount = value
            }
            if let value = dict["FullNatTableId"] as? String {
                self.fullNatTableId = value
            }
        }
    }
    public class IpList : Tea.TeaModel {
        public var allocationId: String?

        public var ipAddress: String?

        public var usingStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocationId != nil {
                map["AllocationId"] = self.allocationId!
            }
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            if self.usingStatus != nil {
                map["UsingStatus"] = self.usingStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AllocationId"] as? String {
                self.allocationId = value
            }
            if let value = dict["IpAddress"] as? String {
                self.ipAddress = value
            }
            if let value = dict["UsingStatus"] as? String {
                self.usingStatus = value
            }
        }
    }
    public class LogDelivery : Tea.TeaModel {
        public var deliverLogsErrorMessage: String?

        public var deliveryStatus: String?

        public var logDeliveryType: String?

        public var logDestination: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deliverLogsErrorMessage != nil {
                map["DeliverLogsErrorMessage"] = self.deliverLogsErrorMessage!
            }
            if self.deliveryStatus != nil {
                map["DeliveryStatus"] = self.deliveryStatus!
            }
            if self.logDeliveryType != nil {
                map["LogDeliveryType"] = self.logDeliveryType!
            }
            if self.logDestination != nil {
                map["LogDestination"] = self.logDestination!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeliverLogsErrorMessage"] as? String {
                self.deliverLogsErrorMessage = value
            }
            if let value = dict["DeliveryStatus"] as? String {
                self.deliveryStatus = value
            }
            if let value = dict["LogDeliveryType"] as? String {
                self.logDeliveryType = value
            }
            if let value = dict["LogDestination"] as? String {
                self.logDestination = value
            }
        }
    }
    public class PrivateInfo : Tea.TeaModel {
        public var eniInstanceId: String?

        public var izNo: String?

        public var maxBandwidth: Int32?

        public var privateIpAddress: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eniInstanceId != nil {
                map["EniInstanceId"] = self.eniInstanceId!
            }
            if self.izNo != nil {
                map["IzNo"] = self.izNo!
            }
            if self.maxBandwidth != nil {
                map["MaxBandwidth"] = self.maxBandwidth!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EniInstanceId"] as? String {
                self.eniInstanceId = value
            }
            if let value = dict["IzNo"] as? String {
                self.izNo = value
            }
            if let value = dict["MaxBandwidth"] as? Int32 {
                self.maxBandwidth = value
            }
            if let value = dict["PrivateIpAddress"] as? String {
                self.privateIpAddress = value
            }
            if let value = dict["VswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public class SnatTable : Tea.TeaModel {
        public var snatEntryCount: Int32?

        public var snatTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snatEntryCount != nil {
                map["SnatEntryCount"] = self.snatEntryCount!
            }
            if self.snatTableId != nil {
                map["SnatTableId"] = self.snatTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SnatEntryCount"] as? Int32 {
                self.snatEntryCount = value
            }
            if let value = dict["SnatTableId"] as? String {
                self.snatTableId = value
            }
        }
    }
    public var accessMode: GetNatGatewayAttributeResponseBody.AccessMode?

    public var billingConfig: GetNatGatewayAttributeResponseBody.BillingConfig?

    public var businessStatus: String?

    public var creationTime: String?

    public var deletionProtectionInfo: GetNatGatewayAttributeResponseBody.DeletionProtectionInfo?

    public var description_: String?

    public var ecsMetricEnabled: Bool?

    public var enableSessionLog: Bool?

    public var expiredTime: String?

    public var forwardTable: GetNatGatewayAttributeResponseBody.ForwardTable?

    public var fullNatTable: GetNatGatewayAttributeResponseBody.FullNatTable?

    public var ipList: [GetNatGatewayAttributeResponseBody.IpList]?

    public var logDelivery: GetNatGatewayAttributeResponseBody.LogDelivery?

    public var name: String?

    public var natGatewayId: String?

    public var natType: String?

    public var networkType: String?

    public var privateInfo: GetNatGatewayAttributeResponseBody.PrivateInfo?

    public var privateLinkEnabled: Bool?

    public var privateLinkMode: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var snatTable: GetNatGatewayAttributeResponseBody.SnatTable?

    public var status: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessMode?.validate()
        try self.billingConfig?.validate()
        try self.deletionProtectionInfo?.validate()
        try self.forwardTable?.validate()
        try self.fullNatTable?.validate()
        try self.logDelivery?.validate()
        try self.privateInfo?.validate()
        try self.snatTable?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode?.toMap()
        }
        if self.billingConfig != nil {
            map["BillingConfig"] = self.billingConfig?.toMap()
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.deletionProtectionInfo != nil {
            map["DeletionProtectionInfo"] = self.deletionProtectionInfo?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ecsMetricEnabled != nil {
            map["EcsMetricEnabled"] = self.ecsMetricEnabled!
        }
        if self.enableSessionLog != nil {
            map["EnableSessionLog"] = self.enableSessionLog!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.forwardTable != nil {
            map["ForwardTable"] = self.forwardTable?.toMap()
        }
        if self.fullNatTable != nil {
            map["FullNatTable"] = self.fullNatTable?.toMap()
        }
        if self.ipList != nil {
            var tmp : [Any] = []
            for k in self.ipList! {
                tmp.append(k.toMap())
            }
            map["IpList"] = tmp
        }
        if self.logDelivery != nil {
            map["LogDelivery"] = self.logDelivery?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.privateInfo != nil {
            map["PrivateInfo"] = self.privateInfo?.toMap()
        }
        if self.privateLinkEnabled != nil {
            map["PrivateLinkEnabled"] = self.privateLinkEnabled!
        }
        if self.privateLinkMode != nil {
            map["PrivateLinkMode"] = self.privateLinkMode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.snatTable != nil {
            map["SnatTable"] = self.snatTable?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessMode"] as? [String: Any?] {
            var model = GetNatGatewayAttributeResponseBody.AccessMode()
            model.fromMap(value)
            self.accessMode = model
        }
        if let value = dict["BillingConfig"] as? [String: Any?] {
            var model = GetNatGatewayAttributeResponseBody.BillingConfig()
            model.fromMap(value)
            self.billingConfig = model
        }
        if let value = dict["BusinessStatus"] as? String {
            self.businessStatus = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["DeletionProtectionInfo"] as? [String: Any?] {
            var model = GetNatGatewayAttributeResponseBody.DeletionProtectionInfo()
            model.fromMap(value)
            self.deletionProtectionInfo = model
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EcsMetricEnabled"] as? Bool {
            self.ecsMetricEnabled = value
        }
        if let value = dict["EnableSessionLog"] as? Bool {
            self.enableSessionLog = value
        }
        if let value = dict["ExpiredTime"] as? String {
            self.expiredTime = value
        }
        if let value = dict["ForwardTable"] as? [String: Any?] {
            var model = GetNatGatewayAttributeResponseBody.ForwardTable()
            model.fromMap(value)
            self.forwardTable = model
        }
        if let value = dict["FullNatTable"] as? [String: Any?] {
            var model = GetNatGatewayAttributeResponseBody.FullNatTable()
            model.fromMap(value)
            self.fullNatTable = model
        }
        if let value = dict["IpList"] as? [Any?] {
            var tmp : [GetNatGatewayAttributeResponseBody.IpList] = []
            for v in value {
                if v != nil {
                    var model = GetNatGatewayAttributeResponseBody.IpList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ipList = tmp
        }
        if let value = dict["LogDelivery"] as? [String: Any?] {
            var model = GetNatGatewayAttributeResponseBody.LogDelivery()
            model.fromMap(value)
            self.logDelivery = model
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatType"] as? String {
            self.natType = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["PrivateInfo"] as? [String: Any?] {
            var model = GetNatGatewayAttributeResponseBody.PrivateInfo()
            model.fromMap(value)
            self.privateInfo = model
        }
        if let value = dict["PrivateLinkEnabled"] as? Bool {
            self.privateLinkEnabled = value
        }
        if let value = dict["PrivateLinkMode"] as? String {
            self.privateLinkMode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SnatTable"] as? [String: Any?] {
            var model = GetNatGatewayAttributeResponseBody.SnatTable()
            model.fromMap(value)
            self.snatTable = model
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class GetNatGatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNatGatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNatGatewayAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPhysicalConnectionServiceStatusRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetPhysicalConnectionServiceStatusResponseBody : Tea.TeaModel {
    public var enabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPhysicalConnectionServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPhysicalConnectionServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPhysicalConnectionServiceStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPublicIpAddressPoolServiceStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetPublicIpAddressPoolServiceStatusResponseBody : Tea.TeaModel {
    public var enabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPublicIpAddressPoolServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPublicIpAddressPoolServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPublicIpAddressPoolServiceStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRouteTargetGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var regionId: String?

    public var routeTargetGroupId: String?

    public var tag: [GetRouteTargetGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.routeTargetGroupId != nil {
            map["RouteTargetGroupId"] = self.routeTargetGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RouteTargetGroupId"] as? String {
            self.routeTargetGroupId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [GetRouteTargetGroupRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = GetRouteTargetGroupRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class GetRouteTargetGroupResponseBody : Tea.TeaModel {
    public class RouteTargetMemberList : Tea.TeaModel {
        public var enableStatus: String?

        public var healthCheckStatus: String?

        public var memberId: String?

        public var memberType: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableStatus != nil {
                map["EnableStatus"] = self.enableStatus!
            }
            if self.healthCheckStatus != nil {
                map["HealthCheckStatus"] = self.healthCheckStatus!
            }
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableStatus"] as? String {
                self.enableStatus = value
            }
            if let value = dict["HealthCheckStatus"] as? String {
                self.healthCheckStatus = value
            }
            if let value = dict["MemberId"] as? String {
                self.memberId = value
            }
            if let value = dict["MemberType"] as? String {
                self.memberType = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var configMode: String?

    public var createTime: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var routeTargetGroupDescription: String?

    public var routeTargetGroupId: String?

    public var routeTargetGroupName: String?

    public var routeTargetMemberList: [GetRouteTargetGroupResponseBody.RouteTargetMemberList]?

    public var status: String?

    public var tags: [GetRouteTargetGroupResponseBody.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configMode != nil {
            map["ConfigMode"] = self.configMode!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.routeTargetGroupDescription != nil {
            map["RouteTargetGroupDescription"] = self.routeTargetGroupDescription!
        }
        if self.routeTargetGroupId != nil {
            map["RouteTargetGroupId"] = self.routeTargetGroupId!
        }
        if self.routeTargetGroupName != nil {
            map["RouteTargetGroupName"] = self.routeTargetGroupName!
        }
        if self.routeTargetMemberList != nil {
            var tmp : [Any] = []
            for k in self.routeTargetMemberList! {
                tmp.append(k.toMap())
            }
            map["RouteTargetMemberList"] = tmp
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigMode"] as? String {
            self.configMode = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["RouteTargetGroupDescription"] as? String {
            self.routeTargetGroupDescription = value
        }
        if let value = dict["RouteTargetGroupId"] as? String {
            self.routeTargetGroupId = value
        }
        if let value = dict["RouteTargetGroupName"] as? String {
            self.routeTargetGroupName = value
        }
        if let value = dict["RouteTargetMemberList"] as? [Any?] {
            var tmp : [GetRouteTargetGroupResponseBody.RouteTargetMemberList] = []
            for v in value {
                if v != nil {
                    var model = GetRouteTargetGroupResponseBody.RouteTargetMemberList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeTargetMemberList = tmp
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [GetRouteTargetGroupResponseBody.Tags] = []
            for v in value {
                if v != nil {
                    var model = GetRouteTargetGroupResponseBody.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class GetRouteTargetGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRouteTargetGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRouteTargetGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTrafficMirrorServiceStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetTrafficMirrorServiceStatusResponseBody : Tea.TeaModel {
    public var enabled: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetTrafficMirrorServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTrafficMirrorServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTrafficMirrorServiceStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetVSwitchCidrReservationUsageRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchCidrReservationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchCidrReservationId != nil {
            map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchCidrReservationId"] as? String {
            self.vSwitchCidrReservationId = value
        }
    }
}

public class GetVSwitchCidrReservationUsageResponseBody : Tea.TeaModel {
    public class CidrReservationUsages : Tea.TeaModel {
        public var ipPrefixCidr: String?

        public var ipPrefixId: String?

        public var resourceId: String?

        public var resourceType: String?

        public var vSwitchCidrReservationId: String?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipPrefixCidr != nil {
                map["IpPrefixCidr"] = self.ipPrefixCidr!
            }
            if self.ipPrefixId != nil {
                map["IpPrefixId"] = self.ipPrefixId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.vSwitchCidrReservationId != nil {
                map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IpPrefixCidr"] as? String {
                self.ipPrefixCidr = value
            }
            if let value = dict["IpPrefixId"] as? String {
                self.ipPrefixId = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["VSwitchCidrReservationId"] as? String {
                self.vSwitchCidrReservationId = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
        }
    }
    public var cidrReservationUsages: [GetVSwitchCidrReservationUsageResponseBody.CidrReservationUsages]?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrReservationUsages != nil {
            var tmp : [Any] = []
            for k in self.cidrReservationUsages! {
                tmp.append(k.toMap())
            }
            map["CidrReservationUsages"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrReservationUsages"] as? [Any?] {
            var tmp : [GetVSwitchCidrReservationUsageResponseBody.CidrReservationUsages] = []
            for v in value {
                if v != nil {
                    var model = GetVSwitchCidrReservationUsageResponseBody.CidrReservationUsages()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.cidrReservationUsages = tmp
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class GetVSwitchCidrReservationUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVSwitchCidrReservationUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetVSwitchCidrReservationUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetVpcGatewayEndpointAttributeRequest : Tea.TeaModel {
    public var endpointId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndpointId"] as? String {
            self.endpointId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetVpcGatewayEndpointAttributeResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var creationTime: String?

    public var endpointDescription: String?

    public var endpointId: String?

    public var endpointName: String?

    public var endpointStatus: String?

    public var policyDocument: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var routeTables: [String]?

    public var serviceName: String?

    public var tags: [GetVpcGatewayEndpointAttributeResponseBody.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.endpointDescription != nil {
            map["EndpointDescription"] = self.endpointDescription!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.endpointStatus != nil {
            map["EndpointStatus"] = self.endpointStatus!
        }
        if self.policyDocument != nil {
            map["PolicyDocument"] = self.policyDocument!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.routeTables != nil {
            map["RouteTables"] = self.routeTables!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["EndpointDescription"] as? String {
            self.endpointDescription = value
        }
        if let value = dict["EndpointId"] as? String {
            self.endpointId = value
        }
        if let value = dict["EndpointName"] as? String {
            self.endpointName = value
        }
        if let value = dict["EndpointStatus"] as? String {
            self.endpointStatus = value
        }
        if let value = dict["PolicyDocument"] as? String {
            self.policyDocument = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["RouteTables"] as? [String] {
            self.routeTables = value
        }
        if let value = dict["ServiceName"] as? String {
            self.serviceName = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [GetVpcGatewayEndpointAttributeResponseBody.Tags] = []
            for v in value {
                if v != nil {
                    var model = GetVpcGatewayEndpointAttributeResponseBody.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class GetVpcGatewayEndpointAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpcGatewayEndpointAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetVpcGatewayEndpointAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetVpcPrefixListAssociationsRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetVpcPrefixListAssociationsResponseBody : Tea.TeaModel {
    public class PrefixListAssociation : Tea.TeaModel {
        public var cidrList: String?

        public var ownerId: String?

        public var prefixListId: String?

        public var reason: String?

        public var regionId: String?

        public var resourceId: String?

        public var resourceType: String?

        public var resourceUid: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrList != nil {
                map["CidrList"] = self.cidrList!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.prefixListId != nil {
                map["PrefixListId"] = self.prefixListId!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.resourceUid != nil {
                map["ResourceUid"] = self.resourceUid!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CidrList"] as? String {
                self.cidrList = value
            }
            if let value = dict["OwnerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["PrefixListId"] as? String {
                self.prefixListId = value
            }
            if let value = dict["Reason"] as? String {
                self.reason = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["ResourceUid"] as? String {
                self.resourceUid = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var count: Int64?

    public var nextToken: String?

    public var prefixListAssociation: [GetVpcPrefixListAssociationsResponseBody.PrefixListAssociation]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixListAssociation != nil {
            var tmp : [Any] = []
            for k in self.prefixListAssociation! {
                tmp.append(k.toMap())
            }
            map["PrefixListAssociation"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int64 {
            self.count = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PrefixListAssociation"] as? [Any?] {
            var tmp : [GetVpcPrefixListAssociationsResponseBody.PrefixListAssociation] = []
            for v in value {
                if v != nil {
                    var model = GetVpcPrefixListAssociationsResponseBody.PrefixListAssociation()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.prefixListAssociation = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class GetVpcPrefixListAssociationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpcPrefixListAssociationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetVpcPrefixListAssociationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetVpcPrefixListEntriesRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetVpcPrefixListEntriesResponseBody : Tea.TeaModel {
    public class PrefixListEntry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public var prefixListId: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.prefixListId != nil {
                map["PrefixListId"] = self.prefixListId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cidr"] as? String {
                self.cidr = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["PrefixListId"] as? String {
                self.prefixListId = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var count: Int64?

    public var nextToken: String?

    public var prefixListEntry: [GetVpcPrefixListEntriesResponseBody.PrefixListEntry]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixListEntry != nil {
            var tmp : [Any] = []
            for k in self.prefixListEntry! {
                tmp.append(k.toMap())
            }
            map["PrefixListEntry"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int64 {
            self.count = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PrefixListEntry"] as? [Any?] {
            var tmp : [GetVpcPrefixListEntriesResponseBody.PrefixListEntry] = []
            for v in value {
                if v != nil {
                    var model = GetVpcPrefixListEntriesResponseBody.PrefixListEntry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.prefixListEntry = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class GetVpcPrefixListEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpcPrefixListEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetVpcPrefixListEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetVpcRouteEntrySummaryRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryType: String?

    public var routeTableId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntryType"] as? String {
            self.routeEntryType = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class GetVpcRouteEntrySummaryResponseBody : Tea.TeaModel {
    public class RouteEntrySummarys : Tea.TeaModel {
        public class EntrySummarys : Tea.TeaModel {
            public var count: Int32?

            public var routeEntryType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.routeEntryType != nil {
                    map["RouteEntryType"] = self.routeEntryType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["RouteEntryType"] as? String {
                    self.routeEntryType = value
                }
            }
        }
        public var entrySummarys: [GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys.EntrySummarys]?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entrySummarys != nil {
                var tmp : [Any] = []
                for k in self.entrySummarys! {
                    tmp.append(k.toMap())
                }
                map["EntrySummarys"] = tmp
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EntrySummarys"] as? [Any?] {
                var tmp : [GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys.EntrySummarys] = []
                for v in value {
                    if v != nil {
                        var model = GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys.EntrySummarys()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.entrySummarys = tmp
            }
            if let value = dict["RouteTableId"] as? String {
                self.routeTableId = value
            }
        }
    }
    public var requestId: String?

    public var routeEntrySummarys: [GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntrySummarys != nil {
            var tmp : [Any] = []
            for k in self.routeEntrySummarys! {
                tmp.append(k.toMap())
            }
            map["RouteEntrySummarys"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteEntrySummarys"] as? [Any?] {
            var tmp : [GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys] = []
            for v in value {
                if v != nil {
                    var model = GetVpcRouteEntrySummaryResponseBody.RouteEntrySummarys()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeEntrySummarys = tmp
        }
    }
}

public class GetVpcRouteEntrySummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpcRouteEntrySummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetVpcRouteEntrySummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetVpnGatewayDiagnoseResultRequest : Tea.TeaModel {
    public var clientToken: String?

    public var diagnoseId: String?

    public var regionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DiagnoseId"] as? String {
            self.diagnoseId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class GetVpnGatewayDiagnoseResultResponseBody : Tea.TeaModel {
    public class DiagnoseResult : Tea.TeaModel {
        public var diagnoseName: String?

        public var diagnoseResultDescription: String?

        public var diagnoseResultLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diagnoseName != nil {
                map["DiagnoseName"] = self.diagnoseName!
            }
            if self.diagnoseResultDescription != nil {
                map["DiagnoseResultDescription"] = self.diagnoseResultDescription!
            }
            if self.diagnoseResultLevel != nil {
                map["DiagnoseResultLevel"] = self.diagnoseResultLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiagnoseName"] as? String {
                self.diagnoseName = value
            }
            if let value = dict["DiagnoseResultDescription"] as? String {
                self.diagnoseResultDescription = value
            }
            if let value = dict["DiagnoseResultLevel"] as? String {
                self.diagnoseResultLevel = value
            }
        }
    }
    public var beginTime: String?

    public var diagnoseId: String?

    public var diagnoseResult: [GetVpnGatewayDiagnoseResultResponseBody.DiagnoseResult]?

    public var finishTime: String?

    public var finishedCount: Int32?

    public var requestId: String?

    public var resourceInstanceId: String?

    public var resourceType: String?

    public var totalCount: Int32?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.diagnoseResult != nil {
            var tmp : [Any] = []
            for k in self.diagnoseResult! {
                tmp.append(k.toMap())
            }
            map["DiagnoseResult"] = tmp
        }
        if self.finishTime != nil {
            map["FinishTime"] = self.finishTime!
        }
        if self.finishedCount != nil {
            map["FinishedCount"] = self.finishedCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceInstanceId != nil {
            map["ResourceInstanceId"] = self.resourceInstanceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BeginTime"] as? String {
            self.beginTime = value
        }
        if let value = dict["DiagnoseId"] as? String {
            self.diagnoseId = value
        }
        if let value = dict["DiagnoseResult"] as? [Any?] {
            var tmp : [GetVpnGatewayDiagnoseResultResponseBody.DiagnoseResult] = []
            for v in value {
                if v != nil {
                    var model = GetVpnGatewayDiagnoseResultResponseBody.DiagnoseResult()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.diagnoseResult = tmp
        }
        if let value = dict["FinishTime"] as? String {
            self.finishTime = value
        }
        if let value = dict["FinishedCount"] as? Int32 {
            self.finishedCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceInstanceId"] as? String {
            self.resourceInstanceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class GetVpnGatewayDiagnoseResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVpnGatewayDiagnoseResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetVpnGatewayDiagnoseResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GrantInstanceToCenRequest : Tea.TeaModel {
    public var cenId: String?

    public var cenOwnerId: Int64?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.cenOwnerId != nil {
            map["CenOwnerId"] = self.cenOwnerId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CenId"] as? String {
            self.cenId = value
        }
        if let value = dict["CenOwnerId"] as? Int64 {
            self.cenOwnerId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GrantInstanceToCenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GrantInstanceToCenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantInstanceToCenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GrantInstanceToCenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GrantInstanceToVbrRequest : Tea.TeaModel {
    public var grantType: String?

    public var instanceId: String?

    public var regionId: String?

    public var vbrInstanceIds: [String]?

    public var vbrOwnerUid: Int64?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grantType != nil {
            map["GrantType"] = self.grantType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vbrInstanceIds != nil {
            map["VbrInstanceIds"] = self.vbrInstanceIds!
        }
        if self.vbrOwnerUid != nil {
            map["VbrOwnerUid"] = self.vbrOwnerUid!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GrantType"] as? String {
            self.grantType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VbrInstanceIds"] as? [String] {
            self.vbrInstanceIds = value
        }
        if let value = dict["VbrOwnerUid"] as? Int64 {
            self.vbrOwnerUid = value
        }
        if let value = dict["VbrRegionNo"] as? String {
            self.vbrRegionNo = value
        }
    }
}

public class GrantInstanceToVbrShrinkRequest : Tea.TeaModel {
    public var grantType: String?

    public var instanceId: String?

    public var regionId: String?

    public var vbrInstanceIdsShrink: String?

    public var vbrOwnerUid: Int64?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grantType != nil {
            map["GrantType"] = self.grantType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vbrInstanceIdsShrink != nil {
            map["VbrInstanceIds"] = self.vbrInstanceIdsShrink!
        }
        if self.vbrOwnerUid != nil {
            map["VbrOwnerUid"] = self.vbrOwnerUid!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GrantType"] as? String {
            self.grantType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VbrInstanceIds"] as? String {
            self.vbrInstanceIdsShrink = value
        }
        if let value = dict["VbrOwnerUid"] as? Int64 {
            self.vbrOwnerUid = value
        }
        if let value = dict["VbrRegionNo"] as? String {
            self.vbrRegionNo = value
        }
    }
}

public class GrantInstanceToVbrResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GrantInstanceToVbrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantInstanceToVbrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GrantInstanceToVbrResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListBusinessAccessPointsRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListBusinessAccessPointsResponseBody : Tea.TeaModel {
    public class BusinessAccessPoints : Tea.TeaModel {
        public class OpticalModuleModels : Tea.TeaModel {
            public var opticalModuleModel: String?

            public var portType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.opticalModuleModel != nil {
                    map["OpticalModuleModel"] = self.opticalModuleModel!
                }
                if self.portType != nil {
                    map["PortType"] = self.portType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OpticalModuleModel"] as? String {
                    self.opticalModuleModel = value
                }
                if let value = dict["PortType"] as? String {
                    self.portType = value
                }
            }
        }
        public var accessPointId: String?

        public var accessPointName: String?

        public var cloudBoxInstanceIds: String?

        public var latitude: Double?

        public var longitude: Double?

        public var opticalModuleModels: [ListBusinessAccessPointsResponseBody.BusinessAccessPoints.OpticalModuleModels]?

        public var supportLineOperator: String?

        public var supportPortTypes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointId != nil {
                map["AccessPointId"] = self.accessPointId!
            }
            if self.accessPointName != nil {
                map["AccessPointName"] = self.accessPointName!
            }
            if self.cloudBoxInstanceIds != nil {
                map["CloudBoxInstanceIds"] = self.cloudBoxInstanceIds!
            }
            if self.latitude != nil {
                map["Latitude"] = self.latitude!
            }
            if self.longitude != nil {
                map["Longitude"] = self.longitude!
            }
            if self.opticalModuleModels != nil {
                var tmp : [Any] = []
                for k in self.opticalModuleModels! {
                    tmp.append(k.toMap())
                }
                map["OpticalModuleModels"] = tmp
            }
            if self.supportLineOperator != nil {
                map["SupportLineOperator"] = self.supportLineOperator!
            }
            if self.supportPortTypes != nil {
                map["SupportPortTypes"] = self.supportPortTypes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessPointId"] as? String {
                self.accessPointId = value
            }
            if let value = dict["AccessPointName"] as? String {
                self.accessPointName = value
            }
            if let value = dict["CloudBoxInstanceIds"] as? String {
                self.cloudBoxInstanceIds = value
            }
            if let value = dict["Latitude"] as? Double {
                self.latitude = value
            }
            if let value = dict["Longitude"] as? Double {
                self.longitude = value
            }
            if let value = dict["OpticalModuleModels"] as? [Any?] {
                var tmp : [ListBusinessAccessPointsResponseBody.BusinessAccessPoints.OpticalModuleModels] = []
                for v in value {
                    if v != nil {
                        var model = ListBusinessAccessPointsResponseBody.BusinessAccessPoints.OpticalModuleModels()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.opticalModuleModels = tmp
            }
            if let value = dict["SupportLineOperator"] as? String {
                self.supportLineOperator = value
            }
            if let value = dict["SupportPortTypes"] as? String {
                self.supportPortTypes = value
            }
        }
    }
    public var businessAccessPoints: [ListBusinessAccessPointsResponseBody.BusinessAccessPoints]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessAccessPoints != nil {
            var tmp : [Any] = []
            for k in self.businessAccessPoints! {
                tmp.append(k.toMap())
            }
            map["BusinessAccessPoints"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessAccessPoints"] as? [Any?] {
            var tmp : [ListBusinessAccessPointsResponseBody.BusinessAccessPoints] = []
            for v in value {
                if v != nil {
                    var model = ListBusinessAccessPointsResponseBody.BusinessAccessPoints()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.businessAccessPoints = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListBusinessAccessPointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBusinessAccessPointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListBusinessAccessPointsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListBusinessRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
    }
}

public class ListBusinessRegionsResponseBody : Tea.TeaModel {
    public class GeographicSubRegions : Tea.TeaModel {
        public var name: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var count: Int64?

    public var geographicSubRegions: [ListBusinessRegionsResponseBody.GeographicSubRegions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.geographicSubRegions != nil {
            var tmp : [Any] = []
            for k in self.geographicSubRegions! {
                tmp.append(k.toMap())
            }
            map["GeographicSubRegions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int64 {
            self.count = value
        }
        if let value = dict["GeographicSubRegions"] as? [Any?] {
            var tmp : [ListBusinessRegionsResponseBody.GeographicSubRegions] = []
            for v in value {
                if v != nil {
                    var model = ListBusinessRegionsResponseBody.GeographicSubRegions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.geographicSubRegions = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListBusinessRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBusinessRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListBusinessRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDhcpOptionsSetsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dhcpOptionsSetId: [String]?

    public var dhcpOptionsSetName: String?

    public var domainName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListDhcpOptionsSetsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dhcpOptionsSetName != nil {
            map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DhcpOptionsSetId"] as? [String] {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["DhcpOptionsSetName"] as? String {
            self.dhcpOptionsSetName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListDhcpOptionsSetsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListDhcpOptionsSetsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class ListDhcpOptionsSetsResponseBody : Tea.TeaModel {
    public class DhcpOptionsSets : Tea.TeaModel {
        public class DhcpOptions : Tea.TeaModel {
            public var domainName: String?

            public var domainNameServers: String?

            public var ipv6LeaseTime: String?

            public var leaseTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainNameServers != nil {
                    map["DomainNameServers"] = self.domainNameServers!
                }
                if self.ipv6LeaseTime != nil {
                    map["Ipv6LeaseTime"] = self.ipv6LeaseTime!
                }
                if self.leaseTime != nil {
                    map["LeaseTime"] = self.leaseTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["DomainNameServers"] as? String {
                    self.domainNameServers = value
                }
                if let value = dict["Ipv6LeaseTime"] as? String {
                    self.ipv6LeaseTime = value
                }
                if let value = dict["LeaseTime"] as? String {
                    self.leaseTime = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var associateVpcCount: Int32?

        public var creationTime: String?

        public var dhcpOptions: ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.DhcpOptions?

        public var dhcpOptionsSetDescription: String?

        public var dhcpOptionsSetId: String?

        public var dhcpOptionsSetName: String?

        public var ownerId: Int64?

        public var resourceGroupId: String?

        public var status: String?

        public var tags: [ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dhcpOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associateVpcCount != nil {
                map["AssociateVpcCount"] = self.associateVpcCount!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dhcpOptions != nil {
                map["DhcpOptions"] = self.dhcpOptions?.toMap()
            }
            if self.dhcpOptionsSetDescription != nil {
                map["DhcpOptionsSetDescription"] = self.dhcpOptionsSetDescription!
            }
            if self.dhcpOptionsSetId != nil {
                map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
            }
            if self.dhcpOptionsSetName != nil {
                map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssociateVpcCount"] as? Int32 {
                self.associateVpcCount = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["DhcpOptions"] as? [String: Any?] {
                var model = ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.DhcpOptions()
                model.fromMap(value)
                self.dhcpOptions = model
            }
            if let value = dict["DhcpOptionsSetDescription"] as? String {
                self.dhcpOptionsSetDescription = value
            }
            if let value = dict["DhcpOptionsSetId"] as? String {
                self.dhcpOptionsSetId = value
            }
            if let value = dict["DhcpOptionsSetName"] as? String {
                self.dhcpOptionsSetName = value
            }
            if let value = dict["OwnerId"] as? Int64 {
                self.ownerId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListDhcpOptionsSetsResponseBody.DhcpOptionsSets.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
        }
    }
    public var dhcpOptionsSets: [ListDhcpOptionsSetsResponseBody.DhcpOptionsSets]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dhcpOptionsSets != nil {
            var tmp : [Any] = []
            for k in self.dhcpOptionsSets! {
                tmp.append(k.toMap())
            }
            map["DhcpOptionsSets"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DhcpOptionsSets"] as? [Any?] {
            var tmp : [ListDhcpOptionsSetsResponseBody.DhcpOptionsSets] = []
            for v in value {
                if v != nil {
                    var model = ListDhcpOptionsSetsResponseBody.DhcpOptionsSets()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dhcpOptionsSets = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class ListDhcpOptionsSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDhcpOptionsSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDhcpOptionsSetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEnhanhcedNatGatewayAvailableZonesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var acceptLanguage: String?

    public var filter: [ListEnhanhcedNatGatewayAvailableZonesRequest.Filter]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [ListEnhanhcedNatGatewayAvailableZonesRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = ListEnhanhcedNatGatewayAvailableZonesRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ListEnhanhcedNatGatewayAvailableZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public var localName: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LocalName"] as? String {
                self.localName = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var requestId: String?

    public var zones: [ListEnhanhcedNatGatewayAvailableZonesResponseBody.Zones]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            var tmp : [Any] = []
            for k in self.zones! {
                tmp.append(k.toMap())
            }
            map["Zones"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Zones"] as? [Any?] {
            var tmp : [ListEnhanhcedNatGatewayAvailableZonesResponseBody.Zones] = []
            for v in value {
                if v != nil {
                    var model = ListEnhanhcedNatGatewayAvailableZonesResponseBody.Zones()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.zones = tmp
        }
    }
}

public class ListEnhanhcedNatGatewayAvailableZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEnhanhcedNatGatewayAvailableZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEnhanhcedNatGatewayAvailableZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListFullNatEntriesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var fullNatEntryId: String?

    public var fullNatEntryNames: [String]?

    public var fullNatTableId: String?

    public var ipProtocol: String?

    public var maxResults: Int64?

    public var natGatewayId: String?

    public var natIp: String?

    public var natIpPort: String?

    public var networkInterfaceIds: [String]?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.fullNatEntryId != nil {
            map["FullNatEntryId"] = self.fullNatEntryId!
        }
        if self.fullNatEntryNames != nil {
            map["FullNatEntryNames"] = self.fullNatEntryNames!
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpPort != nil {
            map["NatIpPort"] = self.natIpPort!
        }
        if self.networkInterfaceIds != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIds!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["FullNatEntryId"] as? String {
            self.fullNatEntryId = value
        }
        if let value = dict["FullNatEntryNames"] as? [String] {
            self.fullNatEntryNames = value
        }
        if let value = dict["FullNatTableId"] as? String {
            self.fullNatTableId = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatIp"] as? String {
            self.natIp = value
        }
        if let value = dict["NatIpPort"] as? String {
            self.natIpPort = value
        }
        if let value = dict["NetworkInterfaceIds"] as? [String] {
            self.networkInterfaceIds = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ListFullNatEntriesResponseBody : Tea.TeaModel {
    public class FullNatEntries : Tea.TeaModel {
        public var accessIp: String?

        public var accessPort: String?

        public var creationTime: String?

        public var fullNatEntryDescription: String?

        public var fullNatEntryId: String?

        public var fullNatEntryName: String?

        public var fullNatEntryStatus: String?

        public var fullNatTableId: String?

        public var ipProtocol: String?

        public var natIp: String?

        public var natIpPort: String?

        public var networkInterfaceId: String?

        public var networkInterfaceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessIp != nil {
                map["AccessIp"] = self.accessIp!
            }
            if self.accessPort != nil {
                map["AccessPort"] = self.accessPort!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fullNatEntryDescription != nil {
                map["FullNatEntryDescription"] = self.fullNatEntryDescription!
            }
            if self.fullNatEntryId != nil {
                map["FullNatEntryId"] = self.fullNatEntryId!
            }
            if self.fullNatEntryName != nil {
                map["FullNatEntryName"] = self.fullNatEntryName!
            }
            if self.fullNatEntryStatus != nil {
                map["FullNatEntryStatus"] = self.fullNatEntryStatus!
            }
            if self.fullNatTableId != nil {
                map["FullNatTableId"] = self.fullNatTableId!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.natIp != nil {
                map["NatIp"] = self.natIp!
            }
            if self.natIpPort != nil {
                map["NatIpPort"] = self.natIpPort!
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.networkInterfaceType != nil {
                map["NetworkInterfaceType"] = self.networkInterfaceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessIp"] as? String {
                self.accessIp = value
            }
            if let value = dict["AccessPort"] as? String {
                self.accessPort = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["FullNatEntryDescription"] as? String {
                self.fullNatEntryDescription = value
            }
            if let value = dict["FullNatEntryId"] as? String {
                self.fullNatEntryId = value
            }
            if let value = dict["FullNatEntryName"] as? String {
                self.fullNatEntryName = value
            }
            if let value = dict["FullNatEntryStatus"] as? String {
                self.fullNatEntryStatus = value
            }
            if let value = dict["FullNatTableId"] as? String {
                self.fullNatTableId = value
            }
            if let value = dict["IpProtocol"] as? String {
                self.ipProtocol = value
            }
            if let value = dict["NatIp"] as? String {
                self.natIp = value
            }
            if let value = dict["NatIpPort"] as? String {
                self.natIpPort = value
            }
            if let value = dict["NetworkInterfaceId"] as? String {
                self.networkInterfaceId = value
            }
            if let value = dict["NetworkInterfaceType"] as? String {
                self.networkInterfaceType = value
            }
        }
    }
    public var fullNatEntries: [ListFullNatEntriesResponseBody.FullNatEntries]?

    public var fullNatTableId: String?

    public var maxResults: Int64?

    public var natGatewayId: String?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fullNatEntries != nil {
            var tmp : [Any] = []
            for k in self.fullNatEntries! {
                tmp.append(k.toMap())
            }
            map["FullNatEntries"] = tmp
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FullNatEntries"] as? [Any?] {
            var tmp : [ListFullNatEntriesResponseBody.FullNatEntries] = []
            for v in value {
                if v != nil {
                    var model = ListFullNatEntriesResponseBody.FullNatEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.fullNatEntries = tmp
        }
        if let value = dict["FullNatTableId"] as? String {
            self.fullNatTableId = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListFullNatEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFullNatEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListFullNatEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListGatewayRouteTableEntriesRequest : Tea.TeaModel {
    public var destinationCidrBlock: String?

    public var gatewayRouteTableId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.gatewayRouteTableId != nil {
            map["GatewayRouteTableId"] = self.gatewayRouteTableId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["GatewayRouteTableId"] as? String {
            self.gatewayRouteTableId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ListGatewayRouteTableEntriesResponseBody : Tea.TeaModel {
    public class GatewayRouteEntryModels : Tea.TeaModel {
        public class NextHops : Tea.TeaModel {
            public var enabled: String?

            public var nextHopId: String?

            public var nextHopType: String?

            public var weight: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.nextHopId != nil {
                    map["NextHopId"] = self.nextHopId!
                }
                if self.nextHopType != nil {
                    map["NextHopType"] = self.nextHopType!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Enabled"] as? String {
                    self.enabled = value
                }
                if let value = dict["NextHopId"] as? String {
                    self.nextHopId = value
                }
                if let value = dict["NextHopType"] as? String {
                    self.nextHopType = value
                }
                if let value = dict["Weight"] as? String {
                    self.weight = value
                }
            }
        }
        public var description_: String?

        public var destinationCidrBlock: String?

        public var name: String?

        public var nextHopId: String?

        public var nextHopType: String?

        public var nextHops: [ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels.NextHops]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            if self.nextHops != nil {
                var tmp : [Any] = []
                for k in self.nextHops! {
                    tmp.append(k.toMap())
                }
                map["NextHops"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DestinationCidrBlock"] as? String {
                self.destinationCidrBlock = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NextHopId"] as? String {
                self.nextHopId = value
            }
            if let value = dict["NextHopType"] as? String {
                self.nextHopType = value
            }
            if let value = dict["NextHops"] as? [Any?] {
                var tmp : [ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels.NextHops] = []
                for v in value {
                    if v != nil {
                        var model = ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels.NextHops()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nextHops = tmp
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var gatewayRouteEntryModels: [ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gatewayRouteEntryModels != nil {
            var tmp : [Any] = []
            for k in self.gatewayRouteEntryModels! {
                tmp.append(k.toMap())
            }
            map["GatewayRouteEntryModels"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GatewayRouteEntryModels"] as? [Any?] {
            var tmp : [ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels] = []
            for v in value {
                if v != nil {
                    var model = ListGatewayRouteTableEntriesResponseBody.GatewayRouteEntryModels()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.gatewayRouteEntryModels = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class ListGatewayRouteTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayRouteTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListGatewayRouteTableEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListGeographicSubRegionsResponseBody : Tea.TeaModel {
    public var count: Int64?

    public var geographicSubRegions: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.geographicSubRegions != nil {
            map["GeographicSubRegions"] = self.geographicSubRegions!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int64 {
            self.count = value
        }
        if let value = dict["GeographicSubRegions"] as? [String] {
            self.geographicSubRegions = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListGeographicSubRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGeographicSubRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListGeographicSubRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListIpsecServerLogsRequest : Tea.TeaModel {
    public var from: Int32?

    public var ipsecServerId: String?

    public var minutePeriod: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var to: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.minutePeriod != nil {
            map["MinutePeriod"] = self.minutePeriod!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["From"] as? Int32 {
            self.from = value
        }
        if let value = dict["IpsecServerId"] as? String {
            self.ipsecServerId = value
        }
        if let value = dict["MinutePeriod"] as? Int32 {
            self.minutePeriod = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["To"] as? Int32 {
            self.to = value
        }
    }
}

public class ListIpsecServerLogsResponseBody : Tea.TeaModel {
    public var count: Int32?

    public var data: [String]?

    public var isCompleted: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.isCompleted != nil {
            map["IsCompleted"] = self.isCompleted!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["Data"] as? [String] {
            self.data = value
        }
        if let value = dict["IsCompleted"] as? Bool {
            self.isCompleted = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListIpsecServerLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIpsecServerLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListIpsecServerLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListIpsecServersRequest : Tea.TeaModel {
    public var ipsecServerId: [String]?

    public var ipsecServerName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.ipsecServerName != nil {
            map["IpsecServerName"] = self.ipsecServerName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IpsecServerId"] as? [String] {
            self.ipsecServerId = value
        }
        if let value = dict["IpsecServerName"] as? String {
            self.ipsecServerName = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class ListIpsecServersResponseBody : Tea.TeaModel {
    public class IpsecServers : Tea.TeaModel {
        public class IkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IkeAuthAlg"] as? String {
                    self.ikeAuthAlg = value
                }
                if let value = dict["IkeEncAlg"] as? String {
                    self.ikeEncAlg = value
                }
                if let value = dict["IkeLifetime"] as? Int64 {
                    self.ikeLifetime = value
                }
                if let value = dict["IkeMode"] as? String {
                    self.ikeMode = value
                }
                if let value = dict["IkePfs"] as? String {
                    self.ikePfs = value
                }
                if let value = dict["IkeVersion"] as? String {
                    self.ikeVersion = value
                }
                if let value = dict["LocalId"] as? String {
                    self.localId = value
                }
                if let value = dict["RemoteId"] as? String {
                    self.remoteId = value
                }
            }
        }
        public class IpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpsecAuthAlg"] as? String {
                    self.ipsecAuthAlg = value
                }
                if let value = dict["IpsecEncAlg"] as? String {
                    self.ipsecEncAlg = value
                }
                if let value = dict["IpsecLifetime"] as? Int64 {
                    self.ipsecLifetime = value
                }
                if let value = dict["IpsecPfs"] as? String {
                    self.ipsecPfs = value
                }
            }
        }
        public var clientIpPool: String?

        public var creationTime: String?

        public var effectImmediately: Bool?

        public var IDaaSInstanceId: String?

        public var ikeConfig: ListIpsecServersResponseBody.IpsecServers.IkeConfig?

        public var internetIp: String?

        public var ipsecConfig: ListIpsecServersResponseBody.IpsecServers.IpsecConfig?

        public var ipsecServerId: String?

        public var ipsecServerName: String?

        public var localSubnet: String?

        public var maxConnections: Int32?

        public var multiFactorAuthEnabled: Bool?

        public var onlineClientCount: Int32?

        public var psk: String?

        public var pskEnabled: Bool?

        public var regionId: String?

        public var resourceGroupId: String?

        public var vpnGatewayId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ikeConfig?.validate()
            try self.ipsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIpPool != nil {
                map["ClientIpPool"] = self.clientIpPool!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.effectImmediately != nil {
                map["EffectImmediately"] = self.effectImmediately!
            }
            if self.IDaaSInstanceId != nil {
                map["IDaaSInstanceId"] = self.IDaaSInstanceId!
            }
            if self.ikeConfig != nil {
                map["IkeConfig"] = self.ikeConfig?.toMap()
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.ipsecConfig != nil {
                map["IpsecConfig"] = self.ipsecConfig?.toMap()
            }
            if self.ipsecServerId != nil {
                map["IpsecServerId"] = self.ipsecServerId!
            }
            if self.ipsecServerName != nil {
                map["IpsecServerName"] = self.ipsecServerName!
            }
            if self.localSubnet != nil {
                map["LocalSubnet"] = self.localSubnet!
            }
            if self.maxConnections != nil {
                map["MaxConnections"] = self.maxConnections!
            }
            if self.multiFactorAuthEnabled != nil {
                map["MultiFactorAuthEnabled"] = self.multiFactorAuthEnabled!
            }
            if self.onlineClientCount != nil {
                map["OnlineClientCount"] = self.onlineClientCount!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.pskEnabled != nil {
                map["PskEnabled"] = self.pskEnabled!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.vpnGatewayId != nil {
                map["VpnGatewayId"] = self.vpnGatewayId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClientIpPool"] as? String {
                self.clientIpPool = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["EffectImmediately"] as? Bool {
                self.effectImmediately = value
            }
            if let value = dict["IDaaSInstanceId"] as? String {
                self.IDaaSInstanceId = value
            }
            if let value = dict["IkeConfig"] as? [String: Any?] {
                var model = ListIpsecServersResponseBody.IpsecServers.IkeConfig()
                model.fromMap(value)
                self.ikeConfig = model
            }
            if let value = dict["InternetIp"] as? String {
                self.internetIp = value
            }
            if let value = dict["IpsecConfig"] as? [String: Any?] {
                var model = ListIpsecServersResponseBody.IpsecServers.IpsecConfig()
                model.fromMap(value)
                self.ipsecConfig = model
            }
            if let value = dict["IpsecServerId"] as? String {
                self.ipsecServerId = value
            }
            if let value = dict["IpsecServerName"] as? String {
                self.ipsecServerName = value
            }
            if let value = dict["LocalSubnet"] as? String {
                self.localSubnet = value
            }
            if let value = dict["MaxConnections"] as? Int32 {
                self.maxConnections = value
            }
            if let value = dict["MultiFactorAuthEnabled"] as? Bool {
                self.multiFactorAuthEnabled = value
            }
            if let value = dict["OnlineClientCount"] as? Int32 {
                self.onlineClientCount = value
            }
            if let value = dict["Psk"] as? String {
                self.psk = value
            }
            if let value = dict["PskEnabled"] as? Bool {
                self.pskEnabled = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["VpnGatewayId"] as? String {
                self.vpnGatewayId = value
            }
        }
    }
    public var ipsecServers: [ListIpsecServersResponseBody.IpsecServers]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipsecServers != nil {
            var tmp : [Any] = []
            for k in self.ipsecServers! {
                tmp.append(k.toMap())
            }
            map["IpsecServers"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IpsecServers"] as? [Any?] {
            var tmp : [ListIpsecServersResponseBody.IpsecServers] = []
            for v in value {
                if v != nil {
                    var model = ListIpsecServersResponseBody.IpsecServers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ipsecServers = tmp
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListIpsecServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIpsecServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListIpsecServersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListIpv4GatewaysRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ipv4GatewayId: String?

    public var ipv4GatewayName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListIpv4GatewaysRequest.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ipv4GatewayName != nil {
            map["Ipv4GatewayName"] = self.ipv4GatewayName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv4GatewayId"] as? String {
            self.ipv4GatewayId = value
        }
        if let value = dict["Ipv4GatewayName"] as? String {
            self.ipv4GatewayName = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListIpv4GatewaysRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListIpv4GatewaysRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ListIpv4GatewaysResponseBody : Tea.TeaModel {
    public class Ipv4GatewayModels : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var enabled: Bool?

        public var gmtCreate: String?

        public var ipv4GatewayDescription: String?

        public var ipv4GatewayId: String?

        public var ipv4GatewayName: String?

        public var ipv4GatewayRouteTableId: String?

        public var resourceGroupId: String?

        public var status: String?

        public var tags: [ListIpv4GatewaysResponseBody.Ipv4GatewayModels.Tags]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.ipv4GatewayDescription != nil {
                map["Ipv4GatewayDescription"] = self.ipv4GatewayDescription!
            }
            if self.ipv4GatewayId != nil {
                map["Ipv4GatewayId"] = self.ipv4GatewayId!
            }
            if self.ipv4GatewayName != nil {
                map["Ipv4GatewayName"] = self.ipv4GatewayName!
            }
            if self.ipv4GatewayRouteTableId != nil {
                map["Ipv4GatewayRouteTableId"] = self.ipv4GatewayRouteTableId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["GmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["Ipv4GatewayDescription"] as? String {
                self.ipv4GatewayDescription = value
            }
            if let value = dict["Ipv4GatewayId"] as? String {
                self.ipv4GatewayId = value
            }
            if let value = dict["Ipv4GatewayName"] as? String {
                self.ipv4GatewayName = value
            }
            if let value = dict["Ipv4GatewayRouteTableId"] as? String {
                self.ipv4GatewayRouteTableId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListIpv4GatewaysResponseBody.Ipv4GatewayModels.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListIpv4GatewaysResponseBody.Ipv4GatewayModels.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var ipv4GatewayModels: [ListIpv4GatewaysResponseBody.Ipv4GatewayModels]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4GatewayModels != nil {
            var tmp : [Any] = []
            for k in self.ipv4GatewayModels! {
                tmp.append(k.toMap())
            }
            map["Ipv4GatewayModels"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv4GatewayModels"] as? [Any?] {
            var tmp : [ListIpv4GatewaysResponseBody.Ipv4GatewayModels] = []
            for v in value {
                if v != nil {
                    var model = ListIpv4GatewaysResponseBody.Ipv4GatewayModels()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ipv4GatewayModels = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class ListIpv4GatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIpv4GatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListIpv4GatewaysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNatIpCidrsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var maxResults: String?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var natIpCidrName: [String]?

    public var natIpCidrStatus: String?

    public var natIpCidrs: [String]?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpCidrName != nil {
            map["NatIpCidrName"] = self.natIpCidrName!
        }
        if self.natIpCidrStatus != nil {
            map["NatIpCidrStatus"] = self.natIpCidrStatus!
        }
        if self.natIpCidrs != nil {
            map["NatIpCidrs"] = self.natIpCidrs!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["MaxResults"] as? String {
            self.maxResults = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatIpCidr"] as? String {
            self.natIpCidr = value
        }
        if let value = dict["NatIpCidrName"] as? [String] {
            self.natIpCidrName = value
        }
        if let value = dict["NatIpCidrStatus"] as? String {
            self.natIpCidrStatus = value
        }
        if let value = dict["NatIpCidrs"] as? [String] {
            self.natIpCidrs = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ListNatIpCidrsResponseBody : Tea.TeaModel {
    public class NatIpCidrs : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: Bool?

        public var natGatewayId: String?

        public var natIpCidr: String?

        public var natIpCidrDescription: String?

        public var natIpCidrId: String?

        public var natIpCidrName: String?

        public var natIpCidrStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.natIpCidr != nil {
                map["NatIpCidr"] = self.natIpCidr!
            }
            if self.natIpCidrDescription != nil {
                map["NatIpCidrDescription"] = self.natIpCidrDescription!
            }
            if self.natIpCidrId != nil {
                map["NatIpCidrId"] = self.natIpCidrId!
            }
            if self.natIpCidrName != nil {
                map["NatIpCidrName"] = self.natIpCidrName!
            }
            if self.natIpCidrStatus != nil {
                map["NatIpCidrStatus"] = self.natIpCidrStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["IsDefault"] as? Bool {
                self.isDefault = value
            }
            if let value = dict["NatGatewayId"] as? String {
                self.natGatewayId = value
            }
            if let value = dict["NatIpCidr"] as? String {
                self.natIpCidr = value
            }
            if let value = dict["NatIpCidrDescription"] as? String {
                self.natIpCidrDescription = value
            }
            if let value = dict["NatIpCidrId"] as? String {
                self.natIpCidrId = value
            }
            if let value = dict["NatIpCidrName"] as? String {
                self.natIpCidrName = value
            }
            if let value = dict["NatIpCidrStatus"] as? String {
                self.natIpCidrStatus = value
            }
        }
    }
    public var natIpCidrs: [ListNatIpCidrsResponseBody.NatIpCidrs]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natIpCidrs != nil {
            var tmp : [Any] = []
            for k in self.natIpCidrs! {
                tmp.append(k.toMap())
            }
            map["NatIpCidrs"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NatIpCidrs"] as? [Any?] {
            var tmp : [ListNatIpCidrsResponseBody.NatIpCidrs] = []
            for v in value {
                if v != nil {
                    var model = ListNatIpCidrsResponseBody.NatIpCidrs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.natIpCidrs = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class ListNatIpCidrsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNatIpCidrsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNatIpCidrsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNatIpsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipOrigin: String?

    public var ipv4Prefix: String?

    public var maxResults: String?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var natIpIds: [String]?

    public var natIpName: [String]?

    public var natIpStatus: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipOrigin != nil {
            map["IpOrigin"] = self.ipOrigin!
        }
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpIds != nil {
            map["NatIpIds"] = self.natIpIds!
        }
        if self.natIpName != nil {
            map["NatIpName"] = self.natIpName!
        }
        if self.natIpStatus != nil {
            map["NatIpStatus"] = self.natIpStatus!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["IpOrigin"] as? String {
            self.ipOrigin = value
        }
        if let value = dict["Ipv4Prefix"] as? String {
            self.ipv4Prefix = value
        }
        if let value = dict["MaxResults"] as? String {
            self.maxResults = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatIpCidr"] as? String {
            self.natIpCidr = value
        }
        if let value = dict["NatIpIds"] as? [String] {
            self.natIpIds = value
        }
        if let value = dict["NatIpName"] as? [String] {
            self.natIpName = value
        }
        if let value = dict["NatIpStatus"] as? String {
            self.natIpStatus = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ListNatIpsResponseBody : Tea.TeaModel {
    public class NatIps : Tea.TeaModel {
        public var ipv4Prefix: String?

        public var isDefault: Bool?

        public var natGatewayId: String?

        public var natIp: String?

        public var natIpCidr: String?

        public var natIpDescription: String?

        public var natIpId: String?

        public var natIpName: String?

        public var natIpStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4Prefix != nil {
                map["Ipv4Prefix"] = self.ipv4Prefix!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.natIp != nil {
                map["NatIp"] = self.natIp!
            }
            if self.natIpCidr != nil {
                map["NatIpCidr"] = self.natIpCidr!
            }
            if self.natIpDescription != nil {
                map["NatIpDescription"] = self.natIpDescription!
            }
            if self.natIpId != nil {
                map["NatIpId"] = self.natIpId!
            }
            if self.natIpName != nil {
                map["NatIpName"] = self.natIpName!
            }
            if self.natIpStatus != nil {
                map["NatIpStatus"] = self.natIpStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv4Prefix"] as? String {
                self.ipv4Prefix = value
            }
            if let value = dict["IsDefault"] as? Bool {
                self.isDefault = value
            }
            if let value = dict["NatGatewayId"] as? String {
                self.natGatewayId = value
            }
            if let value = dict["NatIp"] as? String {
                self.natIp = value
            }
            if let value = dict["NatIpCidr"] as? String {
                self.natIpCidr = value
            }
            if let value = dict["NatIpDescription"] as? String {
                self.natIpDescription = value
            }
            if let value = dict["NatIpId"] as? String {
                self.natIpId = value
            }
            if let value = dict["NatIpName"] as? String {
                self.natIpName = value
            }
            if let value = dict["NatIpStatus"] as? String {
                self.natIpStatus = value
            }
        }
    }
    public var natIps: [ListNatIpsResponseBody.NatIps]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natIps != nil {
            var tmp : [Any] = []
            for k in self.natIps! {
                tmp.append(k.toMap())
            }
            map["NatIps"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NatIps"] as? [Any?] {
            var tmp : [ListNatIpsResponseBody.NatIps] = []
            for v in value {
                if v != nil {
                    var model = ListNatIpsResponseBody.NatIps()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.natIps = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class ListNatIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNatIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNatIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPhysicalConnectionFeaturesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ListPhysicalConnectionFeaturesResponseBody : Tea.TeaModel {
    public class PhysicalConnectionFeatures : Tea.TeaModel {
        public var featureKey: String?

        public var featureValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.featureKey != nil {
                map["FeatureKey"] = self.featureKey!
            }
            if self.featureValue != nil {
                map["FeatureValue"] = self.featureValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FeatureKey"] as? String {
                self.featureKey = value
            }
            if let value = dict["FeatureValue"] as? String {
                self.featureValue = value
            }
        }
    }
    public var physicalConnectionFeatures: [ListPhysicalConnectionFeaturesResponseBody.PhysicalConnectionFeatures]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.physicalConnectionFeatures != nil {
            var tmp : [Any] = []
            for k in self.physicalConnectionFeatures! {
                tmp.append(k.toMap())
            }
            map["PhysicalConnectionFeatures"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PhysicalConnectionFeatures"] as? [Any?] {
            var tmp : [ListPhysicalConnectionFeaturesResponseBody.PhysicalConnectionFeatures] = []
            for v in value {
                if v != nil {
                    var model = ListPhysicalConnectionFeaturesResponseBody.PhysicalConnectionFeatures()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.physicalConnectionFeatures = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListPhysicalConnectionFeaturesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPhysicalConnectionFeaturesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPhysicalConnectionFeaturesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPrefixListsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListIds: [String]?

    public var prefixListName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListPrefixListsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListIds != nil {
            map["PrefixListIds"] = self.prefixListIds!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListIds"] as? [String] {
            self.prefixListIds = value
        }
        if let value = dict["PrefixListName"] as? String {
            self.prefixListName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListPrefixListsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListPrefixListsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class ListPrefixListsResponseBody : Tea.TeaModel {
    public class PrefixLists : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var cidrBlocks: [String]?

        public var creationTime: String?

        public var ipVersion: String?

        public var maxEntries: Int32?

        public var ownerId: String?

        public var prefixListDescription: String?

        public var prefixListId: String?

        public var prefixListName: String?

        public var prefixListStatus: String?

        public var prefixListType: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var shareType: String?

        public var status: String?

        public var tags: [ListPrefixListsResponseBody.PrefixLists.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlocks != nil {
                map["CidrBlocks"] = self.cidrBlocks!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.maxEntries != nil {
                map["MaxEntries"] = self.maxEntries!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.prefixListDescription != nil {
                map["PrefixListDescription"] = self.prefixListDescription!
            }
            if self.prefixListId != nil {
                map["PrefixListId"] = self.prefixListId!
            }
            if self.prefixListName != nil {
                map["PrefixListName"] = self.prefixListName!
            }
            if self.prefixListStatus != nil {
                map["PrefixListStatus"] = self.prefixListStatus!
            }
            if self.prefixListType != nil {
                map["PrefixListType"] = self.prefixListType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.shareType != nil {
                map["ShareType"] = self.shareType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CidrBlocks"] as? [String] {
                self.cidrBlocks = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["IpVersion"] as? String {
                self.ipVersion = value
            }
            if let value = dict["MaxEntries"] as? Int32 {
                self.maxEntries = value
            }
            if let value = dict["OwnerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["PrefixListDescription"] as? String {
                self.prefixListDescription = value
            }
            if let value = dict["PrefixListId"] as? String {
                self.prefixListId = value
            }
            if let value = dict["PrefixListName"] as? String {
                self.prefixListName = value
            }
            if let value = dict["PrefixListStatus"] as? String {
                self.prefixListStatus = value
            }
            if let value = dict["PrefixListType"] as? String {
                self.prefixListType = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["ShareType"] as? String {
                self.shareType = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListPrefixListsResponseBody.PrefixLists.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListPrefixListsResponseBody.PrefixLists.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var prefixLists: [ListPrefixListsResponseBody.PrefixLists]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixLists != nil {
            var tmp : [Any] = []
            for k in self.prefixLists! {
                tmp.append(k.toMap())
            }
            map["PrefixLists"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PrefixLists"] as? [Any?] {
            var tmp : [ListPrefixListsResponseBody.PrefixLists] = []
            for v in value {
                if v != nil {
                    var model = ListPrefixListsResponseBody.PrefixLists()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.prefixLists = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListPrefixListsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrefixListsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPrefixListsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPublicIpAddressPoolCidrBlocksRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var dryRun: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ListPublicIpAddressPoolCidrBlocksResponseBody : Tea.TeaModel {
    public class PublicIpPoolCidrBlockList : Tea.TeaModel {
        public var cidrBlock: String?

        public var creationTime: String?

        public var publicIpAddressPoolId: String?

        public var status: String?

        public var totalIpNum: Int32?

        public var usedIpNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.publicIpAddressPoolId != nil {
                map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalIpNum != nil {
                map["TotalIpNum"] = self.totalIpNum!
            }
            if self.usedIpNum != nil {
                map["UsedIpNum"] = self.usedIpNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CidrBlock"] as? String {
                self.cidrBlock = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["PublicIpAddressPoolId"] as? String {
                self.publicIpAddressPoolId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TotalIpNum"] as? Int32 {
                self.totalIpNum = value
            }
            if let value = dict["UsedIpNum"] as? Int32 {
                self.usedIpNum = value
            }
        }
    }
    public var nextToken: String?

    public var publicIpPoolCidrBlockList: [ListPublicIpAddressPoolCidrBlocksResponseBody.PublicIpPoolCidrBlockList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.publicIpPoolCidrBlockList != nil {
            var tmp : [Any] = []
            for k in self.publicIpPoolCidrBlockList! {
                tmp.append(k.toMap())
            }
            map["PublicIpPoolCidrBlockList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PublicIpPoolCidrBlockList"] as? [Any?] {
            var tmp : [ListPublicIpAddressPoolCidrBlocksResponseBody.PublicIpPoolCidrBlockList] = []
            for v in value {
                if v != nil {
                    var model = ListPublicIpAddressPoolCidrBlocksResponseBody.PublicIpPoolCidrBlockList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.publicIpPoolCidrBlockList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListPublicIpAddressPoolCidrBlocksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublicIpAddressPoolCidrBlocksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPublicIpAddressPoolCidrBlocksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPublicIpAddressPoolsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dryRun: Bool?

    public var isp: String?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolIds: [String]?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityProtectionEnabled: Bool?

    public var status: String?

    public var tags: [ListPublicIpAddressPoolsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolIds != nil {
            map["PublicIpAddressPoolIds"] = self.publicIpAddressPoolIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityProtectionEnabled != nil {
            map["SecurityProtectionEnabled"] = self.securityProtectionEnabled!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Isp"] as? String {
            self.isp = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PublicIpAddressPoolIds"] as? [String] {
            self.publicIpAddressPoolIds = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityProtectionEnabled"] as? Bool {
            self.securityProtectionEnabled = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListPublicIpAddressPoolsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListPublicIpAddressPoolsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class ListPublicIpAddressPoolsResponseBody : Tea.TeaModel {
    public class PublicIpAddressPoolList : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var bizType: String?

        public var businessStatus: String?

        public var creationTime: String?

        public var description_: String?

        public var ipAddressRemaining: Bool?

        public var isp: String?

        public var name: String?

        public var ownerId: Int64?

        public var publicIpAddressPoolId: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var securityProtectionTypes: [String]?

        public var shareType: String?

        public var status: String?

        public var tags: [ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList.Tags]?

        public var totalIpNum: Int32?

        public var usedIpNum: Int32?

        public var userType: String?

        public var zones: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizType != nil {
                map["BizType"] = self.bizType!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ipAddressRemaining != nil {
                map["IpAddressRemaining"] = self.ipAddressRemaining!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.publicIpAddressPoolId != nil {
                map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityProtectionTypes != nil {
                map["SecurityProtectionTypes"] = self.securityProtectionTypes!
            }
            if self.shareType != nil {
                map["ShareType"] = self.shareType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.totalIpNum != nil {
                map["TotalIpNum"] = self.totalIpNum!
            }
            if self.usedIpNum != nil {
                map["UsedIpNum"] = self.usedIpNum!
            }
            if self.userType != nil {
                map["UserType"] = self.userType!
            }
            if self.zones != nil {
                map["Zones"] = self.zones!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BizType"] as? String {
                self.bizType = value
            }
            if let value = dict["BusinessStatus"] as? String {
                self.businessStatus = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["IpAddressRemaining"] as? Bool {
                self.ipAddressRemaining = value
            }
            if let value = dict["Isp"] as? String {
                self.isp = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["OwnerId"] as? Int64 {
                self.ownerId = value
            }
            if let value = dict["PublicIpAddressPoolId"] as? String {
                self.publicIpAddressPoolId = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["SecurityProtectionTypes"] as? [String] {
                self.securityProtectionTypes = value
            }
            if let value = dict["ShareType"] as? String {
                self.shareType = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TotalIpNum"] as? Int32 {
                self.totalIpNum = value
            }
            if let value = dict["UsedIpNum"] as? Int32 {
                self.usedIpNum = value
            }
            if let value = dict["UserType"] as? String {
                self.userType = value
            }
            if let value = dict["Zones"] as? [String] {
                self.zones = value
            }
        }
    }
    public var nextToken: String?

    public var publicIpAddressPoolList: [ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.publicIpAddressPoolList != nil {
            var tmp : [Any] = []
            for k in self.publicIpAddressPoolList! {
                tmp.append(k.toMap())
            }
            map["PublicIpAddressPoolList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PublicIpAddressPoolList"] as? [Any?] {
            var tmp : [ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList] = []
            for v in value {
                if v != nil {
                    var model = ListPublicIpAddressPoolsResponseBody.PublicIpAddressPoolList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.publicIpAddressPoolList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListPublicIpAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublicIpAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPublicIpAddressPoolsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRouteTargetGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var maxResults: Int32?

    public var memberId: String?

    public var nextToken: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var routeTargetGroupIds: [String]?

    public var tag: [ListRouteTargetGroupsRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.memberId != nil {
            map["MemberId"] = self.memberId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.routeTargetGroupIds != nil {
            map["RouteTargetGroupIds"] = self.routeTargetGroupIds!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["MemberId"] as? String {
            self.memberId = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["RouteTargetGroupIds"] as? [String] {
            self.routeTargetGroupIds = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListRouteTargetGroupsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListRouteTargetGroupsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ListRouteTargetGroupsResponseBody : Tea.TeaModel {
    public class RouteTargetGroups : Tea.TeaModel {
        public class RouteTargetMemberList : Tea.TeaModel {
            public var enableStatus: String?

            public var healthCheckStatus: String?

            public var memberId: String?

            public var memberType: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthCheckStatus != nil {
                    map["HealthCheckStatus"] = self.healthCheckStatus!
                }
                if self.memberId != nil {
                    map["MemberId"] = self.memberId!
                }
                if self.memberType != nil {
                    map["MemberType"] = self.memberType!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthCheckStatus"] as? String {
                    self.healthCheckStatus = value
                }
                if let value = dict["MemberId"] as? String {
                    self.memberId = value
                }
                if let value = dict["MemberType"] as? String {
                    self.memberType = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var configMode: String?

        public var createTime: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var routeTargetGroupDescription: String?

        public var routeTargetGroupId: String?

        public var routeTargetGroupName: String?

        public var routeTargetMemberList: [ListRouteTargetGroupsResponseBody.RouteTargetGroups.RouteTargetMemberList]?

        public var status: String?

        public var tags: [ListRouteTargetGroupsResponseBody.RouteTargetGroups.Tags]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMode != nil {
                map["ConfigMode"] = self.configMode!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.routeTargetGroupDescription != nil {
                map["RouteTargetGroupDescription"] = self.routeTargetGroupDescription!
            }
            if self.routeTargetGroupId != nil {
                map["RouteTargetGroupId"] = self.routeTargetGroupId!
            }
            if self.routeTargetGroupName != nil {
                map["RouteTargetGroupName"] = self.routeTargetGroupName!
            }
            if self.routeTargetMemberList != nil {
                var tmp : [Any] = []
                for k in self.routeTargetMemberList! {
                    tmp.append(k.toMap())
                }
                map["RouteTargetMemberList"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigMode"] as? String {
                self.configMode = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["RouteTargetGroupDescription"] as? String {
                self.routeTargetGroupDescription = value
            }
            if let value = dict["RouteTargetGroupId"] as? String {
                self.routeTargetGroupId = value
            }
            if let value = dict["RouteTargetGroupName"] as? String {
                self.routeTargetGroupName = value
            }
            if let value = dict["RouteTargetMemberList"] as? [Any?] {
                var tmp : [ListRouteTargetGroupsResponseBody.RouteTargetGroups.RouteTargetMemberList] = []
                for v in value {
                    if v != nil {
                        var model = ListRouteTargetGroupsResponseBody.RouteTargetGroups.RouteTargetMemberList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.routeTargetMemberList = tmp
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListRouteTargetGroupsResponseBody.RouteTargetGroups.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListRouteTargetGroupsResponseBody.RouteTargetGroups.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var routeTargetGroups: [ListRouteTargetGroupsResponseBody.RouteTargetGroups]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTargetGroups != nil {
            var tmp : [Any] = []
            for k in self.routeTargetGroups! {
                tmp.append(k.toMap())
            }
            map["RouteTargetGroups"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteTargetGroups"] as? [Any?] {
            var tmp : [ListRouteTargetGroupsResponseBody.RouteTargetGroups] = []
            for v in value {
                if v != nil {
                    var model = ListRouteTargetGroupsResponseBody.RouteTargetGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeTargetGroups = tmp
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListRouteTargetGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRouteTargetGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRouteTargetGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = ListTagResourcesResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesForExpressConnectRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [ListTagResourcesForExpressConnectRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListTagResourcesForExpressConnectRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesForExpressConnectRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesForExpressConnectResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [ListTagResourcesForExpressConnectResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [ListTagResourcesForExpressConnectResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = ListTagResourcesForExpressConnectResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesForExpressConnectResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = ListTagResourcesForExpressConnectResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class ListTagResourcesForExpressConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesForExpressConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesForExpressConnectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTrafficMirrorFiltersRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListTrafficMirrorFiltersRequest.Tags]?

    public var trafficMirrorFilterIds: [String]?

    public var trafficMirrorFilterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.trafficMirrorFilterIds != nil {
            map["TrafficMirrorFilterIds"] = self.trafficMirrorFilterIds!
        }
        if self.trafficMirrorFilterName != nil {
            map["TrafficMirrorFilterName"] = self.trafficMirrorFilterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListTrafficMirrorFiltersRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListTrafficMirrorFiltersRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["TrafficMirrorFilterIds"] as? [String] {
            self.trafficMirrorFilterIds = value
        }
        if let value = dict["TrafficMirrorFilterName"] as? String {
            self.trafficMirrorFilterName = value
        }
    }
}

public class ListTrafficMirrorFiltersResponseBody : Tea.TeaModel {
    public class TrafficMirrorFilters : Tea.TeaModel {
        public class EgressRules : Tea.TeaModel {
            public var action: String?

            public var destinationCidrBlock: String?

            public var destinationPortRange: String?

            public var ipVersion: String?

            public var priority: Int32?

            public var protocol_: String?

            public var sourceCidrBlock: String?

            public var sourcePortRange: String?

            public var trafficDirection: String?

            public var trafficMirrorFilterId: String?

            public var trafficMirrorFilterRuleId: String?

            public var trafficMirrorFilterRuleStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.destinationCidrBlock != nil {
                    map["DestinationCidrBlock"] = self.destinationCidrBlock!
                }
                if self.destinationPortRange != nil {
                    map["DestinationPortRange"] = self.destinationPortRange!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.sourceCidrBlock != nil {
                    map["SourceCidrBlock"] = self.sourceCidrBlock!
                }
                if self.sourcePortRange != nil {
                    map["SourcePortRange"] = self.sourcePortRange!
                }
                if self.trafficDirection != nil {
                    map["TrafficDirection"] = self.trafficDirection!
                }
                if self.trafficMirrorFilterId != nil {
                    map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
                }
                if self.trafficMirrorFilterRuleId != nil {
                    map["TrafficMirrorFilterRuleId"] = self.trafficMirrorFilterRuleId!
                }
                if self.trafficMirrorFilterRuleStatus != nil {
                    map["TrafficMirrorFilterRuleStatus"] = self.trafficMirrorFilterRuleStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["DestinationCidrBlock"] as? String {
                    self.destinationCidrBlock = value
                }
                if let value = dict["DestinationPortRange"] as? String {
                    self.destinationPortRange = value
                }
                if let value = dict["IpVersion"] as? String {
                    self.ipVersion = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["SourceCidrBlock"] as? String {
                    self.sourceCidrBlock = value
                }
                if let value = dict["SourcePortRange"] as? String {
                    self.sourcePortRange = value
                }
                if let value = dict["TrafficDirection"] as? String {
                    self.trafficDirection = value
                }
                if let value = dict["TrafficMirrorFilterId"] as? String {
                    self.trafficMirrorFilterId = value
                }
                if let value = dict["TrafficMirrorFilterRuleId"] as? String {
                    self.trafficMirrorFilterRuleId = value
                }
                if let value = dict["TrafficMirrorFilterRuleStatus"] as? String {
                    self.trafficMirrorFilterRuleStatus = value
                }
            }
        }
        public class IngressRules : Tea.TeaModel {
            public var action: String?

            public var destinationCidrBlock: String?

            public var destinationPortRange: String?

            public var ipVersion: String?

            public var priority: Int32?

            public var protocol_: String?

            public var sourceCidrBlock: String?

            public var sourcePortRange: String?

            public var trafficDirection: String?

            public var trafficMirrorFilterId: String?

            public var trafficMirrorFilterRuleId: String?

            public var trafficMirrorFilterRuleStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.destinationCidrBlock != nil {
                    map["DestinationCidrBlock"] = self.destinationCidrBlock!
                }
                if self.destinationPortRange != nil {
                    map["DestinationPortRange"] = self.destinationPortRange!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.sourceCidrBlock != nil {
                    map["SourceCidrBlock"] = self.sourceCidrBlock!
                }
                if self.sourcePortRange != nil {
                    map["SourcePortRange"] = self.sourcePortRange!
                }
                if self.trafficDirection != nil {
                    map["TrafficDirection"] = self.trafficDirection!
                }
                if self.trafficMirrorFilterId != nil {
                    map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
                }
                if self.trafficMirrorFilterRuleId != nil {
                    map["TrafficMirrorFilterRuleId"] = self.trafficMirrorFilterRuleId!
                }
                if self.trafficMirrorFilterRuleStatus != nil {
                    map["TrafficMirrorFilterRuleStatus"] = self.trafficMirrorFilterRuleStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["DestinationCidrBlock"] as? String {
                    self.destinationCidrBlock = value
                }
                if let value = dict["DestinationPortRange"] as? String {
                    self.destinationPortRange = value
                }
                if let value = dict["IpVersion"] as? String {
                    self.ipVersion = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["SourceCidrBlock"] as? String {
                    self.sourceCidrBlock = value
                }
                if let value = dict["SourcePortRange"] as? String {
                    self.sourcePortRange = value
                }
                if let value = dict["TrafficDirection"] as? String {
                    self.trafficDirection = value
                }
                if let value = dict["TrafficMirrorFilterId"] as? String {
                    self.trafficMirrorFilterId = value
                }
                if let value = dict["TrafficMirrorFilterRuleId"] as? String {
                    self.trafficMirrorFilterRuleId = value
                }
                if let value = dict["TrafficMirrorFilterRuleStatus"] as? String {
                    self.trafficMirrorFilterRuleStatus = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var creationTime: String?

        public var egressRules: [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.EgressRules]?

        public var ingressRules: [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.IngressRules]?

        public var resourceGroupId: String?

        public var tags: [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.Tags]?

        public var trafficMirrorFilterDescription: String?

        public var trafficMirrorFilterId: String?

        public var trafficMirrorFilterName: String?

        public var trafficMirrorFilterStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.egressRules != nil {
                var tmp : [Any] = []
                for k in self.egressRules! {
                    tmp.append(k.toMap())
                }
                map["EgressRules"] = tmp
            }
            if self.ingressRules != nil {
                var tmp : [Any] = []
                for k in self.ingressRules! {
                    tmp.append(k.toMap())
                }
                map["IngressRules"] = tmp
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.trafficMirrorFilterDescription != nil {
                map["TrafficMirrorFilterDescription"] = self.trafficMirrorFilterDescription!
            }
            if self.trafficMirrorFilterId != nil {
                map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
            }
            if self.trafficMirrorFilterName != nil {
                map["TrafficMirrorFilterName"] = self.trafficMirrorFilterName!
            }
            if self.trafficMirrorFilterStatus != nil {
                map["TrafficMirrorFilterStatus"] = self.trafficMirrorFilterStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["EgressRules"] as? [Any?] {
                var tmp : [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.EgressRules] = []
                for v in value {
                    if v != nil {
                        var model = ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.EgressRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.egressRules = tmp
            }
            if let value = dict["IngressRules"] as? [Any?] {
                var tmp : [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.IngressRules] = []
                for v in value {
                    if v != nil {
                        var model = ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.IngressRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ingressRules = tmp
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TrafficMirrorFilterDescription"] as? String {
                self.trafficMirrorFilterDescription = value
            }
            if let value = dict["TrafficMirrorFilterId"] as? String {
                self.trafficMirrorFilterId = value
            }
            if let value = dict["TrafficMirrorFilterName"] as? String {
                self.trafficMirrorFilterName = value
            }
            if let value = dict["TrafficMirrorFilterStatus"] as? String {
                self.trafficMirrorFilterStatus = value
            }
        }
    }
    public var count: Int32?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public var trafficMirrorFilters: [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.trafficMirrorFilters != nil {
            var tmp : [Any] = []
            for k in self.trafficMirrorFilters! {
                tmp.append(k.toMap())
            }
            map["TrafficMirrorFilters"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
        if let value = dict["TrafficMirrorFilters"] as? [Any?] {
            var tmp : [ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters] = []
            for v in value {
                if v != nil {
                    var model = ListTrafficMirrorFiltersResponseBody.TrafficMirrorFilters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.trafficMirrorFilters = tmp
        }
    }
}

public class ListTrafficMirrorFiltersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTrafficMirrorFiltersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTrafficMirrorFiltersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTrafficMirrorSessionsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var enabled: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListTrafficMirrorSessionsRequest.Tags]?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorSessionIds: [String]?

    public var trafficMirrorSessionName: String?

    public var trafficMirrorSourceId: String?

    public var trafficMirrorTargetId: String?

    public var virtualNetworkId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorSessionIds != nil {
            map["TrafficMirrorSessionIds"] = self.trafficMirrorSessionIds!
        }
        if self.trafficMirrorSessionName != nil {
            map["TrafficMirrorSessionName"] = self.trafficMirrorSessionName!
        }
        if self.trafficMirrorSourceId != nil {
            map["TrafficMirrorSourceId"] = self.trafficMirrorSourceId!
        }
        if self.trafficMirrorTargetId != nil {
            map["TrafficMirrorTargetId"] = self.trafficMirrorTargetId!
        }
        if self.virtualNetworkId != nil {
            map["VirtualNetworkId"] = self.virtualNetworkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListTrafficMirrorSessionsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListTrafficMirrorSessionsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["TrafficMirrorFilterId"] as? String {
            self.trafficMirrorFilterId = value
        }
        if let value = dict["TrafficMirrorSessionIds"] as? [String] {
            self.trafficMirrorSessionIds = value
        }
        if let value = dict["TrafficMirrorSessionName"] as? String {
            self.trafficMirrorSessionName = value
        }
        if let value = dict["TrafficMirrorSourceId"] as? String {
            self.trafficMirrorSourceId = value
        }
        if let value = dict["TrafficMirrorTargetId"] as? String {
            self.trafficMirrorTargetId = value
        }
        if let value = dict["VirtualNetworkId"] as? Int32 {
            self.virtualNetworkId = value
        }
    }
}

public class ListTrafficMirrorSessionsResponseBody : Tea.TeaModel {
    public class TrafficMirrorSessions : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var creationTime: String?

        public var enabled: Bool?

        public var packetLength: Int32?

        public var priority: Int32?

        public var resourceGroupId: String?

        public var tags: [ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions.Tags]?

        public var trafficMirrorFilterId: String?

        public var trafficMirrorSessionBusinessStatus: String?

        public var trafficMirrorSessionDescription: String?

        public var trafficMirrorSessionId: String?

        public var trafficMirrorSessionName: String?

        public var trafficMirrorSessionStatus: String?

        public var trafficMirrorSourceIds: [String]?

        public var trafficMirrorTargetId: String?

        public var trafficMirrorTargetType: String?

        public var virtualNetworkId: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.packetLength != nil {
                map["PacketLength"] = self.packetLength!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.trafficMirrorFilterId != nil {
                map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
            }
            if self.trafficMirrorSessionBusinessStatus != nil {
                map["TrafficMirrorSessionBusinessStatus"] = self.trafficMirrorSessionBusinessStatus!
            }
            if self.trafficMirrorSessionDescription != nil {
                map["TrafficMirrorSessionDescription"] = self.trafficMirrorSessionDescription!
            }
            if self.trafficMirrorSessionId != nil {
                map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
            }
            if self.trafficMirrorSessionName != nil {
                map["TrafficMirrorSessionName"] = self.trafficMirrorSessionName!
            }
            if self.trafficMirrorSessionStatus != nil {
                map["TrafficMirrorSessionStatus"] = self.trafficMirrorSessionStatus!
            }
            if self.trafficMirrorSourceIds != nil {
                map["TrafficMirrorSourceIds"] = self.trafficMirrorSourceIds!
            }
            if self.trafficMirrorTargetId != nil {
                map["TrafficMirrorTargetId"] = self.trafficMirrorTargetId!
            }
            if self.trafficMirrorTargetType != nil {
                map["TrafficMirrorTargetType"] = self.trafficMirrorTargetType!
            }
            if self.virtualNetworkId != nil {
                map["VirtualNetworkId"] = self.virtualNetworkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["PacketLength"] as? Int32 {
                self.packetLength = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TrafficMirrorFilterId"] as? String {
                self.trafficMirrorFilterId = value
            }
            if let value = dict["TrafficMirrorSessionBusinessStatus"] as? String {
                self.trafficMirrorSessionBusinessStatus = value
            }
            if let value = dict["TrafficMirrorSessionDescription"] as? String {
                self.trafficMirrorSessionDescription = value
            }
            if let value = dict["TrafficMirrorSessionId"] as? String {
                self.trafficMirrorSessionId = value
            }
            if let value = dict["TrafficMirrorSessionName"] as? String {
                self.trafficMirrorSessionName = value
            }
            if let value = dict["TrafficMirrorSessionStatus"] as? String {
                self.trafficMirrorSessionStatus = value
            }
            if let value = dict["TrafficMirrorSourceIds"] as? [String] {
                self.trafficMirrorSourceIds = value
            }
            if let value = dict["TrafficMirrorTargetId"] as? String {
                self.trafficMirrorTargetId = value
            }
            if let value = dict["TrafficMirrorTargetType"] as? String {
                self.trafficMirrorTargetType = value
            }
            if let value = dict["VirtualNetworkId"] as? Int32 {
                self.virtualNetworkId = value
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public var trafficMirrorSessions: [ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.trafficMirrorSessions != nil {
            var tmp : [Any] = []
            for k in self.trafficMirrorSessions! {
                tmp.append(k.toMap())
            }
            map["TrafficMirrorSessions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
        if let value = dict["TrafficMirrorSessions"] as? [Any?] {
            var tmp : [ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions] = []
            for v in value {
                if v != nil {
                    var model = ListTrafficMirrorSessionsResponseBody.TrafficMirrorSessions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.trafficMirrorSessions = tmp
        }
    }
}

public class ListTrafficMirrorSessionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTrafficMirrorSessionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTrafficMirrorSessionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListVSwitchCidrReservationsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ipVersion: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: [ListVSwitchCidrReservationsRequest.Tags]?

    public var vSwitchCidrReservationIds: [String]?

    public var vSwitchCidrReservationType: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vSwitchCidrReservationIds != nil {
            map["VSwitchCidrReservationIds"] = self.vSwitchCidrReservationIds!
        }
        if self.vSwitchCidrReservationType != nil {
            map["VSwitchCidrReservationType"] = self.vSwitchCidrReservationType!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListVSwitchCidrReservationsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListVSwitchCidrReservationsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VSwitchCidrReservationIds"] as? [String] {
            self.vSwitchCidrReservationIds = value
        }
        if let value = dict["VSwitchCidrReservationType"] as? String {
            self.vSwitchCidrReservationType = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class ListVSwitchCidrReservationsResponseBody : Tea.TeaModel {
    public class VSwitchCidrReservations : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var assignedCidrCount: Int32?

        public var availableCidrCount: Int32?

        public var creationTime: String?

        public var ipVersion: String?

        public var status: String?

        public var tags: [ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations.Tags]?

        public var type: String?

        public var vSwitchCidrReservationCidr: String?

        public var vSwitchCidrReservationDescription: String?

        public var vSwitchCidrReservationId: String?

        public var vSwitchCidrReservationName: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedCidrCount != nil {
                map["AssignedCidrCount"] = self.assignedCidrCount!
            }
            if self.availableCidrCount != nil {
                map["AvailableCidrCount"] = self.availableCidrCount!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.vSwitchCidrReservationCidr != nil {
                map["VSwitchCidrReservationCidr"] = self.vSwitchCidrReservationCidr!
            }
            if self.vSwitchCidrReservationDescription != nil {
                map["VSwitchCidrReservationDescription"] = self.vSwitchCidrReservationDescription!
            }
            if self.vSwitchCidrReservationId != nil {
                map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
            }
            if self.vSwitchCidrReservationName != nil {
                map["VSwitchCidrReservationName"] = self.vSwitchCidrReservationName!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssignedCidrCount"] as? Int32 {
                self.assignedCidrCount = value
            }
            if let value = dict["AvailableCidrCount"] as? Int32 {
                self.availableCidrCount = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["IpVersion"] as? String {
                self.ipVersion = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["VSwitchCidrReservationCidr"] as? String {
                self.vSwitchCidrReservationCidr = value
            }
            if let value = dict["VSwitchCidrReservationDescription"] as? String {
                self.vSwitchCidrReservationDescription = value
            }
            if let value = dict["VSwitchCidrReservationId"] as? String {
                self.vSwitchCidrReservationId = value
            }
            if let value = dict["VSwitchCidrReservationName"] as? String {
                self.vSwitchCidrReservationName = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public var vSwitchCidrReservations: [ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vSwitchCidrReservations != nil {
            var tmp : [Any] = []
            for k in self.vSwitchCidrReservations! {
                tmp.append(k.toMap())
            }
            map["VSwitchCidrReservations"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
        if let value = dict["VSwitchCidrReservations"] as? [Any?] {
            var tmp : [ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations] = []
            for v in value {
                if v != nil {
                    var model = ListVSwitchCidrReservationsResponseBody.VSwitchCidrReservations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.vSwitchCidrReservations = tmp
        }
    }
}

public class ListVSwitchCidrReservationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVSwitchCidrReservationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListVSwitchCidrReservationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListVirtualPhysicalConnectionsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var isConfirmed: Bool?

    public var maxResults: Int32?

    public var nextToken: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: [ListVirtualPhysicalConnectionsRequest.Tags]?

    public var virtualPhysicalConnectionAliUids: [String]?

    public var virtualPhysicalConnectionBusinessStatus: String?

    public var virtualPhysicalConnectionIds: [String]?

    public var virtualPhysicalConnectionStatuses: [String]?

    public var vlanIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isConfirmed != nil {
            map["IsConfirmed"] = self.isConfirmed!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.virtualPhysicalConnectionAliUids != nil {
            map["VirtualPhysicalConnectionAliUids"] = self.virtualPhysicalConnectionAliUids!
        }
        if self.virtualPhysicalConnectionBusinessStatus != nil {
            map["VirtualPhysicalConnectionBusinessStatus"] = self.virtualPhysicalConnectionBusinessStatus!
        }
        if self.virtualPhysicalConnectionIds != nil {
            map["VirtualPhysicalConnectionIds"] = self.virtualPhysicalConnectionIds!
        }
        if self.virtualPhysicalConnectionStatuses != nil {
            map["VirtualPhysicalConnectionStatuses"] = self.virtualPhysicalConnectionStatuses!
        }
        if self.vlanIds != nil {
            map["VlanIds"] = self.vlanIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IsConfirmed"] as? Bool {
            self.isConfirmed = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListVirtualPhysicalConnectionsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListVirtualPhysicalConnectionsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VirtualPhysicalConnectionAliUids"] as? [String] {
            self.virtualPhysicalConnectionAliUids = value
        }
        if let value = dict["VirtualPhysicalConnectionBusinessStatus"] as? String {
            self.virtualPhysicalConnectionBusinessStatus = value
        }
        if let value = dict["VirtualPhysicalConnectionIds"] as? [String] {
            self.virtualPhysicalConnectionIds = value
        }
        if let value = dict["VirtualPhysicalConnectionStatuses"] as? [String] {
            self.virtualPhysicalConnectionStatuses = value
        }
        if let value = dict["VlanIds"] as? [String] {
            self.vlanIds = value
        }
    }
}

public class ListVirtualPhysicalConnectionsResponseBody : Tea.TeaModel {
    public class VirtualPhysicalConnections : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var accessPointId: String?

        public var adLocation: String?

        public var aliUid: String?

        public var bandwidth: Int64?

        public var businessStatus: String?

        public var chargeType: String?

        public var circuitCode: String?

        public var creationTime: String?

        public var description_: String?

        public var enabledTime: String?

        public var endTime: String?

        public var expectSpec: String?

        public var lineOperator: String?

        public var loaStatus: String?

        public var name: String?

        public var orderMode: String?

        public var parentPhysicalConnectionAliUid: String?

        public var parentPhysicalConnectionId: String?

        public var peerLocation: String?

        public var physicalConnectionId: String?

        public var portNumber: String?

        public var portType: String?

        public var productType: String?

        public var redundantPhysicalConnectionId: String?

        public var resourceGroupId: String?

        public var spec: String?

        public var status: String?

        public var tags: [ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections.Tags]?

        public var type: String?

        public var virtualPhysicalConnectionStatus: String?

        public var vlanId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointId != nil {
                map["AccessPointId"] = self.accessPointId!
            }
            if self.adLocation != nil {
                map["AdLocation"] = self.adLocation!
            }
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.businessStatus != nil {
                map["BusinessStatus"] = self.businessStatus!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.circuitCode != nil {
                map["CircuitCode"] = self.circuitCode!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabledTime != nil {
                map["EnabledTime"] = self.enabledTime!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.expectSpec != nil {
                map["ExpectSpec"] = self.expectSpec!
            }
            if self.lineOperator != nil {
                map["LineOperator"] = self.lineOperator!
            }
            if self.loaStatus != nil {
                map["LoaStatus"] = self.loaStatus!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.orderMode != nil {
                map["OrderMode"] = self.orderMode!
            }
            if self.parentPhysicalConnectionAliUid != nil {
                map["ParentPhysicalConnectionAliUid"] = self.parentPhysicalConnectionAliUid!
            }
            if self.parentPhysicalConnectionId != nil {
                map["ParentPhysicalConnectionId"] = self.parentPhysicalConnectionId!
            }
            if self.peerLocation != nil {
                map["PeerLocation"] = self.peerLocation!
            }
            if self.physicalConnectionId != nil {
                map["PhysicalConnectionId"] = self.physicalConnectionId!
            }
            if self.portNumber != nil {
                map["PortNumber"] = self.portNumber!
            }
            if self.portType != nil {
                map["PortType"] = self.portType!
            }
            if self.productType != nil {
                map["ProductType"] = self.productType!
            }
            if self.redundantPhysicalConnectionId != nil {
                map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.virtualPhysicalConnectionStatus != nil {
                map["VirtualPhysicalConnectionStatus"] = self.virtualPhysicalConnectionStatus!
            }
            if self.vlanId != nil {
                map["VlanId"] = self.vlanId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessPointId"] as? String {
                self.accessPointId = value
            }
            if let value = dict["AdLocation"] as? String {
                self.adLocation = value
            }
            if let value = dict["AliUid"] as? String {
                self.aliUid = value
            }
            if let value = dict["Bandwidth"] as? Int64 {
                self.bandwidth = value
            }
            if let value = dict["BusinessStatus"] as? String {
                self.businessStatus = value
            }
            if let value = dict["ChargeType"] as? String {
                self.chargeType = value
            }
            if let value = dict["CircuitCode"] as? String {
                self.circuitCode = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EnabledTime"] as? String {
                self.enabledTime = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["ExpectSpec"] as? String {
                self.expectSpec = value
            }
            if let value = dict["LineOperator"] as? String {
                self.lineOperator = value
            }
            if let value = dict["LoaStatus"] as? String {
                self.loaStatus = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["OrderMode"] as? String {
                self.orderMode = value
            }
            if let value = dict["ParentPhysicalConnectionAliUid"] as? String {
                self.parentPhysicalConnectionAliUid = value
            }
            if let value = dict["ParentPhysicalConnectionId"] as? String {
                self.parentPhysicalConnectionId = value
            }
            if let value = dict["PeerLocation"] as? String {
                self.peerLocation = value
            }
            if let value = dict["PhysicalConnectionId"] as? String {
                self.physicalConnectionId = value
            }
            if let value = dict["PortNumber"] as? String {
                self.portNumber = value
            }
            if let value = dict["PortType"] as? String {
                self.portType = value
            }
            if let value = dict["ProductType"] as? String {
                self.productType = value
            }
            if let value = dict["RedundantPhysicalConnectionId"] as? String {
                self.redundantPhysicalConnectionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Spec"] as? String {
                self.spec = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["VirtualPhysicalConnectionStatus"] as? String {
                self.virtualPhysicalConnectionStatus = value
            }
            if let value = dict["VlanId"] as? String {
                self.vlanId = value
            }
        }
    }
    public var count: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualPhysicalConnections: [ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualPhysicalConnections != nil {
            var tmp : [Any] = []
            for k in self.virtualPhysicalConnections! {
                tmp.append(k.toMap())
            }
            map["VirtualPhysicalConnections"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VirtualPhysicalConnections"] as? [Any?] {
            var tmp : [ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections] = []
            for v in value {
                if v != nil {
                    var model = ListVirtualPhysicalConnectionsResponseBody.VirtualPhysicalConnections()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.virtualPhysicalConnections = tmp
        }
    }
}

public class ListVirtualPhysicalConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVirtualPhysicalConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListVirtualPhysicalConnectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListVpcEndpointServicesByEndUserRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServiceName"] as? String {
            self.serviceName = value
        }
    }
}

public class ListVpcEndpointServicesByEndUserResponseBody : Tea.TeaModel {
    public class Services : Tea.TeaModel {
        public var defaultPolicyDocument: String?

        public var serviceDomain: String?

        public var serviceId: String?

        public var serviceName: String?

        public var supportPolicy: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultPolicyDocument != nil {
                map["DefaultPolicyDocument"] = self.defaultPolicyDocument!
            }
            if self.serviceDomain != nil {
                map["ServiceDomain"] = self.serviceDomain!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.supportPolicy != nil {
                map["SupportPolicy"] = self.supportPolicy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DefaultPolicyDocument"] as? String {
                self.defaultPolicyDocument = value
            }
            if let value = dict["ServiceDomain"] as? String {
                self.serviceDomain = value
            }
            if let value = dict["ServiceId"] as? String {
                self.serviceId = value
            }
            if let value = dict["ServiceName"] as? String {
                self.serviceName = value
            }
            if let value = dict["SupportPolicy"] as? Bool {
                self.supportPolicy = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var services: [ListVpcEndpointServicesByEndUserResponseBody.Services]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Services"] as? [Any?] {
            var tmp : [ListVpcEndpointServicesByEndUserResponseBody.Services] = []
            for v in value {
                if v != nil {
                    var model = ListVpcEndpointServicesByEndUserResponseBody.Services()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.services = tmp
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class ListVpcEndpointServicesByEndUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcEndpointServicesByEndUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListVpcEndpointServicesByEndUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListVpcGatewayEndpointsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var endpointId: String?

    public var endpointName: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public var tags: [ListVpcGatewayEndpointsRequest.Tags]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndpointId"] as? String {
            self.endpointId = value
        }
        if let value = dict["EndpointName"] as? String {
            self.endpointName = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServiceName"] as? String {
            self.serviceName = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListVpcGatewayEndpointsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListVpcGatewayEndpointsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ListVpcGatewayEndpointsResponseBody : Tea.TeaModel {
    public class Endpoints : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var associatedRouteTables: [String]?

        public var creationTime: String?

        public var endpointDescription: String?

        public var endpointId: String?

        public var endpointName: String?

        public var endpointStatus: String?

        public var policyDocument: String?

        public var resourceGroupId: String?

        public var serviceName: String?

        public var tags: [ListVpcGatewayEndpointsResponseBody.Endpoints.Tags]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associatedRouteTables != nil {
                map["AssociatedRouteTables"] = self.associatedRouteTables!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.endpointDescription != nil {
                map["EndpointDescription"] = self.endpointDescription!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.endpointName != nil {
                map["EndpointName"] = self.endpointName!
            }
            if self.endpointStatus != nil {
                map["EndpointStatus"] = self.endpointStatus!
            }
            if self.policyDocument != nil {
                map["PolicyDocument"] = self.policyDocument!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssociatedRouteTables"] as? [String] {
                self.associatedRouteTables = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["EndpointDescription"] as? String {
                self.endpointDescription = value
            }
            if let value = dict["EndpointId"] as? String {
                self.endpointId = value
            }
            if let value = dict["EndpointName"] as? String {
                self.endpointName = value
            }
            if let value = dict["EndpointStatus"] as? String {
                self.endpointStatus = value
            }
            if let value = dict["PolicyDocument"] as? String {
                self.policyDocument = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["ServiceName"] as? String {
                self.serviceName = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListVpcGatewayEndpointsResponseBody.Endpoints.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListVpcGatewayEndpointsResponseBody.Endpoints.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var endpoints: [ListVpcGatewayEndpointsResponseBody.Endpoints]?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpoints != nil {
            var tmp : [Any] = []
            for k in self.endpoints! {
                tmp.append(k.toMap())
            }
            map["Endpoints"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Endpoints"] as? [Any?] {
            var tmp : [ListVpcGatewayEndpointsResponseBody.Endpoints] = []
            for v in value {
                if v != nil {
                    var model = ListVpcGatewayEndpointsResponseBody.Endpoints()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.endpoints = tmp
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListVpcGatewayEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcGatewayEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListVpcGatewayEndpointsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListVpcPublishedRouteEntriesRequest : Tea.TeaModel {
    public var destinationCidrBlock: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var targetInstanceId: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["TargetInstanceId"] as? String {
            self.targetInstanceId = value
        }
        if let value = dict["TargetType"] as? String {
            self.targetType = value
        }
    }
}

public class ListVpcPublishedRouteEntriesResponseBody : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public class RoutePublishTargets : Tea.TeaModel {
            public var publishStatus: String?

            public var publishTargetInstanceId: String?

            public var publishTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.publishStatus != nil {
                    map["PublishStatus"] = self.publishStatus!
                }
                if self.publishTargetInstanceId != nil {
                    map["PublishTargetInstanceId"] = self.publishTargetInstanceId!
                }
                if self.publishTargetType != nil {
                    map["PublishTargetType"] = self.publishTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PublishStatus"] as? String {
                    self.publishStatus = value
                }
                if let value = dict["PublishTargetInstanceId"] as? String {
                    self.publishTargetInstanceId = value
                }
                if let value = dict["PublishTargetType"] as? String {
                    self.publishTargetType = value
                }
            }
        }
        public var destinationCidrBlock: String?

        public var routeEntryId: String?

        public var routePublishTargets: [ListVpcPublishedRouteEntriesResponseBody.RouteEntries.RoutePublishTargets]?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.routeEntryId != nil {
                map["RouteEntryId"] = self.routeEntryId!
            }
            if self.routePublishTargets != nil {
                var tmp : [Any] = []
                for k in self.routePublishTargets! {
                    tmp.append(k.toMap())
                }
                map["RoutePublishTargets"] = tmp
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DestinationCidrBlock"] as? String {
                self.destinationCidrBlock = value
            }
            if let value = dict["RouteEntryId"] as? String {
                self.routeEntryId = value
            }
            if let value = dict["RoutePublishTargets"] as? [Any?] {
                var tmp : [ListVpcPublishedRouteEntriesResponseBody.RouteEntries.RoutePublishTargets] = []
                for v in value {
                    if v != nil {
                        var model = ListVpcPublishedRouteEntriesResponseBody.RouteEntries.RoutePublishTargets()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.routePublishTargets = tmp
            }
            if let value = dict["RouteTableId"] as? String {
                self.routeTableId = value
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var routeEntries: [ListVpcPublishedRouteEntriesResponseBody.RouteEntries]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteEntries"] as? [Any?] {
            var tmp : [ListVpcPublishedRouteEntriesResponseBody.RouteEntries] = []
            for v in value {
                if v != nil {
                    var model = ListVpcPublishedRouteEntriesResponseBody.RouteEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeEntries = tmp
        }
    }
}

public class ListVpcPublishedRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcPublishedRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListVpcPublishedRouteEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListVpnCertificateAssociationsRequest : Tea.TeaModel {
    public var certificateId: [String]?

    public var certificateType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var vpnGatewayId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.certificateType != nil {
            map["CertificateType"] = self.certificateType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertificateId"] as? [String] {
            self.certificateId = value
        }
        if let value = dict["CertificateType"] as? String {
            self.certificateType = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpnGatewayId"] as? [String] {
            self.vpnGatewayId = value
        }
    }
}

public class ListVpnCertificateAssociationsResponseBody : Tea.TeaModel {
    public class VpnCertificateRelations : Tea.TeaModel {
        public var associationTime: String?

        public var certificateId: String?

        public var certificateType: String?

        public var regionId: String?

        public var vpnGatewayId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associationTime != nil {
                map["AssociationTime"] = self.associationTime!
            }
            if self.certificateId != nil {
                map["CertificateId"] = self.certificateId!
            }
            if self.certificateType != nil {
                map["CertificateType"] = self.certificateType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.vpnGatewayId != nil {
                map["VpnGatewayId"] = self.vpnGatewayId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssociationTime"] as? String {
                self.associationTime = value
            }
            if let value = dict["CertificateId"] as? String {
                self.certificateId = value
            }
            if let value = dict["CertificateType"] as? String {
                self.certificateType = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["VpnGatewayId"] as? String {
                self.vpnGatewayId = value
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpnCertificateRelations: [ListVpnCertificateAssociationsResponseBody.VpnCertificateRelations]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpnCertificateRelations != nil {
            var tmp : [Any] = []
            for k in self.vpnCertificateRelations! {
                tmp.append(k.toMap())
            }
            map["VpnCertificateRelations"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VpnCertificateRelations"] as? [Any?] {
            var tmp : [ListVpnCertificateAssociationsResponseBody.VpnCertificateRelations] = []
            for v in value {
                if v != nil {
                    var model = ListVpnCertificateAssociationsResponseBody.VpnCertificateRelations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.vpnCertificateRelations = tmp
        }
    }
}

public class ListVpnCertificateAssociationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpnCertificateAssociationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListVpnCertificateAssociationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyBgpGroupAttributeRequest : Tea.TeaModel {
    public var authKey: String?

    public var bgpGroupId: String?

    public var clearAuthKey: Bool?

    public var clientToken: String?

    public var description_: String?

    public var isFakeAsn: Bool?

    public var localAsn: Int64?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerAsn: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeQuota: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.clearAuthKey != nil {
            map["ClearAuthKey"] = self.clearAuthKey!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.isFakeAsn != nil {
            map["IsFakeAsn"] = self.isFakeAsn!
        }
        if self.localAsn != nil {
            map["LocalAsn"] = self.localAsn!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerAsn != nil {
            map["PeerAsn"] = self.peerAsn!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeQuota != nil {
            map["RouteQuota"] = self.routeQuota!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthKey"] as? String {
            self.authKey = value
        }
        if let value = dict["BgpGroupId"] as? String {
            self.bgpGroupId = value
        }
        if let value = dict["ClearAuthKey"] as? Bool {
            self.clearAuthKey = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IsFakeAsn"] as? Bool {
            self.isFakeAsn = value
        }
        if let value = dict["LocalAsn"] as? Int64 {
            self.localAsn = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerAsn"] as? Int64 {
            self.peerAsn = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteQuota"] as? Int32 {
            self.routeQuota = value
        }
    }
}

public class ModifyBgpGroupAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyBgpGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBgpGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyBgpGroupAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyBgpPeerAttributeRequest : Tea.TeaModel {
    public var bfdMultiHop: Int32?

    public var bgpGroupId: String?

    public var bgpPeerId: String?

    public var clientToken: String?

    public var enableBfd: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bfdMultiHop != nil {
            map["BfdMultiHop"] = self.bfdMultiHop!
        }
        if self.bgpGroupId != nil {
            map["BgpGroupId"] = self.bgpGroupId!
        }
        if self.bgpPeerId != nil {
            map["BgpPeerId"] = self.bgpPeerId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableBfd != nil {
            map["EnableBfd"] = self.enableBfd!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerIpAddress != nil {
            map["PeerIpAddress"] = self.peerIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BfdMultiHop"] as? Int32 {
            self.bfdMultiHop = value
        }
        if let value = dict["BgpGroupId"] as? String {
            self.bgpGroupId = value
        }
        if let value = dict["BgpPeerId"] as? String {
            self.bgpPeerId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableBfd"] as? Bool {
            self.enableBfd = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerIpAddress"] as? String {
            self.peerIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyBgpPeerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyBgpPeerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBgpPeerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyBgpPeerAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCommonBandwidthPackageAttributeRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyCommonBandwidthPackageAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCommonBandwidthPackageAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCommonBandwidthPackageAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCommonBandwidthPackageAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCommonBandwidthPackageIpBandwidthRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var bandwidthPackageId: String?

    public var eipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.eipId != nil {
            map["EipId"] = self.eipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["EipId"] as? String {
            self.eipId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyCommonBandwidthPackageIpBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCommonBandwidthPackageIpBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCommonBandwidthPackageIpBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCommonBandwidthPackageIpBandwidthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCommonBandwidthPackageSpecRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var bandwidthPackageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyCommonBandwidthPackageSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCommonBandwidthPackageSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCommonBandwidthPackageSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCommonBandwidthPackageSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCustomerGatewayAttributeRequest : Tea.TeaModel {
    public var authKey: String?

    public var clientToken: String?

    public var customerGatewayId: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthKey"] as? String {
            self.authKey = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyCustomerGatewayAttributeResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class ModifyCustomerGatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCustomerGatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCustomerGatewayAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyEipAddressAttributeRequest : Tea.TeaModel {
    public var allocationId: String?

    public var bandwidth: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyEipAddressAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyEipAddressAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEipAddressAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyEipAddressAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyEipForwardModeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var mode: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Mode"] as? String {
            self.mode = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyEipForwardModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyEipForwardModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEipForwardModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyEipForwardModeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyExpressCloudConnectionAttributeRequest : Tea.TeaModel {
    public var bgpAs: String?

    public var ceIp: String?

    public var description_: String?

    public var eccId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peIp: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgpAs != nil {
            map["BgpAs"] = self.bgpAs!
        }
        if self.ceIp != nil {
            map["CeIp"] = self.ceIp!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eccId != nil {
            map["EccId"] = self.eccId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peIp != nil {
            map["PeIp"] = self.peIp!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgpAs"] as? String {
            self.bgpAs = value
        }
        if let value = dict["CeIp"] as? String {
            self.ceIp = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EccId"] as? String {
            self.eccId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeIp"] as? String {
            self.peIp = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyExpressCloudConnectionAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyExpressCloudConnectionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressCloudConnectionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyExpressCloudConnectionAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyExpressCloudConnectionBandwidthRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var eccId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.eccId != nil {
            map["EccId"] = self.eccId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["EccId"] as? String {
            self.eccId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyExpressCloudConnectionBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyExpressCloudConnectionBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressCloudConnectionBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyExpressCloudConnectionBandwidthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyExpressConnectTrafficQosRequest : Tea.TeaModel {
    public class AddInstanceList : Tea.TeaModel {
        public var instanceId: String?

        public var instanceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
        }
    }
    public class RemoveInstanceList : Tea.TeaModel {
        public var instanceId: String?

        public var instanceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
        }
    }
    public var addInstanceList: [ModifyExpressConnectTrafficQosRequest.AddInstanceList]?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosDescription: String?

    public var qosId: String?

    public var qosName: String?

    public var regionId: String?

    public var removeInstanceList: [ModifyExpressConnectTrafficQosRequest.RemoveInstanceList]?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addInstanceList != nil {
            var tmp : [Any] = []
            for k in self.addInstanceList! {
                tmp.append(k.toMap())
            }
            map["AddInstanceList"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosDescription != nil {
            map["QosDescription"] = self.qosDescription!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.qosName != nil {
            map["QosName"] = self.qosName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeInstanceList != nil {
            var tmp : [Any] = []
            for k in self.removeInstanceList! {
                tmp.append(k.toMap())
            }
            map["RemoveInstanceList"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddInstanceList"] as? [Any?] {
            var tmp : [ModifyExpressConnectTrafficQosRequest.AddInstanceList] = []
            for v in value {
                if v != nil {
                    var model = ModifyExpressConnectTrafficQosRequest.AddInstanceList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addInstanceList = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosDescription"] as? String {
            self.qosDescription = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QosName"] as? String {
            self.qosName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoveInstanceList"] as? [Any?] {
            var tmp : [ModifyExpressConnectTrafficQosRequest.RemoveInstanceList] = []
            for v in value {
                if v != nil {
                    var model = ModifyExpressConnectTrafficQosRequest.RemoveInstanceList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.removeInstanceList = tmp
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class ModifyExpressConnectTrafficQosResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyExpressConnectTrafficQosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressConnectTrafficQosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyExpressConnectTrafficQosResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyExpressConnectTrafficQosQueueRequest : Tea.TeaModel {
    public var bandwidthPercent: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var qosId: String?

    public var queueDescription: String?

    public var queueId: String?

    public var queueName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPercent != nil {
            map["BandwidthPercent"] = self.bandwidthPercent!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueDescription != nil {
            map["QueueDescription"] = self.queueDescription!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.queueName != nil {
            map["QueueName"] = self.queueName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPercent"] as? String {
            self.bandwidthPercent = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueDescription"] as? String {
            self.queueDescription = value
        }
        if let value = dict["QueueId"] as? String {
            self.queueId = value
        }
        if let value = dict["QueueName"] as? String {
            self.queueName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class ModifyExpressConnectTrafficQosQueueResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyExpressConnectTrafficQosQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressConnectTrafficQosQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyExpressConnectTrafficQosQueueResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyExpressConnectTrafficQosRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dstCidr: String?

    public var dstIPv6Cidr: String?

    public var dstPortRange: String?

    public var matchDscp: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var protocol_: String?

    public var qosId: String?

    public var queueId: String?

    public var regionId: String?

    public var remarkingDscp: Int32?

    public var resourceOwnerAccount: String?

    public var ruleDescription: String?

    public var ruleId: String?

    public var ruleName: String?

    public var srcCidr: String?

    public var srcIPv6Cidr: String?

    public var srcPortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dstCidr != nil {
            map["DstCidr"] = self.dstCidr!
        }
        if self.dstIPv6Cidr != nil {
            map["DstIPv6Cidr"] = self.dstIPv6Cidr!
        }
        if self.dstPortRange != nil {
            map["DstPortRange"] = self.dstPortRange!
        }
        if self.matchDscp != nil {
            map["MatchDscp"] = self.matchDscp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.qosId != nil {
            map["QosId"] = self.qosId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remarkingDscp != nil {
            map["RemarkingDscp"] = self.remarkingDscp!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.ruleDescription != nil {
            map["RuleDescription"] = self.ruleDescription!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.srcCidr != nil {
            map["SrcCidr"] = self.srcCidr!
        }
        if self.srcIPv6Cidr != nil {
            map["SrcIPv6Cidr"] = self.srcIPv6Cidr!
        }
        if self.srcPortRange != nil {
            map["SrcPortRange"] = self.srcPortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DstCidr"] as? String {
            self.dstCidr = value
        }
        if let value = dict["DstIPv6Cidr"] as? String {
            self.dstIPv6Cidr = value
        }
        if let value = dict["DstPortRange"] as? String {
            self.dstPortRange = value
        }
        if let value = dict["MatchDscp"] as? Int32 {
            self.matchDscp = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["QosId"] as? String {
            self.qosId = value
        }
        if let value = dict["QueueId"] as? String {
            self.queueId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemarkingDscp"] as? Int32 {
            self.remarkingDscp = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["RuleDescription"] as? String {
            self.ruleDescription = value
        }
        if let value = dict["RuleId"] as? String {
            self.ruleId = value
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
        if let value = dict["SrcCidr"] as? String {
            self.srcCidr = value
        }
        if let value = dict["SrcIPv6Cidr"] as? String {
            self.srcIPv6Cidr = value
        }
        if let value = dict["SrcPortRange"] as? String {
            self.srcPortRange = value
        }
    }
}

public class ModifyExpressConnectTrafficQosRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyExpressConnectTrafficQosRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyExpressConnectTrafficQosRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyExpressConnectTrafficQosRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyFlowLogAttributeRequest : Tea.TeaModel {
    public var aggregationInterval: Int32?

    public var description_: String?

    public var flowLogId: String?

    public var flowLogName: String?

    public var ipVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregationInterval != nil {
            map["AggregationInterval"] = self.aggregationInterval!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.flowLogId != nil {
            map["FlowLogId"] = self.flowLogId!
        }
        if self.flowLogName != nil {
            map["FlowLogName"] = self.flowLogName!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AggregationInterval"] as? Int32 {
            self.aggregationInterval = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FlowLogId"] as? String {
            self.flowLogId = value
        }
        if let value = dict["FlowLogName"] as? String {
            self.flowLogName = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyFlowLogAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class ModifyFlowLogAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFlowLogAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyFlowLogAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyForwardEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryId: String?

    public var forwardEntryName: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portBreak: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portBreak != nil {
            map["PortBreak"] = self.portBreak!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ExternalIp"] as? String {
            self.externalIp = value
        }
        if let value = dict["ExternalPort"] as? String {
            self.externalPort = value
        }
        if let value = dict["ForwardEntryId"] as? String {
            self.forwardEntryId = value
        }
        if let value = dict["ForwardEntryName"] as? String {
            self.forwardEntryName = value
        }
        if let value = dict["ForwardTableId"] as? String {
            self.forwardTableId = value
        }
        if let value = dict["InternalIp"] as? String {
            self.internalIp = value
        }
        if let value = dict["InternalPort"] as? String {
            self.internalPort = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortBreak"] as? Bool {
            self.portBreak = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyForwardEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyFullNatEntryAttributeRequest : Tea.TeaModel {
    public var accessIp: String?

    public var accessPort: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var fullNatEntryDescription: String?

    public var fullNatEntryId: String?

    public var fullNatEntryName: String?

    public var fullNatTableId: String?

    public var ipProtocol: String?

    public var natIp: String?

    public var natIpPort: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessIp != nil {
            map["AccessIp"] = self.accessIp!
        }
        if self.accessPort != nil {
            map["AccessPort"] = self.accessPort!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.fullNatEntryDescription != nil {
            map["FullNatEntryDescription"] = self.fullNatEntryDescription!
        }
        if self.fullNatEntryId != nil {
            map["FullNatEntryId"] = self.fullNatEntryId!
        }
        if self.fullNatEntryName != nil {
            map["FullNatEntryName"] = self.fullNatEntryName!
        }
        if self.fullNatTableId != nil {
            map["FullNatTableId"] = self.fullNatTableId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natIp != nil {
            map["NatIp"] = self.natIp!
        }
        if self.natIpPort != nil {
            map["NatIpPort"] = self.natIpPort!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessIp"] as? String {
            self.accessIp = value
        }
        if let value = dict["AccessPort"] as? String {
            self.accessPort = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["FullNatEntryDescription"] as? String {
            self.fullNatEntryDescription = value
        }
        if let value = dict["FullNatEntryId"] as? String {
            self.fullNatEntryId = value
        }
        if let value = dict["FullNatEntryName"] as? String {
            self.fullNatEntryName = value
        }
        if let value = dict["FullNatTableId"] as? String {
            self.fullNatTableId = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["NatIp"] as? String {
            self.natIp = value
        }
        if let value = dict["NatIpPort"] as? String {
            self.natIpPort = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyFullNatEntryAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyFullNatEntryAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFullNatEntryAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyFullNatEntryAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyGlobalAccelerationInstanceAttributesRequest : Tea.TeaModel {
    public var description_: String?

    public var globalAccelerationInstanceId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["GlobalAccelerationInstanceId"] as? String {
            self.globalAccelerationInstanceId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyGlobalAccelerationInstanceAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyGlobalAccelerationInstanceAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGlobalAccelerationInstanceAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyGlobalAccelerationInstanceAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyGlobalAccelerationInstanceSpecRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var globalAccelerationInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["GlobalAccelerationInstanceId"] as? String {
            self.globalAccelerationInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyGlobalAccelerationInstanceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyGlobalAccelerationInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGlobalAccelerationInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyGlobalAccelerationInstanceSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyHaVipAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var haVipId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyHaVipAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyHaVipAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHaVipAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyHaVipAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorAclAttributeRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclName: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["AclName"] as? String {
            self.aclName = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyIPv6TranslatorAclAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyIPv6TranslatorAclAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorAclAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyIPv6TranslatorAclAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorAclListEntryRequest : Tea.TeaModel {
    public var aclEntryComment: String?

    public var aclEntryId: String?

    public var aclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntryComment != nil {
            map["AclEntryComment"] = self.aclEntryComment!
        }
        if self.aclEntryId != nil {
            map["AclEntryId"] = self.aclEntryId!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclEntryComment"] as? String {
            self.aclEntryComment = value
        }
        if let value = dict["AclEntryId"] as? String {
            self.aclEntryId = value
        }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyIPv6TranslatorAclListEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyIPv6TranslatorAclListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorAclListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyIPv6TranslatorAclListEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var ipv6TranslatorId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Ipv6TranslatorId"] as? String {
            self.ipv6TranslatorId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyIPv6TranslatorAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyIPv6TranslatorAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyIPv6TranslatorAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorBandwidthRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var bandwidth: Int32?

    public var clientToken: String?

    public var ipv6TranslatorId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6TranslatorId != nil {
            map["Ipv6TranslatorId"] = self.ipv6TranslatorId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Ipv6TranslatorId"] as? String {
            self.ipv6TranslatorId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyIPv6TranslatorBandwidthResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyIPv6TranslatorBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyIPv6TranslatorBandwidthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyIPv6TranslatorEntryRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclStatus: String?

    public var aclType: String?

    public var allocateIpv6Port: Int32?

    public var backendIpv4Addr: String?

    public var backendIpv4Port: Int32?

    public var entryBandwidth: Int32?

    public var entryDescription: String?

    public var entryName: String?

    public var ipv6TranslatorEntryId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var transProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclStatus != nil {
            map["AclStatus"] = self.aclStatus!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.allocateIpv6Port != nil {
            map["AllocateIpv6Port"] = self.allocateIpv6Port!
        }
        if self.backendIpv4Addr != nil {
            map["BackendIpv4Addr"] = self.backendIpv4Addr!
        }
        if self.backendIpv4Port != nil {
            map["BackendIpv4Port"] = self.backendIpv4Port!
        }
        if self.entryBandwidth != nil {
            map["EntryBandwidth"] = self.entryBandwidth!
        }
        if self.entryDescription != nil {
            map["EntryDescription"] = self.entryDescription!
        }
        if self.entryName != nil {
            map["EntryName"] = self.entryName!
        }
        if self.ipv6TranslatorEntryId != nil {
            map["Ipv6TranslatorEntryId"] = self.ipv6TranslatorEntryId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.transProtocol != nil {
            map["TransProtocol"] = self.transProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["AclStatus"] as? String {
            self.aclStatus = value
        }
        if let value = dict["AclType"] as? String {
            self.aclType = value
        }
        if let value = dict["AllocateIpv6Port"] as? Int32 {
            self.allocateIpv6Port = value
        }
        if let value = dict["BackendIpv4Addr"] as? String {
            self.backendIpv4Addr = value
        }
        if let value = dict["BackendIpv4Port"] as? Int32 {
            self.backendIpv4Port = value
        }
        if let value = dict["EntryBandwidth"] as? Int32 {
            self.entryBandwidth = value
        }
        if let value = dict["EntryDescription"] as? String {
            self.entryDescription = value
        }
        if let value = dict["EntryName"] as? String {
            self.entryName = value
        }
        if let value = dict["Ipv6TranslatorEntryId"] as? String {
            self.ipv6TranslatorEntryId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TransProtocol"] as? String {
            self.transProtocol = value
        }
    }
}

public class ModifyIPv6TranslatorEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyIPv6TranslatorEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIPv6TranslatorEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyIPv6TranslatorEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyIpv6AddressAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var ipv6AddressId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv6AddressId"] as? String {
            self.ipv6AddressId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyIpv6AddressAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyIpv6AddressAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpv6AddressAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyIpv6AddressAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyIpv6GatewayAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var ipv6GatewayId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6GatewayId != nil {
            map["Ipv6GatewayId"] = self.ipv6GatewayId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv6GatewayId"] as? String {
            self.ipv6GatewayId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyIpv6GatewayAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyIpv6GatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpv6GatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyIpv6GatewayAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyIpv6InternetBandwidthRequest : Tea.TeaModel {
    public var bandwidth: Int64?

    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6AddressId: String?

    public var ipv6InternetBandwidthId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ipv6InternetBandwidthId != nil {
            map["Ipv6InternetBandwidthId"] = self.ipv6InternetBandwidthId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? Int64 {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv6AddressId"] as? String {
            self.ipv6AddressId = value
        }
        if let value = dict["Ipv6InternetBandwidthId"] as? String {
            self.ipv6InternetBandwidthId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyIpv6InternetBandwidthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyIpv6InternetBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpv6InternetBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyIpv6InternetBandwidthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyNatGatewayAttributeRequest : Tea.TeaModel {
    public class LogDelivery : Tea.TeaModel {
        public var logDeliveryType: String?

        public var logDestination: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logDeliveryType != nil {
                map["LogDeliveryType"] = self.logDeliveryType!
            }
            if self.logDestination != nil {
                map["LogDestination"] = self.logDestination!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LogDeliveryType"] as? String {
                self.logDeliveryType = value
            }
            if let value = dict["LogDestination"] as? String {
                self.logDestination = value
            }
        }
    }
    public var description_: String?

    public var eipBindMode: String?

    public var enableSessionLog: Bool?

    public var icmpReplyEnabled: Bool?

    public var logDelivery: ModifyNatGatewayAttributeRequest.LogDelivery?

    public var name: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logDelivery?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipBindMode != nil {
            map["EipBindMode"] = self.eipBindMode!
        }
        if self.enableSessionLog != nil {
            map["EnableSessionLog"] = self.enableSessionLog!
        }
        if self.icmpReplyEnabled != nil {
            map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
        }
        if self.logDelivery != nil {
            map["LogDelivery"] = self.logDelivery?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EipBindMode"] as? String {
            self.eipBindMode = value
        }
        if let value = dict["EnableSessionLog"] as? Bool {
            self.enableSessionLog = value
        }
        if let value = dict["IcmpReplyEnabled"] as? Bool {
            self.icmpReplyEnabled = value
        }
        if let value = dict["LogDelivery"] as? [String: Any?] {
            var model = ModifyNatGatewayAttributeRequest.LogDelivery()
            model.fromMap(value)
            self.logDelivery = model
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyNatGatewayAttributeShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var eipBindMode: String?

    public var enableSessionLog: Bool?

    public var icmpReplyEnabled: Bool?

    public var logDeliveryShrink: String?

    public var name: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipBindMode != nil {
            map["EipBindMode"] = self.eipBindMode!
        }
        if self.enableSessionLog != nil {
            map["EnableSessionLog"] = self.enableSessionLog!
        }
        if self.icmpReplyEnabled != nil {
            map["IcmpReplyEnabled"] = self.icmpReplyEnabled!
        }
        if self.logDeliveryShrink != nil {
            map["LogDelivery"] = self.logDeliveryShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EipBindMode"] as? String {
            self.eipBindMode = value
        }
        if let value = dict["EnableSessionLog"] as? Bool {
            self.enableSessionLog = value
        }
        if let value = dict["IcmpReplyEnabled"] as? Bool {
            self.icmpReplyEnabled = value
        }
        if let value = dict["LogDelivery"] as? String {
            self.logDeliveryShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyNatGatewayAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyNatGatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNatGatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyNatGatewayAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyNatGatewaySpecRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class ModifyNatGatewaySpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyNatGatewaySpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNatGatewaySpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyNatGatewaySpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyNatIpAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natIpDescription: String?

    public var natIpId: String?

    public var natIpName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natIpDescription != nil {
            map["NatIpDescription"] = self.natIpDescription!
        }
        if self.natIpId != nil {
            map["NatIpId"] = self.natIpId!
        }
        if self.natIpName != nil {
            map["NatIpName"] = self.natIpName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NatIpDescription"] as? String {
            self.natIpDescription = value
        }
        if let value = dict["NatIpId"] as? String {
            self.natIpId = value
        }
        if let value = dict["NatIpName"] as? String {
            self.natIpName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyNatIpAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyNatIpAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNatIpAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyNatIpAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyNatIpCidrAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natGatewayId: String?

    public var natIpCidr: String?

    public var natIpCidrDescription: String?

    public var natIpCidrName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natIpCidr != nil {
            map["NatIpCidr"] = self.natIpCidr!
        }
        if self.natIpCidrDescription != nil {
            map["NatIpCidrDescription"] = self.natIpCidrDescription!
        }
        if self.natIpCidrName != nil {
            map["NatIpCidrName"] = self.natIpCidrName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatIpCidr"] as? String {
            self.natIpCidr = value
        }
        if let value = dict["NatIpCidrDescription"] as? String {
            self.natIpCidrDescription = value
        }
        if let value = dict["NatIpCidrName"] as? String {
            self.natIpCidrName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyNatIpCidrAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyNatIpCidrAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNatIpCidrAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyNatIpCidrAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyNetworkAclAttributesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var networkAclName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["NetworkAclName"] as? String {
            self.networkAclName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyNetworkAclAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyNetworkAclAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNetworkAclAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyNetworkAclAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyPhysicalConnectionAttributeRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var lineOperator: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerLocation: String?

    public var physicalConnectionId: String?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var bandwidth: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.bandwidth != nil {
            map["bandwidth"] = self.bandwidth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CircuitCode"] as? String {
            self.circuitCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LineOperator"] as? String {
            self.lineOperator = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerLocation"] as? String {
            self.peerLocation = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["PortType"] as? String {
            self.portType = value
        }
        if let value = dict["RedundantPhysicalConnectionId"] as? String {
            self.redundantPhysicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["bandwidth"] as? Int32 {
            self.bandwidth = value
        }
    }
}

public class ModifyPhysicalConnectionAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyPhysicalConnectionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPhysicalConnectionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyPhysicalConnectionAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRouteEntryRequest : Tea.TeaModel {
    public var description_: String?

    public var destinationCidrBlock: String?

    public var dryRun: Bool?

    public var newNextHopId: String?

    public var newNextHopType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntryId: String?

    public var routeEntryName: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.newNextHopId != nil {
            map["NewNextHopId"] = self.newNextHopId!
        }
        if self.newNextHopType != nil {
            map["NewNextHopType"] = self.newNextHopType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NewNextHopId"] as? String {
            self.newNextHopId = value
        }
        if let value = dict["NewNextHopType"] as? String {
            self.newNextHopType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntryId"] as? String {
            self.routeEntryId = value
        }
        if let value = dict["RouteEntryName"] as? String {
            self.routeEntryName = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
    }
}

public class ModifyRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRouteTableAttributesRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routePropagationEnable: Bool?

    public var routeTableId: String?

    public var routeTableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routePropagationEnable != nil {
            map["RoutePropagationEnable"] = self.routePropagationEnable!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RoutePropagationEnable"] as? Bool {
            self.routePropagationEnable = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["RouteTableName"] as? String {
            self.routeTableName = value
        }
    }
}

public class ModifyRouteTableAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRouteTableAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouteTableAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRouteTableAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRouterInterfaceAttributeRequest : Tea.TeaModel {
    public var deleteHealthCheckIp: Bool?

    public var description_: String?

    public var hcRate: Int32?

    public var hcThreshold: Int32?

    public var healthCheckSourceIp: String?

    public var healthCheckTargetIp: String?

    public var name: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: Int64?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteHealthCheckIp != nil {
            map["DeleteHealthCheckIp"] = self.deleteHealthCheckIp!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hcRate != nil {
            map["HcRate"] = self.hcRate!
        }
        if self.hcThreshold != nil {
            map["HcThreshold"] = self.hcThreshold!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteHealthCheckIp"] as? Bool {
            self.deleteHealthCheckIp = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["HcRate"] as? Int32 {
            self.hcRate = value
        }
        if let value = dict["HcThreshold"] as? Int32 {
            self.hcThreshold = value
        }
        if let value = dict["HealthCheckSourceIp"] as? String {
            self.healthCheckSourceIp = value
        }
        if let value = dict["HealthCheckTargetIp"] as? String {
            self.healthCheckTargetIp = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OppositeInterfaceId"] as? String {
            self.oppositeInterfaceId = value
        }
        if let value = dict["OppositeInterfaceOwnerId"] as? Int64 {
            self.oppositeInterfaceOwnerId = value
        }
        if let value = dict["OppositeRouterId"] as? String {
            self.oppositeRouterId = value
        }
        if let value = dict["OppositeRouterType"] as? String {
            self.oppositeRouterType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class ModifyRouterInterfaceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRouterInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouterInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRouterInterfaceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRouterInterfaceSpecRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class ModifyRouterInterfaceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class ModifyRouterInterfaceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouterInterfaceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRouterInterfaceSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySnatEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var eipAffinity: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snatEntryId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public var snatTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.eipAffinity != nil {
            map["EipAffinity"] = self.eipAffinity!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.snatTableId != nil {
            map["SnatTableId"] = self.snatTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EipAffinity"] as? Int32 {
            self.eipAffinity = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnatEntryId"] as? String {
            self.snatEntryId = value
        }
        if let value = dict["SnatEntryName"] as? String {
            self.snatEntryName = value
        }
        if let value = dict["SnatIp"] as? String {
            self.snatIp = value
        }
        if let value = dict["SnatTableId"] as? String {
            self.snatTableId = value
        }
    }
}

public class ModifySnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySnatEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySslVpnClientCertRequest : Tea.TeaModel {
    public var clientToken: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslVpnClientCertId"] as? String {
            self.sslVpnClientCertId = value
        }
    }
}

public class ModifySslVpnClientCertResponseBody : Tea.TeaModel {
    public var name: String?

    public var requestId: String?

    public var sslVpnClientCertId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sslVpnClientCertId != nil {
            map["SslVpnClientCertId"] = self.sslVpnClientCertId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SslVpnClientCertId"] as? String {
            self.sslVpnClientCertId = value
        }
    }
}

public class ModifySslVpnClientCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySslVpnClientCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySslVpnClientCertResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySslVpnServerRequest : Tea.TeaModel {
    public var cipher: String?

    public var clientIpPool: String?

    public var clientToken: String?

    public var compress: Bool?

    public var dryRun: Bool?

    public var enableMultiFactorAuth: Bool?

    public var IDaaSApplicationId: String?

    public var IDaaSInstanceId: String?

    public var IDaaSRegionId: String?

    public var localSubnet: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var port: Int32?

    public var proto: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sslVpnServerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipher != nil {
            map["Cipher"] = self.cipher!
        }
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.compress != nil {
            map["Compress"] = self.compress!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableMultiFactorAuth != nil {
            map["EnableMultiFactorAuth"] = self.enableMultiFactorAuth!
        }
        if self.IDaaSApplicationId != nil {
            map["IDaaSApplicationId"] = self.IDaaSApplicationId!
        }
        if self.IDaaSInstanceId != nil {
            map["IDaaSInstanceId"] = self.IDaaSInstanceId!
        }
        if self.IDaaSRegionId != nil {
            map["IDaaSRegionId"] = self.IDaaSRegionId!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.proto != nil {
            map["Proto"] = self.proto!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cipher"] as? String {
            self.cipher = value
        }
        if let value = dict["ClientIpPool"] as? String {
            self.clientIpPool = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Compress"] as? Bool {
            self.compress = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EnableMultiFactorAuth"] as? Bool {
            self.enableMultiFactorAuth = value
        }
        if let value = dict["IDaaSApplicationId"] as? String {
            self.IDaaSApplicationId = value
        }
        if let value = dict["IDaaSInstanceId"] as? String {
            self.IDaaSInstanceId = value
        }
        if let value = dict["IDaaSRegionId"] as? String {
            self.IDaaSRegionId = value
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
        if let value = dict["Proto"] as? String {
            self.proto = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SslVpnServerId"] as? String {
            self.sslVpnServerId = value
        }
    }
}

public class ModifySslVpnServerResponseBody : Tea.TeaModel {
    public var cipher: String?

    public var clientIpPool: String?

    public var compress: Bool?

    public var connections: Int32?

    public var createTime: Int64?

    public var enableMultiFactorAuth: Bool?

    public var IDaaSApplicationId: String?

    public var IDaaSInstanceId: String?

    public var IDaaSInstanceVersion: String?

    public var internetIp: String?

    public var localSubnet: String?

    public var maxConnections: Int32?

    public var name: String?

    public var port: Int32?

    public var proto: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var sslVpnServerId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipher != nil {
            map["Cipher"] = self.cipher!
        }
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.compress != nil {
            map["Compress"] = self.compress!
        }
        if self.connections != nil {
            map["Connections"] = self.connections!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.enableMultiFactorAuth != nil {
            map["EnableMultiFactorAuth"] = self.enableMultiFactorAuth!
        }
        if self.IDaaSApplicationId != nil {
            map["IDaaSApplicationId"] = self.IDaaSApplicationId!
        }
        if self.IDaaSInstanceId != nil {
            map["IDaaSInstanceId"] = self.IDaaSInstanceId!
        }
        if self.IDaaSInstanceVersion != nil {
            map["IDaaSInstanceVersion"] = self.IDaaSInstanceVersion!
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.maxConnections != nil {
            map["MaxConnections"] = self.maxConnections!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.proto != nil {
            map["Proto"] = self.proto!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sslVpnServerId != nil {
            map["SslVpnServerId"] = self.sslVpnServerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cipher"] as? String {
            self.cipher = value
        }
        if let value = dict["ClientIpPool"] as? String {
            self.clientIpPool = value
        }
        if let value = dict["Compress"] as? Bool {
            self.compress = value
        }
        if let value = dict["Connections"] as? Int32 {
            self.connections = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["EnableMultiFactorAuth"] as? Bool {
            self.enableMultiFactorAuth = value
        }
        if let value = dict["IDaaSApplicationId"] as? String {
            self.IDaaSApplicationId = value
        }
        if let value = dict["IDaaSInstanceId"] as? String {
            self.IDaaSInstanceId = value
        }
        if let value = dict["IDaaSInstanceVersion"] as? String {
            self.IDaaSInstanceVersion = value
        }
        if let value = dict["InternetIp"] as? String {
            self.internetIp = value
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["MaxConnections"] as? Int32 {
            self.maxConnections = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
        if let value = dict["Proto"] as? String {
            self.proto = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SslVpnServerId"] as? String {
            self.sslVpnServerId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class ModifySslVpnServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySslVpnServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySslVpnServerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyTunnelAttributeRequest : Tea.TeaModel {
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalAsn"] as? Int64 {
                    self.localAsn = value
                }
                if let value = dict["LocalBgpIp"] as? String {
                    self.localBgpIp = value
                }
                if let value = dict["TunnelCidr"] as? String {
                    self.tunnelCidr = value
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IkeAuthAlg"] as? String {
                    self.ikeAuthAlg = value
                }
                if let value = dict["IkeEncAlg"] as? String {
                    self.ikeEncAlg = value
                }
                if let value = dict["IkeLifetime"] as? Int64 {
                    self.ikeLifetime = value
                }
                if let value = dict["IkeMode"] as? String {
                    self.ikeMode = value
                }
                if let value = dict["IkePfs"] as? String {
                    self.ikePfs = value
                }
                if let value = dict["IkeVersion"] as? String {
                    self.ikeVersion = value
                }
                if let value = dict["LocalId"] as? String {
                    self.localId = value
                }
                if let value = dict["Psk"] as? String {
                    self.psk = value
                }
                if let value = dict["RemoteId"] as? String {
                    self.remoteId = value
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpsecAuthAlg"] as? String {
                    self.ipsecAuthAlg = value
                }
                if let value = dict["IpsecEncAlg"] as? String {
                    self.ipsecEncAlg = value
                }
                if let value = dict["IpsecLifetime"] as? Int64 {
                    self.ipsecLifetime = value
                }
                if let value = dict["IpsecPfs"] as? String {
                    self.ipsecPfs = value
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var remoteCaCertificate: String?

        public var tunnelBgpConfig: ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelIkeConfig: ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIpsecConfig: ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.remoteCaCertificate != nil {
                map["RemoteCaCertificate"] = self.remoteCaCertificate!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CustomerGatewayId"] as? String {
                self.customerGatewayId = value
            }
            if let value = dict["EnableDpd"] as? Bool {
                self.enableDpd = value
            }
            if let value = dict["EnableNatTraversal"] as? Bool {
                self.enableNatTraversal = value
            }
            if let value = dict["RemoteCaCertificate"] as? String {
                self.remoteCaCertificate = value
            }
            if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
                var model = ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(value)
                self.tunnelBgpConfig = model
            }
            if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
                var model = ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(value)
                self.tunnelIkeConfig = model
            }
            if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
                var model = ModifyTunnelAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(value)
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tunnelId: String?

    public var tunnelOptionsSpecification: ModifyTunnelAttributeRequest.TunnelOptionsSpecification?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tunnelOptionsSpecification?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tunnelId != nil {
            map["TunnelId"] = self.tunnelId!
        }
        if self.tunnelOptionsSpecification != nil {
            map["TunnelOptionsSpecification"] = self.tunnelOptionsSpecification?.toMap()
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TunnelId"] as? String {
            self.tunnelId = value
        }
        if let value = dict["TunnelOptionsSpecification"] as? [String: Any?] {
            var model = ModifyTunnelAttributeRequest.TunnelOptionsSpecification()
            model.fromMap(value)
            self.tunnelOptionsSpecification = model
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class ModifyTunnelAttributeResponseBody : Tea.TeaModel {
    public class TunnelBgpConfig : Tea.TeaModel {
        public var enableBgp: Bool?

        public var localAsn: Int64?

        public var localBgpIp: String?

        public var peerAsn: Int64?

        public var peerBgpIp: String?

        public var tunnelCidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableBgp != nil {
                map["EnableBgp"] = self.enableBgp!
            }
            if self.localAsn != nil {
                map["LocalAsn"] = self.localAsn!
            }
            if self.localBgpIp != nil {
                map["LocalBgpIp"] = self.localBgpIp!
            }
            if self.peerAsn != nil {
                map["PeerAsn"] = self.peerAsn!
            }
            if self.peerBgpIp != nil {
                map["PeerBgpIp"] = self.peerBgpIp!
            }
            if self.tunnelCidr != nil {
                map["TunnelCidr"] = self.tunnelCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableBgp"] as? Bool {
                self.enableBgp = value
            }
            if let value = dict["LocalAsn"] as? Int64 {
                self.localAsn = value
            }
            if let value = dict["LocalBgpIp"] as? String {
                self.localBgpIp = value
            }
            if let value = dict["PeerAsn"] as? Int64 {
                self.peerAsn = value
            }
            if let value = dict["PeerBgpIp"] as? String {
                self.peerBgpIp = value
            }
            if let value = dict["TunnelCidr"] as? String {
                self.tunnelCidr = value
            }
        }
    }
    public class TunnelIkeConfig : Tea.TeaModel {
        public var ikeAuthAlg: String?

        public var ikeEncAlg: String?

        public var ikeLifetime: Int64?

        public var ikeMode: String?

        public var ikePfs: String?

        public var ikeVersion: String?

        public var localId: String?

        public var psk: String?

        public var remoteId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ikeAuthAlg != nil {
                map["IkeAuthAlg"] = self.ikeAuthAlg!
            }
            if self.ikeEncAlg != nil {
                map["IkeEncAlg"] = self.ikeEncAlg!
            }
            if self.ikeLifetime != nil {
                map["IkeLifetime"] = self.ikeLifetime!
            }
            if self.ikeMode != nil {
                map["IkeMode"] = self.ikeMode!
            }
            if self.ikePfs != nil {
                map["IkePfs"] = self.ikePfs!
            }
            if self.ikeVersion != nil {
                map["IkeVersion"] = self.ikeVersion!
            }
            if self.localId != nil {
                map["LocalId"] = self.localId!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.remoteId != nil {
                map["RemoteId"] = self.remoteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IkeAuthAlg"] as? String {
                self.ikeAuthAlg = value
            }
            if let value = dict["IkeEncAlg"] as? String {
                self.ikeEncAlg = value
            }
            if let value = dict["IkeLifetime"] as? Int64 {
                self.ikeLifetime = value
            }
            if let value = dict["IkeMode"] as? String {
                self.ikeMode = value
            }
            if let value = dict["IkePfs"] as? String {
                self.ikePfs = value
            }
            if let value = dict["IkeVersion"] as? String {
                self.ikeVersion = value
            }
            if let value = dict["LocalId"] as? String {
                self.localId = value
            }
            if let value = dict["Psk"] as? String {
                self.psk = value
            }
            if let value = dict["RemoteId"] as? String {
                self.remoteId = value
            }
        }
    }
    public class TunnelIpsecConfig : Tea.TeaModel {
        public var ipsecAuthAlg: String?

        public var ipsecEncAlg: String?

        public var ipsecLifetime: Int64?

        public var ipsecPfs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipsecAuthAlg != nil {
                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
            }
            if self.ipsecEncAlg != nil {
                map["IpsecEncAlg"] = self.ipsecEncAlg!
            }
            if self.ipsecLifetime != nil {
                map["IpsecLifetime"] = self.ipsecLifetime!
            }
            if self.ipsecPfs != nil {
                map["IpsecPfs"] = self.ipsecPfs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IpsecAuthAlg"] as? String {
                self.ipsecAuthAlg = value
            }
            if let value = dict["IpsecEncAlg"] as? String {
                self.ipsecEncAlg = value
            }
            if let value = dict["IpsecLifetime"] as? Int64 {
                self.ipsecLifetime = value
            }
            if let value = dict["IpsecPfs"] as? String {
                self.ipsecPfs = value
            }
        }
    }
    public var customerGatewayId: String?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var internetIp: String?

    public var remoteCaCertificate: String?

    public var requestId: String?

    public var role: String?

    public var state: String?

    public var tunnelBgpConfig: ModifyTunnelAttributeResponseBody.TunnelBgpConfig?

    public var tunnelId: String?

    public var tunnelIkeConfig: ModifyTunnelAttributeResponseBody.TunnelIkeConfig?

    public var tunnelIpsecConfig: ModifyTunnelAttributeResponseBody.TunnelIpsecConfig?

    public var zoneNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tunnelBgpConfig?.validate()
        try self.tunnelIkeConfig?.validate()
        try self.tunnelIpsecConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.remoteCaCertificate != nil {
            map["RemoteCaCertificate"] = self.remoteCaCertificate!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.tunnelBgpConfig != nil {
            map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
        }
        if self.tunnelId != nil {
            map["TunnelId"] = self.tunnelId!
        }
        if self.tunnelIkeConfig != nil {
            map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
        }
        if self.tunnelIpsecConfig != nil {
            map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
        }
        if self.zoneNo != nil {
            map["ZoneNo"] = self.zoneNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["EnableDpd"] as? Bool {
            self.enableDpd = value
        }
        if let value = dict["EnableNatTraversal"] as? Bool {
            self.enableNatTraversal = value
        }
        if let value = dict["InternetIp"] as? String {
            self.internetIp = value
        }
        if let value = dict["RemoteCaCertificate"] as? String {
            self.remoteCaCertificate = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
        if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
            var model = ModifyTunnelAttributeResponseBody.TunnelBgpConfig()
            model.fromMap(value)
            self.tunnelBgpConfig = model
        }
        if let value = dict["TunnelId"] as? String {
            self.tunnelId = value
        }
        if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
            var model = ModifyTunnelAttributeResponseBody.TunnelIkeConfig()
            model.fromMap(value)
            self.tunnelIkeConfig = model
        }
        if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
            var model = ModifyTunnelAttributeResponseBody.TunnelIpsecConfig()
            model.fromMap(value)
            self.tunnelIpsecConfig = model
        }
        if let value = dict["ZoneNo"] as? String {
            self.zoneNo = value
        }
    }
}

public class ModifyTunnelAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTunnelAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyTunnelAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVRouterAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VRouterId: String?

    public var VRouterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.VRouterName != nil {
            map["VRouterName"] = self.VRouterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
        if let value = dict["VRouterName"] as? String {
            self.VRouterName = value
        }
    }
}

public class ModifyVRouterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVRouterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVRouterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVRouterAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVSwitchAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var enableIPv6: Bool?

    public var ipv6CidrBlock: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public var vpcIpv6CidrBlock: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableIPv6 != nil {
            map["EnableIPv6"] = self.enableIPv6!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vpcIpv6CidrBlock != nil {
            map["VpcIpv6CidrBlock"] = self.vpcIpv6CidrBlock!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableIPv6"] as? Bool {
            self.enableIPv6 = value
        }
        if let value = dict["Ipv6CidrBlock"] as? Int32 {
            self.ipv6CidrBlock = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VSwitchName"] as? String {
            self.vSwitchName = value
        }
        if let value = dict["VpcIpv6CidrBlock"] as? String {
            self.vpcIpv6CidrBlock = value
        }
    }
}

public class ModifyVSwitchAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVSwitchAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVSwitchAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVSwitchAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVSwitchCidrReservationAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchCidrReservationDescription: String?

    public var vSwitchCidrReservationId: String?

    public var vSwitchCidrReservationName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchCidrReservationDescription != nil {
            map["VSwitchCidrReservationDescription"] = self.vSwitchCidrReservationDescription!
        }
        if self.vSwitchCidrReservationId != nil {
            map["VSwitchCidrReservationId"] = self.vSwitchCidrReservationId!
        }
        if self.vSwitchCidrReservationName != nil {
            map["VSwitchCidrReservationName"] = self.vSwitchCidrReservationName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchCidrReservationDescription"] as? String {
            self.vSwitchCidrReservationDescription = value
        }
        if let value = dict["VSwitchCidrReservationId"] as? String {
            self.vSwitchCidrReservationId = value
        }
        if let value = dict["VSwitchCidrReservationName"] as? String {
            self.vSwitchCidrReservationName = value
        }
    }
}

public class ModifyVSwitchCidrReservationAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVSwitchCidrReservationAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVSwitchCidrReservationAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVSwitchCidrReservationAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVcoRouteEntryWeightRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newWeight: Int32?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnConnectionId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newWeight != nil {
            map["NewWeight"] = self.newWeight!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NewWeight"] as? Int32 {
            self.newWeight = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class ModifyVcoRouteEntryWeightResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVcoRouteEntryWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVcoRouteEntryWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVcoRouteEntryWeightResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVirtualBorderRouterAttributeRequest : Tea.TeaModel {
    public var associatedPhysicalConnections: String?

    public var bandwidth: Int32?

    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var detectMultiplier: Int64?

    public var enableIpv6: Bool?

    public var localGatewayIp: String?

    public var localIpv6GatewayIp: String?

    public var minRxInterval: Int64?

    public var minTxInterval: Int64?

    public var mtu: Int32?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peerIpv6GatewayIp: String?

    public var peeringIpv6SubnetMask: String?

    public var peeringSubnetMask: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sitelinkEnable: Bool?

    public var vbrId: String?

    public var vlanId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associatedPhysicalConnections != nil {
            map["AssociatedPhysicalConnections"] = self.associatedPhysicalConnections!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.detectMultiplier != nil {
            map["DetectMultiplier"] = self.detectMultiplier!
        }
        if self.enableIpv6 != nil {
            map["EnableIpv6"] = self.enableIpv6!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.localIpv6GatewayIp != nil {
            map["LocalIpv6GatewayIp"] = self.localIpv6GatewayIp!
        }
        if self.minRxInterval != nil {
            map["MinRxInterval"] = self.minRxInterval!
        }
        if self.minTxInterval != nil {
            map["MinTxInterval"] = self.minTxInterval!
        }
        if self.mtu != nil {
            map["Mtu"] = self.mtu!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peerIpv6GatewayIp != nil {
            map["PeerIpv6GatewayIp"] = self.peerIpv6GatewayIp!
        }
        if self.peeringIpv6SubnetMask != nil {
            map["PeeringIpv6SubnetMask"] = self.peeringIpv6SubnetMask!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sitelinkEnable != nil {
            map["SitelinkEnable"] = self.sitelinkEnable!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AssociatedPhysicalConnections"] as? String {
            self.associatedPhysicalConnections = value
        }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["CircuitCode"] as? String {
            self.circuitCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DetectMultiplier"] as? Int64 {
            self.detectMultiplier = value
        }
        if let value = dict["EnableIpv6"] as? Bool {
            self.enableIpv6 = value
        }
        if let value = dict["LocalGatewayIp"] as? String {
            self.localGatewayIp = value
        }
        if let value = dict["LocalIpv6GatewayIp"] as? String {
            self.localIpv6GatewayIp = value
        }
        if let value = dict["MinRxInterval"] as? Int64 {
            self.minRxInterval = value
        }
        if let value = dict["MinTxInterval"] as? Int64 {
            self.minTxInterval = value
        }
        if let value = dict["Mtu"] as? Int32 {
            self.mtu = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerGatewayIp"] as? String {
            self.peerGatewayIp = value
        }
        if let value = dict["PeerIpv6GatewayIp"] as? String {
            self.peerIpv6GatewayIp = value
        }
        if let value = dict["PeeringIpv6SubnetMask"] as? String {
            self.peeringIpv6SubnetMask = value
        }
        if let value = dict["PeeringSubnetMask"] as? String {
            self.peeringSubnetMask = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SitelinkEnable"] as? Bool {
            self.sitelinkEnable = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
        if let value = dict["VlanId"] as? Int32 {
            self.vlanId = value
        }
    }
}

public class ModifyVirtualBorderRouterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVirtualBorderRouterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVirtualBorderRouterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVirtualBorderRouterAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpcAttributeRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var enableDnsHostname: Bool?

    public var enableIPv6: Bool?

    public var ipv6CidrBlock: String?

    public var ipv6Isp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableDnsHostname != nil {
            map["EnableDnsHostname"] = self.enableDnsHostname!
        }
        if self.enableIPv6 != nil {
            map["EnableIPv6"] = self.enableIPv6!
        }
        if self.ipv6CidrBlock != nil {
            map["Ipv6CidrBlock"] = self.ipv6CidrBlock!
        }
        if self.ipv6Isp != nil {
            map["Ipv6Isp"] = self.ipv6Isp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableDnsHostname"] as? Bool {
            self.enableDnsHostname = value
        }
        if let value = dict["EnableIPv6"] as? Bool {
            self.enableIPv6 = value
        }
        if let value = dict["Ipv6CidrBlock"] as? String {
            self.ipv6CidrBlock = value
        }
        if let value = dict["Ipv6Isp"] as? String {
            self.ipv6Isp = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpcName"] as? String {
            self.vpcName = value
        }
    }
}

public class ModifyVpcAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVpcAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpcAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpcAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpcPrefixListRequest : Tea.TeaModel {
    public class AddPrefixListEntry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cidr"] as? String {
                self.cidr = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
        }
    }
    public class RemovePrefixListEntry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cidr"] as? String {
                self.cidr = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
        }
    }
    public var addPrefixListEntry: [ModifyVpcPrefixListRequest.AddPrefixListEntry]?

    public var clientToken: String?

    public var dryRun: Bool?

    public var maxEntries: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListDescription: String?

    public var prefixListId: String?

    public var prefixListName: String?

    public var regionId: String?

    public var removePrefixListEntry: [ModifyVpcPrefixListRequest.RemovePrefixListEntry]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addPrefixListEntry != nil {
            var tmp : [Any] = []
            for k in self.addPrefixListEntry! {
                tmp.append(k.toMap())
            }
            map["AddPrefixListEntry"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.maxEntries != nil {
            map["MaxEntries"] = self.maxEntries!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListDescription != nil {
            map["PrefixListDescription"] = self.prefixListDescription!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removePrefixListEntry != nil {
            var tmp : [Any] = []
            for k in self.removePrefixListEntry! {
                tmp.append(k.toMap())
            }
            map["RemovePrefixListEntry"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddPrefixListEntry"] as? [Any?] {
            var tmp : [ModifyVpcPrefixListRequest.AddPrefixListEntry] = []
            for v in value {
                if v != nil {
                    var model = ModifyVpcPrefixListRequest.AddPrefixListEntry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addPrefixListEntry = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["MaxEntries"] as? Int32 {
            self.maxEntries = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListDescription"] as? String {
            self.prefixListDescription = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["PrefixListName"] as? String {
            self.prefixListName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemovePrefixListEntry"] as? [Any?] {
            var tmp : [ModifyVpcPrefixListRequest.RemovePrefixListEntry] = []
            for v in value {
                if v != nil {
                    var model = ModifyVpcPrefixListRequest.RemovePrefixListEntry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.removePrefixListEntry = tmp
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyVpcPrefixListResponseBody : Tea.TeaModel {
    public var prefixListId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVpcPrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpcPrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpcPrefixListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpnAttachmentAttributeRequest : Tea.TeaModel {
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalAsn"] as? Int64 {
                    self.localAsn = value
                }
                if let value = dict["LocalBgpIp"] as? String {
                    self.localBgpIp = value
                }
                if let value = dict["TunnelCidr"] as? String {
                    self.tunnelCidr = value
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IkeAuthAlg"] as? String {
                    self.ikeAuthAlg = value
                }
                if let value = dict["IkeEncAlg"] as? String {
                    self.ikeEncAlg = value
                }
                if let value = dict["IkeLifetime"] as? Int64 {
                    self.ikeLifetime = value
                }
                if let value = dict["IkeMode"] as? String {
                    self.ikeMode = value
                }
                if let value = dict["IkePfs"] as? String {
                    self.ikePfs = value
                }
                if let value = dict["IkeVersion"] as? String {
                    self.ikeVersion = value
                }
                if let value = dict["LocalId"] as? String {
                    self.localId = value
                }
                if let value = dict["Psk"] as? String {
                    self.psk = value
                }
                if let value = dict["RemoteId"] as? String {
                    self.remoteId = value
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int32?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpsecAuthAlg"] as? String {
                    self.ipsecAuthAlg = value
                }
                if let value = dict["IpsecEncAlg"] as? String {
                    self.ipsecEncAlg = value
                }
                if let value = dict["IpsecLifetime"] as? Int32 {
                    self.ipsecLifetime = value
                }
                if let value = dict["IpsecPfs"] as? String {
                    self.ipsecPfs = value
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var tunnelBgpConfig: ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelId: String?

        public var tunnelIkeConfig: ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIndex: Int32?

        public var tunnelIpsecConfig: ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelId != nil {
                map["TunnelId"] = self.tunnelId!
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIndex != nil {
                map["TunnelIndex"] = self.tunnelIndex!
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CustomerGatewayId"] as? String {
                self.customerGatewayId = value
            }
            if let value = dict["EnableDpd"] as? Bool {
                self.enableDpd = value
            }
            if let value = dict["EnableNatTraversal"] as? Bool {
                self.enableNatTraversal = value
            }
            if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
                var model = ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(value)
                self.tunnelBgpConfig = model
            }
            if let value = dict["TunnelId"] as? String {
                self.tunnelId = value
            }
            if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
                var model = ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(value)
                self.tunnelIkeConfig = model
            }
            if let value = dict["TunnelIndex"] as? Int32 {
                self.tunnelIndex = value
            }
            if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
                var model = ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(value)
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var autoConfigRoute: Bool?

    public var bgpConfig: String?

    public var clientToken: String?

    public var customerGatewayId: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var healthCheckConfig: String?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var name: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var remoteCaCert: String?

    public var remoteSubnet: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tunnelOptionsSpecification: [ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification]?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoConfigRoute != nil {
            map["AutoConfigRoute"] = self.autoConfigRoute!
        }
        if self.bgpConfig != nil {
            map["BgpConfig"] = self.bgpConfig!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.healthCheckConfig != nil {
            map["HealthCheckConfig"] = self.healthCheckConfig!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCaCert != nil {
            map["RemoteCaCert"] = self.remoteCaCert!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoConfigRoute"] as? Bool {
            self.autoConfigRoute = value
        }
        if let value = dict["BgpConfig"] as? String {
            self.bgpConfig = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["EffectImmediately"] as? Bool {
            self.effectImmediately = value
        }
        if let value = dict["EnableDpd"] as? Bool {
            self.enableDpd = value
        }
        if let value = dict["EnableNatTraversal"] as? Bool {
            self.enableNatTraversal = value
        }
        if let value = dict["EnableTunnelsBgp"] as? Bool {
            self.enableTunnelsBgp = value
        }
        if let value = dict["HealthCheckConfig"] as? String {
            self.healthCheckConfig = value
        }
        if let value = dict["IkeConfig"] as? String {
            self.ikeConfig = value
        }
        if let value = dict["IpsecConfig"] as? String {
            self.ipsecConfig = value
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoteCaCert"] as? String {
            self.remoteCaCert = value
        }
        if let value = dict["RemoteSubnet"] as? String {
            self.remoteSubnet = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TunnelOptionsSpecification"] as? [Any?] {
            var tmp : [ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification] = []
            for v in value {
                if v != nil {
                    var model = ModifyVpnAttachmentAttributeRequest.TunnelOptionsSpecification()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tunnelOptionsSpecification = tmp
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class ModifyVpnAttachmentAttributeResponseBody : Tea.TeaModel {
    public class IkeConfig : Tea.TeaModel {
        public var ikeAuthAlg: String?

        public var ikeEncAlg: String?

        public var ikeLifetime: Int64?

        public var ikeMode: String?

        public var ikePfs: String?

        public var ikeVersion: String?

        public var localId: String?

        public var psk: String?

        public var remoteId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ikeAuthAlg != nil {
                map["IkeAuthAlg"] = self.ikeAuthAlg!
            }
            if self.ikeEncAlg != nil {
                map["IkeEncAlg"] = self.ikeEncAlg!
            }
            if self.ikeLifetime != nil {
                map["IkeLifetime"] = self.ikeLifetime!
            }
            if self.ikeMode != nil {
                map["IkeMode"] = self.ikeMode!
            }
            if self.ikePfs != nil {
                map["IkePfs"] = self.ikePfs!
            }
            if self.ikeVersion != nil {
                map["IkeVersion"] = self.ikeVersion!
            }
            if self.localId != nil {
                map["LocalId"] = self.localId!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.remoteId != nil {
                map["RemoteId"] = self.remoteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IkeAuthAlg"] as? String {
                self.ikeAuthAlg = value
            }
            if let value = dict["IkeEncAlg"] as? String {
                self.ikeEncAlg = value
            }
            if let value = dict["IkeLifetime"] as? Int64 {
                self.ikeLifetime = value
            }
            if let value = dict["IkeMode"] as? String {
                self.ikeMode = value
            }
            if let value = dict["IkePfs"] as? String {
                self.ikePfs = value
            }
            if let value = dict["IkeVersion"] as? String {
                self.ikeVersion = value
            }
            if let value = dict["LocalId"] as? String {
                self.localId = value
            }
            if let value = dict["Psk"] as? String {
                self.psk = value
            }
            if let value = dict["RemoteId"] as? String {
                self.remoteId = value
            }
        }
    }
    public class IpsecConfig : Tea.TeaModel {
        public var ipsecAuthAlg: String?

        public var ipsecEncAlg: String?

        public var ipsecLifetime: Int64?

        public var ipsecPfs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipsecAuthAlg != nil {
                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
            }
            if self.ipsecEncAlg != nil {
                map["IpsecEncAlg"] = self.ipsecEncAlg!
            }
            if self.ipsecLifetime != nil {
                map["IpsecLifetime"] = self.ipsecLifetime!
            }
            if self.ipsecPfs != nil {
                map["IpsecPfs"] = self.ipsecPfs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IpsecAuthAlg"] as? String {
                self.ipsecAuthAlg = value
            }
            if let value = dict["IpsecEncAlg"] as? String {
                self.ipsecEncAlg = value
            }
            if let value = dict["IpsecLifetime"] as? Int64 {
                self.ipsecLifetime = value
            }
            if let value = dict["IpsecPfs"] as? String {
                self.ipsecPfs = value
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var peerAsn: Int64?

            public var peerBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.peerAsn != nil {
                    map["PeerAsn"] = self.peerAsn!
                }
                if self.peerBgpIp != nil {
                    map["PeerBgpIp"] = self.peerBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalAsn"] as? Int64 {
                    self.localAsn = value
                }
                if let value = dict["LocalBgpIp"] as? String {
                    self.localBgpIp = value
                }
                if let value = dict["PeerAsn"] as? Int64 {
                    self.peerAsn = value
                }
                if let value = dict["PeerBgpIp"] as? String {
                    self.peerBgpIp = value
                }
                if let value = dict["TunnelCidr"] as? String {
                    self.tunnelCidr = value
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IkeAuthAlg"] as? String {
                    self.ikeAuthAlg = value
                }
                if let value = dict["IkeEncAlg"] as? String {
                    self.ikeEncAlg = value
                }
                if let value = dict["IkeLifetime"] as? Int64 {
                    self.ikeLifetime = value
                }
                if let value = dict["IkeMode"] as? String {
                    self.ikeMode = value
                }
                if let value = dict["IkePfs"] as? String {
                    self.ikePfs = value
                }
                if let value = dict["IkeVersion"] as? String {
                    self.ikeVersion = value
                }
                if let value = dict["LocalId"] as? String {
                    self.localId = value
                }
                if let value = dict["Psk"] as? String {
                    self.psk = value
                }
                if let value = dict["RemoteId"] as? String {
                    self.remoteId = value
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int64?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpsecAuthAlg"] as? String {
                    self.ipsecAuthAlg = value
                }
                if let value = dict["IpsecEncAlg"] as? String {
                    self.ipsecEncAlg = value
                }
                if let value = dict["IpsecLifetime"] as? Int64 {
                    self.ipsecLifetime = value
                }
                if let value = dict["IpsecPfs"] as? String {
                    self.ipsecPfs = value
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var internetIp: String?

        public var role: String?

        public var state: String?

        public var tunnelBgpConfig: ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelId: String?

        public var tunnelIkeConfig: ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIndex: Int32?

        public var tunnelIpsecConfig: ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelId != nil {
                map["TunnelId"] = self.tunnelId!
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIndex != nil {
                map["TunnelIndex"] = self.tunnelIndex!
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CustomerGatewayId"] as? String {
                self.customerGatewayId = value
            }
            if let value = dict["EnableDpd"] as? Bool {
                self.enableDpd = value
            }
            if let value = dict["EnableNatTraversal"] as? Bool {
                self.enableNatTraversal = value
            }
            if let value = dict["InternetIp"] as? String {
                self.internetIp = value
            }
            if let value = dict["Role"] as? String {
                self.role = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
                var model = ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(value)
                self.tunnelBgpConfig = model
            }
            if let value = dict["TunnelId"] as? String {
                self.tunnelId = value
            }
            if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
                var model = ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(value)
                self.tunnelIkeConfig = model
            }
            if let value = dict["TunnelIndex"] as? Int32 {
                self.tunnelIndex = value
            }
            if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
                var model = ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(value)
                self.tunnelIpsecConfig = model
            }
        }
    }
    public class VcoHealthCheck : Tea.TeaModel {
        public var dip: String?

        public var enable: String?

        public var interval: Int32?

        public var policy: String?

        public var retry: Int32?

        public var sip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dip != nil {
                map["Dip"] = self.dip!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.retry != nil {
                map["Retry"] = self.retry!
            }
            if self.sip != nil {
                map["Sip"] = self.sip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Dip"] as? String {
                self.dip = value
            }
            if let value = dict["Enable"] as? String {
                self.enable = value
            }
            if let value = dict["Interval"] as? Int32 {
                self.interval = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["Retry"] as? Int32 {
                self.retry = value
            }
            if let value = dict["Sip"] as? String {
                self.sip = value
            }
        }
    }
    public class VpnBgpConfig : Tea.TeaModel {
        public var enableBgp: String?

        public var localAsn: Int64?

        public var localBgpIp: String?

        public var peerAsn: Int64?

        public var peerBgpIp: String?

        public var status: String?

        public var tunnelCidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableBgp != nil {
                map["EnableBgp"] = self.enableBgp!
            }
            if self.localAsn != nil {
                map["LocalAsn"] = self.localAsn!
            }
            if self.localBgpIp != nil {
                map["LocalBgpIp"] = self.localBgpIp!
            }
            if self.peerAsn != nil {
                map["PeerAsn"] = self.peerAsn!
            }
            if self.peerBgpIp != nil {
                map["PeerBgpIp"] = self.peerBgpIp!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tunnelCidr != nil {
                map["TunnelCidr"] = self.tunnelCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableBgp"] as? String {
                self.enableBgp = value
            }
            if let value = dict["LocalAsn"] as? Int64 {
                self.localAsn = value
            }
            if let value = dict["LocalBgpIp"] as? String {
                self.localBgpIp = value
            }
            if let value = dict["PeerAsn"] as? Int64 {
                self.peerAsn = value
            }
            if let value = dict["PeerBgpIp"] as? String {
                self.peerBgpIp = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TunnelCidr"] as? String {
                self.tunnelCidr = value
            }
        }
    }
    public var attachInstanceId: String?

    public var attachType: String?

    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var ikeConfig: ModifyVpnAttachmentAttributeResponseBody.IkeConfig?

    public var ipsecConfig: ModifyVpnAttachmentAttributeResponseBody.IpsecConfig?

    public var localSubnet: String?

    public var name: String?

    public var networkType: String?

    public var remoteSubnet: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var spec: String?

    public var status: String?

    public var tunnelOptionsSpecification: [ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification]?

    public var vcoHealthCheck: ModifyVpnAttachmentAttributeResponseBody.VcoHealthCheck?

    public var vpnBgpConfig: ModifyVpnAttachmentAttributeResponseBody.VpnBgpConfig?

    public var vpnConnectionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ikeConfig?.validate()
        try self.ipsecConfig?.validate()
        try self.vcoHealthCheck?.validate()
        try self.vpnBgpConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachInstanceId != nil {
            map["AttachInstanceId"] = self.attachInstanceId!
        }
        if self.attachType != nil {
            map["AttachType"] = self.attachType!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig?.toMap()
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig?.toMap()
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        if self.vcoHealthCheck != nil {
            map["VcoHealthCheck"] = self.vcoHealthCheck?.toMap()
        }
        if self.vpnBgpConfig != nil {
            map["VpnBgpConfig"] = self.vpnBgpConfig?.toMap()
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttachInstanceId"] as? String {
            self.attachInstanceId = value
        }
        if let value = dict["AttachType"] as? String {
            self.attachType = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EffectImmediately"] as? Bool {
            self.effectImmediately = value
        }
        if let value = dict["EnableDpd"] as? Bool {
            self.enableDpd = value
        }
        if let value = dict["EnableNatTraversal"] as? Bool {
            self.enableNatTraversal = value
        }
        if let value = dict["EnableTunnelsBgp"] as? Bool {
            self.enableTunnelsBgp = value
        }
        if let value = dict["IkeConfig"] as? [String: Any?] {
            var model = ModifyVpnAttachmentAttributeResponseBody.IkeConfig()
            model.fromMap(value)
            self.ikeConfig = model
        }
        if let value = dict["IpsecConfig"] as? [String: Any?] {
            var model = ModifyVpnAttachmentAttributeResponseBody.IpsecConfig()
            model.fromMap(value)
            self.ipsecConfig = model
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["RemoteSubnet"] as? String {
            self.remoteSubnet = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TunnelOptionsSpecification"] as? [Any?] {
            var tmp : [ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification] = []
            for v in value {
                if v != nil {
                    var model = ModifyVpnAttachmentAttributeResponseBody.TunnelOptionsSpecification()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tunnelOptionsSpecification = tmp
        }
        if let value = dict["VcoHealthCheck"] as? [String: Any?] {
            var model = ModifyVpnAttachmentAttributeResponseBody.VcoHealthCheck()
            model.fromMap(value)
            self.vcoHealthCheck = model
        }
        if let value = dict["VpnBgpConfig"] as? [String: Any?] {
            var model = ModifyVpnAttachmentAttributeResponseBody.VpnBgpConfig()
            model.fromMap(value)
            self.vpnBgpConfig = model
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class ModifyVpnAttachmentAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnAttachmentAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpnAttachmentAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpnConnectionAttributeRequest : Tea.TeaModel {
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelBgpConfig : Tea.TeaModel {
            public var localAsn: Int64?

            public var localBgpIp: String?

            public var tunnelCidr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localAsn != nil {
                    map["LocalAsn"] = self.localAsn!
                }
                if self.localBgpIp != nil {
                    map["LocalBgpIp"] = self.localBgpIp!
                }
                if self.tunnelCidr != nil {
                    map["TunnelCidr"] = self.tunnelCidr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalAsn"] as? Int64 {
                    self.localAsn = value
                }
                if let value = dict["LocalBgpIp"] as? String {
                    self.localBgpIp = value
                }
                if let value = dict["TunnelCidr"] as? String {
                    self.tunnelCidr = value
                }
            }
        }
        public class TunnelIkeConfig : Tea.TeaModel {
            public var ikeAuthAlg: String?

            public var ikeEncAlg: String?

            public var ikeLifetime: Int64?

            public var ikeMode: String?

            public var ikePfs: String?

            public var ikeVersion: String?

            public var localId: String?

            public var psk: String?

            public var remoteId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ikeAuthAlg != nil {
                    map["IkeAuthAlg"] = self.ikeAuthAlg!
                }
                if self.ikeEncAlg != nil {
                    map["IkeEncAlg"] = self.ikeEncAlg!
                }
                if self.ikeLifetime != nil {
                    map["IkeLifetime"] = self.ikeLifetime!
                }
                if self.ikeMode != nil {
                    map["IkeMode"] = self.ikeMode!
                }
                if self.ikePfs != nil {
                    map["IkePfs"] = self.ikePfs!
                }
                if self.ikeVersion != nil {
                    map["IkeVersion"] = self.ikeVersion!
                }
                if self.localId != nil {
                    map["LocalId"] = self.localId!
                }
                if self.psk != nil {
                    map["Psk"] = self.psk!
                }
                if self.remoteId != nil {
                    map["RemoteId"] = self.remoteId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IkeAuthAlg"] as? String {
                    self.ikeAuthAlg = value
                }
                if let value = dict["IkeEncAlg"] as? String {
                    self.ikeEncAlg = value
                }
                if let value = dict["IkeLifetime"] as? Int64 {
                    self.ikeLifetime = value
                }
                if let value = dict["IkeMode"] as? String {
                    self.ikeMode = value
                }
                if let value = dict["IkePfs"] as? String {
                    self.ikePfs = value
                }
                if let value = dict["IkeVersion"] as? String {
                    self.ikeVersion = value
                }
                if let value = dict["LocalId"] as? String {
                    self.localId = value
                }
                if let value = dict["Psk"] as? String {
                    self.psk = value
                }
                if let value = dict["RemoteId"] as? String {
                    self.remoteId = value
                }
            }
        }
        public class TunnelIpsecConfig : Tea.TeaModel {
            public var ipsecAuthAlg: String?

            public var ipsecEncAlg: String?

            public var ipsecLifetime: Int32?

            public var ipsecPfs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipsecAuthAlg != nil {
                    map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                }
                if self.ipsecEncAlg != nil {
                    map["IpsecEncAlg"] = self.ipsecEncAlg!
                }
                if self.ipsecLifetime != nil {
                    map["IpsecLifetime"] = self.ipsecLifetime!
                }
                if self.ipsecPfs != nil {
                    map["IpsecPfs"] = self.ipsecPfs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpsecAuthAlg"] as? String {
                    self.ipsecAuthAlg = value
                }
                if let value = dict["IpsecEncAlg"] as? String {
                    self.ipsecEncAlg = value
                }
                if let value = dict["IpsecLifetime"] as? Int32 {
                    self.ipsecLifetime = value
                }
                if let value = dict["IpsecPfs"] as? String {
                    self.ipsecPfs = value
                }
            }
        }
        public var customerGatewayId: String?

        public var enableDpd: Bool?

        public var enableNatTraversal: Bool?

        public var remoteCaCertificate: String?

        public var role: String?

        public var tunnelBgpConfig: ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig?

        public var tunnelId: String?

        public var tunnelIkeConfig: ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig?

        public var tunnelIpsecConfig: ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tunnelBgpConfig?.validate()
            try self.tunnelIkeConfig?.validate()
            try self.tunnelIpsecConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerGatewayId != nil {
                map["CustomerGatewayId"] = self.customerGatewayId!
            }
            if self.enableDpd != nil {
                map["EnableDpd"] = self.enableDpd!
            }
            if self.enableNatTraversal != nil {
                map["EnableNatTraversal"] = self.enableNatTraversal!
            }
            if self.remoteCaCertificate != nil {
                map["RemoteCaCertificate"] = self.remoteCaCertificate!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.tunnelBgpConfig != nil {
                map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
            }
            if self.tunnelId != nil {
                map["TunnelId"] = self.tunnelId!
            }
            if self.tunnelIkeConfig != nil {
                map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
            }
            if self.tunnelIpsecConfig != nil {
                map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CustomerGatewayId"] as? String {
                self.customerGatewayId = value
            }
            if let value = dict["EnableDpd"] as? Bool {
                self.enableDpd = value
            }
            if let value = dict["EnableNatTraversal"] as? Bool {
                self.enableNatTraversal = value
            }
            if let value = dict["RemoteCaCertificate"] as? String {
                self.remoteCaCertificate = value
            }
            if let value = dict["Role"] as? String {
                self.role = value
            }
            if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
                var model = ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelBgpConfig()
                model.fromMap(value)
                self.tunnelBgpConfig = model
            }
            if let value = dict["TunnelId"] as? String {
                self.tunnelId = value
            }
            if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
                var model = ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelIkeConfig()
                model.fromMap(value)
                self.tunnelIkeConfig = model
            }
            if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
                var model = ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification.TunnelIpsecConfig()
                model.fromMap(value)
                self.tunnelIpsecConfig = model
            }
        }
    }
    public var autoConfigRoute: Bool?

    public var bgpConfig: String?

    public var clientToken: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var healthCheckConfig: String?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var localSubnet: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var remoteCaCertificate: String?

    public var remoteSubnet: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tunnelOptionsSpecification: [ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification]?

    public var vpnConnectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoConfigRoute != nil {
            map["AutoConfigRoute"] = self.autoConfigRoute!
        }
        if self.bgpConfig != nil {
            map["BgpConfig"] = self.bgpConfig!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.healthCheckConfig != nil {
            map["HealthCheckConfig"] = self.healthCheckConfig!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remoteCaCertificate != nil {
            map["RemoteCaCertificate"] = self.remoteCaCertificate!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tunnelOptionsSpecification != nil {
            var tmp : [Any] = []
            for k in self.tunnelOptionsSpecification! {
                tmp.append(k.toMap())
            }
            map["TunnelOptionsSpecification"] = tmp
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoConfigRoute"] as? Bool {
            self.autoConfigRoute = value
        }
        if let value = dict["BgpConfig"] as? String {
            self.bgpConfig = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EffectImmediately"] as? Bool {
            self.effectImmediately = value
        }
        if let value = dict["EnableDpd"] as? Bool {
            self.enableDpd = value
        }
        if let value = dict["EnableNatTraversal"] as? Bool {
            self.enableNatTraversal = value
        }
        if let value = dict["EnableTunnelsBgp"] as? Bool {
            self.enableTunnelsBgp = value
        }
        if let value = dict["HealthCheckConfig"] as? String {
            self.healthCheckConfig = value
        }
        if let value = dict["IkeConfig"] as? String {
            self.ikeConfig = value
        }
        if let value = dict["IpsecConfig"] as? String {
            self.ipsecConfig = value
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoteCaCertificate"] as? String {
            self.remoteCaCertificate = value
        }
        if let value = dict["RemoteSubnet"] as? String {
            self.remoteSubnet = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TunnelOptionsSpecification"] as? [Any?] {
            var tmp : [ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification] = []
            for v in value {
                if v != nil {
                    var model = ModifyVpnConnectionAttributeRequest.TunnelOptionsSpecification()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tunnelOptionsSpecification = tmp
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
    }
}

public class ModifyVpnConnectionAttributeResponseBody : Tea.TeaModel {
    public class IkeConfig : Tea.TeaModel {
        public var ikeAuthAlg: String?

        public var ikeEncAlg: String?

        public var ikeLifetime: Int64?

        public var ikeMode: String?

        public var ikePfs: String?

        public var ikeVersion: String?

        public var localId: String?

        public var psk: String?

        public var remoteId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ikeAuthAlg != nil {
                map["IkeAuthAlg"] = self.ikeAuthAlg!
            }
            if self.ikeEncAlg != nil {
                map["IkeEncAlg"] = self.ikeEncAlg!
            }
            if self.ikeLifetime != nil {
                map["IkeLifetime"] = self.ikeLifetime!
            }
            if self.ikeMode != nil {
                map["IkeMode"] = self.ikeMode!
            }
            if self.ikePfs != nil {
                map["IkePfs"] = self.ikePfs!
            }
            if self.ikeVersion != nil {
                map["IkeVersion"] = self.ikeVersion!
            }
            if self.localId != nil {
                map["LocalId"] = self.localId!
            }
            if self.psk != nil {
                map["Psk"] = self.psk!
            }
            if self.remoteId != nil {
                map["RemoteId"] = self.remoteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IkeAuthAlg"] as? String {
                self.ikeAuthAlg = value
            }
            if let value = dict["IkeEncAlg"] as? String {
                self.ikeEncAlg = value
            }
            if let value = dict["IkeLifetime"] as? Int64 {
                self.ikeLifetime = value
            }
            if let value = dict["IkeMode"] as? String {
                self.ikeMode = value
            }
            if let value = dict["IkePfs"] as? String {
                self.ikePfs = value
            }
            if let value = dict["IkeVersion"] as? String {
                self.ikeVersion = value
            }
            if let value = dict["LocalId"] as? String {
                self.localId = value
            }
            if let value = dict["Psk"] as? String {
                self.psk = value
            }
            if let value = dict["RemoteId"] as? String {
                self.remoteId = value
            }
        }
    }
    public class IpsecConfig : Tea.TeaModel {
        public var ipsecAuthAlg: String?

        public var ipsecEncAlg: String?

        public var ipsecLifetime: Int64?

        public var ipsecPfs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipsecAuthAlg != nil {
                map["IpsecAuthAlg"] = self.ipsecAuthAlg!
            }
            if self.ipsecEncAlg != nil {
                map["IpsecEncAlg"] = self.ipsecEncAlg!
            }
            if self.ipsecLifetime != nil {
                map["IpsecLifetime"] = self.ipsecLifetime!
            }
            if self.ipsecPfs != nil {
                map["IpsecPfs"] = self.ipsecPfs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IpsecAuthAlg"] as? String {
                self.ipsecAuthAlg = value
            }
            if let value = dict["IpsecEncAlg"] as? String {
                self.ipsecEncAlg = value
            }
            if let value = dict["IpsecLifetime"] as? Int64 {
                self.ipsecLifetime = value
            }
            if let value = dict["IpsecPfs"] as? String {
                self.ipsecPfs = value
            }
        }
    }
    public class TunnelOptionsSpecification : Tea.TeaModel {
        public class TunnelOptions : Tea.TeaModel {
            public class TunnelBgpConfig : Tea.TeaModel {
                public var localAsn: Int64?

                public var localBgpIp: String?

                public var peerAsn: Int64?

                public var peerBgpIp: String?

                public var tunnelCidr: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.localAsn != nil {
                        map["LocalAsn"] = self.localAsn!
                    }
                    if self.localBgpIp != nil {
                        map["LocalBgpIp"] = self.localBgpIp!
                    }
                    if self.peerAsn != nil {
                        map["PeerAsn"] = self.peerAsn!
                    }
                    if self.peerBgpIp != nil {
                        map["PeerBgpIp"] = self.peerBgpIp!
                    }
                    if self.tunnelCidr != nil {
                        map["TunnelCidr"] = self.tunnelCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LocalAsn"] as? Int64 {
                        self.localAsn = value
                    }
                    if let value = dict["LocalBgpIp"] as? String {
                        self.localBgpIp = value
                    }
                    if let value = dict["PeerAsn"] as? Int64 {
                        self.peerAsn = value
                    }
                    if let value = dict["PeerBgpIp"] as? String {
                        self.peerBgpIp = value
                    }
                    if let value = dict["TunnelCidr"] as? String {
                        self.tunnelCidr = value
                    }
                }
            }
            public class TunnelIkeConfig : Tea.TeaModel {
                public var ikeAuthAlg: String?

                public var ikeEncAlg: String?

                public var ikeLifetime: Int64?

                public var ikeMode: String?

                public var ikePfs: String?

                public var ikeVersion: String?

                public var localId: String?

                public var psk: String?

                public var remoteId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ikeAuthAlg != nil {
                        map["IkeAuthAlg"] = self.ikeAuthAlg!
                    }
                    if self.ikeEncAlg != nil {
                        map["IkeEncAlg"] = self.ikeEncAlg!
                    }
                    if self.ikeLifetime != nil {
                        map["IkeLifetime"] = self.ikeLifetime!
                    }
                    if self.ikeMode != nil {
                        map["IkeMode"] = self.ikeMode!
                    }
                    if self.ikePfs != nil {
                        map["IkePfs"] = self.ikePfs!
                    }
                    if self.ikeVersion != nil {
                        map["IkeVersion"] = self.ikeVersion!
                    }
                    if self.localId != nil {
                        map["LocalId"] = self.localId!
                    }
                    if self.psk != nil {
                        map["Psk"] = self.psk!
                    }
                    if self.remoteId != nil {
                        map["RemoteId"] = self.remoteId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IkeAuthAlg"] as? String {
                        self.ikeAuthAlg = value
                    }
                    if let value = dict["IkeEncAlg"] as? String {
                        self.ikeEncAlg = value
                    }
                    if let value = dict["IkeLifetime"] as? Int64 {
                        self.ikeLifetime = value
                    }
                    if let value = dict["IkeMode"] as? String {
                        self.ikeMode = value
                    }
                    if let value = dict["IkePfs"] as? String {
                        self.ikePfs = value
                    }
                    if let value = dict["IkeVersion"] as? String {
                        self.ikeVersion = value
                    }
                    if let value = dict["LocalId"] as? String {
                        self.localId = value
                    }
                    if let value = dict["Psk"] as? String {
                        self.psk = value
                    }
                    if let value = dict["RemoteId"] as? String {
                        self.remoteId = value
                    }
                }
            }
            public class TunnelIpsecConfig : Tea.TeaModel {
                public var ipsecAuthAlg: String?

                public var ipsecEncAlg: String?

                public var ipsecLifetime: Int64?

                public var ipsecPfs: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipsecAuthAlg != nil {
                        map["IpsecAuthAlg"] = self.ipsecAuthAlg!
                    }
                    if self.ipsecEncAlg != nil {
                        map["IpsecEncAlg"] = self.ipsecEncAlg!
                    }
                    if self.ipsecLifetime != nil {
                        map["IpsecLifetime"] = self.ipsecLifetime!
                    }
                    if self.ipsecPfs != nil {
                        map["IpsecPfs"] = self.ipsecPfs!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IpsecAuthAlg"] as? String {
                        self.ipsecAuthAlg = value
                    }
                    if let value = dict["IpsecEncAlg"] as? String {
                        self.ipsecEncAlg = value
                    }
                    if let value = dict["IpsecLifetime"] as? Int64 {
                        self.ipsecLifetime = value
                    }
                    if let value = dict["IpsecPfs"] as? String {
                        self.ipsecPfs = value
                    }
                }
            }
            public var customerGatewayId: String?

            public var enableDpd: Bool?

            public var enableNatTraversal: Bool?

            public var internetIp: String?

            public var remoteCaCertificate: String?

            public var role: String?

            public var state: String?

            public var tunnelBgpConfig: ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig?

            public var tunnelId: String?

            public var tunnelIkeConfig: ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig?

            public var tunnelIpsecConfig: ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig?

            public var zoneNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tunnelBgpConfig?.validate()
                try self.tunnelIkeConfig?.validate()
                try self.tunnelIpsecConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customerGatewayId != nil {
                    map["CustomerGatewayId"] = self.customerGatewayId!
                }
                if self.enableDpd != nil {
                    map["EnableDpd"] = self.enableDpd!
                }
                if self.enableNatTraversal != nil {
                    map["EnableNatTraversal"] = self.enableNatTraversal!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.remoteCaCertificate != nil {
                    map["RemoteCaCertificate"] = self.remoteCaCertificate!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.tunnelBgpConfig != nil {
                    map["TunnelBgpConfig"] = self.tunnelBgpConfig?.toMap()
                }
                if self.tunnelId != nil {
                    map["TunnelId"] = self.tunnelId!
                }
                if self.tunnelIkeConfig != nil {
                    map["TunnelIkeConfig"] = self.tunnelIkeConfig?.toMap()
                }
                if self.tunnelIpsecConfig != nil {
                    map["TunnelIpsecConfig"] = self.tunnelIpsecConfig?.toMap()
                }
                if self.zoneNo != nil {
                    map["ZoneNo"] = self.zoneNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CustomerGatewayId"] as? String {
                    self.customerGatewayId = value
                }
                if let value = dict["EnableDpd"] as? Bool {
                    self.enableDpd = value
                }
                if let value = dict["EnableNatTraversal"] as? Bool {
                    self.enableNatTraversal = value
                }
                if let value = dict["InternetIp"] as? String {
                    self.internetIp = value
                }
                if let value = dict["RemoteCaCertificate"] as? String {
                    self.remoteCaCertificate = value
                }
                if let value = dict["Role"] as? String {
                    self.role = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["TunnelBgpConfig"] as? [String: Any?] {
                    var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelBgpConfig()
                    model.fromMap(value)
                    self.tunnelBgpConfig = model
                }
                if let value = dict["TunnelId"] as? String {
                    self.tunnelId = value
                }
                if let value = dict["TunnelIkeConfig"] as? [String: Any?] {
                    var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIkeConfig()
                    model.fromMap(value)
                    self.tunnelIkeConfig = model
                }
                if let value = dict["TunnelIpsecConfig"] as? [String: Any?] {
                    var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions.TunnelIpsecConfig()
                    model.fromMap(value)
                    self.tunnelIpsecConfig = model
                }
                if let value = dict["ZoneNo"] as? String {
                    self.zoneNo = value
                }
            }
        }
        public var tunnelOptions: [ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tunnelOptions != nil {
                var tmp : [Any] = []
                for k in self.tunnelOptions! {
                    tmp.append(k.toMap())
                }
                map["TunnelOptions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TunnelOptions"] as? [Any?] {
                var tmp : [ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions] = []
                for v in value {
                    if v != nil {
                        var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification.TunnelOptions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tunnelOptions = tmp
            }
        }
    }
    public class VcoHealthCheck : Tea.TeaModel {
        public var dip: String?

        public var enable: String?

        public var interval: Int32?

        public var retry: Int32?

        public var sip: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dip != nil {
                map["Dip"] = self.dip!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.retry != nil {
                map["Retry"] = self.retry!
            }
            if self.sip != nil {
                map["Sip"] = self.sip!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Dip"] as? String {
                self.dip = value
            }
            if let value = dict["Enable"] as? String {
                self.enable = value
            }
            if let value = dict["Interval"] as? Int32 {
                self.interval = value
            }
            if let value = dict["Retry"] as? Int32 {
                self.retry = value
            }
            if let value = dict["Sip"] as? String {
                self.sip = value
            }
        }
    }
    public class VpnBgpConfig : Tea.TeaModel {
        public var enableBgp: String?

        public var localAsn: Int32?

        public var localBgpIp: String?

        public var peerAsn: Int32?

        public var peerBgpIp: String?

        public var status: String?

        public var tunnelCidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableBgp != nil {
                map["EnableBgp"] = self.enableBgp!
            }
            if self.localAsn != nil {
                map["LocalAsn"] = self.localAsn!
            }
            if self.localBgpIp != nil {
                map["LocalBgpIp"] = self.localBgpIp!
            }
            if self.peerAsn != nil {
                map["PeerAsn"] = self.peerAsn!
            }
            if self.peerBgpIp != nil {
                map["PeerBgpIp"] = self.peerBgpIp!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tunnelCidr != nil {
                map["TunnelCidr"] = self.tunnelCidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableBgp"] as? String {
                self.enableBgp = value
            }
            if let value = dict["LocalAsn"] as? Int32 {
                self.localAsn = value
            }
            if let value = dict["LocalBgpIp"] as? String {
                self.localBgpIp = value
            }
            if let value = dict["PeerAsn"] as? Int32 {
                self.peerAsn = value
            }
            if let value = dict["PeerBgpIp"] as? String {
                self.peerBgpIp = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TunnelCidr"] as? String {
                self.tunnelCidr = value
            }
        }
    }
    public var createTime: Int64?

    public var customerGatewayId: String?

    public var description_: String?

    public var effectImmediately: Bool?

    public var enableDpd: Bool?

    public var enableNatTraversal: Bool?

    public var enableTunnelsBgp: Bool?

    public var ikeConfig: ModifyVpnConnectionAttributeResponseBody.IkeConfig?

    public var ipsecConfig: ModifyVpnConnectionAttributeResponseBody.IpsecConfig?

    public var localSubnet: String?

    public var name: String?

    public var remoteSubnet: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var tunnelOptionsSpecification: ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification?

    public var vcoHealthCheck: ModifyVpnConnectionAttributeResponseBody.VcoHealthCheck?

    public var vpnBgpConfig: ModifyVpnConnectionAttributeResponseBody.VpnBgpConfig?

    public var vpnConnectionId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ikeConfig?.validate()
        try self.ipsecConfig?.validate()
        try self.tunnelOptionsSpecification?.validate()
        try self.vcoHealthCheck?.validate()
        try self.vpnBgpConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.customerGatewayId != nil {
            map["CustomerGatewayId"] = self.customerGatewayId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.enableDpd != nil {
            map["EnableDpd"] = self.enableDpd!
        }
        if self.enableNatTraversal != nil {
            map["EnableNatTraversal"] = self.enableNatTraversal!
        }
        if self.enableTunnelsBgp != nil {
            map["EnableTunnelsBgp"] = self.enableTunnelsBgp!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig?.toMap()
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig?.toMap()
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remoteSubnet != nil {
            map["RemoteSubnet"] = self.remoteSubnet!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tunnelOptionsSpecification != nil {
            map["TunnelOptionsSpecification"] = self.tunnelOptionsSpecification?.toMap()
        }
        if self.vcoHealthCheck != nil {
            map["VcoHealthCheck"] = self.vcoHealthCheck?.toMap()
        }
        if self.vpnBgpConfig != nil {
            map["VpnBgpConfig"] = self.vpnBgpConfig?.toMap()
        }
        if self.vpnConnectionId != nil {
            map["VpnConnectionId"] = self.vpnConnectionId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["CustomerGatewayId"] as? String {
            self.customerGatewayId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EffectImmediately"] as? Bool {
            self.effectImmediately = value
        }
        if let value = dict["EnableDpd"] as? Bool {
            self.enableDpd = value
        }
        if let value = dict["EnableNatTraversal"] as? Bool {
            self.enableNatTraversal = value
        }
        if let value = dict["EnableTunnelsBgp"] as? Bool {
            self.enableTunnelsBgp = value
        }
        if let value = dict["IkeConfig"] as? [String: Any?] {
            var model = ModifyVpnConnectionAttributeResponseBody.IkeConfig()
            model.fromMap(value)
            self.ikeConfig = model
        }
        if let value = dict["IpsecConfig"] as? [String: Any?] {
            var model = ModifyVpnConnectionAttributeResponseBody.IpsecConfig()
            model.fromMap(value)
            self.ipsecConfig = model
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RemoteSubnet"] as? String {
            self.remoteSubnet = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["TunnelOptionsSpecification"] as? [String: Any?] {
            var model = ModifyVpnConnectionAttributeResponseBody.TunnelOptionsSpecification()
            model.fromMap(value)
            self.tunnelOptionsSpecification = model
        }
        if let value = dict["VcoHealthCheck"] as? [String: Any?] {
            var model = ModifyVpnConnectionAttributeResponseBody.VcoHealthCheck()
            model.fromMap(value)
            self.vcoHealthCheck = model
        }
        if let value = dict["VpnBgpConfig"] as? [String: Any?] {
            var model = ModifyVpnConnectionAttributeResponseBody.VpnBgpConfig()
            model.fromMap(value)
            self.vpnBgpConfig = model
        }
        if let value = dict["VpnConnectionId"] as? String {
            self.vpnConnectionId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class ModifyVpnConnectionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnConnectionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpnConnectionAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpnGatewayAttributeRequest : Tea.TeaModel {
    public var autoPropagate: Bool?

    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPropagate != nil {
            map["AutoPropagate"] = self.autoPropagate!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPropagate"] as? Bool {
            self.autoPropagate = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class ModifyVpnGatewayAttributeResponseBody : Tea.TeaModel {
    public var autoPropagate: Bool?

    public var businessStatus: String?

    public var createTime: Int64?

    public var description_: String?

    public var disasterRecoveryInternetIp: String?

    public var disasterRecoveryVSwitchId: String?

    public var enableBgp: Bool?

    public var endTime: Int64?

    public var internetIp: String?

    public var intranetIp: String?

    public var name: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var spec: String?

    public var sslVpnInternetIp: String?

    public var status: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPropagate != nil {
            map["AutoPropagate"] = self.autoPropagate!
        }
        if self.businessStatus != nil {
            map["BusinessStatus"] = self.businessStatus!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disasterRecoveryInternetIp != nil {
            map["DisasterRecoveryInternetIp"] = self.disasterRecoveryInternetIp!
        }
        if self.disasterRecoveryVSwitchId != nil {
            map["DisasterRecoveryVSwitchId"] = self.disasterRecoveryVSwitchId!
        }
        if self.enableBgp != nil {
            map["EnableBgp"] = self.enableBgp!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.intranetIp != nil {
            map["IntranetIp"] = self.intranetIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.sslVpnInternetIp != nil {
            map["SslVpnInternetIp"] = self.sslVpnInternetIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPropagate"] as? Bool {
            self.autoPropagate = value
        }
        if let value = dict["BusinessStatus"] as? String {
            self.businessStatus = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DisasterRecoveryInternetIp"] as? String {
            self.disasterRecoveryInternetIp = value
        }
        if let value = dict["DisasterRecoveryVSwitchId"] as? String {
            self.disasterRecoveryVSwitchId = value
        }
        if let value = dict["EnableBgp"] as? Bool {
            self.enableBgp = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InternetIp"] as? String {
            self.internetIp = value
        }
        if let value = dict["IntranetIp"] as? String {
            self.intranetIp = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["SslVpnInternetIp"] as? String {
            self.sslVpnInternetIp = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class ModifyVpnGatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnGatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpnGatewayAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpnPbrRouteEntryAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newPriority: Int32?

    public var newWeight: Int32?

    public var nextHop: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newPriority != nil {
            map["NewPriority"] = self.newPriority!
        }
        if self.newWeight != nil {
            map["NewWeight"] = self.newWeight!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NewPriority"] as? Int32 {
            self.newPriority = value
        }
        if let value = dict["NewWeight"] as? Int32 {
            self.newWeight = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["RouteSource"] as? String {
            self.routeSource = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class ModifyVpnPbrRouteEntryAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVpnPbrRouteEntryAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnPbrRouteEntryAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpnPbrRouteEntryAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpnPbrRouteEntryPriorityRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newPriority: Int32?

    public var nextHop: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newPriority != nil {
            map["NewPriority"] = self.newPriority!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NewPriority"] as? Int32 {
            self.newPriority = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["RouteSource"] as? String {
            self.routeSource = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class ModifyVpnPbrRouteEntryPriorityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVpnPbrRouteEntryPriorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnPbrRouteEntryPriorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpnPbrRouteEntryPriorityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpnPbrRouteEntryWeightRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newWeight: Int32?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeSource: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newWeight != nil {
            map["NewWeight"] = self.newWeight!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeSource != nil {
            map["RouteSource"] = self.routeSource!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NewWeight"] as? Int32 {
            self.newWeight = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["RouteSource"] as? String {
            self.routeSource = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class ModifyVpnPbrRouteEntryWeightResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVpnPbrRouteEntryWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnPbrRouteEntryWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpnPbrRouteEntryWeightResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpnRouteEntryWeightRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newWeight: Int32?

    public var nextHop: String?

    public var overlayMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var vpnGatewayId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newWeight != nil {
            map["NewWeight"] = self.newWeight!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.overlayMode != nil {
            map["OverlayMode"] = self.overlayMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NewWeight"] as? Int32 {
            self.newWeight = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OverlayMode"] as? String {
            self.overlayMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class ModifyVpnRouteEntryWeightResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVpnRouteEntryWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpnRouteEntryWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpnRouteEntryWeightResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MoveResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NewResourceGroupId"] as? String {
            self.newResourceGroupId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class MoveResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class MoveResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MoveResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MoveVpnResourceGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var newResourceGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NewResourceGroupId"] as? String {
            self.newResourceGroupId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class MoveVpnResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class MoveVpnResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveVpnResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MoveVpnResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OpenFlowLogServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class OpenFlowLogServiceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class OpenFlowLogServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenFlowLogServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OpenFlowLogServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OpenPhysicalConnectionServiceRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class OpenPhysicalConnectionServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class OpenPhysicalConnectionServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenPhysicalConnectionServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OpenPhysicalConnectionServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OpenPublicIpAddressPoolServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class OpenPublicIpAddressPoolServiceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class OpenPublicIpAddressPoolServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenPublicIpAddressPoolServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OpenPublicIpAddressPoolServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OpenTrafficMirrorServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class OpenTrafficMirrorServiceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class OpenTrafficMirrorServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenTrafficMirrorServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OpenTrafficMirrorServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PublishVpcRouteEntriesRequest : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public var destinationCidrBlock: String?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DestinationCidrBlock"] as? String {
                self.destinationCidrBlock = value
            }
            if let value = dict["RouteTableId"] as? String {
                self.routeTableId = value
            }
        }
    }
    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntries: [PublishVpcRouteEntriesRequest.RouteEntries]?

    public var targetInstanceId: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntries"] as? [Any?] {
            var tmp : [PublishVpcRouteEntriesRequest.RouteEntries] = []
            for v in value {
                if v != nil {
                    var model = PublishVpcRouteEntriesRequest.RouteEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeEntries = tmp
        }
        if let value = dict["TargetInstanceId"] as? String {
            self.targetInstanceId = value
        }
        if let value = dict["TargetType"] as? String {
            self.targetType = value
        }
    }
}

public class PublishVpcRouteEntriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class PublishVpcRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishVpcRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PublishVpcRouteEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PublishVpnRouteEntryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var nextHop: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publishVpc: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeDest: String?

    public var routeType: String?

    public var vpnGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.nextHop != nil {
            map["NextHop"] = self.nextHop!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publishVpc != nil {
            map["PublishVpc"] = self.publishVpc!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeDest != nil {
            map["RouteDest"] = self.routeDest!
        }
        if self.routeType != nil {
            map["RouteType"] = self.routeType!
        }
        if self.vpnGatewayId != nil {
            map["VpnGatewayId"] = self.vpnGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NextHop"] as? String {
            self.nextHop = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PublishVpc"] as? Bool {
            self.publishVpc = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteDest"] as? String {
            self.routeDest = value
        }
        if let value = dict["RouteType"] as? String {
            self.routeType = value
        }
        if let value = dict["VpnGatewayId"] as? String {
            self.vpnGatewayId = value
        }
    }
}

public class PublishVpnRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class PublishVpnRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishVpnRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PublishVpnRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RecoverPhysicalConnectionRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var instanceId: String?

    public var regionId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Token"] as? String {
            self.token = value
        }
    }
}

public class RecoverPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RecoverPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RecoverPhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RecoverVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class RecoverVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RecoverVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RecoverVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReleaseEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseEipAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseEipSegmentAddressRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var segmentInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.segmentInstanceId != nil {
            map["SegmentInstanceId"] = self.segmentInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SegmentInstanceId"] as? String {
            self.segmentInstanceId = value
        }
    }
}

public class ReleaseEipSegmentAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseEipSegmentAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseEipSegmentAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseEipSegmentAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseIpv6AddressRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv6AddressId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6AddressId != nil {
            map["Ipv6AddressId"] = self.ipv6AddressId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv6AddressId"] as? String {
            self.ipv6AddressId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReleaseIpv6AddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseIpv6AddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseIpv6AddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseIpv6AddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveCommonBandwidthPackageIpRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ipInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipInstanceId != nil {
            map["IpInstanceId"] = self.ipInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["IpInstanceId"] as? String {
            self.ipInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RemoveCommonBandwidthPackageIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveCommonBandwidthPackageIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveCommonBandwidthPackageIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveCommonBandwidthPackageIpResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveGlobalAccelerationInstanceIpRequest : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var ipInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.ipInstanceId != nil {
            map["IpInstanceId"] = self.ipInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GlobalAccelerationInstanceId"] as? String {
            self.globalAccelerationInstanceId = value
        }
        if let value = dict["IpInstanceId"] as? String {
            self.ipInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RemoveGlobalAccelerationInstanceIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveGlobalAccelerationInstanceIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveGlobalAccelerationInstanceIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveGlobalAccelerationInstanceIpResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveIPv6TranslatorAclListEntryRequest : Tea.TeaModel {
    public var aclEntryId: String?

    public var aclId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntryId != nil {
            map["AclEntryId"] = self.aclEntryId!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AclEntryId"] as? String {
            self.aclEntryId = value
        }
        if let value = dict["AclId"] as? String {
            self.aclId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RemoveIPv6TranslatorAclListEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveIPv6TranslatorAclListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveIPv6TranslatorAclListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveIPv6TranslatorAclListEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveSourcesFromTrafficMirrorSessionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorSessionId: String?

    public var trafficMirrorSourceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        if self.trafficMirrorSourceIds != nil {
            map["TrafficMirrorSourceIds"] = self.trafficMirrorSourceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrafficMirrorSessionId"] as? String {
            self.trafficMirrorSessionId = value
        }
        if let value = dict["TrafficMirrorSourceIds"] as? [String] {
            self.trafficMirrorSourceIds = value
        }
    }
}

public class RemoveSourcesFromTrafficMirrorSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveSourcesFromTrafficMirrorSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSourcesFromTrafficMirrorSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveSourcesFromTrafficMirrorSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReplaceVpcDhcpOptionsSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ReplaceVpcDhcpOptionsSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReplaceVpcDhcpOptionsSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceVpcDhcpOptionsSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReplaceVpcDhcpOptionsSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RetryVpcPrefixListAssociationRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class RetryVpcPrefixListAssociationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RetryVpcPrefixListAssociationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryVpcPrefixListAssociationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RetryVpcPrefixListAssociationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeInstanceFromCenRequest : Tea.TeaModel {
    public var cenId: String?

    public var cenOwnerId: Int64?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.cenOwnerId != nil {
            map["CenOwnerId"] = self.cenOwnerId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CenId"] as? String {
            self.cenId = value
        }
        if let value = dict["CenOwnerId"] as? Int64 {
            self.cenOwnerId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RevokeInstanceFromCenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeInstanceFromCenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeInstanceFromCenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeInstanceFromCenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeInstanceFromVbrRequest : Tea.TeaModel {
    public var grantType: String?

    public var instanceId: String?

    public var regionId: String?

    public var vbrInstanceIds: [String]?

    public var vbrOwnerUid: String?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grantType != nil {
            map["GrantType"] = self.grantType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vbrInstanceIds != nil {
            map["VbrInstanceIds"] = self.vbrInstanceIds!
        }
        if self.vbrOwnerUid != nil {
            map["VbrOwnerUid"] = self.vbrOwnerUid!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GrantType"] as? String {
            self.grantType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VbrInstanceIds"] as? [String] {
            self.vbrInstanceIds = value
        }
        if let value = dict["VbrOwnerUid"] as? String {
            self.vbrOwnerUid = value
        }
        if let value = dict["VbrRegionNo"] as? String {
            self.vbrRegionNo = value
        }
    }
}

public class RevokeInstanceFromVbrShrinkRequest : Tea.TeaModel {
    public var grantType: String?

    public var instanceId: String?

    public var regionId: String?

    public var vbrInstanceIdsShrink: String?

    public var vbrOwnerUid: String?

    public var vbrRegionNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.grantType != nil {
            map["GrantType"] = self.grantType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vbrInstanceIdsShrink != nil {
            map["VbrInstanceIds"] = self.vbrInstanceIdsShrink!
        }
        if self.vbrOwnerUid != nil {
            map["VbrOwnerUid"] = self.vbrOwnerUid!
        }
        if self.vbrRegionNo != nil {
            map["VbrRegionNo"] = self.vbrRegionNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GrantType"] as? String {
            self.grantType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VbrInstanceIds"] as? String {
            self.vbrInstanceIdsShrink = value
        }
        if let value = dict["VbrOwnerUid"] as? String {
            self.vbrOwnerUid = value
        }
        if let value = dict["VbrRegionNo"] as? String {
            self.vbrRegionNo = value
        }
    }
}

public class RevokeInstanceFromVbrResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeInstanceFromVbrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeInstanceFromVbrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeInstanceFromVbrResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SecondApplyPhysicalConnectionLOARequest : Tea.TeaModel {
    public class PMInfo : Tea.TeaModel {
        public var PMCertificateNo: String?

        public var PMCertificateType: String?

        public var PMContactInfo: String?

        public var PMGender: String?

        public var PMName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.PMCertificateNo != nil {
                map["PMCertificateNo"] = self.PMCertificateNo!
            }
            if self.PMCertificateType != nil {
                map["PMCertificateType"] = self.PMCertificateType!
            }
            if self.PMContactInfo != nil {
                map["PMContactInfo"] = self.PMContactInfo!
            }
            if self.PMGender != nil {
                map["PMGender"] = self.PMGender!
            }
            if self.PMName != nil {
                map["PMName"] = self.PMName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PMCertificateNo"] as? String {
                self.PMCertificateNo = value
            }
            if let value = dict["PMCertificateType"] as? String {
                self.PMCertificateType = value
            }
            if let value = dict["PMContactInfo"] as? String {
                self.PMContactInfo = value
            }
            if let value = dict["PMGender"] as? String {
                self.PMGender = value
            }
            if let value = dict["PMName"] as? String {
                self.PMName = value
            }
        }
    }
    public var bandwidth: Int32?

    public var clientToken: String?

    public var companyName: String?

    public var constructionTime: String?

    public var instanceId: String?

    public var lineType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var PMInfo: [SecondApplyPhysicalConnectionLOARequest.PMInfo]?

    public var peerLocation: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var si: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.companyName != nil {
            map["CompanyName"] = self.companyName!
        }
        if self.constructionTime != nil {
            map["ConstructionTime"] = self.constructionTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lineType != nil {
            map["LineType"] = self.lineType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.PMInfo != nil {
            var tmp : [Any] = []
            for k in self.PMInfo! {
                tmp.append(k.toMap())
            }
            map["PMInfo"] = tmp
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.si != nil {
            map["Si"] = self.si!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CompanyName"] as? String {
            self.companyName = value
        }
        if let value = dict["ConstructionTime"] as? String {
            self.constructionTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LineType"] as? String {
            self.lineType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PMInfo"] as? [Any?] {
            var tmp : [SecondApplyPhysicalConnectionLOARequest.PMInfo] = []
            for v in value {
                if v != nil {
                    var model = SecondApplyPhysicalConnectionLOARequest.PMInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.PMInfo = tmp
        }
        if let value = dict["PeerLocation"] as? String {
            self.peerLocation = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Si"] as? String {
            self.si = value
        }
    }
}

public class SecondApplyPhysicalConnectionLOAResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SecondApplyPhysicalConnectionLOAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SecondApplyPhysicalConnectionLOAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SecondApplyPhysicalConnectionLOAResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetHighDefinitionMonitorLogStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public var logProject: String?

    public var logStore: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.logProject != nil {
            map["LogProject"] = self.logProject!
        }
        if self.logStore != nil {
            map["LogStore"] = self.logStore!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["LogProject"] as? String {
            self.logProject = value
        }
        if let value = dict["LogStore"] as? String {
            self.logStore = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class SetHighDefinitionMonitorLogStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class SetHighDefinitionMonitorLogStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetHighDefinitionMonitorLogStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetHighDefinitionMonitorLogStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class StartFailoverTestJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartFailoverTestJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class StopFailoverTestJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopFailoverTestJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SwitchActiveRouteTargetRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var regionId: String?

    public var routeTargetGroupId: String?

    public var tag: [SwitchActiveRouteTargetRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.routeTargetGroupId != nil {
            map["RouteTargetGroupId"] = self.routeTargetGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RouteTargetGroupId"] as? String {
            self.routeTargetGroupId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [SwitchActiveRouteTargetRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = SwitchActiveRouteTargetRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class SwitchActiveRouteTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SwitchActiveRouteTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchActiveRouteTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SwitchActiveRouteTargetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = TagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesForExpressConnectRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [TagResourcesForExpressConnectRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [TagResourcesForExpressConnectRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = TagResourcesForExpressConnectRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesForExpressConnectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TagResourcesForExpressConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesForExpressConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesForExpressConnectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TerminatePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class TerminatePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TerminatePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminatePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TerminatePhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TerminateVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class TerminateVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TerminateVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TerminateVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TransformEipSegmentToPublicIpAddressPoolRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var instanceId: String?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class TransformEipSegmentToPublicIpAddressPoolResponseBody : Tea.TeaModel {
    public var publicIpAddressPoolId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class TransformEipSegmentToPublicIpAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransformEipSegmentToPublicIpAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TransformEipSegmentToPublicIpAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnTagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["All"] as? Bool {
            self.all = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKey"] as? [String] {
            self.tagKey = value
        }
    }
}

public class UnTagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociateEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var clientToken: String?

    public var force: Bool?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UnassociateEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociateEipAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociateGlobalAccelerationInstanceRequest : Tea.TeaModel {
    public var globalAccelerationInstanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalAccelerationInstanceId != nil {
            map["GlobalAccelerationInstanceId"] = self.globalAccelerationInstanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GlobalAccelerationInstanceId"] as? String {
            self.globalAccelerationInstanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UnassociateGlobalAccelerationInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociateGlobalAccelerationInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateGlobalAccelerationInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociateGlobalAccelerationInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var force: String?

    public var haVipId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Force"] as? String {
            self.force = value
        }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UnassociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociateHaVipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociateNetworkAclRequest : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resource: [UnassociateNetworkAclRequest.Resource]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            var tmp : [Any] = []
            for k in self.resource! {
                tmp.append(k.toMap())
            }
            map["Resource"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Resource"] as? [Any?] {
            var tmp : [UnassociateNetworkAclRequest.Resource] = []
            for v in value {
                if v != nil {
                    var model = UnassociateNetworkAclRequest.Resource()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resource = tmp
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UnassociateNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociateNetworkAclResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociatePhysicalConnectionFromVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociatePhysicalConnectionFromVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociateRouteTableRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class UnassociateRouteTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociateRouteTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateRouteTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociateRouteTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociateVpcCidrBlockRequest : Tea.TeaModel {
    public var IPv6CidrBlock: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var secondaryCidrBlock: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.IPv6CidrBlock != nil {
            map["IPv6CidrBlock"] = self.IPv6CidrBlock!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.secondaryCidrBlock != nil {
            map["SecondaryCidrBlock"] = self.secondaryCidrBlock!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IPv6CidrBlock"] as? String {
            self.IPv6CidrBlock = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecondaryCidrBlock"] as? String {
            self.secondaryCidrBlock = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class UnassociateVpcCidrBlockResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociateVpcCidrBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateVpcCidrBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociateVpcCidrBlockResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UntagResourcesForExpressConnectRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["All"] as? Bool {
            self.all = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKey"] as? [String] {
            self.tagKey = value
        }
    }
}

public class UntagResourcesForExpressConnectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UntagResourcesForExpressConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesForExpressConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UntagResourcesForExpressConnectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDhcpOptionsSetAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dhcpOptionsSetDescription: String?

    public var dhcpOptionsSetId: String?

    public var dhcpOptionsSetName: String?

    public var domainName: String?

    public var domainNameServers: String?

    public var dryRun: Bool?

    public var ipv6LeaseTime: String?

    public var leaseTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dhcpOptionsSetDescription != nil {
            map["DhcpOptionsSetDescription"] = self.dhcpOptionsSetDescription!
        }
        if self.dhcpOptionsSetId != nil {
            map["DhcpOptionsSetId"] = self.dhcpOptionsSetId!
        }
        if self.dhcpOptionsSetName != nil {
            map["DhcpOptionsSetName"] = self.dhcpOptionsSetName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainNameServers != nil {
            map["DomainNameServers"] = self.domainNameServers!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv6LeaseTime != nil {
            map["Ipv6LeaseTime"] = self.ipv6LeaseTime!
        }
        if self.leaseTime != nil {
            map["LeaseTime"] = self.leaseTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DhcpOptionsSetDescription"] as? String {
            self.dhcpOptionsSetDescription = value
        }
        if let value = dict["DhcpOptionsSetId"] as? String {
            self.dhcpOptionsSetId = value
        }
        if let value = dict["DhcpOptionsSetName"] as? String {
            self.dhcpOptionsSetName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainNameServers"] as? String {
            self.domainNameServers = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv6LeaseTime"] as? String {
            self.ipv6LeaseTime = value
        }
        if let value = dict["LeaseTime"] as? String {
            self.leaseTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UpdateDhcpOptionsSetAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDhcpOptionsSetAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDhcpOptionsSetAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDhcpOptionsSetAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateFailoverTestJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var jobDuration: Int32?

    public var jobId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.jobDuration != nil {
            map["JobDuration"] = self.jobDuration!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["JobDuration"] as? Int32 {
            self.jobDuration = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class UpdateFailoverTestJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateFailoverTestJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFailoverTestJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateFailoverTestJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGatewayRouteTableEntryAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var destinationCidrBlock: String?

    public var dryRun: Bool?

    public var gatewayRouteTableId: String?

    public var IPv4GatewayRouteTableId: String?

    public var name: String?

    public var nextHopId: String?

    public var nextHopType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.gatewayRouteTableId != nil {
            map["GatewayRouteTableId"] = self.gatewayRouteTableId!
        }
        if self.IPv4GatewayRouteTableId != nil {
            map["IPv4GatewayRouteTableId"] = self.IPv4GatewayRouteTableId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["GatewayRouteTableId"] as? String {
            self.gatewayRouteTableId = value
        }
        if let value = dict["IPv4GatewayRouteTableId"] as? String {
            self.IPv4GatewayRouteTableId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NextHopId"] as? String {
            self.nextHopId = value
        }
        if let value = dict["NextHopType"] as? String {
            self.nextHopType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UpdateGatewayRouteTableEntryAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateGatewayRouteTableEntryAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteTableEntryAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGatewayRouteTableEntryAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateIpsecServerRequest : Tea.TeaModel {
    public var clientIpPool: String?

    public var clientToken: String?

    public var dryRun: String?

    public var effectImmediately: Bool?

    public var ikeConfig: String?

    public var ipsecConfig: String?

    public var ipsecServerId: String?

    public var ipsecServerName: String?

    public var localSubnet: String?

    public var psk: String?

    public var pskEnabled: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientIpPool != nil {
            map["ClientIpPool"] = self.clientIpPool!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.effectImmediately != nil {
            map["EffectImmediately"] = self.effectImmediately!
        }
        if self.ikeConfig != nil {
            map["IkeConfig"] = self.ikeConfig!
        }
        if self.ipsecConfig != nil {
            map["IpsecConfig"] = self.ipsecConfig!
        }
        if self.ipsecServerId != nil {
            map["IpsecServerId"] = self.ipsecServerId!
        }
        if self.ipsecServerName != nil {
            map["IpsecServerName"] = self.ipsecServerName!
        }
        if self.localSubnet != nil {
            map["LocalSubnet"] = self.localSubnet!
        }
        if self.psk != nil {
            map["Psk"] = self.psk!
        }
        if self.pskEnabled != nil {
            map["PskEnabled"] = self.pskEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientIpPool"] as? String {
            self.clientIpPool = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? String {
            self.dryRun = value
        }
        if let value = dict["EffectImmediately"] as? Bool {
            self.effectImmediately = value
        }
        if let value = dict["IkeConfig"] as? String {
            self.ikeConfig = value
        }
        if let value = dict["IpsecConfig"] as? String {
            self.ipsecConfig = value
        }
        if let value = dict["IpsecServerId"] as? String {
            self.ipsecServerId = value
        }
        if let value = dict["IpsecServerName"] as? String {
            self.ipsecServerName = value
        }
        if let value = dict["LocalSubnet"] as? String {
            self.localSubnet = value
        }
        if let value = dict["Psk"] as? String {
            self.psk = value
        }
        if let value = dict["PskEnabled"] as? Bool {
            self.pskEnabled = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class UpdateIpsecServerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateIpsecServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIpsecServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateIpsecServerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateIpv4GatewayAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ipv4GatewayDescription: String?

    public var ipv4GatewayId: String?

    public var ipv4GatewayName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ipv4GatewayDescription != nil {
            map["Ipv4GatewayDescription"] = self.ipv4GatewayDescription!
        }
        if self.ipv4GatewayId != nil {
            map["Ipv4GatewayId"] = self.ipv4GatewayId!
        }
        if self.ipv4GatewayName != nil {
            map["Ipv4GatewayName"] = self.ipv4GatewayName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Ipv4GatewayDescription"] as? String {
            self.ipv4GatewayDescription = value
        }
        if let value = dict["Ipv4GatewayId"] as? String {
            self.ipv4GatewayId = value
        }
        if let value = dict["Ipv4GatewayName"] as? String {
            self.ipv4GatewayName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UpdateIpv4GatewayAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateIpv4GatewayAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIpv4GatewayAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateIpv4GatewayAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateNatGatewayNatTypeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var natGatewayId: String?

    public var natType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["NatType"] as? String {
            self.natType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class UpdateNatGatewayNatTypeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateNatGatewayNatTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNatGatewayNatTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateNatGatewayNatTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateNetworkAclEntriesRequest : Tea.TeaModel {
    public class EgressAclEntries : Tea.TeaModel {
        public var description_: String?

        public var destinationCidrIp: String?

        public var entryType: String?

        public var ipVersion: String?

        public var networkAclEntryId: String?

        public var networkAclEntryName: String?

        public var policy: String?

        public var port: String?

        public var protocol_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationCidrIp != nil {
                map["DestinationCidrIp"] = self.destinationCidrIp!
            }
            if self.entryType != nil {
                map["EntryType"] = self.entryType!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.networkAclEntryId != nil {
                map["NetworkAclEntryId"] = self.networkAclEntryId!
            }
            if self.networkAclEntryName != nil {
                map["NetworkAclEntryName"] = self.networkAclEntryName!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DestinationCidrIp"] as? String {
                self.destinationCidrIp = value
            }
            if let value = dict["EntryType"] as? String {
                self.entryType = value
            }
            if let value = dict["IpVersion"] as? String {
                self.ipVersion = value
            }
            if let value = dict["NetworkAclEntryId"] as? String {
                self.networkAclEntryId = value
            }
            if let value = dict["NetworkAclEntryName"] as? String {
                self.networkAclEntryName = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["Port"] as? String {
                self.port = value
            }
            if let value = dict["Protocol"] as? String {
                self.protocol_ = value
            }
        }
    }
    public class IngressAclEntries : Tea.TeaModel {
        public var description_: String?

        public var entryType: String?

        public var ipVersion: String?

        public var networkAclEntryId: String?

        public var networkAclEntryName: String?

        public var policy: String?

        public var port: String?

        public var protocol_: String?

        public var sourceCidrIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.entryType != nil {
                map["EntryType"] = self.entryType!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.networkAclEntryId != nil {
                map["NetworkAclEntryId"] = self.networkAclEntryId!
            }
            if self.networkAclEntryName != nil {
                map["NetworkAclEntryName"] = self.networkAclEntryName!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EntryType"] as? String {
                self.entryType = value
            }
            if let value = dict["IpVersion"] as? String {
                self.ipVersion = value
            }
            if let value = dict["NetworkAclEntryId"] as? String {
                self.networkAclEntryId = value
            }
            if let value = dict["NetworkAclEntryName"] as? String {
                self.networkAclEntryName = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["Port"] as? String {
                self.port = value
            }
            if let value = dict["Protocol"] as? String {
                self.protocol_ = value
            }
            if let value = dict["SourceCidrIp"] as? String {
                self.sourceCidrIp = value
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var egressAclEntries: [UpdateNetworkAclEntriesRequest.EgressAclEntries]?

    public var ingressAclEntries: [UpdateNetworkAclEntriesRequest.IngressAclEntries]?

    public var networkAclId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var updateEgressAclEntries: Bool?

    public var updateIngressAclEntries: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.egressAclEntries != nil {
            var tmp : [Any] = []
            for k in self.egressAclEntries! {
                tmp.append(k.toMap())
            }
            map["EgressAclEntries"] = tmp
        }
        if self.ingressAclEntries != nil {
            var tmp : [Any] = []
            for k in self.ingressAclEntries! {
                tmp.append(k.toMap())
            }
            map["IngressAclEntries"] = tmp
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.updateEgressAclEntries != nil {
            map["UpdateEgressAclEntries"] = self.updateEgressAclEntries!
        }
        if self.updateIngressAclEntries != nil {
            map["UpdateIngressAclEntries"] = self.updateIngressAclEntries!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EgressAclEntries"] as? [Any?] {
            var tmp : [UpdateNetworkAclEntriesRequest.EgressAclEntries] = []
            for v in value {
                if v != nil {
                    var model = UpdateNetworkAclEntriesRequest.EgressAclEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.egressAclEntries = tmp
        }
        if let value = dict["IngressAclEntries"] as? [Any?] {
            var tmp : [UpdateNetworkAclEntriesRequest.IngressAclEntries] = []
            for v in value {
                if v != nil {
                    var model = UpdateNetworkAclEntriesRequest.IngressAclEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ingressAclEntries = tmp
        }
        if let value = dict["NetworkAclId"] as? String {
            self.networkAclId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UpdateEgressAclEntries"] as? Bool {
            self.updateEgressAclEntries = value
        }
        if let value = dict["UpdateIngressAclEntries"] as? Bool {
            self.updateIngressAclEntries = value
        }
    }
}

public class UpdateNetworkAclEntriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateNetworkAclEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNetworkAclEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateNetworkAclEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePublicIpAddressPoolAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var dryRun: Bool?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publicIpAddressPoolId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicIpAddressPoolId != nil {
            map["PublicIpAddressPoolId"] = self.publicIpAddressPoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PublicIpAddressPoolId"] as? String {
            self.publicIpAddressPoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UpdatePublicIpAddressPoolAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdatePublicIpAddressPoolAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePublicIpAddressPoolAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePublicIpAddressPoolAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRouteTargetGroupRequest : Tea.TeaModel {
    public class RouteTargetMemberList : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MemberId"] as? String {
                self.memberId = value
            }
            if let value = dict["MemberType"] as? String {
                self.memberType = value
            }
            if let value = dict["Weight"] as? Int32 {
                self.weight = value
            }
        }
    }
    public var clientToken: String?

    public var regionId: String?

    public var routeTargetGroupDescription: String?

    public var routeTargetGroupId: String?

    public var routeTargetGroupName: String?

    public var routeTargetMemberList: [UpdateRouteTargetGroupRequest.RouteTargetMemberList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.routeTargetGroupDescription != nil {
            map["RouteTargetGroupDescription"] = self.routeTargetGroupDescription!
        }
        if self.routeTargetGroupId != nil {
            map["RouteTargetGroupId"] = self.routeTargetGroupId!
        }
        if self.routeTargetGroupName != nil {
            map["RouteTargetGroupName"] = self.routeTargetGroupName!
        }
        if self.routeTargetMemberList != nil {
            var tmp : [Any] = []
            for k in self.routeTargetMemberList! {
                tmp.append(k.toMap())
            }
            map["RouteTargetMemberList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RouteTargetGroupDescription"] as? String {
            self.routeTargetGroupDescription = value
        }
        if let value = dict["RouteTargetGroupId"] as? String {
            self.routeTargetGroupId = value
        }
        if let value = dict["RouteTargetGroupName"] as? String {
            self.routeTargetGroupName = value
        }
        if let value = dict["RouteTargetMemberList"] as? [Any?] {
            var tmp : [UpdateRouteTargetGroupRequest.RouteTargetMemberList] = []
            for v in value {
                if v != nil {
                    var model = UpdateRouteTargetGroupRequest.RouteTargetMemberList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeTargetMemberList = tmp
        }
    }
}

public class UpdateRouteTargetGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRouteTargetGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRouteTargetGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRouteTargetGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTrafficMirrorFilterAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterDescription: String?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorFilterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterDescription != nil {
            map["TrafficMirrorFilterDescription"] = self.trafficMirrorFilterDescription!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorFilterName != nil {
            map["TrafficMirrorFilterName"] = self.trafficMirrorFilterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrafficMirrorFilterDescription"] as? String {
            self.trafficMirrorFilterDescription = value
        }
        if let value = dict["TrafficMirrorFilterId"] as? String {
            self.trafficMirrorFilterId = value
        }
        if let value = dict["TrafficMirrorFilterName"] as? String {
            self.trafficMirrorFilterName = value
        }
    }
}

public class UpdateTrafficMirrorFilterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateTrafficMirrorFilterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTrafficMirrorFilterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTrafficMirrorFilterAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTrafficMirrorFilterRuleAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var destinationCidrBlock: String?

    public var destinationPortRange: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var protocol_: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var ruleAction: String?

    public var sourceCidrBlock: String?

    public var sourcePortRange: String?

    public var trafficMirrorFilterRuleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.destinationPortRange != nil {
            map["DestinationPortRange"] = self.destinationPortRange!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.ruleAction != nil {
            map["RuleAction"] = self.ruleAction!
        }
        if self.sourceCidrBlock != nil {
            map["SourceCidrBlock"] = self.sourceCidrBlock!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.trafficMirrorFilterRuleId != nil {
            map["TrafficMirrorFilterRuleId"] = self.trafficMirrorFilterRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["DestinationPortRange"] as? String {
            self.destinationPortRange = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RuleAction"] as? String {
            self.ruleAction = value
        }
        if let value = dict["SourceCidrBlock"] as? String {
            self.sourceCidrBlock = value
        }
        if let value = dict["SourcePortRange"] as? String {
            self.sourcePortRange = value
        }
        if let value = dict["TrafficMirrorFilterRuleId"] as? String {
            self.trafficMirrorFilterRuleId = value
        }
    }
}

public class UpdateTrafficMirrorFilterRuleAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateTrafficMirrorFilterRuleAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTrafficMirrorFilterRuleAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTrafficMirrorFilterRuleAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTrafficMirrorSessionAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var enabled: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var packetLength: Int32?

    public var priority: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trafficMirrorFilterId: String?

    public var trafficMirrorSessionDescription: String?

    public var trafficMirrorSessionId: String?

    public var trafficMirrorSessionName: String?

    public var trafficMirrorTargetId: String?

    public var trafficMirrorTargetType: String?

    public var virtualNetworkId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.packetLength != nil {
            map["PacketLength"] = self.packetLength!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trafficMirrorFilterId != nil {
            map["TrafficMirrorFilterId"] = self.trafficMirrorFilterId!
        }
        if self.trafficMirrorSessionDescription != nil {
            map["TrafficMirrorSessionDescription"] = self.trafficMirrorSessionDescription!
        }
        if self.trafficMirrorSessionId != nil {
            map["TrafficMirrorSessionId"] = self.trafficMirrorSessionId!
        }
        if self.trafficMirrorSessionName != nil {
            map["TrafficMirrorSessionName"] = self.trafficMirrorSessionName!
        }
        if self.trafficMirrorTargetId != nil {
            map["TrafficMirrorTargetId"] = self.trafficMirrorTargetId!
        }
        if self.trafficMirrorTargetType != nil {
            map["TrafficMirrorTargetType"] = self.trafficMirrorTargetType!
        }
        if self.virtualNetworkId != nil {
            map["VirtualNetworkId"] = self.virtualNetworkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PacketLength"] as? Int32 {
            self.packetLength = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrafficMirrorFilterId"] as? String {
            self.trafficMirrorFilterId = value
        }
        if let value = dict["TrafficMirrorSessionDescription"] as? String {
            self.trafficMirrorSessionDescription = value
        }
        if let value = dict["TrafficMirrorSessionId"] as? String {
            self.trafficMirrorSessionId = value
        }
        if let value = dict["TrafficMirrorSessionName"] as? String {
            self.trafficMirrorSessionName = value
        }
        if let value = dict["TrafficMirrorTargetId"] as? String {
            self.trafficMirrorTargetId = value
        }
        if let value = dict["TrafficMirrorTargetType"] as? String {
            self.trafficMirrorTargetType = value
        }
        if let value = dict["VirtualNetworkId"] as? Int32 {
            self.virtualNetworkId = value
        }
    }
}

public class UpdateTrafficMirrorSessionAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateTrafficMirrorSessionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTrafficMirrorSessionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTrafficMirrorSessionAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateVirtualBorderBandwidthRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var virtualBorderRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.virtualBorderRouterId != nil {
            map["VirtualBorderRouterId"] = self.virtualBorderRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? Int32 {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VirtualBorderRouterId"] as? String {
            self.virtualBorderRouterId = value
        }
    }
}

public class UpdateVirtualBorderBandwidthResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateVirtualBorderBandwidthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVirtualBorderBandwidthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateVirtualBorderBandwidthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateVirtualPhysicalConnectionRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var expectSpec: String?

    public var instanceId: String?

    public var regionId: String?

    public var token: String?

    public var vlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.expectSpec != nil {
            map["ExpectSpec"] = self.expectSpec!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ExpectSpec"] as? String {
            self.expectSpec = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Token"] as? String {
            self.token = value
        }
        if let value = dict["VlanId"] as? Int64 {
            self.vlanId = value
        }
    }
}

public class UpdateVirtualPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class UpdateVirtualPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVirtualPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateVirtualPhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateVpcGatewayEndpointAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointDescription: String?

    public var endpointId: String?

    public var endpointName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var policyDocument: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointDescription != nil {
            map["EndpointDescription"] = self.endpointDescription!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policyDocument != nil {
            map["PolicyDocument"] = self.policyDocument!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EndpointDescription"] as? String {
            self.endpointDescription = value
        }
        if let value = dict["EndpointId"] as? String {
            self.endpointId = value
        }
        if let value = dict["EndpointName"] as? String {
            self.endpointName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PolicyDocument"] as? String {
            self.policyDocument = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UpdateVpcGatewayEndpointAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateVpcGatewayEndpointAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVpcGatewayEndpointAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateVpcGatewayEndpointAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class VpcDescribeVpcNatGatewayNetworkInterfaceQuotaRequest : Tea.TeaModel {
    public var clientToken: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceUid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceUid != nil {
            map["ResourceUid"] = self.resourceUid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceUid"] as? Int64 {
            self.resourceUid = value
        }
    }
}

public class VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody : Tea.TeaModel {
    public var quota: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.quota != nil {
            map["Quota"] = self.quota!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Quota"] as? Int64 {
            self.quota = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = VpcDescribeVpcNatGatewayNetworkInterfaceQuotaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class WithdrawVpcPublishedRouteEntriesRequest : Tea.TeaModel {
    public class RouteEntries : Tea.TeaModel {
        public var destinationCidrBlock: String?

        public var routeTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DestinationCidrBlock"] as? String {
                self.destinationCidrBlock = value
            }
            if let value = dict["RouteTableId"] as? String {
                self.routeTableId = value
            }
        }
    }
    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeEntries: [WithdrawVpcPublishedRouteEntriesRequest.RouteEntries]?

    public var targetInstanceId: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeEntries != nil {
            var tmp : [Any] = []
            for k in self.routeEntries! {
                tmp.append(k.toMap())
            }
            map["RouteEntries"] = tmp
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteEntries"] as? [Any?] {
            var tmp : [WithdrawVpcPublishedRouteEntriesRequest.RouteEntries] = []
            for v in value {
                if v != nil {
                    var model = WithdrawVpcPublishedRouteEntriesRequest.RouteEntries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeEntries = tmp
        }
        if let value = dict["TargetInstanceId"] as? String {
            self.targetInstanceId = value
        }
        if let value = dict["TargetType"] as? String {
            self.targetType = value
        }
    }
}

public class WithdrawVpcPublishedRouteEntriesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class WithdrawVpcPublishedRouteEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WithdrawVpcPublishedRouteEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WithdrawVpcPublishedRouteEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
