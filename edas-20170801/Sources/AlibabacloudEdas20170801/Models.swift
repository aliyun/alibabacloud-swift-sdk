import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AppConfig : Tea.TeaModel {
    public class ConfigMountDescs : Tea.TeaModel {
        public class MountItems : Tea.TeaModel {
            public var key: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var mountItems: [AppConfig.ConfigMountDescs.MountItems]?

        public var mountPath: String?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountItems != nil {
                var tmp : [Any] = []
                for k in self.mountItems! {
                    tmp.append(k.toMap())
                }
                map["MountItems"] = tmp
            }
            if self.mountPath != nil {
                map["MountPath"] = self.mountPath!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MountItems") && dict["MountItems"] != nil {
                var tmp : [AppConfig.ConfigMountDescs.MountItems] = []
                for v in dict["MountItems"] as! [Any] {
                    var model = AppConfig.ConfigMountDescs.MountItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mountItems = tmp
            }
            if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                self.mountPath = dict["MountPath"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class EmptyDirs : Tea.TeaModel {
        public var mountPath: String?

        public var name: String?

        public var readOnly: Bool?

        public var subPathExpr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountPath != nil {
                map["MountPath"] = self.mountPath!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.readOnly != nil {
                map["ReadOnly"] = self.readOnly!
            }
            if self.subPathExpr != nil {
                map["SubPathExpr"] = self.subPathExpr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                self.mountPath = dict["MountPath"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                self.readOnly = dict["ReadOnly"] as! Bool
            }
            if dict.keys.contains("SubPathExpr") && dict["SubPathExpr"] != nil {
                self.subPathExpr = dict["SubPathExpr"] as! String
            }
        }
    }
    public class EnvFroms : Tea.TeaModel {
        public var configMapRef: String?

        public var secretRef: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapRef != nil {
                map["ConfigMapRef"] = self.configMapRef!
            }
            if self.secretRef != nil {
                map["SecretRef"] = self.secretRef!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigMapRef") && dict["ConfigMapRef"] != nil {
                self.configMapRef = dict["ConfigMapRef"] as! String
            }
            if dict.keys.contains("SecretRef") && dict["SecretRef"] != nil {
                self.secretRef = dict["SecretRef"] as! String
            }
        }
    }
    public class Envs : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public var valueFrom: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            if self.valueFrom != nil {
                map["ValueFrom"] = self.valueFrom!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
            if dict.keys.contains("ValueFrom") && dict["ValueFrom"] != nil {
                self.valueFrom = dict["ValueFrom"] as! String
            }
        }
    }
    public class ImageConfig : Tea.TeaModel {
        public var containerRegistryId: String?

        public var crInstanceId: String?

        public var crRegionId: String?

        public var imageUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.containerRegistryId != nil {
                map["ContainerRegistryId"] = self.containerRegistryId!
            }
            if self.crInstanceId != nil {
                map["CrInstanceId"] = self.crInstanceId!
            }
            if self.crRegionId != nil {
                map["CrRegionId"] = self.crRegionId!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContainerRegistryId") && dict["ContainerRegistryId"] != nil {
                self.containerRegistryId = dict["ContainerRegistryId"] as! String
            }
            if dict.keys.contains("CrInstanceId") && dict["CrInstanceId"] != nil {
                self.crInstanceId = dict["CrInstanceId"] as! String
            }
            if dict.keys.contains("CrRegionId") && dict["CrRegionId"] != nil {
                self.crRegionId = dict["CrRegionId"] as! String
            }
            if dict.keys.contains("ImageUrl") && dict["ImageUrl"] != nil {
                self.imageUrl = dict["ImageUrl"] as! String
            }
        }
    }
    public class LocalVolumes : Tea.TeaModel {
        public var mountPath: String?

        public var name: String?

        public var nodePath: String?

        public var opsAuth: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountPath != nil {
                map["MountPath"] = self.mountPath!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodePath != nil {
                map["NodePath"] = self.nodePath!
            }
            if self.opsAuth != nil {
                map["OpsAuth"] = self.opsAuth!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                self.mountPath = dict["MountPath"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodePath") && dict["NodePath"] != nil {
                self.nodePath = dict["NodePath"] as! String
            }
            if dict.keys.contains("OpsAuth") && dict["OpsAuth"] != nil {
                self.opsAuth = dict["OpsAuth"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class NasMountDescs : Tea.TeaModel {
        public var mountPath: String?

        public var nasPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountPath != nil {
                map["MountPath"] = self.mountPath!
            }
            if self.nasPath != nil {
                map["NasPath"] = self.nasPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                self.mountPath = dict["MountPath"] as! String
            }
            if dict.keys.contains("NasPath") && dict["NasPath"] != nil {
                self.nasPath = dict["NasPath"] as! String
            }
        }
    }
    public class PackageConfig : Tea.TeaModel {
        public var edasContainerVersion: String?

        public var jdk: String?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public var timezone: String?

        public var uriEncoding: String?

        public var useBodyEncoding: Bool?

        public var webContainer: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            if self.jdk != nil {
                map["Jdk"] = self.jdk!
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.timezone != nil {
                map["Timezone"] = self.timezone!
            }
            if self.uriEncoding != nil {
                map["UriEncoding"] = self.uriEncoding!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            if self.webContainer != nil {
                map["WebContainer"] = self.webContainer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EdasContainerVersion") && dict["EdasContainerVersion"] != nil {
                self.edasContainerVersion = dict["EdasContainerVersion"] as! String
            }
            if dict.keys.contains("Jdk") && dict["Jdk"] != nil {
                self.jdk = dict["Jdk"] as! String
            }
            if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
                self.packageType = dict["PackageType"] as! String
            }
            if dict.keys.contains("PackageUrl") && dict["PackageUrl"] != nil {
                self.packageUrl = dict["PackageUrl"] as! String
            }
            if dict.keys.contains("PackageVersion") && dict["PackageVersion"] != nil {
                self.packageVersion = dict["PackageVersion"] as! String
            }
            if dict.keys.contains("Timezone") && dict["Timezone"] != nil {
                self.timezone = dict["Timezone"] as! String
            }
            if dict.keys.contains("UriEncoding") && dict["UriEncoding"] != nil {
                self.uriEncoding = dict["UriEncoding"] as! String
            }
            if dict.keys.contains("UseBodyEncoding") && dict["UseBodyEncoding"] != nil {
                self.useBodyEncoding = dict["UseBodyEncoding"] as! Bool
            }
            if dict.keys.contains("WebContainer") && dict["WebContainer"] != nil {
                self.webContainer = dict["WebContainer"] as! String
            }
        }
    }
    public class PvcMountDescs : Tea.TeaModel {
        public class MountPaths : Tea.TeaModel {
            public var mountPath: String?

            public var readOnly: Bool?

            public var subPathExpr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPathExpr != nil {
                    map["SubPathExpr"] = self.subPathExpr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") && dict["MountPath"] != nil {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("SubPathExpr") && dict["SubPathExpr"] != nil {
                    self.subPathExpr = dict["SubPathExpr"] as! String
                }
            }
        }
        public var mountPaths: [AppConfig.PvcMountDescs.MountPaths]?

        public var pvcName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountPaths != nil {
                var tmp : [Any] = []
                for k in self.mountPaths! {
                    tmp.append(k.toMap())
                }
                map["MountPaths"] = tmp
            }
            if self.pvcName != nil {
                map["PvcName"] = self.pvcName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MountPaths") && dict["MountPaths"] != nil {
                var tmp : [AppConfig.PvcMountDescs.MountPaths] = []
                for v in dict["MountPaths"] as! [Any] {
                    var model = AppConfig.PvcMountDescs.MountPaths()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mountPaths = tmp
            }
            if dict.keys.contains("PvcName") && dict["PvcName"] != nil {
                self.pvcName = dict["PvcName"] as! String
            }
        }
    }
    public class SlsConfigs : Tea.TeaModel {
        public var logDir: String?

        public var logstore: String?

        public var project: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logDir != nil {
                map["LogDir"] = self.logDir!
            }
            if self.logstore != nil {
                map["Logstore"] = self.logstore!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogDir") && dict["LogDir"] != nil {
                self.logDir = dict["LogDir"] as! String
            }
            if dict.keys.contains("Logstore") && dict["Logstore"] != nil {
                self.logstore = dict["Logstore"] as! String
            }
            if dict.keys.contains("Project") && dict["Project"] != nil {
                self.project = dict["Project"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class WebContainerConfig : Tea.TeaModel {
        public var connectorType: String?

        public var contextInputType: String?

        public var contextPath: String?

        public var httpPort: Int64?

        public var maxThreads: Int64?

        public var serverXml: String?

        public var uriEncoding: String?

        public var useAdvancedServerXml: Bool?

        public var useBodyEncoding: Bool?

        public var useDefaultConfig: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectorType != nil {
                map["ConnectorType"] = self.connectorType!
            }
            if self.contextInputType != nil {
                map["ContextInputType"] = self.contextInputType!
            }
            if self.contextPath != nil {
                map["ContextPath"] = self.contextPath!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.maxThreads != nil {
                map["MaxThreads"] = self.maxThreads!
            }
            if self.serverXml != nil {
                map["ServerXml"] = self.serverXml!
            }
            if self.uriEncoding != nil {
                map["UriEncoding"] = self.uriEncoding!
            }
            if self.useAdvancedServerXml != nil {
                map["UseAdvancedServerXml"] = self.useAdvancedServerXml!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            if self.useDefaultConfig != nil {
                map["UseDefaultConfig"] = self.useDefaultConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectorType") && dict["ConnectorType"] != nil {
                self.connectorType = dict["ConnectorType"] as! String
            }
            if dict.keys.contains("ContextInputType") && dict["ContextInputType"] != nil {
                self.contextInputType = dict["ContextInputType"] as! String
            }
            if dict.keys.contains("ContextPath") && dict["ContextPath"] != nil {
                self.contextPath = dict["ContextPath"] as! String
            }
            if dict.keys.contains("HttpPort") && dict["HttpPort"] != nil {
                self.httpPort = dict["HttpPort"] as! Int64
            }
            if dict.keys.contains("MaxThreads") && dict["MaxThreads"] != nil {
                self.maxThreads = dict["MaxThreads"] as! Int64
            }
            if dict.keys.contains("ServerXml") && dict["ServerXml"] != nil {
                self.serverXml = dict["ServerXml"] as! String
            }
            if dict.keys.contains("UriEncoding") && dict["UriEncoding"] != nil {
                self.uriEncoding = dict["UriEncoding"] as! String
            }
            if dict.keys.contains("UseAdvancedServerXml") && dict["UseAdvancedServerXml"] != nil {
                self.useAdvancedServerXml = dict["UseAdvancedServerXml"] as! Bool
            }
            if dict.keys.contains("UseBodyEncoding") && dict["UseBodyEncoding"] != nil {
                self.useBodyEncoding = dict["UseBodyEncoding"] as! Bool
            }
            if dict.keys.contains("UseDefaultConfig") && dict["UseDefaultConfig"] != nil {
                self.useDefaultConfig = dict["UseDefaultConfig"] as! Bool
            }
        }
    }
    public var command: String?

    public var commandArgs: [String]?

    public var configMountDescs: [AppConfig.ConfigMountDescs]?

    public var deployAcrossNodes: Bool?

    public var deployAcrossZones: Bool?

    public var emptyDirs: [AppConfig.EmptyDirs]?

    public var enableAhas: Bool?

    public var envFroms: [AppConfig.EnvFroms]?

    public var envs: [AppConfig.Envs]?

    public var imageConfig: AppConfig.ImageConfig?

    public var isMultilingualApp: Bool?

    public var javaStartUpConfig: String?

    public var limitCpu: String?

    public var limitMem: String?

    public var liveness: String?

    public var localVolumes: [AppConfig.LocalVolumes]?

    public var nasId: String?

    public var nasMountDescs: [AppConfig.NasMountDescs]?

    public var nasStorageType: String?

    public var packageConfig: AppConfig.PackageConfig?

    public var postStart: String?

    public var preStop: String?

    public var pvcMountDescs: [AppConfig.PvcMountDescs]?

    public var readiness: String?

    public var replicas: Int64?

    public var requestCpu: String?

    public var requestMem: String?

    public var runtimeClassName: String?

    public var slsConfigs: [AppConfig.SlsConfigs]?

    public var webContainerConfig: AppConfig.WebContainerConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageConfig?.validate()
        try self.packageConfig?.validate()
        try self.webContainerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMountDescs != nil {
            var tmp : [Any] = []
            for k in self.configMountDescs! {
                tmp.append(k.toMap())
            }
            map["ConfigMountDescs"] = tmp
        }
        if self.deployAcrossNodes != nil {
            map["DeployAcrossNodes"] = self.deployAcrossNodes!
        }
        if self.deployAcrossZones != nil {
            map["DeployAcrossZones"] = self.deployAcrossZones!
        }
        if self.emptyDirs != nil {
            var tmp : [Any] = []
            for k in self.emptyDirs! {
                tmp.append(k.toMap())
            }
            map["EmptyDirs"] = tmp
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        if self.envFroms != nil {
            var tmp : [Any] = []
            for k in self.envFroms! {
                tmp.append(k.toMap())
            }
            map["EnvFroms"] = tmp
        }
        if self.envs != nil {
            var tmp : [Any] = []
            for k in self.envs! {
                tmp.append(k.toMap())
            }
            map["Envs"] = tmp
        }
        if self.imageConfig != nil {
            map["ImageConfig"] = self.imageConfig?.toMap()
        }
        if self.isMultilingualApp != nil {
            map["IsMultilingualApp"] = self.isMultilingualApp!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig!
        }
        if self.limitCpu != nil {
            map["LimitCpu"] = self.limitCpu!
        }
        if self.limitMem != nil {
            map["LimitMem"] = self.limitMem!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.localVolumes != nil {
            var tmp : [Any] = []
            for k in self.localVolumes! {
                tmp.append(k.toMap())
            }
            map["LocalVolumes"] = tmp
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.nasMountDescs != nil {
            var tmp : [Any] = []
            for k in self.nasMountDescs! {
                tmp.append(k.toMap())
            }
            map["NasMountDescs"] = tmp
        }
        if self.nasStorageType != nil {
            map["NasStorageType"] = self.nasStorageType!
        }
        if self.packageConfig != nil {
            map["PackageConfig"] = self.packageConfig?.toMap()
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.pvcMountDescs != nil {
            var tmp : [Any] = []
            for k in self.pvcMountDescs! {
                tmp.append(k.toMap())
            }
            map["PvcMountDescs"] = tmp
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.requestCpu != nil {
            map["RequestCpu"] = self.requestCpu!
        }
        if self.requestMem != nil {
            map["RequestMem"] = self.requestMem!
        }
        if self.runtimeClassName != nil {
            map["RuntimeClassName"] = self.runtimeClassName!
        }
        if self.slsConfigs != nil {
            var tmp : [Any] = []
            for k in self.slsConfigs! {
                tmp.append(k.toMap())
            }
            map["SlsConfigs"] = tmp
        }
        if self.webContainerConfig != nil {
            map["WebContainerConfig"] = self.webContainerConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Command") && dict["Command"] != nil {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("CommandArgs") && dict["CommandArgs"] != nil {
            self.commandArgs = dict["CommandArgs"] as! [String]
        }
        if dict.keys.contains("ConfigMountDescs") && dict["ConfigMountDescs"] != nil {
            var tmp : [AppConfig.ConfigMountDescs] = []
            for v in dict["ConfigMountDescs"] as! [Any] {
                var model = AppConfig.ConfigMountDescs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configMountDescs = tmp
        }
        if dict.keys.contains("DeployAcrossNodes") && dict["DeployAcrossNodes"] != nil {
            self.deployAcrossNodes = dict["DeployAcrossNodes"] as! Bool
        }
        if dict.keys.contains("DeployAcrossZones") && dict["DeployAcrossZones"] != nil {
            self.deployAcrossZones = dict["DeployAcrossZones"] as! Bool
        }
        if dict.keys.contains("EmptyDirs") && dict["EmptyDirs"] != nil {
            var tmp : [AppConfig.EmptyDirs] = []
            for v in dict["EmptyDirs"] as! [Any] {
                var model = AppConfig.EmptyDirs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.emptyDirs = tmp
        }
        if dict.keys.contains("EnableAhas") && dict["EnableAhas"] != nil {
            self.enableAhas = dict["EnableAhas"] as! Bool
        }
        if dict.keys.contains("EnvFroms") && dict["EnvFroms"] != nil {
            var tmp : [AppConfig.EnvFroms] = []
            for v in dict["EnvFroms"] as! [Any] {
                var model = AppConfig.EnvFroms()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.envFroms = tmp
        }
        if dict.keys.contains("Envs") && dict["Envs"] != nil {
            var tmp : [AppConfig.Envs] = []
            for v in dict["Envs"] as! [Any] {
                var model = AppConfig.Envs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.envs = tmp
        }
        if dict.keys.contains("ImageConfig") && dict["ImageConfig"] != nil {
            var model = AppConfig.ImageConfig()
            model.fromMap(dict["ImageConfig"] as! [String: Any])
            self.imageConfig = model
        }
        if dict.keys.contains("IsMultilingualApp") && dict["IsMultilingualApp"] != nil {
            self.isMultilingualApp = dict["IsMultilingualApp"] as! Bool
        }
        if dict.keys.contains("JavaStartUpConfig") && dict["JavaStartUpConfig"] != nil {
            self.javaStartUpConfig = dict["JavaStartUpConfig"] as! String
        }
        if dict.keys.contains("LimitCpu") && dict["LimitCpu"] != nil {
            self.limitCpu = dict["LimitCpu"] as! String
        }
        if dict.keys.contains("LimitMem") && dict["LimitMem"] != nil {
            self.limitMem = dict["LimitMem"] as! String
        }
        if dict.keys.contains("Liveness") && dict["Liveness"] != nil {
            self.liveness = dict["Liveness"] as! String
        }
        if dict.keys.contains("LocalVolumes") && dict["LocalVolumes"] != nil {
            var tmp : [AppConfig.LocalVolumes] = []
            for v in dict["LocalVolumes"] as! [Any] {
                var model = AppConfig.LocalVolumes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.localVolumes = tmp
        }
        if dict.keys.contains("NasId") && dict["NasId"] != nil {
            self.nasId = dict["NasId"] as! String
        }
        if dict.keys.contains("NasMountDescs") && dict["NasMountDescs"] != nil {
            var tmp : [AppConfig.NasMountDescs] = []
            for v in dict["NasMountDescs"] as! [Any] {
                var model = AppConfig.NasMountDescs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nasMountDescs = tmp
        }
        if dict.keys.contains("NasStorageType") && dict["NasStorageType"] != nil {
            self.nasStorageType = dict["NasStorageType"] as! String
        }
        if dict.keys.contains("PackageConfig") && dict["PackageConfig"] != nil {
            var model = AppConfig.PackageConfig()
            model.fromMap(dict["PackageConfig"] as! [String: Any])
            self.packageConfig = model
        }
        if dict.keys.contains("PostStart") && dict["PostStart"] != nil {
            self.postStart = dict["PostStart"] as! String
        }
        if dict.keys.contains("PreStop") && dict["PreStop"] != nil {
            self.preStop = dict["PreStop"] as! String
        }
        if dict.keys.contains("PvcMountDescs") && dict["PvcMountDescs"] != nil {
            var tmp : [AppConfig.PvcMountDescs] = []
            for v in dict["PvcMountDescs"] as! [Any] {
                var model = AppConfig.PvcMountDescs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pvcMountDescs = tmp
        }
        if dict.keys.contains("Readiness") && dict["Readiness"] != nil {
            self.readiness = dict["Readiness"] as! String
        }
        if dict.keys.contains("Replicas") && dict["Replicas"] != nil {
            self.replicas = dict["Replicas"] as! Int64
        }
        if dict.keys.contains("RequestCpu") && dict["RequestCpu"] != nil {
            self.requestCpu = dict["RequestCpu"] as! String
        }
        if dict.keys.contains("RequestMem") && dict["RequestMem"] != nil {
            self.requestMem = dict["RequestMem"] as! String
        }
        if dict.keys.contains("RuntimeClassName") && dict["RuntimeClassName"] != nil {
            self.runtimeClassName = dict["RuntimeClassName"] as! String
        }
        if dict.keys.contains("SlsConfigs") && dict["SlsConfigs"] != nil {
            var tmp : [AppConfig.SlsConfigs] = []
            for v in dict["SlsConfigs"] as! [Any] {
                var model = AppConfig.SlsConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.slsConfigs = tmp
        }
        if dict.keys.contains("WebContainerConfig") && dict["WebContainerConfig"] != nil {
            var model = AppConfig.WebContainerConfig()
            model.fromMap(dict["WebContainerConfig"] as! [String: Any])
            self.webContainerConfig = model
        }
    }
}

public class AbortAndRollbackChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
    }
}

public class AbortAndRollbackChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AbortAndRollbackChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AbortAndRollbackChangeOrderResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class AbortAndRollbackChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortAndRollbackChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AbortAndRollbackChangeOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AbortChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
    }
}

public class AbortChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AbortChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AbortChangeOrderResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class AbortChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AbortChangeOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLogPathRequest : Tea.TeaModel {
    public var appId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
    }
}

public class AddLogPathResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLogPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLogPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddLogPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AuthorizeApplicationRequest : Tea.TeaModel {
    public var appIds: String?

    public var targetUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("TargetUserId") && dict["TargetUserId"] != nil {
            self.targetUserId = dict["TargetUserId"] as! String
        }
    }
}

public class AuthorizeApplicationResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AuthorizeApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AuthorizeApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AuthorizeResourceGroupRequest : Tea.TeaModel {
    public var resourceGroupIds: String?

    public var targetUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceGroupIds != nil {
            map["ResourceGroupIds"] = self.resourceGroupIds!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceGroupIds") && dict["ResourceGroupIds"] != nil {
            self.resourceGroupIds = dict["ResourceGroupIds"] as! String
        }
        if dict.keys.contains("TargetUserId") && dict["TargetUserId"] != nil {
            self.targetUserId = dict["TargetUserId"] as! String
        }
    }
}

public class AuthorizeResourceGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AuthorizeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AuthorizeResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AuthorizeRoleRequest : Tea.TeaModel {
    public var roleIds: String?

    public var targetUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roleIds != nil {
            map["RoleIds"] = self.roleIds!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoleIds") && dict["RoleIds"] != nil {
            self.roleIds = dict["RoleIds"] as! String
        }
        if dict.keys.contains("TargetUserId") && dict["TargetUserId"] != nil {
            self.targetUserId = dict["TargetUserId"] as! String
        }
    }
}

public class AuthorizeRoleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AuthorizeRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AuthorizeRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindEcsSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var deployGroupId: String?

    public var listenerHealthCheckUrl: String?

    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var slbId: String?

    public var VForwardingUrlRule: String?

    public var VServerGroupId: String?

    public var VServerGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deployGroupId != nil {
            map["DeployGroupId"] = self.deployGroupId!
        }
        if self.listenerHealthCheckUrl != nil {
            map["ListenerHealthCheckUrl"] = self.listenerHealthCheckUrl!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.VForwardingUrlRule != nil {
            map["VForwardingUrlRule"] = self.VForwardingUrlRule!
        }
        if self.VServerGroupId != nil {
            map["VServerGroupId"] = self.VServerGroupId!
        }
        if self.VServerGroupName != nil {
            map["VServerGroupName"] = self.VServerGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeployGroupId") && dict["DeployGroupId"] != nil {
            self.deployGroupId = dict["DeployGroupId"] as! String
        }
        if dict.keys.contains("ListenerHealthCheckUrl") && dict["ListenerHealthCheckUrl"] != nil {
            self.listenerHealthCheckUrl = dict["ListenerHealthCheckUrl"] as! String
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("ListenerProtocol") && dict["ListenerProtocol"] != nil {
            self.listenerProtocol = dict["ListenerProtocol"] as! String
        }
        if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
            self.slbId = dict["SlbId"] as! String
        }
        if dict.keys.contains("VForwardingUrlRule") && dict["VForwardingUrlRule"] != nil {
            self.VForwardingUrlRule = dict["VForwardingUrlRule"] as! String
        }
        if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
            self.VServerGroupId = dict["VServerGroupId"] as! String
        }
        if dict.keys.contains("VServerGroupName") && dict["VServerGroupName"] != nil {
            self.VServerGroupName = dict["VServerGroupName"] as! String
        }
    }
}

public class BindEcsSlbResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindEcsSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindEcsSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BindEcsSlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindK8sSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var port: String?

    public var scheduler: String?

    public var servicePortInfos: String?

    public var slbId: String?

    public var slbProtocol: String?

    public var specification: String?

    public var targetPort: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.servicePortInfos != nil {
            map["ServicePortInfos"] = self.servicePortInfos!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.slbProtocol != nil {
            map["SlbProtocol"] = self.slbProtocol!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.targetPort != nil {
            map["TargetPort"] = self.targetPort!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServicePortInfos") && dict["ServicePortInfos"] != nil {
            self.servicePortInfos = dict["ServicePortInfos"] as! String
        }
        if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
            self.slbId = dict["SlbId"] as! String
        }
        if dict.keys.contains("SlbProtocol") && dict["SlbProtocol"] != nil {
            self.slbProtocol = dict["SlbProtocol"] as! String
        }
        if dict.keys.contains("Specification") && dict["Specification"] != nil {
            self.specification = dict["Specification"] as! String
        }
        if dict.keys.contains("TargetPort") && dict["TargetPort"] != nil {
            self.targetPort = dict["TargetPort"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class BindK8sSlbResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindK8sSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindK8sSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BindK8sSlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var listenerPort: Int32?

    public var slbId: String?

    public var slbIp: String?

    public var type: String?

    public var VServerGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.slbIp != nil {
            map["SlbIp"] = self.slbIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.VServerGroupId != nil {
            map["VServerGroupId"] = self.VServerGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
            self.slbId = dict["SlbId"] as! String
        }
        if dict.keys.contains("SlbIp") && dict["SlbIp"] != nil {
            self.slbIp = dict["SlbIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
            self.VServerGroupId = dict["VServerGroupId"] as! String
        }
    }
}

public class BindSlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var extSlbId: String?

        public var extSlbIp: String?

        public var extSlbName: String?

        public var extVServerGroupId: String?

        public var slbId: String?

        public var slbIp: String?

        public var slbName: String?

        public var slbPort: Int32?

        public var VServerGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extSlbId != nil {
                map["ExtSlbId"] = self.extSlbId!
            }
            if self.extSlbIp != nil {
                map["ExtSlbIp"] = self.extSlbIp!
            }
            if self.extSlbName != nil {
                map["ExtSlbName"] = self.extSlbName!
            }
            if self.extVServerGroupId != nil {
                map["ExtVServerGroupId"] = self.extVServerGroupId!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbIp != nil {
                map["SlbIp"] = self.slbIp!
            }
            if self.slbName != nil {
                map["SlbName"] = self.slbName!
            }
            if self.slbPort != nil {
                map["SlbPort"] = self.slbPort!
            }
            if self.VServerGroupId != nil {
                map["VServerGroupId"] = self.VServerGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExtSlbId") && dict["ExtSlbId"] != nil {
                self.extSlbId = dict["ExtSlbId"] as! String
            }
            if dict.keys.contains("ExtSlbIp") && dict["ExtSlbIp"] != nil {
                self.extSlbIp = dict["ExtSlbIp"] as! String
            }
            if dict.keys.contains("ExtSlbName") && dict["ExtSlbName"] != nil {
                self.extSlbName = dict["ExtSlbName"] as! String
            }
            if dict.keys.contains("ExtVServerGroupId") && dict["ExtVServerGroupId"] != nil {
                self.extVServerGroupId = dict["ExtVServerGroupId"] as! String
            }
            if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbIp") && dict["SlbIp"] != nil {
                self.slbIp = dict["SlbIp"] as! String
            }
            if dict.keys.contains("SlbName") && dict["SlbName"] != nil {
                self.slbName = dict["SlbName"] as! String
            }
            if dict.keys.contains("SlbPort") && dict["SlbPort"] != nil {
                self.slbPort = dict["SlbPort"] as! Int32
            }
            if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                self.VServerGroupId = dict["VServerGroupId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: BindSlbResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = BindSlbResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BindSlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeDeployGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public var forceStatus: Bool?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        if self.forceStatus != nil {
            map["ForceStatus"] = self.forceStatus!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EccInfo") && dict["EccInfo"] != nil {
            self.eccInfo = dict["EccInfo"] as! String
        }
        if dict.keys.contains("ForceStatus") && dict["ForceStatus"] != nil {
            self.forceStatus = dict["ForceStatus"] as! Bool
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class ChangeDeployGroupResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeDeployGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeDeployGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeDeployGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ContinuePipelineRequest : Tea.TeaModel {
    public var confirm: Bool?

    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confirm != nil {
            map["Confirm"] = self.confirm!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Confirm") && dict["Confirm"] != nil {
            self.confirm = dict["Confirm"] as! Bool
        }
        if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class ContinuePipelineResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ContinuePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ContinuePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ContinuePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConvertK8sResourceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var namespace: String?

    public var resourceName: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.resourceName != nil {
            map["ResourceName"] = self.resourceName!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("ResourceName") && dict["ResourceName"] != nil {
            self.resourceName = dict["ResourceName"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ConvertK8sResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConvertK8sResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConvertK8sResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConvertK8sResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingBehaviour: String?

    public var scalingRuleEnable: Bool?

    public var scalingRuleMetric: String?

    public var scalingRuleName: String?

    public var scalingRuleTimer: String?

    public var scalingRuleTrigger: String?

    public var scalingRuleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingBehaviour != nil {
            map["ScalingBehaviour"] = self.scalingBehaviour!
        }
        if self.scalingRuleEnable != nil {
            map["ScalingRuleEnable"] = self.scalingRuleEnable!
        }
        if self.scalingRuleMetric != nil {
            map["ScalingRuleMetric"] = self.scalingRuleMetric!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleTimer != nil {
            map["ScalingRuleTimer"] = self.scalingRuleTimer!
        }
        if self.scalingRuleTrigger != nil {
            map["ScalingRuleTrigger"] = self.scalingRuleTrigger!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ScalingBehaviour") && dict["ScalingBehaviour"] != nil {
            self.scalingBehaviour = dict["ScalingBehaviour"] as! String
        }
        if dict.keys.contains("ScalingRuleEnable") && dict["ScalingRuleEnable"] != nil {
            self.scalingRuleEnable = dict["ScalingRuleEnable"] as! Bool
        }
        if dict.keys.contains("ScalingRuleMetric") && dict["ScalingRuleMetric"] != nil {
            self.scalingRuleMetric = dict["ScalingRuleMetric"] as! String
        }
        if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("ScalingRuleTimer") && dict["ScalingRuleTimer"] != nil {
            self.scalingRuleTimer = dict["ScalingRuleTimer"] as! String
        }
        if dict.keys.contains("ScalingRuleTrigger") && dict["ScalingRuleTrigger"] != nil {
            self.scalingRuleTrigger = dict["ScalingRuleTrigger"] as! String
        }
        if dict.keys.contains("ScalingRuleType") && dict["ScalingRuleType"] != nil {
            self.scalingRuleType = dict["ScalingRuleType"] as! String
        }
    }
}

public class CreateApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class AppScalingRule : Tea.TeaModel {
        public class Behaviour : Tea.TeaModel {
            public class ScaleDown : Tea.TeaModel {
                public class Policies : Tea.TeaModel {
                    public var periodSeconds: Int32?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.periodSeconds != nil {
                            map["PeriodSeconds"] = self.periodSeconds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                            self.periodSeconds = dict["PeriodSeconds"] as! Int32
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var policies: [CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies]?

                public var selectPolicy: String?

                public var stabilizationWindowSeconds: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.policies != nil {
                        var tmp : [Any] = []
                        for k in self.policies! {
                            tmp.append(k.toMap())
                        }
                        map["Policies"] = tmp
                    }
                    if self.selectPolicy != nil {
                        map["SelectPolicy"] = self.selectPolicy!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Policies") && dict["Policies"] != nil {
                        var tmp : [CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies] = []
                        for v in dict["Policies"] as! [Any] {
                            var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.policies = tmp
                    }
                    if dict.keys.contains("SelectPolicy") && dict["SelectPolicy"] != nil {
                        self.selectPolicy = dict["SelectPolicy"] as! String
                    }
                    if dict.keys.contains("StabilizationWindowSeconds") && dict["StabilizationWindowSeconds"] != nil {
                        self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int32
                    }
                }
            }
            public class ScaleUp : Tea.TeaModel {
                public class Policies : Tea.TeaModel {
                    public var periodSeconds: Int32?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.periodSeconds != nil {
                            map["PeriodSeconds"] = self.periodSeconds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                            self.periodSeconds = dict["PeriodSeconds"] as! Int32
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var policies: [CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies]?

                public var selectPolicy: String?

                public var stabilizationWindowSeconds: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.policies != nil {
                        var tmp : [Any] = []
                        for k in self.policies! {
                            tmp.append(k.toMap())
                        }
                        map["Policies"] = tmp
                    }
                    if self.selectPolicy != nil {
                        map["SelectPolicy"] = self.selectPolicy!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Policies") && dict["Policies"] != nil {
                        var tmp : [CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies] = []
                        for v in dict["Policies"] as! [Any] {
                            var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.policies = tmp
                    }
                    if dict.keys.contains("SelectPolicy") && dict["SelectPolicy"] != nil {
                        self.selectPolicy = dict["SelectPolicy"] as! String
                    }
                    if dict.keys.contains("StabilizationWindowSeconds") && dict["StabilizationWindowSeconds"] != nil {
                        self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int32
                    }
                }
            }
            public var scaleDown: CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown?

            public var scaleUp: CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scaleDown?.validate()
                try self.scaleUp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scaleDown != nil {
                    map["ScaleDown"] = self.scaleDown?.toMap()
                }
                if self.scaleUp != nil {
                    map["ScaleUp"] = self.scaleUp?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ScaleDown") && dict["ScaleDown"] != nil {
                    var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown()
                    model.fromMap(dict["ScaleDown"] as! [String: Any])
                    self.scaleDown = model
                }
                if dict.keys.contains("ScaleUp") && dict["ScaleUp"] != nil {
                    var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp()
                    model.fromMap(dict["ScaleUp"] as! [String: Any])
                    self.scaleUp = model
                }
            }
        }
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetricTargetAverageUtilization") && dict["MetricTargetAverageUtilization"] != nil {
                        self.metricTargetAverageUtilization = dict["MetricTargetAverageUtilization"] as! Int32
                    }
                    if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
                        self.metricType = dict["MetricType"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("Metrics") && dict["Metrics"] != nil {
                    var tmp : [CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics] = []
                    for v in dict["Metrics"] as! [Any] {
                        var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.metrics = tmp
                }
                if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public class Triggers : Tea.TeaModel {
                public var metaData: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metaData != nil {
                        map["MetaData"] = self.metaData!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetaData") && dict["MetaData"] != nil {
                        self.metaData = dict["MetaData"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var minReplicas: Int32?

            public var triggers: [CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.triggers != nil {
                    var tmp : [Any] = []
                    for k in self.triggers! {
                        tmp.append(k.toMap())
                    }
                    map["Triggers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
                if dict.keys.contains("Triggers") && dict["Triggers"] != nil {
                    var tmp : [CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers] = []
                    for v in dict["Triggers"] as! [Any] {
                        var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.triggers = tmp
                }
            }
        }
        public var appId: String?

        public var behaviour: CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var maxReplicas: Int32?

        public var metric: CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric?

        public var minReplicas: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var trigger: CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.behaviour?.validate()
            try self.metric?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.behaviour != nil {
                map["Behaviour"] = self.behaviour?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReplicas != nil {
                map["MinReplicas"] = self.minReplicas!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Behaviour") && dict["Behaviour"] != nil {
                var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour()
                model.fromMap(dict["Behaviour"] as! [String: Any])
                self.behaviour = model
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("LastDisableTime") && dict["LastDisableTime"] != nil {
                self.lastDisableTime = dict["LastDisableTime"] as! Int64
            }
            if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                self.maxReplicas = dict["MaxReplicas"] as! Int32
            }
            if dict.keys.contains("Metric") && dict["Metric"] != nil {
                var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric()
                model.fromMap(dict["Metric"] as! [String: Any])
                self.metric = model
            }
            if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                self.minReplicas = dict["MinReplicas"] as! Int32
            }
            if dict.keys.contains("ScaleRuleEnabled") && dict["ScaleRuleEnabled"] != nil {
                self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
            }
            if dict.keys.contains("ScaleRuleName") && dict["ScaleRuleName"] != nil {
                self.scaleRuleName = dict["ScaleRuleName"] as! String
            }
            if dict.keys.contains("ScaleRuleType") && dict["ScaleRuleType"] != nil {
                self.scaleRuleType = dict["ScaleRuleType"] as! String
            }
            if dict.keys.contains("Trigger") && dict["Trigger"] != nil {
                var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger()
                model.fromMap(dict["Trigger"] as! [String: Any])
                self.trigger = model
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var appScalingRule: CreateApplicationScalingRuleResponseBody.AppScalingRule?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRule != nil {
            map["AppScalingRule"] = self.appScalingRule?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppScalingRule") && dict["AppScalingRule"] != nil {
            var model = CreateApplicationScalingRuleResponseBody.AppScalingRule()
            model.fromMap(dict["AppScalingRule"] as! [String: Any])
            self.appScalingRule = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateConfigTemplateRequest : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var format: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Format") && dict["Format"] != nil {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class CreateConfigTemplateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: CreateConfigTemplateResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateConfigTemplateResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateConfigTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConfigTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateConfigTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIDCImportCommandRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class CreateIDCImportCommandResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIDCImportCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIDCImportCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIDCImportCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateK8sConfigMapRequest : Tea.TeaModel {
    public var clusterId: String?

    public var data: [String: Any]?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String: Any]
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class CreateK8sConfigMapResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateK8sConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateK8sConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateK8sConfigMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateK8sIngressRuleRequest : Tea.TeaModel {
    public var annotations: String?

    public var clusterId: String?

    public var ingressConf: [String: Any]?

    public var labels: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ingressConf != nil {
            map["IngressConf"] = self.ingressConf!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("IngressConf") && dict["IngressConf"] != nil {
            self.ingressConf = dict["IngressConf"] as! [String: Any]
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class CreateK8sIngressRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
    }
}

public class CreateK8sIngressRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateK8sIngressRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateK8sIngressRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateK8sSecretRequest : Tea.TeaModel {
    public var base64Encoded: Bool?

    public var certId: String?

    public var certRegionId: String?

    public var clusterId: String?

    public var data: String?

    public var name: String?

    public var namespace: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.base64Encoded != nil {
            map["Base64Encoded"] = self.base64Encoded!
        }
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certRegionId != nil {
            map["CertRegionId"] = self.certRegionId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Base64Encoded") && dict["Base64Encoded"] != nil {
            self.base64Encoded = dict["Base64Encoded"] as! Bool
        }
        if dict.keys.contains("CertId") && dict["CertId"] != nil {
            self.certId = dict["CertId"] as! String
        }
        if dict.keys.contains("CertRegionId") && dict["CertRegionId"] != nil {
            self.certRegionId = dict["CertRegionId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateK8sSecretResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateK8sSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateK8sSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateK8sSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateK8sServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var externalTrafficPolicy: String?

    public var name: String?

    public var servicePorts: [String: Any]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.externalTrafficPolicy != nil {
            map["ExternalTrafficPolicy"] = self.externalTrafficPolicy!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.servicePorts != nil {
            map["ServicePorts"] = self.servicePorts!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ExternalTrafficPolicy") && dict["ExternalTrafficPolicy"] != nil {
            self.externalTrafficPolicy = dict["ExternalTrafficPolicy"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServicePorts") && dict["ServicePorts"] != nil {
            self.servicePorts = dict["ServicePorts"] as! [String: Any]
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateK8sServiceResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateK8sServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateK8sServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateK8sServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DeleteApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
    }
}

public class DeleteApplicationScalingRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var mode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! Int32
        }
    }
}

public class DeleteClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteClusterMemberRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterMemberId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterMemberId != nil {
            map["ClusterMemberId"] = self.clusterMemberId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterMemberId") && dict["ClusterMemberId"] != nil {
            self.clusterMemberId = dict["ClusterMemberId"] as! String
        }
    }
}

public class DeleteClusterMemberResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteClusterMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClusterMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteClusterMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteConfigTemplateRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteConfigTemplateResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteConfigTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConfigTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteConfigTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDeployGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class DeleteDeployGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDeployGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDeployGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDeployGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEcuRequest : Tea.TeaModel {
    public var ecuId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ecuId != nil {
            map["EcuId"] = self.ecuId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
            self.ecuId = dict["EcuId"] as! String
        }
    }
}

public class DeleteEcuResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEcuResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Force") && dict["Force"] != nil {
            self.force = dict["Force"] as! Bool
        }
    }
}

public class DeleteK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteK8sApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteK8sConfigMapRequest : Tea.TeaModel {
    public var clusterId: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteK8sConfigMapResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteK8sConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteK8sConfigMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteK8sIngressRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteK8sIngressRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
    }
}

public class DeleteK8sIngressRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sIngressRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteK8sIngressRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteK8sSecretRequest : Tea.TeaModel {
    public var clusterId: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteK8sSecretResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteK8sSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteK8sSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteK8sServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class DeleteK8sServiceResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteK8sServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteK8sServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLogPathRequest : Tea.TeaModel {
    public var appId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
    }
}

public class DeleteLogPathResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLogPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLogPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRoleRequest : Tea.TeaModel {
    public var roleId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
            self.roleId = dict["RoleId"] as! Int32
        }
    }
}

public class DeleteRoleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteServiceGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
    }
}

public class DeleteServiceGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSwimmingLaneRequest : Tea.TeaModel {
    public var laneId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaneId") && dict["LaneId"] != nil {
            self.laneId = dict["LaneId"] as! Int64
        }
    }
}

public class DeleteSwimmingLaneResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteUserDefineRegionRequest : Tea.TeaModel {
    public var id: Int64?

    public var regionTag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionTag != nil {
            map["RegionTag"] = self.regionTag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RegionTag") && dict["RegionTag"] != nil {
            self.regionTag = dict["RegionTag"] as! String
        }
    }
}

public class DeleteUserDefineRegionResponseBody : Tea.TeaModel {
    public class RegionDefine : Tea.TeaModel {
        public var belongRegion: String?

        public var description_: String?

        public var id: Int64?

        public var regionId: String?

        public var regionName: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.belongRegion != nil {
                map["BelongRegion"] = self.belongRegion!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BelongRegion") && dict["BelongRegion"] != nil {
                self.belongRegion = dict["BelongRegion"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regionDefine: DeleteUserDefineRegionResponseBody.RegionDefine?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regionDefine?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regionDefine != nil {
            map["RegionDefine"] = self.regionDefine?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RegionDefine") && dict["RegionDefine"] != nil {
            var model = DeleteUserDefineRegionResponseBody.RegionDefine()
            model.fromMap(dict["RegionDefine"] as! [String: Any])
            self.regionDefine = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteUserDefineRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserDefineRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteUserDefineRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeployApplicationRequest : Tea.TeaModel {
    public var appEnv: String?

    public var appId: String?

    public var batch: Int32?

    public var batchWaitTime: Int32?

    public var buildPackId: Int64?

    public var componentIds: String?

    public var deployType: String?

    public var desc: String?

    public var gray: Bool?

    public var groupId: String?

    public var imageUrl: String?

    public var packageVersion: String?

    public var releaseType: Int64?

    public var trafficControlStrategy: String?

    public var warUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appEnv != nil {
            map["AppEnv"] = self.appEnv!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.batch != nil {
            map["Batch"] = self.batch!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        if self.componentIds != nil {
            map["ComponentIds"] = self.componentIds!
        }
        if self.deployType != nil {
            map["DeployType"] = self.deployType!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.gray != nil {
            map["Gray"] = self.gray!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.releaseType != nil {
            map["ReleaseType"] = self.releaseType!
        }
        if self.trafficControlStrategy != nil {
            map["TrafficControlStrategy"] = self.trafficControlStrategy!
        }
        if self.warUrl != nil {
            map["WarUrl"] = self.warUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppEnv") && dict["AppEnv"] != nil {
            self.appEnv = dict["AppEnv"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Batch") && dict["Batch"] != nil {
            self.batch = dict["Batch"] as! Int32
        }
        if dict.keys.contains("BatchWaitTime") && dict["BatchWaitTime"] != nil {
            self.batchWaitTime = dict["BatchWaitTime"] as! Int32
        }
        if dict.keys.contains("BuildPackId") && dict["BuildPackId"] != nil {
            self.buildPackId = dict["BuildPackId"] as! Int64
        }
        if dict.keys.contains("ComponentIds") && dict["ComponentIds"] != nil {
            self.componentIds = dict["ComponentIds"] as! String
        }
        if dict.keys.contains("DeployType") && dict["DeployType"] != nil {
            self.deployType = dict["DeployType"] as! String
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Gray") && dict["Gray"] != nil {
            self.gray = dict["Gray"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ImageUrl") && dict["ImageUrl"] != nil {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("PackageVersion") && dict["PackageVersion"] != nil {
            self.packageVersion = dict["PackageVersion"] as! String
        }
        if dict.keys.contains("ReleaseType") && dict["ReleaseType"] != nil {
            self.releaseType = dict["ReleaseType"] as! Int64
        }
        if dict.keys.contains("TrafficControlStrategy") && dict["TrafficControlStrategy"] != nil {
            self.trafficControlStrategy = dict["TrafficControlStrategy"] as! String
        }
        if dict.keys.contains("WarUrl") && dict["WarUrl"] != nil {
            self.warUrl = dict["WarUrl"] as! String
        }
    }
}

public class DeployApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeployApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeployApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeployK8sApplicationRequest : Tea.TeaModel {
    public var annotations: String?

    public var appId: String?

    public var args: String?

    public var batchTimeout: Int32?

    public var batchWaitTime: Int32?

    public var buildPackId: String?

    public var canaryRuleId: String?

    public var changeOrderDesc: String?

    public var command: String?

    public var configMountDescs: String?

    public var cpuLimit: Int32?

    public var cpuRequest: Int32?

    public var customAffinity: String?

    public var customTolerations: String?

    public var deployAcrossNodes: String?

    public var deployAcrossZones: String?

    public var edasContainerVersion: String?

    public var emptyDirs: String?

    public var enableAhas: Bool?

    public var enableEmptyPushReject: Bool?

    public var enableLosslessRule: Bool?

    public var envFroms: String?

    public var envs: String?

    public var image: String?

    public var imagePlatforms: String?

    public var imageTag: String?

    public var initContainers: String?

    public var JDK: String?

    public var javaStartUpConfig: String?

    public var labels: String?

    public var limitEphemeralStorage: Int32?

    public var liveness: String?

    public var localVolume: String?

    public var losslessRuleAligned: Bool?

    public var losslessRuleDelayTime: Int32?

    public var losslessRuleFuncType: Int32?

    public var losslessRuleRelated: Bool?

    public var losslessRuleWarmupTime: Int32?

    public var mcpuLimit: Int32?

    public var mcpuRequest: Int32?

    public var memoryLimit: Int32?

    public var memoryRequest: Int32?

    public var mountDescs: String?

    public var nasId: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var packageVersionId: String?

    public var postStart: String?

    public var preStop: String?

    public var pvcMountDescs: String?

    public var readiness: String?

    public var replicas: Int32?

    public var requestsEphemeralStorage: Int32?

    public var runtimeClassName: String?

    public var sidecars: String?

    public var slsConfigs: String?

    public var startup: String?

    public var storageType: String?

    public var terminateGracePeriod: Int32?

    public var trafficControlStrategy: String?

    public var updateStrategy: String?

    public var uriEncoding: String?

    public var useBodyEncoding: Bool?

    public var userBaseImageUrl: String?

    public var volumesStr: String?

    public var webContainer: String?

    public var webContainerConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.args != nil {
            map["Args"] = self.args!
        }
        if self.batchTimeout != nil {
            map["BatchTimeout"] = self.batchTimeout!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        if self.canaryRuleId != nil {
            map["CanaryRuleId"] = self.canaryRuleId!
        }
        if self.changeOrderDesc != nil {
            map["ChangeOrderDesc"] = self.changeOrderDesc!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.configMountDescs != nil {
            map["ConfigMountDescs"] = self.configMountDescs!
        }
        if self.cpuLimit != nil {
            map["CpuLimit"] = self.cpuLimit!
        }
        if self.cpuRequest != nil {
            map["CpuRequest"] = self.cpuRequest!
        }
        if self.customAffinity != nil {
            map["CustomAffinity"] = self.customAffinity!
        }
        if self.customTolerations != nil {
            map["CustomTolerations"] = self.customTolerations!
        }
        if self.deployAcrossNodes != nil {
            map["DeployAcrossNodes"] = self.deployAcrossNodes!
        }
        if self.deployAcrossZones != nil {
            map["DeployAcrossZones"] = self.deployAcrossZones!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.emptyDirs != nil {
            map["EmptyDirs"] = self.emptyDirs!
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        if self.enableEmptyPushReject != nil {
            map["EnableEmptyPushReject"] = self.enableEmptyPushReject!
        }
        if self.enableLosslessRule != nil {
            map["EnableLosslessRule"] = self.enableLosslessRule!
        }
        if self.envFroms != nil {
            map["EnvFroms"] = self.envFroms!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.image != nil {
            map["Image"] = self.image!
        }
        if self.imagePlatforms != nil {
            map["ImagePlatforms"] = self.imagePlatforms!
        }
        if self.imageTag != nil {
            map["ImageTag"] = self.imageTag!
        }
        if self.initContainers != nil {
            map["InitContainers"] = self.initContainers!
        }
        if self.JDK != nil {
            map["JDK"] = self.JDK!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.limitEphemeralStorage != nil {
            map["LimitEphemeralStorage"] = self.limitEphemeralStorage!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.localVolume != nil {
            map["LocalVolume"] = self.localVolume!
        }
        if self.losslessRuleAligned != nil {
            map["LosslessRuleAligned"] = self.losslessRuleAligned!
        }
        if self.losslessRuleDelayTime != nil {
            map["LosslessRuleDelayTime"] = self.losslessRuleDelayTime!
        }
        if self.losslessRuleFuncType != nil {
            map["LosslessRuleFuncType"] = self.losslessRuleFuncType!
        }
        if self.losslessRuleRelated != nil {
            map["LosslessRuleRelated"] = self.losslessRuleRelated!
        }
        if self.losslessRuleWarmupTime != nil {
            map["LosslessRuleWarmupTime"] = self.losslessRuleWarmupTime!
        }
        if self.mcpuLimit != nil {
            map["McpuLimit"] = self.mcpuLimit!
        }
        if self.mcpuRequest != nil {
            map["McpuRequest"] = self.mcpuRequest!
        }
        if self.memoryLimit != nil {
            map["MemoryLimit"] = self.memoryLimit!
        }
        if self.memoryRequest != nil {
            map["MemoryRequest"] = self.memoryRequest!
        }
        if self.mountDescs != nil {
            map["MountDescs"] = self.mountDescs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.packageVersionId != nil {
            map["PackageVersionId"] = self.packageVersionId!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.pvcMountDescs != nil {
            map["PvcMountDescs"] = self.pvcMountDescs!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.requestsEphemeralStorage != nil {
            map["RequestsEphemeralStorage"] = self.requestsEphemeralStorage!
        }
        if self.runtimeClassName != nil {
            map["RuntimeClassName"] = self.runtimeClassName!
        }
        if self.sidecars != nil {
            map["Sidecars"] = self.sidecars!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.startup != nil {
            map["Startup"] = self.startup!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        if self.terminateGracePeriod != nil {
            map["TerminateGracePeriod"] = self.terminateGracePeriod!
        }
        if self.trafficControlStrategy != nil {
            map["TrafficControlStrategy"] = self.trafficControlStrategy!
        }
        if self.updateStrategy != nil {
            map["UpdateStrategy"] = self.updateStrategy!
        }
        if self.uriEncoding != nil {
            map["UriEncoding"] = self.uriEncoding!
        }
        if self.useBodyEncoding != nil {
            map["UseBodyEncoding"] = self.useBodyEncoding!
        }
        if self.userBaseImageUrl != nil {
            map["UserBaseImageUrl"] = self.userBaseImageUrl!
        }
        if self.volumesStr != nil {
            map["VolumesStr"] = self.volumesStr!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        if self.webContainerConfig != nil {
            map["WebContainerConfig"] = self.webContainerConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Args") && dict["Args"] != nil {
            self.args = dict["Args"] as! String
        }
        if dict.keys.contains("BatchTimeout") && dict["BatchTimeout"] != nil {
            self.batchTimeout = dict["BatchTimeout"] as! Int32
        }
        if dict.keys.contains("BatchWaitTime") && dict["BatchWaitTime"] != nil {
            self.batchWaitTime = dict["BatchWaitTime"] as! Int32
        }
        if dict.keys.contains("BuildPackId") && dict["BuildPackId"] != nil {
            self.buildPackId = dict["BuildPackId"] as! String
        }
        if dict.keys.contains("CanaryRuleId") && dict["CanaryRuleId"] != nil {
            self.canaryRuleId = dict["CanaryRuleId"] as! String
        }
        if dict.keys.contains("ChangeOrderDesc") && dict["ChangeOrderDesc"] != nil {
            self.changeOrderDesc = dict["ChangeOrderDesc"] as! String
        }
        if dict.keys.contains("Command") && dict["Command"] != nil {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("ConfigMountDescs") && dict["ConfigMountDescs"] != nil {
            self.configMountDescs = dict["ConfigMountDescs"] as! String
        }
        if dict.keys.contains("CpuLimit") && dict["CpuLimit"] != nil {
            self.cpuLimit = dict["CpuLimit"] as! Int32
        }
        if dict.keys.contains("CpuRequest") && dict["CpuRequest"] != nil {
            self.cpuRequest = dict["CpuRequest"] as! Int32
        }
        if dict.keys.contains("CustomAffinity") && dict["CustomAffinity"] != nil {
            self.customAffinity = dict["CustomAffinity"] as! String
        }
        if dict.keys.contains("CustomTolerations") && dict["CustomTolerations"] != nil {
            self.customTolerations = dict["CustomTolerations"] as! String
        }
        if dict.keys.contains("DeployAcrossNodes") && dict["DeployAcrossNodes"] != nil {
            self.deployAcrossNodes = dict["DeployAcrossNodes"] as! String
        }
        if dict.keys.contains("DeployAcrossZones") && dict["DeployAcrossZones"] != nil {
            self.deployAcrossZones = dict["DeployAcrossZones"] as! String
        }
        if dict.keys.contains("EdasContainerVersion") && dict["EdasContainerVersion"] != nil {
            self.edasContainerVersion = dict["EdasContainerVersion"] as! String
        }
        if dict.keys.contains("EmptyDirs") && dict["EmptyDirs"] != nil {
            self.emptyDirs = dict["EmptyDirs"] as! String
        }
        if dict.keys.contains("EnableAhas") && dict["EnableAhas"] != nil {
            self.enableAhas = dict["EnableAhas"] as! Bool
        }
        if dict.keys.contains("EnableEmptyPushReject") && dict["EnableEmptyPushReject"] != nil {
            self.enableEmptyPushReject = dict["EnableEmptyPushReject"] as! Bool
        }
        if dict.keys.contains("EnableLosslessRule") && dict["EnableLosslessRule"] != nil {
            self.enableLosslessRule = dict["EnableLosslessRule"] as! Bool
        }
        if dict.keys.contains("EnvFroms") && dict["EnvFroms"] != nil {
            self.envFroms = dict["EnvFroms"] as! String
        }
        if dict.keys.contains("Envs") && dict["Envs"] != nil {
            self.envs = dict["Envs"] as! String
        }
        if dict.keys.contains("Image") && dict["Image"] != nil {
            self.image = dict["Image"] as! String
        }
        if dict.keys.contains("ImagePlatforms") && dict["ImagePlatforms"] != nil {
            self.imagePlatforms = dict["ImagePlatforms"] as! String
        }
        if dict.keys.contains("ImageTag") && dict["ImageTag"] != nil {
            self.imageTag = dict["ImageTag"] as! String
        }
        if dict.keys.contains("InitContainers") && dict["InitContainers"] != nil {
            self.initContainers = dict["InitContainers"] as! String
        }
        if dict.keys.contains("JDK") && dict["JDK"] != nil {
            self.JDK = dict["JDK"] as! String
        }
        if dict.keys.contains("JavaStartUpConfig") && dict["JavaStartUpConfig"] != nil {
            self.javaStartUpConfig = dict["JavaStartUpConfig"] as! String
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("LimitEphemeralStorage") && dict["LimitEphemeralStorage"] != nil {
            self.limitEphemeralStorage = dict["LimitEphemeralStorage"] as! Int32
        }
        if dict.keys.contains("Liveness") && dict["Liveness"] != nil {
            self.liveness = dict["Liveness"] as! String
        }
        if dict.keys.contains("LocalVolume") && dict["LocalVolume"] != nil {
            self.localVolume = dict["LocalVolume"] as! String
        }
        if dict.keys.contains("LosslessRuleAligned") && dict["LosslessRuleAligned"] != nil {
            self.losslessRuleAligned = dict["LosslessRuleAligned"] as! Bool
        }
        if dict.keys.contains("LosslessRuleDelayTime") && dict["LosslessRuleDelayTime"] != nil {
            self.losslessRuleDelayTime = dict["LosslessRuleDelayTime"] as! Int32
        }
        if dict.keys.contains("LosslessRuleFuncType") && dict["LosslessRuleFuncType"] != nil {
            self.losslessRuleFuncType = dict["LosslessRuleFuncType"] as! Int32
        }
        if dict.keys.contains("LosslessRuleRelated") && dict["LosslessRuleRelated"] != nil {
            self.losslessRuleRelated = dict["LosslessRuleRelated"] as! Bool
        }
        if dict.keys.contains("LosslessRuleWarmupTime") && dict["LosslessRuleWarmupTime"] != nil {
            self.losslessRuleWarmupTime = dict["LosslessRuleWarmupTime"] as! Int32
        }
        if dict.keys.contains("McpuLimit") && dict["McpuLimit"] != nil {
            self.mcpuLimit = dict["McpuLimit"] as! Int32
        }
        if dict.keys.contains("McpuRequest") && dict["McpuRequest"] != nil {
            self.mcpuRequest = dict["McpuRequest"] as! Int32
        }
        if dict.keys.contains("MemoryLimit") && dict["MemoryLimit"] != nil {
            self.memoryLimit = dict["MemoryLimit"] as! Int32
        }
        if dict.keys.contains("MemoryRequest") && dict["MemoryRequest"] != nil {
            self.memoryRequest = dict["MemoryRequest"] as! Int32
        }
        if dict.keys.contains("MountDescs") && dict["MountDescs"] != nil {
            self.mountDescs = dict["MountDescs"] as! String
        }
        if dict.keys.contains("NasId") && dict["NasId"] != nil {
            self.nasId = dict["NasId"] as! String
        }
        if dict.keys.contains("PackageUrl") && dict["PackageUrl"] != nil {
            self.packageUrl = dict["PackageUrl"] as! String
        }
        if dict.keys.contains("PackageVersion") && dict["PackageVersion"] != nil {
            self.packageVersion = dict["PackageVersion"] as! String
        }
        if dict.keys.contains("PackageVersionId") && dict["PackageVersionId"] != nil {
            self.packageVersionId = dict["PackageVersionId"] as! String
        }
        if dict.keys.contains("PostStart") && dict["PostStart"] != nil {
            self.postStart = dict["PostStart"] as! String
        }
        if dict.keys.contains("PreStop") && dict["PreStop"] != nil {
            self.preStop = dict["PreStop"] as! String
        }
        if dict.keys.contains("PvcMountDescs") && dict["PvcMountDescs"] != nil {
            self.pvcMountDescs = dict["PvcMountDescs"] as! String
        }
        if dict.keys.contains("Readiness") && dict["Readiness"] != nil {
            self.readiness = dict["Readiness"] as! String
        }
        if dict.keys.contains("Replicas") && dict["Replicas"] != nil {
            self.replicas = dict["Replicas"] as! Int32
        }
        if dict.keys.contains("RequestsEphemeralStorage") && dict["RequestsEphemeralStorage"] != nil {
            self.requestsEphemeralStorage = dict["RequestsEphemeralStorage"] as! Int32
        }
        if dict.keys.contains("RuntimeClassName") && dict["RuntimeClassName"] != nil {
            self.runtimeClassName = dict["RuntimeClassName"] as! String
        }
        if dict.keys.contains("Sidecars") && dict["Sidecars"] != nil {
            self.sidecars = dict["Sidecars"] as! String
        }
        if dict.keys.contains("SlsConfigs") && dict["SlsConfigs"] != nil {
            self.slsConfigs = dict["SlsConfigs"] as! String
        }
        if dict.keys.contains("Startup") && dict["Startup"] != nil {
            self.startup = dict["Startup"] as! String
        }
        if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
            self.storageType = dict["StorageType"] as! String
        }
        if dict.keys.contains("TerminateGracePeriod") && dict["TerminateGracePeriod"] != nil {
            self.terminateGracePeriod = dict["TerminateGracePeriod"] as! Int32
        }
        if dict.keys.contains("TrafficControlStrategy") && dict["TrafficControlStrategy"] != nil {
            self.trafficControlStrategy = dict["TrafficControlStrategy"] as! String
        }
        if dict.keys.contains("UpdateStrategy") && dict["UpdateStrategy"] != nil {
            self.updateStrategy = dict["UpdateStrategy"] as! String
        }
        if dict.keys.contains("UriEncoding") && dict["UriEncoding"] != nil {
            self.uriEncoding = dict["UriEncoding"] as! String
        }
        if dict.keys.contains("UseBodyEncoding") && dict["UseBodyEncoding"] != nil {
            self.useBodyEncoding = dict["UseBodyEncoding"] as! Bool
        }
        if dict.keys.contains("UserBaseImageUrl") && dict["UserBaseImageUrl"] != nil {
            self.userBaseImageUrl = dict["UserBaseImageUrl"] as! String
        }
        if dict.keys.contains("VolumesStr") && dict["VolumesStr"] != nil {
            self.volumesStr = dict["VolumesStr"] as! String
        }
        if dict.keys.contains("WebContainer") && dict["WebContainer"] != nil {
            self.webContainer = dict["WebContainer"] as! String
        }
        if dict.keys.contains("WebContainerConfig") && dict["WebContainerConfig"] != nil {
            self.webContainerConfig = dict["WebContainerConfig"] as! String
        }
    }
}

public class DeployK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeployK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeployK8sApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppInstanceListRequest : Tea.TeaModel {
    public var appId: String?

    public var withNodeInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.withNodeInfo != nil {
            map["WithNodeInfo"] = self.withNodeInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("WithNodeInfo") && dict["WithNodeInfo"] != nil {
            self.withNodeInfo = dict["WithNodeInfo"] as! Bool
        }
    }
}

public class DescribeAppInstanceListResponseBody : Tea.TeaModel {
    public class InstanceList : Tea.TeaModel {
        public var appId: String?

        public var canary: Bool?

        public var groupId: String?

        public var groupName: String?

        public var nodeLabels: String?

        public var nodeName: String?

        public var podRaw: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.canary != nil {
                map["Canary"] = self.canary!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.nodeLabels != nil {
                map["NodeLabels"] = self.nodeLabels!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.podRaw != nil {
                map["PodRaw"] = self.podRaw!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Canary") && dict["Canary"] != nil {
                self.canary = dict["Canary"] as! Bool
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("NodeLabels") && dict["NodeLabels"] != nil {
                self.nodeLabels = dict["NodeLabels"] as! String
            }
            if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("PodRaw") && dict["PodRaw"] != nil {
                self.podRaw = dict["PodRaw"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var instanceList: [DescribeAppInstanceListResponseBody.InstanceList]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceList != nil {
            var tmp : [Any] = []
            for k in self.instanceList! {
                tmp.append(k.toMap())
            }
            map["InstanceList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("InstanceList") && dict["InstanceList"] != nil {
            var tmp : [DescribeAppInstanceListResponseBody.InstanceList] = []
            for v in dict["InstanceList"] as! [Any] {
                var model = DescribeAppInstanceListResponseBody.InstanceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceList = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAppInstanceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppInstanceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAppInstanceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationScalingRulesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DescribeApplicationScalingRulesResponseBody : Tea.TeaModel {
    public class AppScalingRules : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class Behaviour : Tea.TeaModel {
                public class ScaleDown : Tea.TeaModel {
                    public class Policies : Tea.TeaModel {
                        public var periodSeconds: Int32?

                        public var type: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.periodSeconds != nil {
                                map["PeriodSeconds"] = self.periodSeconds!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                                self.periodSeconds = dict["PeriodSeconds"] as! Int32
                            }
                            if dict.keys.contains("Type") && dict["Type"] != nil {
                                self.type = dict["Type"] as! String
                            }
                            if dict.keys.contains("Value") && dict["Value"] != nil {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var policies: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown.Policies]?

                    public var selectPolicy: String?

                    public var stabilizationWindowSeconds: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.policies != nil {
                            var tmp : [Any] = []
                            for k in self.policies! {
                                tmp.append(k.toMap())
                            }
                            map["Policies"] = tmp
                        }
                        if self.selectPolicy != nil {
                            map["SelectPolicy"] = self.selectPolicy!
                        }
                        if self.stabilizationWindowSeconds != nil {
                            map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Policies") && dict["Policies"] != nil {
                            var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown.Policies] = []
                            for v in dict["Policies"] as! [Any] {
                                var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown.Policies()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.policies = tmp
                        }
                        if dict.keys.contains("SelectPolicy") && dict["SelectPolicy"] != nil {
                            self.selectPolicy = dict["SelectPolicy"] as! String
                        }
                        if dict.keys.contains("StabilizationWindowSeconds") && dict["StabilizationWindowSeconds"] != nil {
                            self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int32
                        }
                    }
                }
                public class ScaleUp : Tea.TeaModel {
                    public class Policies : Tea.TeaModel {
                        public var periodSeconds: Int32?

                        public var type: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.periodSeconds != nil {
                                map["PeriodSeconds"] = self.periodSeconds!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                                self.periodSeconds = dict["PeriodSeconds"] as! Int32
                            }
                            if dict.keys.contains("Type") && dict["Type"] != nil {
                                self.type = dict["Type"] as! String
                            }
                            if dict.keys.contains("Value") && dict["Value"] != nil {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var policies: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp.Policies]?

                    public var selectPolicy: String?

                    public var stabilizationWindowSeconds: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.policies != nil {
                            var tmp : [Any] = []
                            for k in self.policies! {
                                tmp.append(k.toMap())
                            }
                            map["Policies"] = tmp
                        }
                        if self.selectPolicy != nil {
                            map["SelectPolicy"] = self.selectPolicy!
                        }
                        if self.stabilizationWindowSeconds != nil {
                            map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Policies") && dict["Policies"] != nil {
                            var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp.Policies] = []
                            for v in dict["Policies"] as! [Any] {
                                var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp.Policies()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.policies = tmp
                        }
                        if dict.keys.contains("SelectPolicy") && dict["SelectPolicy"] != nil {
                            self.selectPolicy = dict["SelectPolicy"] as! String
                        }
                        if dict.keys.contains("StabilizationWindowSeconds") && dict["StabilizationWindowSeconds"] != nil {
                            self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int32
                        }
                    }
                }
                public var scaleDown: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown?

                public var scaleUp: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.scaleDown?.validate()
                    try self.scaleUp?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.scaleDown != nil {
                        map["ScaleDown"] = self.scaleDown?.toMap()
                    }
                    if self.scaleUp != nil {
                        map["ScaleUp"] = self.scaleUp?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ScaleDown") && dict["ScaleDown"] != nil {
                        var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown()
                        model.fromMap(dict["ScaleDown"] as! [String: Any])
                        self.scaleDown = model
                    }
                    if dict.keys.contains("ScaleUp") && dict["ScaleUp"] != nil {
                        var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp()
                        model.fromMap(dict["ScaleUp"] as! [String: Any])
                        self.scaleUp = model
                    }
                }
            }
            public class Metric : Tea.TeaModel {
                public class Metrics : Tea.TeaModel {
                    public var metricTargetAverageUtilization: Int32?

                    public var metricType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.metricTargetAverageUtilization != nil {
                            map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                        }
                        if self.metricType != nil {
                            map["MetricType"] = self.metricType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MetricTargetAverageUtilization") && dict["MetricTargetAverageUtilization"] != nil {
                            self.metricTargetAverageUtilization = dict["MetricTargetAverageUtilization"] as! Int32
                        }
                        if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
                            self.metricType = dict["MetricType"] as! String
                        }
                    }
                }
                public var maxReplicas: Int32?

                public var metrics: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric.Metrics]?

                public var minReplicas: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.metrics != nil {
                        var tmp : [Any] = []
                        for k in self.metrics! {
                            tmp.append(k.toMap())
                        }
                        map["Metrics"] = tmp
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                        self.maxReplicas = dict["MaxReplicas"] as! Int32
                    }
                    if dict.keys.contains("Metrics") && dict["Metrics"] != nil {
                        var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric.Metrics] = []
                        for v in dict["Metrics"] as! [Any] {
                            var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric.Metrics()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.metrics = tmp
                    }
                    if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                        self.minReplicas = dict["MinReplicas"] as! Int32
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public class Triggers : Tea.TeaModel {
                    public var metaData: String?

                    public var name: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.metaData != nil {
                            map["MetaData"] = self.metaData!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MetaData") && dict["MetaData"] != nil {
                            self.metaData = dict["MetaData"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var maxReplicas: Int32?

                public var minReplicas: Int32?

                public var triggers: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger.Triggers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.triggers != nil {
                        var tmp : [Any] = []
                        for k in self.triggers! {
                            tmp.append(k.toMap())
                        }
                        map["Triggers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                        self.maxReplicas = dict["MaxReplicas"] as! Int32
                    }
                    if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                        self.minReplicas = dict["MinReplicas"] as! Int32
                    }
                    if dict.keys.contains("Triggers") && dict["Triggers"] != nil {
                        var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger.Triggers] = []
                        for v in dict["Triggers"] as! [Any] {
                            var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger.Triggers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.triggers = tmp
                    }
                }
            }
            public var appId: String?

            public var behaviour: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour?

            public var createTime: Int64?

            public var lastDisableTime: Int64?

            public var maxReplicas: Int32?

            public var metric: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric?

            public var minReplicas: Int32?

            public var scaleRuleEnabled: Bool?

            public var scaleRuleName: String?

            public var scaleRuleType: String?

            public var trigger: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.behaviour?.validate()
                try self.metric?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.behaviour != nil {
                    map["Behaviour"] = self.behaviour?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.lastDisableTime != nil {
                    map["LastDisableTime"] = self.lastDisableTime!
                }
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metric != nil {
                    map["Metric"] = self.metric?.toMap()
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.scaleRuleEnabled != nil {
                    map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
                }
                if self.scaleRuleName != nil {
                    map["ScaleRuleName"] = self.scaleRuleName!
                }
                if self.scaleRuleType != nil {
                    map["ScaleRuleType"] = self.scaleRuleType!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("Behaviour") && dict["Behaviour"] != nil {
                    var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour()
                    model.fromMap(dict["Behaviour"] as! [String: Any])
                    self.behaviour = model
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("LastDisableTime") && dict["LastDisableTime"] != nil {
                    self.lastDisableTime = dict["LastDisableTime"] as! Int64
                }
                if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("Metric") && dict["Metric"] != nil {
                    var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric()
                    model.fromMap(dict["Metric"] as! [String: Any])
                    self.metric = model
                }
                if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
                if dict.keys.contains("ScaleRuleEnabled") && dict["ScaleRuleEnabled"] != nil {
                    self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
                }
                if dict.keys.contains("ScaleRuleName") && dict["ScaleRuleName"] != nil {
                    self.scaleRuleName = dict["ScaleRuleName"] as! String
                }
                if dict.keys.contains("ScaleRuleType") && dict["ScaleRuleType"] != nil {
                    self.scaleRuleType = dict["ScaleRuleType"] as! String
                }
                if dict.keys.contains("Trigger") && dict["Trigger"] != nil {
                    var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger()
                    model.fromMap(dict["Trigger"] as! [String: Any])
                    self.trigger = model
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var result: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var appScalingRules: DescribeApplicationScalingRulesResponseBody.AppScalingRules?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRules != nil {
            map["AppScalingRules"] = self.appScalingRules?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppScalingRules") && dict["AppScalingRules"] != nil {
            var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules()
            model.fromMap(dict["AppScalingRules"] as! [String: Any])
            self.appScalingRules = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApplicationScalingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationScalingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApplicationScalingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
    }
}

public class DisableApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class AppScalingRule : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetricTargetAverageUtilization") && dict["MetricTargetAverageUtilization"] != nil {
                        self.metricTargetAverageUtilization = dict["MetricTargetAverageUtilization"] as! Int32
                    }
                    if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
                        self.metricType = dict["MetricType"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("Metrics") && dict["Metrics"] != nil {
                    var tmp : [DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics] = []
                    for v in dict["Metrics"] as! [Any] {
                        var model = DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.metrics = tmp
                }
                if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public class Triggers : Tea.TeaModel {
                public var metaData: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metaData != nil {
                        map["MetaData"] = self.metaData!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetaData") && dict["MetaData"] != nil {
                        self.metaData = dict["MetaData"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var minReplicas: Int32?

            public var triggers: [DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.triggers != nil {
                    var tmp : [Any] = []
                    for k in self.triggers! {
                        tmp.append(k.toMap())
                    }
                    map["Triggers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
                if dict.keys.contains("Triggers") && dict["Triggers"] != nil {
                    var tmp : [DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers] = []
                    for v in dict["Triggers"] as! [Any] {
                        var model = DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.triggers = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var maxReplicas: Int32?

        public var metric: DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric?

        public var minReplicas: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var trigger: DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReplicas != nil {
                map["MinReplicas"] = self.minReplicas!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("LastDisableTime") && dict["LastDisableTime"] != nil {
                self.lastDisableTime = dict["LastDisableTime"] as! Int64
            }
            if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                self.maxReplicas = dict["MaxReplicas"] as! Int32
            }
            if dict.keys.contains("Metric") && dict["Metric"] != nil {
                var model = DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric()
                model.fromMap(dict["Metric"] as! [String: Any])
                self.metric = model
            }
            if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                self.minReplicas = dict["MinReplicas"] as! Int32
            }
            if dict.keys.contains("ScaleRuleEnabled") && dict["ScaleRuleEnabled"] != nil {
                self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
            }
            if dict.keys.contains("ScaleRuleName") && dict["ScaleRuleName"] != nil {
                self.scaleRuleName = dict["ScaleRuleName"] as! String
            }
            if dict.keys.contains("ScaleRuleType") && dict["ScaleRuleType"] != nil {
                self.scaleRuleType = dict["ScaleRuleType"] as! String
            }
            if dict.keys.contains("Trigger") && dict["Trigger"] != nil {
                var model = DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger()
                model.fromMap(dict["Trigger"] as! [String: Any])
                self.trigger = model
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var appScalingRule: DisableApplicationScalingRuleResponseBody.AppScalingRule?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRule != nil {
            map["AppScalingRule"] = self.appScalingRule?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppScalingRule") && dict["AppScalingRule"] != nil {
            var model = DisableApplicationScalingRuleResponseBody.AppScalingRule()
            model.fromMap(dict["AppScalingRule"] as! [String: Any])
            self.appScalingRule = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
    }
}

public class EnableApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class AppScalingRule : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetricTargetAverageUtilization") && dict["MetricTargetAverageUtilization"] != nil {
                        self.metricTargetAverageUtilization = dict["MetricTargetAverageUtilization"] as! Int32
                    }
                    if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
                        self.metricType = dict["MetricType"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("Metrics") && dict["Metrics"] != nil {
                    var tmp : [EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics] = []
                    for v in dict["Metrics"] as! [Any] {
                        var model = EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.metrics = tmp
                }
                if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public class Triggers : Tea.TeaModel {
                public var metaData: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metaData != nil {
                        map["MetaData"] = self.metaData!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetaData") && dict["MetaData"] != nil {
                        self.metaData = dict["MetaData"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var minReplicas: Int32?

            public var triggers: [EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.triggers != nil {
                    var tmp : [Any] = []
                    for k in self.triggers! {
                        tmp.append(k.toMap())
                    }
                    map["Triggers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
                if dict.keys.contains("Triggers") && dict["Triggers"] != nil {
                    var tmp : [EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers] = []
                    for v in dict["Triggers"] as! [Any] {
                        var model = EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.triggers = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var maxReplicas: Int32?

        public var metric: EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric?

        public var minReplicas: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var trigger: EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReplicas != nil {
                map["MinReplicas"] = self.minReplicas!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("LastDisableTime") && dict["LastDisableTime"] != nil {
                self.lastDisableTime = dict["LastDisableTime"] as! Int64
            }
            if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                self.maxReplicas = dict["MaxReplicas"] as! Int32
            }
            if dict.keys.contains("Metric") && dict["Metric"] != nil {
                var model = EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric()
                model.fromMap(dict["Metric"] as! [String: Any])
                self.metric = model
            }
            if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                self.minReplicas = dict["MinReplicas"] as! Int32
            }
            if dict.keys.contains("ScaleRuleEnabled") && dict["ScaleRuleEnabled"] != nil {
                self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
            }
            if dict.keys.contains("ScaleRuleName") && dict["ScaleRuleName"] != nil {
                self.scaleRuleName = dict["ScaleRuleName"] as! String
            }
            if dict.keys.contains("ScaleRuleType") && dict["ScaleRuleType"] != nil {
                self.scaleRuleType = dict["ScaleRuleType"] as! String
            }
            if dict.keys.contains("Trigger") && dict["Trigger"] != nil {
                var model = EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger()
                model.fromMap(dict["Trigger"] as! [String: Any])
                self.trigger = model
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var appScalingRule: EnableApplicationScalingRuleResponseBody.AppScalingRule?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRule != nil {
            map["AppScalingRule"] = self.appScalingRule?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppScalingRule") && dict["AppScalingRule"] != nil {
            var model = EnableApplicationScalingRuleResponseBody.AppScalingRule()
            model.fromMap(dict["AppScalingRule"] as! [String: Any])
            self.appScalingRule = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppDeploymentRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class GetAppDeploymentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAppDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAppDeploymentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class GetApplicationResponseBody : Tea.TeaModel {
    public class Application : Tea.TeaModel {
        public var appId: String?

        public var appPhase: String?

        public var applicationType: String?

        public var buildPackageId: Int64?

        public var clusterId: String?

        public var clusterType: String?

        public var cpu: Int32?

        public var createTime: Int64?

        public var description_: String?

        public var dockerize: Bool?

        public var email: String?

        public var enablePortCheck: Bool?

        public var enableUrlCheck: Bool?

        public var extSlbId: String?

        public var extSlbIp: String?

        public var extSlbName: String?

        public var haveManageAccess: String?

        public var healthCheckUrl: String?

        public var instanceCount: Int32?

        public var memory: Int32?

        public var name: String?

        public var nameSpace: String?

        public var owner: String?

        public var port: Int32?

        public var regionId: String?

        public var resourceGroupId: String?

        public var runningInstanceCount: Int32?

        public var slbId: String?

        public var slbInfo: String?

        public var slbIp: String?

        public var slbName: String?

        public var slbPort: Int32?

        public var userId: String?

        public var workloadType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appPhase != nil {
                map["AppPhase"] = self.appPhase!
            }
            if self.applicationType != nil {
                map["ApplicationType"] = self.applicationType!
            }
            if self.buildPackageId != nil {
                map["BuildPackageId"] = self.buildPackageId!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dockerize != nil {
                map["Dockerize"] = self.dockerize!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.enablePortCheck != nil {
                map["EnablePortCheck"] = self.enablePortCheck!
            }
            if self.enableUrlCheck != nil {
                map["EnableUrlCheck"] = self.enableUrlCheck!
            }
            if self.extSlbId != nil {
                map["ExtSlbId"] = self.extSlbId!
            }
            if self.extSlbIp != nil {
                map["ExtSlbIp"] = self.extSlbIp!
            }
            if self.extSlbName != nil {
                map["ExtSlbName"] = self.extSlbName!
            }
            if self.haveManageAccess != nil {
                map["HaveManageAccess"] = self.haveManageAccess!
            }
            if self.healthCheckUrl != nil {
                map["HealthCheckUrl"] = self.healthCheckUrl!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nameSpace != nil {
                map["NameSpace"] = self.nameSpace!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.runningInstanceCount != nil {
                map["RunningInstanceCount"] = self.runningInstanceCount!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbInfo != nil {
                map["SlbInfo"] = self.slbInfo!
            }
            if self.slbIp != nil {
                map["SlbIp"] = self.slbIp!
            }
            if self.slbName != nil {
                map["SlbName"] = self.slbName!
            }
            if self.slbPort != nil {
                map["SlbPort"] = self.slbPort!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workloadType != nil {
                map["WorkloadType"] = self.workloadType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppPhase") && dict["AppPhase"] != nil {
                self.appPhase = dict["AppPhase"] as! String
            }
            if dict.keys.contains("ApplicationType") && dict["ApplicationType"] != nil {
                self.applicationType = dict["ApplicationType"] as! String
            }
            if dict.keys.contains("BuildPackageId") && dict["BuildPackageId"] != nil {
                self.buildPackageId = dict["BuildPackageId"] as! Int64
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Dockerize") && dict["Dockerize"] != nil {
                self.dockerize = dict["Dockerize"] as! Bool
            }
            if dict.keys.contains("Email") && dict["Email"] != nil {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("EnablePortCheck") && dict["EnablePortCheck"] != nil {
                self.enablePortCheck = dict["EnablePortCheck"] as! Bool
            }
            if dict.keys.contains("EnableUrlCheck") && dict["EnableUrlCheck"] != nil {
                self.enableUrlCheck = dict["EnableUrlCheck"] as! Bool
            }
            if dict.keys.contains("ExtSlbId") && dict["ExtSlbId"] != nil {
                self.extSlbId = dict["ExtSlbId"] as! String
            }
            if dict.keys.contains("ExtSlbIp") && dict["ExtSlbIp"] != nil {
                self.extSlbIp = dict["ExtSlbIp"] as! String
            }
            if dict.keys.contains("ExtSlbName") && dict["ExtSlbName"] != nil {
                self.extSlbName = dict["ExtSlbName"] as! String
            }
            if dict.keys.contains("HaveManageAccess") && dict["HaveManageAccess"] != nil {
                self.haveManageAccess = dict["HaveManageAccess"] as! String
            }
            if dict.keys.contains("HealthCheckUrl") && dict["HealthCheckUrl"] != nil {
                self.healthCheckUrl = dict["HealthCheckUrl"] as! String
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NameSpace") && dict["NameSpace"] != nil {
                self.nameSpace = dict["NameSpace"] as! String
            }
            if dict.keys.contains("Owner") && dict["Owner"] != nil {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RunningInstanceCount") && dict["RunningInstanceCount"] != nil {
                self.runningInstanceCount = dict["RunningInstanceCount"] as! Int32
            }
            if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbInfo") && dict["SlbInfo"] != nil {
                self.slbInfo = dict["SlbInfo"] as! String
            }
            if dict.keys.contains("SlbIp") && dict["SlbIp"] != nil {
                self.slbIp = dict["SlbIp"] as! String
            }
            if dict.keys.contains("SlbName") && dict["SlbName"] != nil {
                self.slbName = dict["SlbName"] as! String
            }
            if dict.keys.contains("SlbPort") && dict["SlbPort"] != nil {
                self.slbPort = dict["SlbPort"] as! Int32
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WorkloadType") && dict["WorkloadType"] != nil {
                self.workloadType = dict["WorkloadType"] as! String
            }
        }
    }
    public var application: GetApplicationResponseBody.Application?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.application?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.application != nil {
            map["Application"] = self.application?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Application") && dict["Application"] != nil {
            var model = GetApplicationResponseBody.Application()
            model.fromMap(dict["Application"] as! [String: Any])
            self.application = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetChangeOrderInfoRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
    }
}

public class GetChangeOrderInfoResponseBody : Tea.TeaModel {
    public class ChangeOrderInfo : Tea.TeaModel {
        public class PipelineInfoList : Tea.TeaModel {
            public class PipelineInfo : Tea.TeaModel {
                public class StageDetailList : Tea.TeaModel {
                    public class StageDetailDTO : Tea.TeaModel {
                        public class TaskList : Tea.TeaModel {
                            public class TaskInfoDTO : Tea.TeaModel {
                                public var retryType: Int32?

                                public var showManualIgnorance: Bool?

                                public var taskErrorCode: String?

                                public var taskErrorIgnorance: Int32?

                                public var taskErrorMessage: String?

                                public var taskId: String?

                                public var taskMessage: String?

                                public var taskName: String?

                                public var taskStatus: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.retryType != nil {
                                        map["RetryType"] = self.retryType!
                                    }
                                    if self.showManualIgnorance != nil {
                                        map["ShowManualIgnorance"] = self.showManualIgnorance!
                                    }
                                    if self.taskErrorCode != nil {
                                        map["TaskErrorCode"] = self.taskErrorCode!
                                    }
                                    if self.taskErrorIgnorance != nil {
                                        map["TaskErrorIgnorance"] = self.taskErrorIgnorance!
                                    }
                                    if self.taskErrorMessage != nil {
                                        map["TaskErrorMessage"] = self.taskErrorMessage!
                                    }
                                    if self.taskId != nil {
                                        map["TaskId"] = self.taskId!
                                    }
                                    if self.taskMessage != nil {
                                        map["TaskMessage"] = self.taskMessage!
                                    }
                                    if self.taskName != nil {
                                        map["TaskName"] = self.taskName!
                                    }
                                    if self.taskStatus != nil {
                                        map["TaskStatus"] = self.taskStatus!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("RetryType") && dict["RetryType"] != nil {
                                        self.retryType = dict["RetryType"] as! Int32
                                    }
                                    if dict.keys.contains("ShowManualIgnorance") && dict["ShowManualIgnorance"] != nil {
                                        self.showManualIgnorance = dict["ShowManualIgnorance"] as! Bool
                                    }
                                    if dict.keys.contains("TaskErrorCode") && dict["TaskErrorCode"] != nil {
                                        self.taskErrorCode = dict["TaskErrorCode"] as! String
                                    }
                                    if dict.keys.contains("TaskErrorIgnorance") && dict["TaskErrorIgnorance"] != nil {
                                        self.taskErrorIgnorance = dict["TaskErrorIgnorance"] as! Int32
                                    }
                                    if dict.keys.contains("TaskErrorMessage") && dict["TaskErrorMessage"] != nil {
                                        self.taskErrorMessage = dict["TaskErrorMessage"] as! String
                                    }
                                    if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                                        self.taskId = dict["TaskId"] as! String
                                    }
                                    if dict.keys.contains("TaskMessage") && dict["TaskMessage"] != nil {
                                        self.taskMessage = dict["TaskMessage"] as! String
                                    }
                                    if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                                        self.taskName = dict["TaskName"] as! String
                                    }
                                    if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                                        self.taskStatus = dict["TaskStatus"] as! String
                                    }
                                }
                            }
                            public var taskInfoDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList.TaskInfoDTO]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.taskInfoDTO != nil {
                                    var tmp : [Any] = []
                                    for k in self.taskInfoDTO! {
                                        tmp.append(k.toMap())
                                    }
                                    map["TaskInfoDTO"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("TaskInfoDTO") && dict["TaskInfoDTO"] != nil {
                                    var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList.TaskInfoDTO] = []
                                    for v in dict["TaskInfoDTO"] as! [Any] {
                                        var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList.TaskInfoDTO()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.taskInfoDTO = tmp
                                }
                            }
                        }
                        public var stageId: String?

                        public var stageName: String?

                        public var stageStatus: Int32?

                        public var taskList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.taskList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.stageId != nil {
                                map["StageId"] = self.stageId!
                            }
                            if self.stageName != nil {
                                map["StageName"] = self.stageName!
                            }
                            if self.stageStatus != nil {
                                map["StageStatus"] = self.stageStatus!
                            }
                            if self.taskList != nil {
                                map["TaskList"] = self.taskList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("StageId") && dict["StageId"] != nil {
                                self.stageId = dict["StageId"] as! String
                            }
                            if dict.keys.contains("StageName") && dict["StageName"] != nil {
                                self.stageName = dict["StageName"] as! String
                            }
                            if dict.keys.contains("StageStatus") && dict["StageStatus"] != nil {
                                self.stageStatus = dict["StageStatus"] as! Int32
                            }
                            if dict.keys.contains("TaskList") && dict["TaskList"] != nil {
                                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList()
                                model.fromMap(dict["TaskList"] as! [String: Any])
                                self.taskList = model
                            }
                        }
                    }
                    public var stageDetailDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.stageDetailDTO != nil {
                            var tmp : [Any] = []
                            for k in self.stageDetailDTO! {
                                tmp.append(k.toMap())
                            }
                            map["StageDetailDTO"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("StageDetailDTO") && dict["StageDetailDTO"] != nil {
                            var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO] = []
                            for v in dict["StageDetailDTO"] as! [Any] {
                                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.stageDetailDTO = tmp
                        }
                    }
                }
                public class StageList : Tea.TeaModel {
                    public class StageInfoDTO : Tea.TeaModel {
                        public class StageResultDTO : Tea.TeaModel {
                            public class InstanceDTOList : Tea.TeaModel {
                                public class InstanceDTO : Tea.TeaModel {
                                    public class InstanceStageDTOList : Tea.TeaModel {
                                        public class InstanceStageDTO : Tea.TeaModel {
                                            public var finishTime: String?

                                            public var stageId: String?

                                            public var stageMessage: String?

                                            public var stageName: String?

                                            public var startTime: String?

                                            public var status: Int32?

                                            public override init() {
                                                super.init()
                                            }

                                            public init(_ dict: [String: Any]) {
                                                super.init()
                                                self.fromMap(dict)
                                            }

                                            public override func validate() throws -> Void {
                                            }

                                            public override func toMap() -> [String : Any] {
                                                var map = super.toMap()
                                                if self.finishTime != nil {
                                                    map["FinishTime"] = self.finishTime!
                                                }
                                                if self.stageId != nil {
                                                    map["StageId"] = self.stageId!
                                                }
                                                if self.stageMessage != nil {
                                                    map["StageMessage"] = self.stageMessage!
                                                }
                                                if self.stageName != nil {
                                                    map["StageName"] = self.stageName!
                                                }
                                                if self.startTime != nil {
                                                    map["StartTime"] = self.startTime!
                                                }
                                                if self.status != nil {
                                                    map["Status"] = self.status!
                                                }
                                                return map
                                            }

                                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                                if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                                                    self.finishTime = dict["FinishTime"] as! String
                                                }
                                                if dict.keys.contains("StageId") && dict["StageId"] != nil {
                                                    self.stageId = dict["StageId"] as! String
                                                }
                                                if dict.keys.contains("StageMessage") && dict["StageMessage"] != nil {
                                                    self.stageMessage = dict["StageMessage"] as! String
                                                }
                                                if dict.keys.contains("StageName") && dict["StageName"] != nil {
                                                    self.stageName = dict["StageName"] as! String
                                                }
                                                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                                                    self.startTime = dict["StartTime"] as! String
                                                }
                                                if dict.keys.contains("Status") && dict["Status"] != nil {
                                                    self.status = dict["Status"] as! Int32
                                                }
                                            }
                                        }
                                        public var instanceStageDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList.InstanceStageDTO]?

                                        public override init() {
                                            super.init()
                                        }

                                        public init(_ dict: [String: Any]) {
                                            super.init()
                                            self.fromMap(dict)
                                        }

                                        public override func validate() throws -> Void {
                                        }

                                        public override func toMap() -> [String : Any] {
                                            var map = super.toMap()
                                            if self.instanceStageDTO != nil {
                                                var tmp : [Any] = []
                                                for k in self.instanceStageDTO! {
                                                    tmp.append(k.toMap())
                                                }
                                                map["InstanceStageDTO"] = tmp
                                            }
                                            return map
                                        }

                                        public override func fromMap(_ dict: [String: Any]) -> Void {
                                            if dict.keys.contains("InstanceStageDTO") && dict["InstanceStageDTO"] != nil {
                                                var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList.InstanceStageDTO] = []
                                                for v in dict["InstanceStageDTO"] as! [Any] {
                                                    var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList.InstanceStageDTO()
                                                    if v != nil {
                                                        model.fromMap(v as! [String: Any])
                                                    }
                                                    tmp.append(model)
                                                }
                                                self.instanceStageDTO = tmp
                                            }
                                        }
                                    }
                                    public var instanceIp: String?

                                    public var instanceName: String?

                                    public var instanceStageDTOList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList?

                                    public var podName: String?

                                    public var podStatus: String?

                                    public var status: Int32?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                        try self.instanceStageDTOList?.validate()
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.instanceIp != nil {
                                            map["InstanceIp"] = self.instanceIp!
                                        }
                                        if self.instanceName != nil {
                                            map["InstanceName"] = self.instanceName!
                                        }
                                        if self.instanceStageDTOList != nil {
                                            map["InstanceStageDTOList"] = self.instanceStageDTOList?.toMap()
                                        }
                                        if self.podName != nil {
                                            map["PodName"] = self.podName!
                                        }
                                        if self.podStatus != nil {
                                            map["PodStatus"] = self.podStatus!
                                        }
                                        if self.status != nil {
                                            map["Status"] = self.status!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("InstanceIp") && dict["InstanceIp"] != nil {
                                            self.instanceIp = dict["InstanceIp"] as! String
                                        }
                                        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                                            self.instanceName = dict["InstanceName"] as! String
                                        }
                                        if dict.keys.contains("InstanceStageDTOList") && dict["InstanceStageDTOList"] != nil {
                                            var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList()
                                            model.fromMap(dict["InstanceStageDTOList"] as! [String: Any])
                                            self.instanceStageDTOList = model
                                        }
                                        if dict.keys.contains("PodName") && dict["PodName"] != nil {
                                            self.podName = dict["PodName"] as! String
                                        }
                                        if dict.keys.contains("PodStatus") && dict["PodStatus"] != nil {
                                            self.podStatus = dict["PodStatus"] as! String
                                        }
                                        if dict.keys.contains("Status") && dict["Status"] != nil {
                                            self.status = dict["Status"] as! Int32
                                        }
                                    }
                                }
                                public var instanceDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.instanceDTO != nil {
                                        var tmp : [Any] = []
                                        for k in self.instanceDTO! {
                                            tmp.append(k.toMap())
                                        }
                                        map["InstanceDTO"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("InstanceDTO") && dict["InstanceDTO"] != nil {
                                        var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO] = []
                                        for v in dict["InstanceDTO"] as! [Any] {
                                            var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.instanceDTO = tmp
                                    }
                                }
                            }
                            public class ServiceStage : Tea.TeaModel {
                                public var message: String?

                                public var stageId: String?

                                public var stageName: String?

                                public var status: Int32?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.message != nil {
                                        map["Message"] = self.message!
                                    }
                                    if self.stageId != nil {
                                        map["StageId"] = self.stageId!
                                    }
                                    if self.stageName != nil {
                                        map["StageName"] = self.stageName!
                                    }
                                    if self.status != nil {
                                        map["Status"] = self.status!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Message") && dict["Message"] != nil {
                                        self.message = dict["Message"] as! String
                                    }
                                    if dict.keys.contains("StageId") && dict["StageId"] != nil {
                                        self.stageId = dict["StageId"] as! String
                                    }
                                    if dict.keys.contains("StageName") && dict["StageName"] != nil {
                                        self.stageName = dict["StageName"] as! String
                                    }
                                    if dict.keys.contains("Status") && dict["Status"] != nil {
                                        self.status = dict["Status"] as! Int32
                                    }
                                }
                            }
                            public var instanceDTOList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList?

                            public var serviceStage: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.ServiceStage?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.instanceDTOList?.validate()
                                try self.serviceStage?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.instanceDTOList != nil {
                                    map["InstanceDTOList"] = self.instanceDTOList?.toMap()
                                }
                                if self.serviceStage != nil {
                                    map["ServiceStage"] = self.serviceStage?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("InstanceDTOList") && dict["InstanceDTOList"] != nil {
                                    var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList()
                                    model.fromMap(dict["InstanceDTOList"] as! [String: Any])
                                    self.instanceDTOList = model
                                }
                                if dict.keys.contains("ServiceStage") && dict["ServiceStage"] != nil {
                                    var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.ServiceStage()
                                    model.fromMap(dict["ServiceStage"] as! [String: Any])
                                    self.serviceStage = model
                                }
                            }
                        }
                        public var stageId: String?

                        public var stageName: String?

                        public var stageResultDTO: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO?

                        public var status: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.stageResultDTO?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.stageId != nil {
                                map["StageId"] = self.stageId!
                            }
                            if self.stageName != nil {
                                map["StageName"] = self.stageName!
                            }
                            if self.stageResultDTO != nil {
                                map["StageResultDTO"] = self.stageResultDTO?.toMap()
                            }
                            if self.status != nil {
                                map["Status"] = self.status!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("StageId") && dict["StageId"] != nil {
                                self.stageId = dict["StageId"] as! String
                            }
                            if dict.keys.contains("StageName") && dict["StageName"] != nil {
                                self.stageName = dict["StageName"] as! String
                            }
                            if dict.keys.contains("StageResultDTO") && dict["StageResultDTO"] != nil {
                                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO()
                                model.fromMap(dict["StageResultDTO"] as! [String: Any])
                                self.stageResultDTO = model
                            }
                            if dict.keys.contains("Status") && dict["Status"] != nil {
                                self.status = dict["Status"] as! Int32
                            }
                        }
                    }
                    public var stageInfoDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.stageInfoDTO != nil {
                            var tmp : [Any] = []
                            for k in self.stageInfoDTO! {
                                tmp.append(k.toMap())
                            }
                            map["StageInfoDTO"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("StageInfoDTO") && dict["StageInfoDTO"] != nil {
                            var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO] = []
                            for v in dict["StageInfoDTO"] as! [Any] {
                                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.stageInfoDTO = tmp
                        }
                    }
                }
                public var pipelineId: String?

                public var pipelineName: String?

                public var pipelineStatus: Int32?

                public var stageDetailList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList?

                public var stageList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList?

                public var startTime: String?

                public var updateTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.stageDetailList?.validate()
                    try self.stageList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.pipelineName != nil {
                        map["PipelineName"] = self.pipelineName!
                    }
                    if self.pipelineStatus != nil {
                        map["PipelineStatus"] = self.pipelineStatus!
                    }
                    if self.stageDetailList != nil {
                        map["StageDetailList"] = self.stageDetailList?.toMap()
                    }
                    if self.stageList != nil {
                        map["StageList"] = self.stageList?.toMap()
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("PipelineName") && dict["PipelineName"] != nil {
                        self.pipelineName = dict["PipelineName"] as! String
                    }
                    if dict.keys.contains("PipelineStatus") && dict["PipelineStatus"] != nil {
                        self.pipelineStatus = dict["PipelineStatus"] as! Int32
                    }
                    if dict.keys.contains("StageDetailList") && dict["StageDetailList"] != nil {
                        var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList()
                        model.fromMap(dict["StageDetailList"] as! [String: Any])
                        self.stageDetailList = model
                    }
                    if dict.keys.contains("StageList") && dict["StageList"] != nil {
                        var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList()
                        model.fromMap(dict["StageList"] as! [String: Any])
                        self.stageList = model
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                        self.updateTime = dict["UpdateTime"] as! String
                    }
                }
            }
            public var pipelineInfo: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineInfo != nil {
                    var tmp : [Any] = []
                    for k in self.pipelineInfo! {
                        tmp.append(k.toMap())
                    }
                    map["PipelineInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PipelineInfo") && dict["PipelineInfo"] != nil {
                    var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo] = []
                    for v in dict["PipelineInfo"] as! [Any] {
                        var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.pipelineInfo = tmp
                }
            }
        }
        public class Targets : Tea.TeaModel {
            public var items: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.items != nil {
                    map["Items"] = self.items!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Items") && dict["Items"] != nil {
                    self.items = dict["Items"] as! [String]
                }
            }
        }
        public class TrafficControl : Tea.TeaModel {
            public var routes: String?

            public var rules: String?

            public var tips: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.routes != nil {
                    map["Routes"] = self.routes!
                }
                if self.rules != nil {
                    map["Rules"] = self.rules!
                }
                if self.tips != nil {
                    map["Tips"] = self.tips!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Routes") && dict["Routes"] != nil {
                    self.routes = dict["Routes"] as! String
                }
                if dict.keys.contains("Rules") && dict["Rules"] != nil {
                    self.rules = dict["Rules"] as! String
                }
                if dict.keys.contains("Tips") && dict["Tips"] != nil {
                    self.tips = dict["Tips"] as! String
                }
            }
        }
        public var batchCount: Int32?

        public var batchType: String?

        public var changeOrderDescription: String?

        public var changeOrderId: String?

        public var coType: String?

        public var createTime: String?

        public var createUserId: String?

        public var desc: String?

        public var pipelineInfoList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList?

        public var status: Int32?

        public var supportRollback: Bool?

        public var targets: GetChangeOrderInfoResponseBody.ChangeOrderInfo.Targets?

        public var trafficControl: GetChangeOrderInfoResponseBody.ChangeOrderInfo.TrafficControl?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pipelineInfoList?.validate()
            try self.targets?.validate()
            try self.trafficControl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchCount != nil {
                map["BatchCount"] = self.batchCount!
            }
            if self.batchType != nil {
                map["BatchType"] = self.batchType!
            }
            if self.changeOrderDescription != nil {
                map["ChangeOrderDescription"] = self.changeOrderDescription!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.coType != nil {
                map["CoType"] = self.coType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUserId != nil {
                map["CreateUserId"] = self.createUserId!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.pipelineInfoList != nil {
                map["PipelineInfoList"] = self.pipelineInfoList?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.supportRollback != nil {
                map["SupportRollback"] = self.supportRollback!
            }
            if self.targets != nil {
                map["Targets"] = self.targets?.toMap()
            }
            if self.trafficControl != nil {
                map["TrafficControl"] = self.trafficControl?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchCount") && dict["BatchCount"] != nil {
                self.batchCount = dict["BatchCount"] as! Int32
            }
            if dict.keys.contains("BatchType") && dict["BatchType"] != nil {
                self.batchType = dict["BatchType"] as! String
            }
            if dict.keys.contains("ChangeOrderDescription") && dict["ChangeOrderDescription"] != nil {
                self.changeOrderDescription = dict["ChangeOrderDescription"] as! String
            }
            if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
            if dict.keys.contains("CoType") && dict["CoType"] != nil {
                self.coType = dict["CoType"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateUserId") && dict["CreateUserId"] != nil {
                self.createUserId = dict["CreateUserId"] as! String
            }
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("PipelineInfoList") && dict["PipelineInfoList"] != nil {
                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList()
                model.fromMap(dict["PipelineInfoList"] as! [String: Any])
                self.pipelineInfoList = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("SupportRollback") && dict["SupportRollback"] != nil {
                self.supportRollback = dict["SupportRollback"] as! Bool
            }
            if dict.keys.contains("Targets") && dict["Targets"] != nil {
                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.Targets()
                model.fromMap(dict["Targets"] as! [String: Any])
                self.targets = model
            }
            if dict.keys.contains("TrafficControl") && dict["TrafficControl"] != nil {
                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.TrafficControl()
                model.fromMap(dict["TrafficControl"] as! [String: Any])
                self.trafficControl = model
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var changeOrderInfo: GetChangeOrderInfoResponseBody.ChangeOrderInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.changeOrderInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.changeOrderInfo != nil {
            map["changeOrderInfo"] = self.changeOrderInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("changeOrderInfo") && dict["changeOrderInfo"] != nil {
            var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo()
            model.fromMap(dict["changeOrderInfo"] as! [String: Any])
            self.changeOrderInfo = model
        }
    }
}

public class GetChangeOrderInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetChangeOrderInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetChangeOrderInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class GetClusterResponseBody : Tea.TeaModel {
    public class Cluster : Tea.TeaModel {
        public var clusterId: String?

        public var clusterImportStatus: Int32?

        public var clusterName: String?

        public var clusterType: Int32?

        public var cpu: Int32?

        public var cpuUsed: Int32?

        public var createTime: Int64?

        public var csClusterId: String?

        public var description_: String?

        public var iaasProvider: String?

        public var mem: Int32?

        public var memUsed: Int32?

        public var networkMode: Int32?

        public var nodeNum: Int32?

        public var oversoldFactor: Int32?

        public var regionId: String?

        public var subClusterType: String?

        public var updateTime: Int64?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterImportStatus != nil {
                map["ClusterImportStatus"] = self.clusterImportStatus!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuUsed != nil {
                map["CpuUsed"] = self.cpuUsed!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.csClusterId != nil {
                map["CsClusterId"] = self.csClusterId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.iaasProvider != nil {
                map["IaasProvider"] = self.iaasProvider!
            }
            if self.mem != nil {
                map["Mem"] = self.mem!
            }
            if self.memUsed != nil {
                map["MemUsed"] = self.memUsed!
            }
            if self.networkMode != nil {
                map["NetworkMode"] = self.networkMode!
            }
            if self.nodeNum != nil {
                map["NodeNum"] = self.nodeNum!
            }
            if self.oversoldFactor != nil {
                map["OversoldFactor"] = self.oversoldFactor!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.subClusterType != nil {
                map["SubClusterType"] = self.subClusterType!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterImportStatus") && dict["ClusterImportStatus"] != nil {
                self.clusterImportStatus = dict["ClusterImportStatus"] as! Int32
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! Int32
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CpuUsed") && dict["CpuUsed"] != nil {
                self.cpuUsed = dict["CpuUsed"] as! Int32
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CsClusterId") && dict["CsClusterId"] != nil {
                self.csClusterId = dict["CsClusterId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IaasProvider") && dict["IaasProvider"] != nil {
                self.iaasProvider = dict["IaasProvider"] as! String
            }
            if dict.keys.contains("Mem") && dict["Mem"] != nil {
                self.mem = dict["Mem"] as! Int32
            }
            if dict.keys.contains("MemUsed") && dict["MemUsed"] != nil {
                self.memUsed = dict["MemUsed"] as! Int32
            }
            if dict.keys.contains("NetworkMode") && dict["NetworkMode"] != nil {
                self.networkMode = dict["NetworkMode"] as! Int32
            }
            if dict.keys.contains("NodeNum") && dict["NodeNum"] != nil {
                self.nodeNum = dict["NodeNum"] as! Int32
            }
            if dict.keys.contains("OversoldFactor") && dict["OversoldFactor"] != nil {
                self.oversoldFactor = dict["OversoldFactor"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("SubClusterType") && dict["SubClusterType"] != nil {
                self.subClusterType = dict["SubClusterType"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var cluster: GetClusterResponseBody.Cluster?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cluster?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cluster != nil {
            map["Cluster"] = self.cluster?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cluster") && dict["Cluster"] != nil {
            var model = GetClusterResponseBody.Cluster()
            model.fromMap(dict["Cluster"] as! [String: Any])
            self.cluster = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetContainerConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
    }
}

public class GetContainerConfigurationResponseBody : Tea.TeaModel {
    public class ContainerConfiguration : Tea.TeaModel {
        public var contextPath: String?

        public var httpPort: Int32?

        public var maxThreads: Int32?

        public var URIEncoding: String?

        public var useBodyEncoding: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contextPath != nil {
                map["ContextPath"] = self.contextPath!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.maxThreads != nil {
                map["MaxThreads"] = self.maxThreads!
            }
            if self.URIEncoding != nil {
                map["URIEncoding"] = self.URIEncoding!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContextPath") && dict["ContextPath"] != nil {
                self.contextPath = dict["ContextPath"] as! String
            }
            if dict.keys.contains("HttpPort") && dict["HttpPort"] != nil {
                self.httpPort = dict["HttpPort"] as! Int32
            }
            if dict.keys.contains("MaxThreads") && dict["MaxThreads"] != nil {
                self.maxThreads = dict["MaxThreads"] as! Int32
            }
            if dict.keys.contains("URIEncoding") && dict["URIEncoding"] != nil {
                self.URIEncoding = dict["URIEncoding"] as! String
            }
            if dict.keys.contains("UseBodyEncoding") && dict["UseBodyEncoding"] != nil {
                self.useBodyEncoding = dict["UseBodyEncoding"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var containerConfiguration: GetContainerConfigurationResponseBody.ContainerConfiguration?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.containerConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.containerConfiguration != nil {
            map["ContainerConfiguration"] = self.containerConfiguration?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ContainerConfiguration") && dict["ContainerConfiguration"] != nil {
            var model = GetContainerConfigurationResponseBody.ContainerConfiguration()
            model.fromMap(dict["ContainerConfiguration"] as! [String: Any])
            self.containerConfiguration = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetContainerConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetContainerConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetContainerConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetJavaStartUpConfigRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class GetJavaStartUpConfigResponseBody : Tea.TeaModel {
    public class JavaStartUpConfig : Tea.TeaModel {
        public var originalConfigs: String?

        public var startUpArgs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.originalConfigs != nil {
                map["OriginalConfigs"] = self.originalConfigs!
            }
            if self.startUpArgs != nil {
                map["StartUpArgs"] = self.startUpArgs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OriginalConfigs") && dict["OriginalConfigs"] != nil {
                self.originalConfigs = dict["OriginalConfigs"] as! String
            }
            if dict.keys.contains("StartUpArgs") && dict["StartUpArgs"] != nil {
                self.startUpArgs = dict["StartUpArgs"] as! String
            }
        }
    }
    public var code: Int32?

    public var javaStartUpConfig: GetJavaStartUpConfigResponseBody.JavaStartUpConfig?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.javaStartUpConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("JavaStartUpConfig") && dict["JavaStartUpConfig"] != nil {
            var model = GetJavaStartUpConfigResponseBody.JavaStartUpConfig()
            model.fromMap(dict["JavaStartUpConfig"] as! [String: Any])
            self.javaStartUpConfig = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetJavaStartUpConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetJavaStartUpConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetJavaStartUpConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetJvmConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
    }
}

public class GetJvmConfigurationResponseBody : Tea.TeaModel {
    public class JvmConfiguration : Tea.TeaModel {
        public var maxHeapSize: Int32?

        public var maxPermSize: Int32?

        public var minHeapSize: Int32?

        public var options: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxHeapSize != nil {
                map["MaxHeapSize"] = self.maxHeapSize!
            }
            if self.maxPermSize != nil {
                map["MaxPermSize"] = self.maxPermSize!
            }
            if self.minHeapSize != nil {
                map["MinHeapSize"] = self.minHeapSize!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaxHeapSize") && dict["MaxHeapSize"] != nil {
                self.maxHeapSize = dict["MaxHeapSize"] as! Int32
            }
            if dict.keys.contains("MaxPermSize") && dict["MaxPermSize"] != nil {
                self.maxPermSize = dict["MaxPermSize"] as! Int32
            }
            if dict.keys.contains("MinHeapSize") && dict["MinHeapSize"] != nil {
                self.minHeapSize = dict["MinHeapSize"] as! Int32
            }
            if dict.keys.contains("Options") && dict["Options"] != nil {
                self.options = dict["Options"] as! String
            }
        }
    }
    public var code: Int32?

    public var jvmConfiguration: GetJvmConfigurationResponseBody.JvmConfiguration?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jvmConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.jvmConfiguration != nil {
            map["JvmConfiguration"] = self.jvmConfiguration?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("JvmConfiguration") && dict["JvmConfiguration"] != nil {
            var model = GetJvmConfigurationResponseBody.JvmConfiguration()
            model.fromMap(dict["JvmConfiguration"] as! [String: Any])
            self.jvmConfiguration = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetJvmConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetJvmConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetJvmConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetK8sAppPrecheckResultRequest : Tea.TeaModel {
    public var appName: String?

    public var clusterId: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class GetK8sAppPrecheckResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class JobResults : Tea.TeaModel {
            public var interrupted: Bool?

            public var name: String?

            public var pass: Bool?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interrupted != nil {
                    map["Interrupted"] = self.interrupted!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pass != nil {
                    map["Pass"] = self.pass!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interrupted") && dict["Interrupted"] != nil {
                    self.interrupted = dict["Interrupted"] as! Bool
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pass") && dict["Pass"] != nil {
                    self.pass = dict["Pass"] as! Bool
                }
                if dict.keys.contains("Reason") && dict["Reason"] != nil {
                    self.reason = dict["Reason"] as! String
                }
            }
        }
        public var jobResults: [GetK8sAppPrecheckResultResponseBody.Data.JobResults]?

        public var reason: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobResults != nil {
                var tmp : [Any] = []
                for k in self.jobResults! {
                    tmp.append(k.toMap())
                }
                map["JobResults"] = tmp
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobResults") && dict["JobResults"] != nil {
                var tmp : [GetK8sAppPrecheckResultResponseBody.Data.JobResults] = []
                for v in dict["JobResults"] as! [Any] {
                    var model = GetK8sAppPrecheckResultResponseBody.Data.JobResults()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.jobResults = tmp
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetK8sAppPrecheckResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetK8sAppPrecheckResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetK8sAppPrecheckResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetK8sAppPrecheckResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetK8sAppPrecheckResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var from: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
    }
}

public class GetK8sApplicationResponseBody : Tea.TeaModel {
    public class Applcation : Tea.TeaModel {
        public class App : Tea.TeaModel {
            public class CmdArgs : Tea.TeaModel {
                public var cmdArg: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cmdArg != nil {
                        map["CmdArg"] = self.cmdArg!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CmdArg") && dict["CmdArg"] != nil {
                        self.cmdArg = dict["CmdArg"] as! [String]
                    }
                }
            }
            public class EnvList : Tea.TeaModel {
                public class Env : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var env: [GetK8sApplicationResponseBody.Applcation.App.EnvList.Env]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.env != nil {
                        var tmp : [Any] = []
                        for k in self.env! {
                            tmp.append(k.toMap())
                        }
                        map["Env"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Env") && dict["Env"] != nil {
                        var tmp : [GetK8sApplicationResponseBody.Applcation.App.EnvList.Env] = []
                        for v in dict["Env"] as! [Any] {
                            var model = GetK8sApplicationResponseBody.Applcation.App.EnvList.Env()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.env = tmp
                    }
                }
            }
            public var annotations: String?

            public var appId: String?

            public var applicationName: String?

            public var applicationType: String?

            public var buildpackId: Int32?

            public var clusterId: String?

            public var cmd: String?

            public var cmdArgs: GetK8sApplicationResponseBody.Applcation.App.CmdArgs?

            public var csClusterId: String?

            public var deployType: String?

            public var developType: String?

            public var edasContainerVersion: String?

            public var enableEmptyPushReject: Bool?

            public var enableLosslessRule: Bool?

            public var envList: GetK8sApplicationResponseBody.Applcation.App.EnvList?

            public var instances: Int32?

            public var instancesBeforeScaling: Int32?

            public var k8sNamespace: String?

            public var labels: String?

            public var limitCpuM: Int32?

            public var limitEphemeralStorage: String?

            public var limitMem: Int32?

            public var losslessRuleAligned: Bool?

            public var losslessRuleDelayTime: Int32?

            public var losslessRuleFuncType: Int32?

            public var losslessRuleRelated: Bool?

            public var losslessRuleWarmupTime: Int32?

            public var regionId: String?

            public var requestCpuM: Int32?

            public var requestEphemeralStorage: String?

            public var requestMem: Int32?

            public var slbInfo: String?

            public var tomcatVersion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cmdArgs?.validate()
                try self.envList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotations != nil {
                    map["Annotations"] = self.annotations!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.applicationName != nil {
                    map["ApplicationName"] = self.applicationName!
                }
                if self.applicationType != nil {
                    map["ApplicationType"] = self.applicationType!
                }
                if self.buildpackId != nil {
                    map["BuildpackId"] = self.buildpackId!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.cmd != nil {
                    map["Cmd"] = self.cmd!
                }
                if self.cmdArgs != nil {
                    map["CmdArgs"] = self.cmdArgs?.toMap()
                }
                if self.csClusterId != nil {
                    map["CsClusterId"] = self.csClusterId!
                }
                if self.deployType != nil {
                    map["DeployType"] = self.deployType!
                }
                if self.developType != nil {
                    map["DevelopType"] = self.developType!
                }
                if self.edasContainerVersion != nil {
                    map["EdasContainerVersion"] = self.edasContainerVersion!
                }
                if self.enableEmptyPushReject != nil {
                    map["EnableEmptyPushReject"] = self.enableEmptyPushReject!
                }
                if self.enableLosslessRule != nil {
                    map["EnableLosslessRule"] = self.enableLosslessRule!
                }
                if self.envList != nil {
                    map["EnvList"] = self.envList?.toMap()
                }
                if self.instances != nil {
                    map["Instances"] = self.instances!
                }
                if self.instancesBeforeScaling != nil {
                    map["InstancesBeforeScaling"] = self.instancesBeforeScaling!
                }
                if self.k8sNamespace != nil {
                    map["K8sNamespace"] = self.k8sNamespace!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.limitCpuM != nil {
                    map["LimitCpuM"] = self.limitCpuM!
                }
                if self.limitEphemeralStorage != nil {
                    map["LimitEphemeralStorage"] = self.limitEphemeralStorage!
                }
                if self.limitMem != nil {
                    map["LimitMem"] = self.limitMem!
                }
                if self.losslessRuleAligned != nil {
                    map["LosslessRuleAligned"] = self.losslessRuleAligned!
                }
                if self.losslessRuleDelayTime != nil {
                    map["LosslessRuleDelayTime"] = self.losslessRuleDelayTime!
                }
                if self.losslessRuleFuncType != nil {
                    map["LosslessRuleFuncType"] = self.losslessRuleFuncType!
                }
                if self.losslessRuleRelated != nil {
                    map["LosslessRuleRelated"] = self.losslessRuleRelated!
                }
                if self.losslessRuleWarmupTime != nil {
                    map["LosslessRuleWarmupTime"] = self.losslessRuleWarmupTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.requestCpuM != nil {
                    map["RequestCpuM"] = self.requestCpuM!
                }
                if self.requestEphemeralStorage != nil {
                    map["RequestEphemeralStorage"] = self.requestEphemeralStorage!
                }
                if self.requestMem != nil {
                    map["RequestMem"] = self.requestMem!
                }
                if self.slbInfo != nil {
                    map["SlbInfo"] = self.slbInfo!
                }
                if self.tomcatVersion != nil {
                    map["TomcatVersion"] = self.tomcatVersion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                    self.annotations = dict["Annotations"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("ApplicationName") && dict["ApplicationName"] != nil {
                    self.applicationName = dict["ApplicationName"] as! String
                }
                if dict.keys.contains("ApplicationType") && dict["ApplicationType"] != nil {
                    self.applicationType = dict["ApplicationType"] as! String
                }
                if dict.keys.contains("BuildpackId") && dict["BuildpackId"] != nil {
                    self.buildpackId = dict["BuildpackId"] as! Int32
                }
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("Cmd") && dict["Cmd"] != nil {
                    self.cmd = dict["Cmd"] as! String
                }
                if dict.keys.contains("CmdArgs") && dict["CmdArgs"] != nil {
                    var model = GetK8sApplicationResponseBody.Applcation.App.CmdArgs()
                    model.fromMap(dict["CmdArgs"] as! [String: Any])
                    self.cmdArgs = model
                }
                if dict.keys.contains("CsClusterId") && dict["CsClusterId"] != nil {
                    self.csClusterId = dict["CsClusterId"] as! String
                }
                if dict.keys.contains("DeployType") && dict["DeployType"] != nil {
                    self.deployType = dict["DeployType"] as! String
                }
                if dict.keys.contains("DevelopType") && dict["DevelopType"] != nil {
                    self.developType = dict["DevelopType"] as! String
                }
                if dict.keys.contains("EdasContainerVersion") && dict["EdasContainerVersion"] != nil {
                    self.edasContainerVersion = dict["EdasContainerVersion"] as! String
                }
                if dict.keys.contains("EnableEmptyPushReject") && dict["EnableEmptyPushReject"] != nil {
                    self.enableEmptyPushReject = dict["EnableEmptyPushReject"] as! Bool
                }
                if dict.keys.contains("EnableLosslessRule") && dict["EnableLosslessRule"] != nil {
                    self.enableLosslessRule = dict["EnableLosslessRule"] as! Bool
                }
                if dict.keys.contains("EnvList") && dict["EnvList"] != nil {
                    var model = GetK8sApplicationResponseBody.Applcation.App.EnvList()
                    model.fromMap(dict["EnvList"] as! [String: Any])
                    self.envList = model
                }
                if dict.keys.contains("Instances") && dict["Instances"] != nil {
                    self.instances = dict["Instances"] as! Int32
                }
                if dict.keys.contains("InstancesBeforeScaling") && dict["InstancesBeforeScaling"] != nil {
                    self.instancesBeforeScaling = dict["InstancesBeforeScaling"] as! Int32
                }
                if dict.keys.contains("K8sNamespace") && dict["K8sNamespace"] != nil {
                    self.k8sNamespace = dict["K8sNamespace"] as! String
                }
                if dict.keys.contains("Labels") && dict["Labels"] != nil {
                    self.labels = dict["Labels"] as! String
                }
                if dict.keys.contains("LimitCpuM") && dict["LimitCpuM"] != nil {
                    self.limitCpuM = dict["LimitCpuM"] as! Int32
                }
                if dict.keys.contains("LimitEphemeralStorage") && dict["LimitEphemeralStorage"] != nil {
                    self.limitEphemeralStorage = dict["LimitEphemeralStorage"] as! String
                }
                if dict.keys.contains("LimitMem") && dict["LimitMem"] != nil {
                    self.limitMem = dict["LimitMem"] as! Int32
                }
                if dict.keys.contains("LosslessRuleAligned") && dict["LosslessRuleAligned"] != nil {
                    self.losslessRuleAligned = dict["LosslessRuleAligned"] as! Bool
                }
                if dict.keys.contains("LosslessRuleDelayTime") && dict["LosslessRuleDelayTime"] != nil {
                    self.losslessRuleDelayTime = dict["LosslessRuleDelayTime"] as! Int32
                }
                if dict.keys.contains("LosslessRuleFuncType") && dict["LosslessRuleFuncType"] != nil {
                    self.losslessRuleFuncType = dict["LosslessRuleFuncType"] as! Int32
                }
                if dict.keys.contains("LosslessRuleRelated") && dict["LosslessRuleRelated"] != nil {
                    self.losslessRuleRelated = dict["LosslessRuleRelated"] as! Bool
                }
                if dict.keys.contains("LosslessRuleWarmupTime") && dict["LosslessRuleWarmupTime"] != nil {
                    self.losslessRuleWarmupTime = dict["LosslessRuleWarmupTime"] as! Int32
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RequestCpuM") && dict["RequestCpuM"] != nil {
                    self.requestCpuM = dict["RequestCpuM"] as! Int32
                }
                if dict.keys.contains("RequestEphemeralStorage") && dict["RequestEphemeralStorage"] != nil {
                    self.requestEphemeralStorage = dict["RequestEphemeralStorage"] as! String
                }
                if dict.keys.contains("RequestMem") && dict["RequestMem"] != nil {
                    self.requestMem = dict["RequestMem"] as! Int32
                }
                if dict.keys.contains("SlbInfo") && dict["SlbInfo"] != nil {
                    self.slbInfo = dict["SlbInfo"] as! String
                }
                if dict.keys.contains("TomcatVersion") && dict["TomcatVersion"] != nil {
                    self.tomcatVersion = dict["TomcatVersion"] as! String
                }
            }
        }
        public class Conf : Tea.TeaModel {
            public var affinity: String?

            public var ahasEnabled: Bool?

            public var deployAcrossNodes: String?

            public var deployAcrossZones: String?

            public var jarStartArgs: String?

            public var jarStartOptions: String?

            public var k8sCmd: String?

            public var k8sCmdArgs: String?

            public var k8sLocalvolumeInfo: String?

            public var k8sNasInfo: String?

            public var k8sVolumeInfo: String?

            public var liveness: String?

            public var postStart: String?

            public var preStop: String?

            public var readiness: String?

            public var runtimeClassName: String?

            public var tolerations: String?

            public var userBaseImageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.affinity != nil {
                    map["Affinity"] = self.affinity!
                }
                if self.ahasEnabled != nil {
                    map["AhasEnabled"] = self.ahasEnabled!
                }
                if self.deployAcrossNodes != nil {
                    map["DeployAcrossNodes"] = self.deployAcrossNodes!
                }
                if self.deployAcrossZones != nil {
                    map["DeployAcrossZones"] = self.deployAcrossZones!
                }
                if self.jarStartArgs != nil {
                    map["JarStartArgs"] = self.jarStartArgs!
                }
                if self.jarStartOptions != nil {
                    map["JarStartOptions"] = self.jarStartOptions!
                }
                if self.k8sCmd != nil {
                    map["K8sCmd"] = self.k8sCmd!
                }
                if self.k8sCmdArgs != nil {
                    map["K8sCmdArgs"] = self.k8sCmdArgs!
                }
                if self.k8sLocalvolumeInfo != nil {
                    map["K8sLocalvolumeInfo"] = self.k8sLocalvolumeInfo!
                }
                if self.k8sNasInfo != nil {
                    map["K8sNasInfo"] = self.k8sNasInfo!
                }
                if self.k8sVolumeInfo != nil {
                    map["K8sVolumeInfo"] = self.k8sVolumeInfo!
                }
                if self.liveness != nil {
                    map["Liveness"] = self.liveness!
                }
                if self.postStart != nil {
                    map["PostStart"] = self.postStart!
                }
                if self.preStop != nil {
                    map["PreStop"] = self.preStop!
                }
                if self.readiness != nil {
                    map["Readiness"] = self.readiness!
                }
                if self.runtimeClassName != nil {
                    map["RuntimeClassName"] = self.runtimeClassName!
                }
                if self.tolerations != nil {
                    map["Tolerations"] = self.tolerations!
                }
                if self.userBaseImageUrl != nil {
                    map["UserBaseImageUrl"] = self.userBaseImageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Affinity") && dict["Affinity"] != nil {
                    self.affinity = dict["Affinity"] as! String
                }
                if dict.keys.contains("AhasEnabled") && dict["AhasEnabled"] != nil {
                    self.ahasEnabled = dict["AhasEnabled"] as! Bool
                }
                if dict.keys.contains("DeployAcrossNodes") && dict["DeployAcrossNodes"] != nil {
                    self.deployAcrossNodes = dict["DeployAcrossNodes"] as! String
                }
                if dict.keys.contains("DeployAcrossZones") && dict["DeployAcrossZones"] != nil {
                    self.deployAcrossZones = dict["DeployAcrossZones"] as! String
                }
                if dict.keys.contains("JarStartArgs") && dict["JarStartArgs"] != nil {
                    self.jarStartArgs = dict["JarStartArgs"] as! String
                }
                if dict.keys.contains("JarStartOptions") && dict["JarStartOptions"] != nil {
                    self.jarStartOptions = dict["JarStartOptions"] as! String
                }
                if dict.keys.contains("K8sCmd") && dict["K8sCmd"] != nil {
                    self.k8sCmd = dict["K8sCmd"] as! String
                }
                if dict.keys.contains("K8sCmdArgs") && dict["K8sCmdArgs"] != nil {
                    self.k8sCmdArgs = dict["K8sCmdArgs"] as! String
                }
                if dict.keys.contains("K8sLocalvolumeInfo") && dict["K8sLocalvolumeInfo"] != nil {
                    self.k8sLocalvolumeInfo = dict["K8sLocalvolumeInfo"] as! String
                }
                if dict.keys.contains("K8sNasInfo") && dict["K8sNasInfo"] != nil {
                    self.k8sNasInfo = dict["K8sNasInfo"] as! String
                }
                if dict.keys.contains("K8sVolumeInfo") && dict["K8sVolumeInfo"] != nil {
                    self.k8sVolumeInfo = dict["K8sVolumeInfo"] as! String
                }
                if dict.keys.contains("Liveness") && dict["Liveness"] != nil {
                    self.liveness = dict["Liveness"] as! String
                }
                if dict.keys.contains("PostStart") && dict["PostStart"] != nil {
                    self.postStart = dict["PostStart"] as! String
                }
                if dict.keys.contains("PreStop") && dict["PreStop"] != nil {
                    self.preStop = dict["PreStop"] as! String
                }
                if dict.keys.contains("Readiness") && dict["Readiness"] != nil {
                    self.readiness = dict["Readiness"] as! String
                }
                if dict.keys.contains("RuntimeClassName") && dict["RuntimeClassName"] != nil {
                    self.runtimeClassName = dict["RuntimeClassName"] as! String
                }
                if dict.keys.contains("Tolerations") && dict["Tolerations"] != nil {
                    self.tolerations = dict["Tolerations"] as! String
                }
                if dict.keys.contains("UserBaseImageUrl") && dict["UserBaseImageUrl"] != nil {
                    self.userBaseImageUrl = dict["UserBaseImageUrl"] as! String
                }
            }
        }
        public class DeployGroups : Tea.TeaModel {
            public class DeployGroup : Tea.TeaModel {
                public class Components : Tea.TeaModel {
                    public class Components : Tea.TeaModel {
                        public var componentId: String?

                        public var componentKey: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.componentId != nil {
                                map["ComponentId"] = self.componentId!
                            }
                            if self.componentKey != nil {
                                map["ComponentKey"] = self.componentKey!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ComponentId") && dict["ComponentId"] != nil {
                                self.componentId = dict["ComponentId"] as! String
                            }
                            if dict.keys.contains("ComponentKey") && dict["ComponentKey"] != nil {
                                self.componentKey = dict["ComponentKey"] as! String
                            }
                            if dict.keys.contains("Type") && dict["Type"] != nil {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public var components: [GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components.Components]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.components != nil {
                            var tmp : [Any] = []
                            for k in self.components! {
                                tmp.append(k.toMap())
                            }
                            map["Components"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Components") && dict["Components"] != nil {
                            var tmp : [GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components.Components] = []
                            for v in dict["Components"] as! [Any] {
                                var model = GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components.Components()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.components = tmp
                        }
                    }
                }
                public var components: GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components?

                public var env: String?

                public var envFrom: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.components?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.components != nil {
                        map["Components"] = self.components?.toMap()
                    }
                    if self.env != nil {
                        map["Env"] = self.env!
                    }
                    if self.envFrom != nil {
                        map["EnvFrom"] = self.envFrom!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Components") && dict["Components"] != nil {
                        var model = GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components()
                        model.fromMap(dict["Components"] as! [String: Any])
                        self.components = model
                    }
                    if dict.keys.contains("Env") && dict["Env"] != nil {
                        self.env = dict["Env"] as! String
                    }
                    if dict.keys.contains("EnvFrom") && dict["EnvFrom"] != nil {
                        self.envFrom = dict["EnvFrom"] as! String
                    }
                }
            }
            public var deployGroup: [GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deployGroup != nil {
                    var tmp : [Any] = []
                    for k in self.deployGroup! {
                        tmp.append(k.toMap())
                    }
                    map["DeployGroup"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeployGroup") && dict["DeployGroup"] != nil {
                    var tmp : [GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup] = []
                    for v in dict["DeployGroup"] as! [Any] {
                        var model = GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.deployGroup = tmp
                }
            }
        }
        public class ImageInfo : Tea.TeaModel {
            public var imageUrl: String?

            public var regionId: String?

            public var repoId: String?

            public var repoName: String?

            public var repoNamespace: String?

            public var repoOriginType: String?

            public var tag: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.repoId != nil {
                    map["RepoId"] = self.repoId!
                }
                if self.repoName != nil {
                    map["RepoName"] = self.repoName!
                }
                if self.repoNamespace != nil {
                    map["RepoNamespace"] = self.repoNamespace!
                }
                if self.repoOriginType != nil {
                    map["RepoOriginType"] = self.repoOriginType!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ImageUrl") && dict["ImageUrl"] != nil {
                    self.imageUrl = dict["ImageUrl"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
                    self.repoId = dict["RepoId"] as! String
                }
                if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                    self.repoName = dict["RepoName"] as! String
                }
                if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                    self.repoNamespace = dict["RepoNamespace"] as! String
                }
                if dict.keys.contains("RepoOriginType") && dict["RepoOriginType"] != nil {
                    self.repoOriginType = dict["RepoOriginType"] as! String
                }
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
            }
        }
        public class LatestVersion : Tea.TeaModel {
            public var packageVersion: String?

            public var url: String?

            public var warUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.packageVersion != nil {
                    map["PackageVersion"] = self.packageVersion!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.warUrl != nil {
                    map["WarUrl"] = self.warUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PackageVersion") && dict["PackageVersion"] != nil {
                    self.packageVersion = dict["PackageVersion"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("WarUrl") && dict["WarUrl"] != nil {
                    self.warUrl = dict["WarUrl"] as! String
                }
            }
        }
        public var app: GetK8sApplicationResponseBody.Applcation.App?

        public var appId: String?

        public var conf: GetK8sApplicationResponseBody.Applcation.Conf?

        public var deployGroups: GetK8sApplicationResponseBody.Applcation.DeployGroups?

        public var imageInfo: GetK8sApplicationResponseBody.Applcation.ImageInfo?

        public var latestVersion: GetK8sApplicationResponseBody.Applcation.LatestVersion?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.app?.validate()
            try self.conf?.validate()
            try self.deployGroups?.validate()
            try self.imageInfo?.validate()
            try self.latestVersion?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app?.toMap()
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.conf != nil {
                map["Conf"] = self.conf?.toMap()
            }
            if self.deployGroups != nil {
                map["DeployGroups"] = self.deployGroups?.toMap()
            }
            if self.imageInfo != nil {
                map["ImageInfo"] = self.imageInfo?.toMap()
            }
            if self.latestVersion != nil {
                map["LatestVersion"] = self.latestVersion?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") && dict["App"] != nil {
                var model = GetK8sApplicationResponseBody.Applcation.App()
                model.fromMap(dict["App"] as! [String: Any])
                self.app = model
            }
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Conf") && dict["Conf"] != nil {
                var model = GetK8sApplicationResponseBody.Applcation.Conf()
                model.fromMap(dict["Conf"] as! [String: Any])
                self.conf = model
            }
            if dict.keys.contains("DeployGroups") && dict["DeployGroups"] != nil {
                var model = GetK8sApplicationResponseBody.Applcation.DeployGroups()
                model.fromMap(dict["DeployGroups"] as! [String: Any])
                self.deployGroups = model
            }
            if dict.keys.contains("ImageInfo") && dict["ImageInfo"] != nil {
                var model = GetK8sApplicationResponseBody.Applcation.ImageInfo()
                model.fromMap(dict["ImageInfo"] as! [String: Any])
                self.imageInfo = model
            }
            if dict.keys.contains("LatestVersion") && dict["LatestVersion"] != nil {
                var model = GetK8sApplicationResponseBody.Applcation.LatestVersion()
                model.fromMap(dict["LatestVersion"] as! [String: Any])
                self.latestVersion = model
            }
        }
    }
    public var applcation: GetK8sApplicationResponseBody.Applcation?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applcation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applcation != nil {
            map["Applcation"] = self.applcation?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Applcation") && dict["Applcation"] != nil {
            var model = GetK8sApplicationResponseBody.Applcation()
            model.fromMap(dict["Applcation"] as! [String: Any])
            self.applcation = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetK8sApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetK8sClusterRequest : Tea.TeaModel {
    public var clusterType: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var regionTag: String?

    public var subClusterType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionTag != nil {
            map["RegionTag"] = self.regionTag!
        }
        if self.subClusterType != nil {
            map["SubClusterType"] = self.subClusterType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionTag") && dict["RegionTag"] != nil {
            self.regionTag = dict["RegionTag"] as! String
        }
        if dict.keys.contains("SubClusterType") && dict["SubClusterType"] != nil {
            self.subClusterType = dict["SubClusterType"] as! String
        }
    }
}

public class GetK8sClusterResponseBody : Tea.TeaModel {
    public class ClusterPage : Tea.TeaModel {
        public class ClusterList : Tea.TeaModel {
            public class Cluster : Tea.TeaModel {
                public var clusterId: String?

                public var clusterImportStatus: Int32?

                public var clusterName: String?

                public var clusterStatus: Int32?

                public var clusterType: Int32?

                public var cpu: Int32?

                public var csClusterId: String?

                public var csClusterStatus: String?

                public var description_: String?

                public var mem: Int32?

                public var networkMode: Int32?

                public var nodeNum: Int32?

                public var regionId: String?

                public var subClusterType: String?

                public var subNetCidr: String?

                public var vpcId: String?

                public var vswitchId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterId != nil {
                        map["ClusterId"] = self.clusterId!
                    }
                    if self.clusterImportStatus != nil {
                        map["ClusterImportStatus"] = self.clusterImportStatus!
                    }
                    if self.clusterName != nil {
                        map["ClusterName"] = self.clusterName!
                    }
                    if self.clusterStatus != nil {
                        map["ClusterStatus"] = self.clusterStatus!
                    }
                    if self.clusterType != nil {
                        map["ClusterType"] = self.clusterType!
                    }
                    if self.cpu != nil {
                        map["Cpu"] = self.cpu!
                    }
                    if self.csClusterId != nil {
                        map["CsClusterId"] = self.csClusterId!
                    }
                    if self.csClusterStatus != nil {
                        map["CsClusterStatus"] = self.csClusterStatus!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.mem != nil {
                        map["Mem"] = self.mem!
                    }
                    if self.networkMode != nil {
                        map["NetworkMode"] = self.networkMode!
                    }
                    if self.nodeNum != nil {
                        map["NodeNum"] = self.nodeNum!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.subClusterType != nil {
                        map["SubClusterType"] = self.subClusterType!
                    }
                    if self.subNetCidr != nil {
                        map["SubNetCidr"] = self.subNetCidr!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    if self.vswitchId != nil {
                        map["VswitchId"] = self.vswitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                        self.clusterId = dict["ClusterId"] as! String
                    }
                    if dict.keys.contains("ClusterImportStatus") && dict["ClusterImportStatus"] != nil {
                        self.clusterImportStatus = dict["ClusterImportStatus"] as! Int32
                    }
                    if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                        self.clusterName = dict["ClusterName"] as! String
                    }
                    if dict.keys.contains("ClusterStatus") && dict["ClusterStatus"] != nil {
                        self.clusterStatus = dict["ClusterStatus"] as! Int32
                    }
                    if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                        self.clusterType = dict["ClusterType"] as! Int32
                    }
                    if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                        self.cpu = dict["Cpu"] as! Int32
                    }
                    if dict.keys.contains("CsClusterId") && dict["CsClusterId"] != nil {
                        self.csClusterId = dict["CsClusterId"] as! String
                    }
                    if dict.keys.contains("CsClusterStatus") && dict["CsClusterStatus"] != nil {
                        self.csClusterStatus = dict["CsClusterStatus"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Mem") && dict["Mem"] != nil {
                        self.mem = dict["Mem"] as! Int32
                    }
                    if dict.keys.contains("NetworkMode") && dict["NetworkMode"] != nil {
                        self.networkMode = dict["NetworkMode"] as! Int32
                    }
                    if dict.keys.contains("NodeNum") && dict["NodeNum"] != nil {
                        self.nodeNum = dict["NodeNum"] as! Int32
                    }
                    if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("SubClusterType") && dict["SubClusterType"] != nil {
                        self.subClusterType = dict["SubClusterType"] as! String
                    }
                    if dict.keys.contains("SubNetCidr") && dict["SubNetCidr"] != nil {
                        self.subNetCidr = dict["SubNetCidr"] as! String
                    }
                    if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                        self.vpcId = dict["VpcId"] as! String
                    }
                    if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                        self.vswitchId = dict["VswitchId"] as! String
                    }
                }
            }
            public var cluster: [GetK8sClusterResponseBody.ClusterPage.ClusterList.Cluster]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cluster != nil {
                    var tmp : [Any] = []
                    for k in self.cluster! {
                        tmp.append(k.toMap())
                    }
                    map["Cluster"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cluster") && dict["Cluster"] != nil {
                    var tmp : [GetK8sClusterResponseBody.ClusterPage.ClusterList.Cluster] = []
                    for v in dict["Cluster"] as! [Any] {
                        var model = GetK8sClusterResponseBody.ClusterPage.ClusterList.Cluster()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.cluster = tmp
                }
            }
        }
        public var clusterList: GetK8sClusterResponseBody.ClusterPage.ClusterList?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clusterList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterList != nil {
                map["ClusterList"] = self.clusterList?.toMap()
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterList") && dict["ClusterList"] != nil {
                var model = GetK8sClusterResponseBody.ClusterPage.ClusterList()
                model.fromMap(dict["ClusterList"] as! [String: Any])
                self.clusterList = model
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var clusterPage: GetK8sClusterResponseBody.ClusterPage?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterPage?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterPage != nil {
            map["ClusterPage"] = self.clusterPage?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterPage") && dict["ClusterPage"] != nil {
            var model = GetK8sClusterResponseBody.ClusterPage()
            model.fromMap(dict["ClusterPage"] as! [String: Any])
            self.clusterPage = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetK8sClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetK8sClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetK8sClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetK8sServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class GetK8sServicesResponseBody : Tea.TeaModel {
    public class Services : Tea.TeaModel {
        public class ServicePorts : Tea.TeaModel {
            public var nodePort: Int32?

            public var port: Int32?

            public var protocol_: String?

            public var targetPort: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodePort != nil {
                    map["NodePort"] = self.nodePort!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NodePort") && dict["NodePort"] != nil {
                    self.nodePort = dict["NodePort"] as! Int32
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("TargetPort") && dict["TargetPort"] != nil {
                    self.targetPort = dict["TargetPort"] as! String
                }
            }
        }
        public var clusterIP: String?

        public var name: String?

        public var servicePorts: [GetK8sServicesResponseBody.Services.ServicePorts]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterIP != nil {
                map["ClusterIP"] = self.clusterIP!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.servicePorts != nil {
                var tmp : [Any] = []
                for k in self.servicePorts! {
                    tmp.append(k.toMap())
                }
                map["ServicePorts"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterIP") && dict["ClusterIP"] != nil {
                self.clusterIP = dict["ClusterIP"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ServicePorts") && dict["ServicePorts"] != nil {
                var tmp : [GetK8sServicesResponseBody.Services.ServicePorts] = []
                for v in dict["ServicePorts"] as! [Any] {
                    var model = GetK8sServicesResponseBody.Services.ServicePorts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.servicePorts = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var services: [GetK8sServicesResponseBody.Services]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Services") && dict["Services"] != nil {
            var tmp : [GetK8sServicesResponseBody.Services] = []
            for v in dict["Services"] as! [Any] {
                var model = GetK8sServicesResponseBody.Services()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.services = tmp
        }
    }
}

public class GetK8sServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetK8sServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetK8sServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPackageStorageCredentialResponseBody : Tea.TeaModel {
    public class Credential : Tea.TeaModel {
        public var accessKeyId: String?

        public var accessKeySecret: String?

        public var bucket: String?

        public var expiration: String?

        public var keyPrefix: String?

        public var ossInternalEndpoint: String?

        public var ossPublicEndpoint: String?

        public var ossVpcEndpoint: String?

        public var regionId: String?

        public var securityToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.accessKeySecret != nil {
                map["AccessKeySecret"] = self.accessKeySecret!
            }
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.expiration != nil {
                map["Expiration"] = self.expiration!
            }
            if self.keyPrefix != nil {
                map["KeyPrefix"] = self.keyPrefix!
            }
            if self.ossInternalEndpoint != nil {
                map["OssInternalEndpoint"] = self.ossInternalEndpoint!
            }
            if self.ossPublicEndpoint != nil {
                map["OssPublicEndpoint"] = self.ossPublicEndpoint!
            }
            if self.ossVpcEndpoint != nil {
                map["OssVpcEndpoint"] = self.ossVpcEndpoint!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityToken != nil {
                map["SecurityToken"] = self.securityToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKeyId") && dict["AccessKeyId"] != nil {
                self.accessKeyId = dict["AccessKeyId"] as! String
            }
            if dict.keys.contains("AccessKeySecret") && dict["AccessKeySecret"] != nil {
                self.accessKeySecret = dict["AccessKeySecret"] as! String
            }
            if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Expiration") && dict["Expiration"] != nil {
                self.expiration = dict["Expiration"] as! String
            }
            if dict.keys.contains("KeyPrefix") && dict["KeyPrefix"] != nil {
                self.keyPrefix = dict["KeyPrefix"] as! String
            }
            if dict.keys.contains("OssInternalEndpoint") && dict["OssInternalEndpoint"] != nil {
                self.ossInternalEndpoint = dict["OssInternalEndpoint"] as! String
            }
            if dict.keys.contains("OssPublicEndpoint") && dict["OssPublicEndpoint"] != nil {
                self.ossPublicEndpoint = dict["OssPublicEndpoint"] as! String
            }
            if dict.keys.contains("OssVpcEndpoint") && dict["OssVpcEndpoint"] != nil {
                self.ossVpcEndpoint = dict["OssVpcEndpoint"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
                self.securityToken = dict["SecurityToken"] as! String
            }
        }
    }
    public var code: Int32?

    public var credential: GetPackageStorageCredentialResponseBody.Credential?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.credential?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.credential != nil {
            map["Credential"] = self.credential?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Credential") && dict["Credential"] != nil {
            var model = GetPackageStorageCredentialResponseBody.Credential()
            model.fromMap(dict["Credential"] as! [String: Any])
            self.credential = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPackageStorageCredentialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPackageStorageCredentialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPackageStorageCredentialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetScalingRulesRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var mode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
    }
}

public class GetScalingRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RuleList : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var appId: String?

                public var cond: String?

                public var cpu: Int32?

                public var createTime: Int64?

                public var duration: Int32?

                public var enable: Bool?

                public var groupId: String?

                public var instNum: Int32?

                public var loadNum: Int32?

                public var metricType: String?

                public var mode: String?

                public var multiAzPolicy: String?

                public var resourceFrom: String?

                public var rt: Int32?

                public var specId: String?

                public var step: Int32?

                public var templateId: String?

                public var templateVersion: Int32?

                public var updateTime: Int64?

                public var vSwitchIds: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.cond != nil {
                        map["Cond"] = self.cond!
                    }
                    if self.cpu != nil {
                        map["Cpu"] = self.cpu!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.enable != nil {
                        map["Enable"] = self.enable!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.instNum != nil {
                        map["InstNum"] = self.instNum!
                    }
                    if self.loadNum != nil {
                        map["LoadNum"] = self.loadNum!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.multiAzPolicy != nil {
                        map["MultiAzPolicy"] = self.multiAzPolicy!
                    }
                    if self.resourceFrom != nil {
                        map["ResourceFrom"] = self.resourceFrom!
                    }
                    if self.rt != nil {
                        map["Rt"] = self.rt!
                    }
                    if self.specId != nil {
                        map["SpecId"] = self.specId!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    if self.templateVersion != nil {
                        map["TemplateVersion"] = self.templateVersion!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    if self.vSwitchIds != nil {
                        map["VSwitchIds"] = self.vSwitchIds!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("Cond") && dict["Cond"] != nil {
                        self.cond = dict["Cond"] as! String
                    }
                    if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                        self.cpu = dict["Cpu"] as! Int32
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! Int32
                    }
                    if dict.keys.contains("Enable") && dict["Enable"] != nil {
                        self.enable = dict["Enable"] as! Bool
                    }
                    if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                        self.groupId = dict["GroupId"] as! String
                    }
                    if dict.keys.contains("InstNum") && dict["InstNum"] != nil {
                        self.instNum = dict["InstNum"] as! Int32
                    }
                    if dict.keys.contains("LoadNum") && dict["LoadNum"] != nil {
                        self.loadNum = dict["LoadNum"] as! Int32
                    }
                    if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
                        self.metricType = dict["MetricType"] as! String
                    }
                    if dict.keys.contains("Mode") && dict["Mode"] != nil {
                        self.mode = dict["Mode"] as! String
                    }
                    if dict.keys.contains("MultiAzPolicy") && dict["MultiAzPolicy"] != nil {
                        self.multiAzPolicy = dict["MultiAzPolicy"] as! String
                    }
                    if dict.keys.contains("ResourceFrom") && dict["ResourceFrom"] != nil {
                        self.resourceFrom = dict["ResourceFrom"] as! String
                    }
                    if dict.keys.contains("Rt") && dict["Rt"] != nil {
                        self.rt = dict["Rt"] as! Int32
                    }
                    if dict.keys.contains("SpecId") && dict["SpecId"] != nil {
                        self.specId = dict["SpecId"] as! String
                    }
                    if dict.keys.contains("Step") && dict["Step"] != nil {
                        self.step = dict["Step"] as! Int32
                    }
                    if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                        self.templateId = dict["TemplateId"] as! String
                    }
                    if dict.keys.contains("TemplateVersion") && dict["TemplateVersion"] != nil {
                        self.templateVersion = dict["TemplateVersion"] as! Int32
                    }
                    if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                        self.updateTime = dict["UpdateTime"] as! Int64
                    }
                    if dict.keys.contains("VSwitchIds") && dict["VSwitchIds"] != nil {
                        self.vSwitchIds = dict["VSwitchIds"] as! String
                    }
                    if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public var rule: [GetScalingRulesResponseBody.Data.RuleList.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Rule") && dict["Rule"] != nil {
                    var tmp : [GetScalingRulesResponseBody.Data.RuleList.Rule] = []
                    for v in dict["Rule"] as! [Any] {
                        var model = GetScalingRulesResponseBody.Data.RuleList.Rule()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rule = tmp
                }
            }
        }
        public var clusterType: Int32?

        public var oversoldFactor: Int32?

        public var ruleList: GetScalingRulesResponseBody.Data.RuleList?

        public var updateTime: Int64?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ruleList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.oversoldFactor != nil {
                map["OversoldFactor"] = self.oversoldFactor!
            }
            if self.ruleList != nil {
                map["RuleList"] = self.ruleList?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! Int32
            }
            if dict.keys.contains("OversoldFactor") && dict["OversoldFactor"] != nil {
                self.oversoldFactor = dict["OversoldFactor"] as! Int32
            }
            if dict.keys.contains("RuleList") && dict["RuleList"] != nil {
                var model = GetScalingRulesResponseBody.Data.RuleList()
                model.fromMap(dict["RuleList"] as! [String: Any])
                self.ruleList = model
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetScalingRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var updateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetScalingRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
            self.updateTime = dict["UpdateTime"] as! Int64
        }
    }
}

public class GetScalingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetScalingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetScalingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSecureTokenRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class GetSecureTokenResponseBody : Tea.TeaModel {
    public class SecureToken : Tea.TeaModel {
        public var accessKey: String?

        public var addressServerHost: String?

        public var belongRegion: String?

        public var description_: String?

        public var edasId: String?

        public var id: Int64?

        public var mseInstanceId: String?

        public var mseInternetAddress: String?

        public var mseIntranetAddress: String?

        public var mseRegistryType: String?

        public var regionId: String?

        public var regionName: String?

        public var secretKey: String?

        public var tenantId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKey != nil {
                map["AccessKey"] = self.accessKey!
            }
            if self.addressServerHost != nil {
                map["AddressServerHost"] = self.addressServerHost!
            }
            if self.belongRegion != nil {
                map["BelongRegion"] = self.belongRegion!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.edasId != nil {
                map["EdasId"] = self.edasId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mseInstanceId != nil {
                map["MseInstanceId"] = self.mseInstanceId!
            }
            if self.mseInternetAddress != nil {
                map["MseInternetAddress"] = self.mseInternetAddress!
            }
            if self.mseIntranetAddress != nil {
                map["MseIntranetAddress"] = self.mseIntranetAddress!
            }
            if self.mseRegistryType != nil {
                map["MseRegistryType"] = self.mseRegistryType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.secretKey != nil {
                map["SecretKey"] = self.secretKey!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKey") && dict["AccessKey"] != nil {
                self.accessKey = dict["AccessKey"] as! String
            }
            if dict.keys.contains("AddressServerHost") && dict["AddressServerHost"] != nil {
                self.addressServerHost = dict["AddressServerHost"] as! String
            }
            if dict.keys.contains("BelongRegion") && dict["BelongRegion"] != nil {
                self.belongRegion = dict["BelongRegion"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EdasId") && dict["EdasId"] != nil {
                self.edasId = dict["EdasId"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MseInstanceId") && dict["MseInstanceId"] != nil {
                self.mseInstanceId = dict["MseInstanceId"] as! String
            }
            if dict.keys.contains("MseInternetAddress") && dict["MseInternetAddress"] != nil {
                self.mseInternetAddress = dict["MseInternetAddress"] as! String
            }
            if dict.keys.contains("MseIntranetAddress") && dict["MseIntranetAddress"] != nil {
                self.mseIntranetAddress = dict["MseIntranetAddress"] as! String
            }
            if dict.keys.contains("MseRegistryType") && dict["MseRegistryType"] != nil {
                self.mseRegistryType = dict["MseRegistryType"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("SecretKey") && dict["SecretKey"] != nil {
                self.secretKey = dict["SecretKey"] as! String
            }
            if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var secureToken: GetSecureTokenResponseBody.SecureToken?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.secureToken?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.secureToken != nil {
            map["SecureToken"] = self.secureToken?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecureToken") && dict["SecureToken"] != nil {
            var model = GetSecureTokenResponseBody.SecureToken()
            model.fromMap(dict["SecureToken"] as! [String: Any])
            self.secureToken = model
        }
    }
}

public class GetSecureTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSecureTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSecureTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceConsumersPageRequest : Tea.TeaModel {
    public var appId: String?

    public var group: String?

    public var ip: String?

    public var namespace: String?

    public var origin: String?

    public var page: Int32?

    public var region: String?

    public var registryType: String?

    public var serviceId: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public var size: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.group != nil {
            map["group"] = self.group!
        }
        if self.ip != nil {
            map["ip"] = self.ip!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.registryType != nil {
            map["registryType"] = self.registryType!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["serviceVersion"] = self.serviceVersion!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appId") && dict["appId"] != nil {
            self.appId = dict["appId"] as! String
        }
        if dict.keys.contains("group") && dict["group"] != nil {
            self.group = dict["group"] as! String
        }
        if dict.keys.contains("ip") && dict["ip"] != nil {
            self.ip = dict["ip"] as! String
        }
        if dict.keys.contains("namespace") && dict["namespace"] != nil {
            self.namespace = dict["namespace"] as! String
        }
        if dict.keys.contains("origin") && dict["origin"] != nil {
            self.origin = dict["origin"] as! String
        }
        if dict.keys.contains("page") && dict["page"] != nil {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("region") && dict["region"] != nil {
            self.region = dict["region"] as! String
        }
        if dict.keys.contains("registryType") && dict["registryType"] != nil {
            self.registryType = dict["registryType"] as! String
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! String
        }
        if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
            self.serviceName = dict["serviceName"] as! String
        }
        if dict.keys.contains("serviceType") && dict["serviceType"] != nil {
            self.serviceType = dict["serviceType"] as! String
        }
        if dict.keys.contains("serviceVersion") && dict["serviceVersion"] != nil {
            self.serviceVersion = dict["serviceVersion"] as! String
        }
        if dict.keys.contains("size") && dict["size"] != nil {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("source") && dict["source"] != nil {
            self.source = dict["source"] as! String
        }
    }
}

public class GetServiceConsumersPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public var edasAppName: String?

            public var edassAppId: String?

            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.edasAppName != nil {
                    map["EdasAppName"] = self.edasAppName!
                }
                if self.edassAppId != nil {
                    map["EdassAppId"] = self.edassAppId!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EdasAppName") && dict["EdasAppName"] != nil {
                    self.edasAppName = dict["EdasAppName"] as! String
                }
                if dict.keys.contains("EdassAppId") && dict["EdassAppId"] != nil {
                    self.edassAppId = dict["EdassAppId"] as! String
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
            }
        }
        public var content: [GetServiceConsumersPageResponseBody.Data.Content]?

        public var size: Int32?

        public var totalElements: Int32?

        public var totalPages: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["Content"] = tmp
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.totalElements != nil {
                map["TotalElements"] = self.totalElements!
            }
            if self.totalPages != nil {
                map["TotalPages"] = self.totalPages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                var tmp : [GetServiceConsumersPageResponseBody.Data.Content] = []
                for v in dict["Content"] as! [Any] {
                    var model = GetServiceConsumersPageResponseBody.Data.Content()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.content = tmp
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("TotalElements") && dict["TotalElements"] != nil {
                self.totalElements = dict["TotalElements"] as! Int32
            }
            if dict.keys.contains("TotalPages") && dict["TotalPages"] != nil {
                self.totalPages = dict["TotalPages"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GetServiceConsumersPageResponseBody.Data?

    public var message: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetServiceConsumersPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceConsumersPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceConsumersPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceConsumersPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceDetailRequest : Tea.TeaModel {
    public var appId: String?

    public var group: String?

    public var ip: String?

    public var namespace: String?

    public var origin: String?

    public var region: String?

    public var registryType: String?

    public var serviceId: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.group != nil {
            map["group"] = self.group!
        }
        if self.ip != nil {
            map["ip"] = self.ip!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.registryType != nil {
            map["registryType"] = self.registryType!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["serviceVersion"] = self.serviceVersion!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appId") && dict["appId"] != nil {
            self.appId = dict["appId"] as! String
        }
        if dict.keys.contains("group") && dict["group"] != nil {
            self.group = dict["group"] as! String
        }
        if dict.keys.contains("ip") && dict["ip"] != nil {
            self.ip = dict["ip"] as! String
        }
        if dict.keys.contains("namespace") && dict["namespace"] != nil {
            self.namespace = dict["namespace"] as! String
        }
        if dict.keys.contains("origin") && dict["origin"] != nil {
            self.origin = dict["origin"] as! String
        }
        if dict.keys.contains("region") && dict["region"] != nil {
            self.region = dict["region"] as! String
        }
        if dict.keys.contains("registryType") && dict["registryType"] != nil {
            self.registryType = dict["registryType"] as! String
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! String
        }
        if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
            self.serviceName = dict["serviceName"] as! String
        }
        if dict.keys.contains("serviceType") && dict["serviceType"] != nil {
            self.serviceType = dict["serviceType"] as! String
        }
        if dict.keys.contains("serviceVersion") && dict["serviceVersion"] != nil {
            self.serviceVersion = dict["serviceVersion"] as! String
        }
        if dict.keys.contains("source") && dict["source"] != nil {
            self.source = dict["source"] as! String
        }
    }
}

public class GetServiceDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Methods : Tea.TeaModel {
            public class ReturnDefinition : Tea.TeaModel {
                public var id: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var methodController: String?

            public var name: String?

            public var nameDetail: String?

            public var parameterDefinitions: String?

            public var parameterDetails: String?

            public var parameterNames: String?

            public var parameterTypes: String?

            public var paths: String?

            public var requestMethods: String?

            public var returnDefinition: GetServiceDetailResponseBody.Data.Methods.ReturnDefinition?

            public var returnDetails: String?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.returnDefinition?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameDetail != nil {
                    map["NameDetail"] = self.nameDetail!
                }
                if self.parameterDefinitions != nil {
                    map["ParameterDefinitions"] = self.parameterDefinitions!
                }
                if self.parameterDetails != nil {
                    map["ParameterDetails"] = self.parameterDetails!
                }
                if self.parameterNames != nil {
                    map["ParameterNames"] = self.parameterNames!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnDefinition != nil {
                    map["ReturnDefinition"] = self.returnDefinition?.toMap()
                }
                if self.returnDetails != nil {
                    map["ReturnDetails"] = self.returnDetails!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MethodController") && dict["MethodController"] != nil {
                    self.methodController = dict["MethodController"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameDetail") && dict["NameDetail"] != nil {
                    self.nameDetail = dict["NameDetail"] as! String
                }
                if dict.keys.contains("ParameterDefinitions") && dict["ParameterDefinitions"] != nil {
                    self.parameterDefinitions = dict["ParameterDefinitions"] as! String
                }
                if dict.keys.contains("ParameterDetails") && dict["ParameterDetails"] != nil {
                    self.parameterDetails = dict["ParameterDetails"] as! String
                }
                if dict.keys.contains("ParameterNames") && dict["ParameterNames"] != nil {
                    self.parameterNames = dict["ParameterNames"] as! String
                }
                if dict.keys.contains("ParameterTypes") && dict["ParameterTypes"] != nil {
                    self.parameterTypes = dict["ParameterTypes"] as! String
                }
                if dict.keys.contains("Paths") && dict["Paths"] != nil {
                    self.paths = dict["Paths"] as! String
                }
                if dict.keys.contains("RequestMethods") && dict["RequestMethods"] != nil {
                    self.requestMethods = dict["RequestMethods"] as! String
                }
                if dict.keys.contains("ReturnDefinition") && dict["ReturnDefinition"] != nil {
                    var model = GetServiceDetailResponseBody.Data.Methods.ReturnDefinition()
                    model.fromMap(dict["ReturnDefinition"] as! [String: Any])
                    self.returnDefinition = model
                }
                if dict.keys.contains("ReturnDetails") && dict["ReturnDetails"] != nil {
                    self.returnDetails = dict["ReturnDetails"] as! String
                }
                if dict.keys.contains("ReturnType") && dict["ReturnType"] != nil {
                    self.returnType = dict["ReturnType"] as! String
                }
            }
        }
        public var dubboApplicationName: String?

        public var edasAppName: String?

        public var group: String?

        public var metadata: String?

        public var methods: [GetServiceDetailResponseBody.Data.Methods]?

        public var registryType: String?

        public var serviceName: String?

        public var serviceType: String?

        public var springApplicationName: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dubboApplicationName != nil {
                map["DubboApplicationName"] = self.dubboApplicationName!
            }
            if self.edasAppName != nil {
                map["EdasAppName"] = self.edasAppName!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.methods != nil {
                var tmp : [Any] = []
                for k in self.methods! {
                    tmp.append(k.toMap())
                }
                map["Methods"] = tmp
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.springApplicationName != nil {
                map["SpringApplicationName"] = self.springApplicationName!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DubboApplicationName") && dict["DubboApplicationName"] != nil {
                self.dubboApplicationName = dict["DubboApplicationName"] as! String
            }
            if dict.keys.contains("EdasAppName") && dict["EdasAppName"] != nil {
                self.edasAppName = dict["EdasAppName"] as! String
            }
            if dict.keys.contains("Group") && dict["Group"] != nil {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Metadata") && dict["Metadata"] != nil {
                self.metadata = dict["Metadata"] as! String
            }
            if dict.keys.contains("Methods") && dict["Methods"] != nil {
                var tmp : [GetServiceDetailResponseBody.Data.Methods] = []
                for v in dict["Methods"] as! [Any] {
                    var model = GetServiceDetailResponseBody.Data.Methods()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.methods = tmp
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("SpringApplicationName") && dict["SpringApplicationName"] != nil {
                self.springApplicationName = dict["SpringApplicationName"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetServiceDetailResponseBody.Data?

    public var message: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetServiceDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceListPageRequest : Tea.TeaModel {
    public var namespace: String?

    public var origin: String?

    public var page: Int32?

    public var region: String?

    public var searchType: String?

    public var searchValue: String?

    public var serviceType: String?

    public var side: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.searchType != nil {
            map["searchType"] = self.searchType!
        }
        if self.searchValue != nil {
            map["searchValue"] = self.searchValue!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.side != nil {
            map["side"] = self.side!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("namespace") && dict["namespace"] != nil {
            self.namespace = dict["namespace"] as! String
        }
        if dict.keys.contains("origin") && dict["origin"] != nil {
            self.origin = dict["origin"] as! String
        }
        if dict.keys.contains("page") && dict["page"] != nil {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("region") && dict["region"] != nil {
            self.region = dict["region"] as! String
        }
        if dict.keys.contains("searchType") && dict["searchType"] != nil {
            self.searchType = dict["searchType"] as! String
        }
        if dict.keys.contains("searchValue") && dict["searchValue"] != nil {
            self.searchValue = dict["searchValue"] as! String
        }
        if dict.keys.contains("serviceType") && dict["serviceType"] != nil {
            self.serviceType = dict["serviceType"] as! String
        }
        if dict.keys.contains("side") && dict["side"] != nil {
            self.side = dict["side"] as! String
        }
        if dict.keys.contains("size") && dict["size"] != nil {
            self.size = dict["size"] as! Int32
        }
    }
}

public class GetServiceListPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public var edasAppId: String?

            public var edasAppName: String?

            public var group: String?

            public var instanceNum: Int32?

            public var registerType: String?

            public var serviceId: String?

            public var serviceName: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.edasAppId != nil {
                    map["EdasAppId"] = self.edasAppId!
                }
                if self.edasAppName != nil {
                    map["EdasAppName"] = self.edasAppName!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                if self.instanceNum != nil {
                    map["InstanceNum"] = self.instanceNum!
                }
                if self.registerType != nil {
                    map["RegisterType"] = self.registerType!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EdasAppId") && dict["EdasAppId"] != nil {
                    self.edasAppId = dict["EdasAppId"] as! String
                }
                if dict.keys.contains("EdasAppName") && dict["EdasAppName"] != nil {
                    self.edasAppName = dict["EdasAppName"] as! String
                }
                if dict.keys.contains("Group") && dict["Group"] != nil {
                    self.group = dict["Group"] as! String
                }
                if dict.keys.contains("InstanceNum") && dict["InstanceNum"] != nil {
                    self.instanceNum = dict["InstanceNum"] as! Int32
                }
                if dict.keys.contains("RegisterType") && dict["RegisterType"] != nil {
                    self.registerType = dict["RegisterType"] as! String
                }
                if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                    self.serviceId = dict["ServiceId"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var content: [GetServiceListPageResponseBody.Data.Content]?

        public var size: Int32?

        public var totalElements: Int32?

        public var totalPages: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["Content"] = tmp
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.totalElements != nil {
                map["TotalElements"] = self.totalElements!
            }
            if self.totalPages != nil {
                map["TotalPages"] = self.totalPages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                var tmp : [GetServiceListPageResponseBody.Data.Content] = []
                for v in dict["Content"] as! [Any] {
                    var model = GetServiceListPageResponseBody.Data.Content()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.content = tmp
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("TotalElements") && dict["TotalElements"] != nil {
                self.totalElements = dict["TotalElements"] as! Int32
            }
            if dict.keys.contains("TotalPages") && dict["TotalPages"] != nil {
                self.totalPages = dict["TotalPages"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GetServiceListPageResponseBody.Data?

    public var message: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetServiceListPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceListPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceListPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceMethodPageRequest : Tea.TeaModel {
    public var appId: String?

    public var group: String?

    public var ip: String?

    public var methodController: String?

    public var name: String?

    public var namespace: String?

    public var origin: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var path: String?

    public var region: String?

    public var registryType: String?

    public var serviceId: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.group != nil {
            map["group"] = self.group!
        }
        if self.ip != nil {
            map["ip"] = self.ip!
        }
        if self.methodController != nil {
            map["methodController"] = self.methodController!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.registryType != nil {
            map["registryType"] = self.registryType!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["serviceVersion"] = self.serviceVersion!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appId") && dict["appId"] != nil {
            self.appId = dict["appId"] as! String
        }
        if dict.keys.contains("group") && dict["group"] != nil {
            self.group = dict["group"] as! String
        }
        if dict.keys.contains("ip") && dict["ip"] != nil {
            self.ip = dict["ip"] as! String
        }
        if dict.keys.contains("methodController") && dict["methodController"] != nil {
            self.methodController = dict["methodController"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("namespace") && dict["namespace"] != nil {
            self.namespace = dict["namespace"] as! String
        }
        if dict.keys.contains("origin") && dict["origin"] != nil {
            self.origin = dict["origin"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("path") && dict["path"] != nil {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("region") && dict["region"] != nil {
            self.region = dict["region"] as! String
        }
        if dict.keys.contains("registryType") && dict["registryType"] != nil {
            self.registryType = dict["registryType"] as! String
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! String
        }
        if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
            self.serviceName = dict["serviceName"] as! String
        }
        if dict.keys.contains("serviceType") && dict["serviceType"] != nil {
            self.serviceType = dict["serviceType"] as! String
        }
        if dict.keys.contains("serviceVersion") && dict["serviceVersion"] != nil {
            self.serviceVersion = dict["serviceVersion"] as! String
        }
        if dict.keys.contains("source") && dict["source"] != nil {
            self.source = dict["source"] as! String
        }
    }
}

public class GetServiceMethodPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class ReturnDefinition : Tea.TeaModel {
                public var id: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var methodController: String?

            public var name: String?

            public var nameDetail: String?

            public var parameterDefinitions: String?

            public var parameterDetails: String?

            public var parameterNames: String?

            public var parameterTypes: String?

            public var paths: String?

            public var requestMethods: String?

            public var returnDefinition: GetServiceMethodPageResponseBody.Data.Result.ReturnDefinition?

            public var returnDetails: String?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.returnDefinition?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameDetail != nil {
                    map["NameDetail"] = self.nameDetail!
                }
                if self.parameterDefinitions != nil {
                    map["ParameterDefinitions"] = self.parameterDefinitions!
                }
                if self.parameterDetails != nil {
                    map["ParameterDetails"] = self.parameterDetails!
                }
                if self.parameterNames != nil {
                    map["ParameterNames"] = self.parameterNames!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnDefinition != nil {
                    map["ReturnDefinition"] = self.returnDefinition?.toMap()
                }
                if self.returnDetails != nil {
                    map["ReturnDetails"] = self.returnDetails!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MethodController") && dict["MethodController"] != nil {
                    self.methodController = dict["MethodController"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameDetail") && dict["NameDetail"] != nil {
                    self.nameDetail = dict["NameDetail"] as! String
                }
                if dict.keys.contains("ParameterDefinitions") && dict["ParameterDefinitions"] != nil {
                    self.parameterDefinitions = dict["ParameterDefinitions"] as! String
                }
                if dict.keys.contains("ParameterDetails") && dict["ParameterDetails"] != nil {
                    self.parameterDetails = dict["ParameterDetails"] as! String
                }
                if dict.keys.contains("ParameterNames") && dict["ParameterNames"] != nil {
                    self.parameterNames = dict["ParameterNames"] as! String
                }
                if dict.keys.contains("ParameterTypes") && dict["ParameterTypes"] != nil {
                    self.parameterTypes = dict["ParameterTypes"] as! String
                }
                if dict.keys.contains("Paths") && dict["Paths"] != nil {
                    self.paths = dict["Paths"] as! String
                }
                if dict.keys.contains("RequestMethods") && dict["RequestMethods"] != nil {
                    self.requestMethods = dict["RequestMethods"] as! String
                }
                if dict.keys.contains("ReturnDefinition") && dict["ReturnDefinition"] != nil {
                    var model = GetServiceMethodPageResponseBody.Data.Result.ReturnDefinition()
                    model.fromMap(dict["ReturnDefinition"] as! [String: Any])
                    self.returnDefinition = model
                }
                if dict.keys.contains("ReturnDetails") && dict["ReturnDetails"] != nil {
                    self.returnDetails = dict["ReturnDetails"] as! String
                }
                if dict.keys.contains("ReturnType") && dict["ReturnType"] != nil {
                    self.returnType = dict["ReturnType"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GetServiceMethodPageResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [GetServiceMethodPageResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetServiceMethodPageResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: GetServiceMethodPageResponseBody.Data?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetServiceMethodPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpCode") && dict["HttpCode"] != nil {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceMethodPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceMethodPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceMethodPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceProvidersPageRequest : Tea.TeaModel {
    public var appId: String?

    public var group: String?

    public var ip: String?

    public var namespace: String?

    public var origin: String?

    public var page: Int32?

    public var region: String?

    public var registryType: String?

    public var serviceId: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public var size: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.group != nil {
            map["group"] = self.group!
        }
        if self.ip != nil {
            map["ip"] = self.ip!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.registryType != nil {
            map["registryType"] = self.registryType!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["serviceVersion"] = self.serviceVersion!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appId") && dict["appId"] != nil {
            self.appId = dict["appId"] as! String
        }
        if dict.keys.contains("group") && dict["group"] != nil {
            self.group = dict["group"] as! String
        }
        if dict.keys.contains("ip") && dict["ip"] != nil {
            self.ip = dict["ip"] as! String
        }
        if dict.keys.contains("namespace") && dict["namespace"] != nil {
            self.namespace = dict["namespace"] as! String
        }
        if dict.keys.contains("origin") && dict["origin"] != nil {
            self.origin = dict["origin"] as! String
        }
        if dict.keys.contains("page") && dict["page"] != nil {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("region") && dict["region"] != nil {
            self.region = dict["region"] as! String
        }
        if dict.keys.contains("registryType") && dict["registryType"] != nil {
            self.registryType = dict["registryType"] as! String
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! String
        }
        if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
            self.serviceName = dict["serviceName"] as! String
        }
        if dict.keys.contains("serviceType") && dict["serviceType"] != nil {
            self.serviceType = dict["serviceType"] as! String
        }
        if dict.keys.contains("serviceVersion") && dict["serviceVersion"] != nil {
            self.serviceVersion = dict["serviceVersion"] as! String
        }
        if dict.keys.contains("size") && dict["size"] != nil {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("source") && dict["source"] != nil {
            self.source = dict["source"] as! String
        }
    }
}

public class GetServiceProvidersPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public var iannotations: String?

            public var ip: String?

            public var port: String?

            public var serializeType: String?

            public var timeout: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.iannotations != nil {
                    map["Iannotations"] = self.iannotations!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serializeType != nil {
                    map["SerializeType"] = self.serializeType!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Iannotations") && dict["Iannotations"] != nil {
                    self.iannotations = dict["Iannotations"] as! String
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("SerializeType") && dict["SerializeType"] != nil {
                    self.serializeType = dict["SerializeType"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! String
                }
            }
        }
        public var content: [GetServiceProvidersPageResponseBody.Data.Content]?

        public var size: Int32?

        public var totalElements: Int32?

        public var totalPages: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["Content"] = tmp
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.totalElements != nil {
                map["TotalElements"] = self.totalElements!
            }
            if self.totalPages != nil {
                map["TotalPages"] = self.totalPages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                var tmp : [GetServiceProvidersPageResponseBody.Data.Content] = []
                for v in dict["Content"] as! [Any] {
                    var model = GetServiceProvidersPageResponseBody.Data.Content()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.content = tmp
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("TotalElements") && dict["TotalElements"] != nil {
                self.totalElements = dict["TotalElements"] as! Int32
            }
            if dict.keys.contains("TotalPages") && dict["TotalPages"] != nil {
                self.totalPages = dict["TotalPages"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GetServiceProvidersPageResponseBody.Data?

    public var message: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetServiceProvidersPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceProvidersPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceProvidersPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceProvidersPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWebContainerConfigRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class GetWebContainerConfigResponseBody : Tea.TeaModel {
    public class WebContainerConfig : Tea.TeaModel {
        public var contextInputType: String?

        public var contextPath: String?

        public var httpPort: Int32?

        public var maxThreads: Int32?

        public var serverXml: String?

        public var uriEncoding: String?

        public var useAdvancedServerXml: Bool?

        public var useBodyEncoding: Bool?

        public var useDefaultConfig: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contextInputType != nil {
                map["ContextInputType"] = self.contextInputType!
            }
            if self.contextPath != nil {
                map["ContextPath"] = self.contextPath!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.maxThreads != nil {
                map["MaxThreads"] = self.maxThreads!
            }
            if self.serverXml != nil {
                map["ServerXml"] = self.serverXml!
            }
            if self.uriEncoding != nil {
                map["UriEncoding"] = self.uriEncoding!
            }
            if self.useAdvancedServerXml != nil {
                map["UseAdvancedServerXml"] = self.useAdvancedServerXml!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            if self.useDefaultConfig != nil {
                map["UseDefaultConfig"] = self.useDefaultConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContextInputType") && dict["ContextInputType"] != nil {
                self.contextInputType = dict["ContextInputType"] as! String
            }
            if dict.keys.contains("ContextPath") && dict["ContextPath"] != nil {
                self.contextPath = dict["ContextPath"] as! String
            }
            if dict.keys.contains("HttpPort") && dict["HttpPort"] != nil {
                self.httpPort = dict["HttpPort"] as! Int32
            }
            if dict.keys.contains("MaxThreads") && dict["MaxThreads"] != nil {
                self.maxThreads = dict["MaxThreads"] as! Int32
            }
            if dict.keys.contains("ServerXml") && dict["ServerXml"] != nil {
                self.serverXml = dict["ServerXml"] as! String
            }
            if dict.keys.contains("UriEncoding") && dict["UriEncoding"] != nil {
                self.uriEncoding = dict["UriEncoding"] as! String
            }
            if dict.keys.contains("UseAdvancedServerXml") && dict["UseAdvancedServerXml"] != nil {
                self.useAdvancedServerXml = dict["UseAdvancedServerXml"] as! Bool
            }
            if dict.keys.contains("UseBodyEncoding") && dict["UseBodyEncoding"] != nil {
                self.useBodyEncoding = dict["UseBodyEncoding"] as! Bool
            }
            if dict.keys.contains("UseDefaultConfig") && dict["UseDefaultConfig"] != nil {
                self.useDefaultConfig = dict["UseDefaultConfig"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var webContainerConfig: GetWebContainerConfigResponseBody.WebContainerConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webContainerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.webContainerConfig != nil {
            map["WebContainerConfig"] = self.webContainerConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WebContainerConfig") && dict["WebContainerConfig"] != nil {
            var model = GetWebContainerConfigResponseBody.WebContainerConfig()
            model.fromMap(dict["WebContainerConfig"] as! [String: Any])
            self.webContainerConfig = model
        }
    }
}

public class GetWebContainerConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWebContainerConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetWebContainerConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportK8sClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var enableAsm: Bool?

    public var mode: Int32?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.enableAsm != nil {
            map["EnableAsm"] = self.enableAsm!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("EnableAsm") && dict["EnableAsm"] != nil {
            self.enableAsm = dict["EnableAsm"] as! Bool
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! Int32
        }
        if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class ImportK8sClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportK8sClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportK8sClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportK8sClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertApplicationRequest : Tea.TeaModel {
    public var applicationName: String?

    public var buildPackId: Int32?

    public var clusterId: String?

    public var componentIds: String?

    public var cpu: Int32?

    public var description_: String?

    public var ecuInfo: String?

    public var enablePortCheck: Bool?

    public var enableUrlCheck: Bool?

    public var healthCheckURL: String?

    public var healthCheckUrl: String?

    public var hooks: String?

    public var jdk: String?

    public var jvmOptions: String?

    public var logicalRegionId: String?

    public var maxHeapSize: Int32?

    public var maxPermSize: Int32?

    public var mem: Int32?

    public var minHeapSize: Int32?

    public var packageType: String?

    public var reservedPortStr: String?

    public var resourceGroupId: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentIds != nil {
            map["ComponentIds"] = self.componentIds!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ecuInfo != nil {
            map["EcuInfo"] = self.ecuInfo!
        }
        if self.enablePortCheck != nil {
            map["EnablePortCheck"] = self.enablePortCheck!
        }
        if self.enableUrlCheck != nil {
            map["EnableUrlCheck"] = self.enableUrlCheck!
        }
        if self.healthCheckURL != nil {
            map["HealthCheckURL"] = self.healthCheckURL!
        }
        if self.healthCheckUrl != nil {
            map["HealthCheckUrl"] = self.healthCheckUrl!
        }
        if self.hooks != nil {
            map["Hooks"] = self.hooks!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.jvmOptions != nil {
            map["JvmOptions"] = self.jvmOptions!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.maxHeapSize != nil {
            map["MaxHeapSize"] = self.maxHeapSize!
        }
        if self.maxPermSize != nil {
            map["MaxPermSize"] = self.maxPermSize!
        }
        if self.mem != nil {
            map["Mem"] = self.mem!
        }
        if self.minHeapSize != nil {
            map["MinHeapSize"] = self.minHeapSize!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.reservedPortStr != nil {
            map["ReservedPortStr"] = self.reservedPortStr!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationName") && dict["ApplicationName"] != nil {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("BuildPackId") && dict["BuildPackId"] != nil {
            self.buildPackId = dict["BuildPackId"] as! Int32
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentIds") && dict["ComponentIds"] != nil {
            self.componentIds = dict["ComponentIds"] as! String
        }
        if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EcuInfo") && dict["EcuInfo"] != nil {
            self.ecuInfo = dict["EcuInfo"] as! String
        }
        if dict.keys.contains("EnablePortCheck") && dict["EnablePortCheck"] != nil {
            self.enablePortCheck = dict["EnablePortCheck"] as! Bool
        }
        if dict.keys.contains("EnableUrlCheck") && dict["EnableUrlCheck"] != nil {
            self.enableUrlCheck = dict["EnableUrlCheck"] as! Bool
        }
        if dict.keys.contains("HealthCheckURL") && dict["HealthCheckURL"] != nil {
            self.healthCheckURL = dict["HealthCheckURL"] as! String
        }
        if dict.keys.contains("HealthCheckUrl") && dict["HealthCheckUrl"] != nil {
            self.healthCheckUrl = dict["HealthCheckUrl"] as! String
        }
        if dict.keys.contains("Hooks") && dict["Hooks"] != nil {
            self.hooks = dict["Hooks"] as! String
        }
        if dict.keys.contains("Jdk") && dict["Jdk"] != nil {
            self.jdk = dict["Jdk"] as! String
        }
        if dict.keys.contains("JvmOptions") && dict["JvmOptions"] != nil {
            self.jvmOptions = dict["JvmOptions"] as! String
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
        if dict.keys.contains("MaxHeapSize") && dict["MaxHeapSize"] != nil {
            self.maxHeapSize = dict["MaxHeapSize"] as! Int32
        }
        if dict.keys.contains("MaxPermSize") && dict["MaxPermSize"] != nil {
            self.maxPermSize = dict["MaxPermSize"] as! Int32
        }
        if dict.keys.contains("Mem") && dict["Mem"] != nil {
            self.mem = dict["Mem"] as! Int32
        }
        if dict.keys.contains("MinHeapSize") && dict["MinHeapSize"] != nil {
            self.minHeapSize = dict["MinHeapSize"] as! Int32
        }
        if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
            self.packageType = dict["PackageType"] as! String
        }
        if dict.keys.contains("ReservedPortStr") && dict["ReservedPortStr"] != nil {
            self.reservedPortStr = dict["ReservedPortStr"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("WebContainer") && dict["WebContainer"] != nil {
            self.webContainer = dict["WebContainer"] as! String
        }
    }
}

public class InsertApplicationResponseBody : Tea.TeaModel {
    public class ApplicationInfo : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var changeOrderId: String?

        public var dockerize: Bool?

        public var owner: String?

        public var port: Int32?

        public var regionName: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.dockerize != nil {
                map["Dockerize"] = self.dockerize!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
            if dict.keys.contains("Dockerize") && dict["Dockerize"] != nil {
                self.dockerize = dict["Dockerize"] as! Bool
            }
            if dict.keys.contains("Owner") && dict["Owner"] != nil {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var applicationInfo: InsertApplicationResponseBody.ApplicationInfo?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationInfo != nil {
            map["ApplicationInfo"] = self.applicationInfo?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationInfo") && dict["ApplicationInfo"] != nil {
            var model = InsertApplicationResponseBody.ApplicationInfo()
            model.fromMap(dict["ApplicationInfo"] as! [String: Any])
            self.applicationInfo = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InsertApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertClusterRequest : Tea.TeaModel {
    public var clusterName: String?

    public var clusterType: Int32?

    public var iaasProvider: String?

    public var logicalRegionId: String?

    public var networkMode: Int32?

    public var oversoldFactor: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.iaasProvider != nil {
            map["IaasProvider"] = self.iaasProvider!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.networkMode != nil {
            map["NetworkMode"] = self.networkMode!
        }
        if self.oversoldFactor != nil {
            map["OversoldFactor"] = self.oversoldFactor!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! Int32
        }
        if dict.keys.contains("IaasProvider") && dict["IaasProvider"] != nil {
            self.iaasProvider = dict["IaasProvider"] as! String
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
        if dict.keys.contains("NetworkMode") && dict["NetworkMode"] != nil {
            self.networkMode = dict["NetworkMode"] as! Int32
        }
        if dict.keys.contains("OversoldFactor") && dict["OversoldFactor"] != nil {
            self.oversoldFactor = dict["OversoldFactor"] as! Int32
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class InsertClusterResponseBody : Tea.TeaModel {
    public class Cluster : Tea.TeaModel {
        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: Int32?

        public var iaasProvider: String?

        public var networkMode: Int32?

        public var oversoldFactor: Int32?

        public var regionId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.iaasProvider != nil {
                map["IaasProvider"] = self.iaasProvider!
            }
            if self.networkMode != nil {
                map["NetworkMode"] = self.networkMode!
            }
            if self.oversoldFactor != nil {
                map["OversoldFactor"] = self.oversoldFactor!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! Int32
            }
            if dict.keys.contains("IaasProvider") && dict["IaasProvider"] != nil {
                self.iaasProvider = dict["IaasProvider"] as! String
            }
            if dict.keys.contains("NetworkMode") && dict["NetworkMode"] != nil {
                self.networkMode = dict["NetworkMode"] as! Int32
            }
            if dict.keys.contains("OversoldFactor") && dict["OversoldFactor"] != nil {
                self.oversoldFactor = dict["OversoldFactor"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var cluster: InsertClusterResponseBody.Cluster?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cluster?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cluster != nil {
            map["Cluster"] = self.cluster?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cluster") && dict["Cluster"] != nil {
            var model = InsertClusterResponseBody.Cluster()
            model.fromMap(dict["Cluster"] as! [String: Any])
            self.cluster = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InsertClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertClusterMemberRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceIds: String?

    public var password: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["clusterId"] = self.clusterId!
        }
        if self.instanceIds != nil {
            map["instanceIds"] = self.instanceIds!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clusterId") && dict["clusterId"] != nil {
            self.clusterId = dict["clusterId"] as! String
        }
        if dict.keys.contains("instanceIds") && dict["instanceIds"] != nil {
            self.instanceIds = dict["instanceIds"] as! String
        }
        if dict.keys.contains("password") && dict["password"] != nil {
            self.password = dict["password"] as! String
        }
    }
}

public class InsertClusterMemberResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InsertClusterMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertClusterMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertClusterMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertDeployGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var groupName: String?

    public var initPackageVersionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.initPackageVersionId != nil {
            map["InitPackageVersionId"] = self.initPackageVersionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InitPackageVersionId") && dict["InitPackageVersionId"] != nil {
            self.initPackageVersionId = dict["InitPackageVersionId"] as! String
        }
    }
}

public class InsertDeployGroupResponseBody : Tea.TeaModel {
    public class DeployGroupEntity : Tea.TeaModel {
        public var appId: String?

        public var appVersionId: String?

        public var clusterId: String?

        public var createTime: Int64?

        public var groupName: String?

        public var groupType: Int32?

        public var id: String?

        public var packageVersionId: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appVersionId != nil {
                map["AppVersionId"] = self.appVersionId!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.packageVersionId != nil {
                map["PackageVersionId"] = self.packageVersionId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppVersionId") && dict["AppVersionId"] != nil {
                self.appVersionId = dict["AppVersionId"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("GroupType") && dict["GroupType"] != nil {
                self.groupType = dict["GroupType"] as! Int32
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("PackageVersionId") && dict["PackageVersionId"] != nil {
                self.packageVersionId = dict["PackageVersionId"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var deployGroupEntity: InsertDeployGroupResponseBody.DeployGroupEntity?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployGroupEntity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.deployGroupEntity != nil {
            map["DeployGroupEntity"] = self.deployGroupEntity?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("DeployGroupEntity") && dict["DeployGroupEntity"] != nil {
            var model = InsertDeployGroupResponseBody.DeployGroupEntity()
            model.fromMap(dict["DeployGroupEntity"] as! [String: Any])
            self.deployGroupEntity = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InsertDeployGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertDeployGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertDeployGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertK8sApplicationRequest : Tea.TeaModel {
    public var annotations: String?

    public var appConfig: String?

    public var appName: String?

    public var appTemplateName: String?

    public var applicationDescription: String?

    public var buildPackId: String?

    public var clusterId: String?

    public var command: String?

    public var commandArgs: String?

    public var configMountDescs: String?

    public var containerRegistryId: String?

    public var csClusterId: String?

    public var customAffinity: String?

    public var customTolerations: String?

    public var deployAcrossNodes: String?

    public var deployAcrossZones: String?

    public var edasContainerVersion: String?

    public var emptyDirs: String?

    public var enableAhas: Bool?

    public var enableAsm: Bool?

    public var enableEmptyPushReject: Bool?

    public var enableLosslessRule: Bool?

    public var envFroms: String?

    public var envs: String?

    public var imagePlatforms: String?

    public var imageUrl: String?

    public var initContainers: String?

    public var internetSlbId: String?

    public var internetSlbPort: Int32?

    public var internetSlbProtocol: String?

    public var internetTargetPort: Int32?

    public var intranetSlbId: String?

    public var intranetSlbPort: Int32?

    public var intranetSlbProtocol: String?

    public var intranetTargetPort: Int32?

    public var isMultilingualApp: Bool?

    public var JDK: String?

    public var javaStartUpConfig: String?

    public var labels: String?

    public var limitCpu: Int32?

    public var limitEphemeralStorage: Int32?

    public var limitMem: Int32?

    public var limitmCpu: Int32?

    public var liveness: String?

    public var localVolume: String?

    public var logicalRegionId: String?

    public var losslessRuleAligned: Bool?

    public var losslessRuleDelayTime: Int32?

    public var losslessRuleFuncType: Int32?

    public var losslessRuleRelated: Bool?

    public var losslessRuleWarmupTime: Int32?

    public var mountDescs: String?

    public var namespace: String?

    public var nasId: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var postStart: String?

    public var preStop: String?

    public var pvcMountDescs: String?

    public var readiness: String?

    public var replicas: Int32?

    public var repoId: String?

    public var requestsCpu: Int32?

    public var requestsEphemeralStorage: Int32?

    public var requestsMem: Int32?

    public var requestsmCpu: Int32?

    public var resourceGroupId: String?

    public var runtimeClassName: String?

    public var secretName: String?

    public var serviceConfigs: String?

    public var sidecars: String?

    public var slsConfigs: String?

    public var startup: String?

    public var storageType: String?

    public var terminateGracePeriod: Int32?

    public var timeout: Int32?

    public var uriEncoding: String?

    public var useBodyEncoding: Bool?

    public var userBaseImageUrl: String?

    public var webContainer: String?

    public var webContainerConfig: String?

    public var workloadType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.appConfig != nil {
            map["AppConfig"] = self.appConfig!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appTemplateName != nil {
            map["AppTemplateName"] = self.appTemplateName!
        }
        if self.applicationDescription != nil {
            map["ApplicationDescription"] = self.applicationDescription!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMountDescs != nil {
            map["ConfigMountDescs"] = self.configMountDescs!
        }
        if self.containerRegistryId != nil {
            map["ContainerRegistryId"] = self.containerRegistryId!
        }
        if self.csClusterId != nil {
            map["CsClusterId"] = self.csClusterId!
        }
        if self.customAffinity != nil {
            map["CustomAffinity"] = self.customAffinity!
        }
        if self.customTolerations != nil {
            map["CustomTolerations"] = self.customTolerations!
        }
        if self.deployAcrossNodes != nil {
            map["DeployAcrossNodes"] = self.deployAcrossNodes!
        }
        if self.deployAcrossZones != nil {
            map["DeployAcrossZones"] = self.deployAcrossZones!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.emptyDirs != nil {
            map["EmptyDirs"] = self.emptyDirs!
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        if self.enableAsm != nil {
            map["EnableAsm"] = self.enableAsm!
        }
        if self.enableEmptyPushReject != nil {
            map["EnableEmptyPushReject"] = self.enableEmptyPushReject!
        }
        if self.enableLosslessRule != nil {
            map["EnableLosslessRule"] = self.enableLosslessRule!
        }
        if self.envFroms != nil {
            map["EnvFroms"] = self.envFroms!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imagePlatforms != nil {
            map["ImagePlatforms"] = self.imagePlatforms!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.initContainers != nil {
            map["InitContainers"] = self.initContainers!
        }
        if self.internetSlbId != nil {
            map["InternetSlbId"] = self.internetSlbId!
        }
        if self.internetSlbPort != nil {
            map["InternetSlbPort"] = self.internetSlbPort!
        }
        if self.internetSlbProtocol != nil {
            map["InternetSlbProtocol"] = self.internetSlbProtocol!
        }
        if self.internetTargetPort != nil {
            map["InternetTargetPort"] = self.internetTargetPort!
        }
        if self.intranetSlbId != nil {
            map["IntranetSlbId"] = self.intranetSlbId!
        }
        if self.intranetSlbPort != nil {
            map["IntranetSlbPort"] = self.intranetSlbPort!
        }
        if self.intranetSlbProtocol != nil {
            map["IntranetSlbProtocol"] = self.intranetSlbProtocol!
        }
        if self.intranetTargetPort != nil {
            map["IntranetTargetPort"] = self.intranetTargetPort!
        }
        if self.isMultilingualApp != nil {
            map["IsMultilingualApp"] = self.isMultilingualApp!
        }
        if self.JDK != nil {
            map["JDK"] = self.JDK!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.limitCpu != nil {
            map["LimitCpu"] = self.limitCpu!
        }
        if self.limitEphemeralStorage != nil {
            map["LimitEphemeralStorage"] = self.limitEphemeralStorage!
        }
        if self.limitMem != nil {
            map["LimitMem"] = self.limitMem!
        }
        if self.limitmCpu != nil {
            map["LimitmCpu"] = self.limitmCpu!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.localVolume != nil {
            map["LocalVolume"] = self.localVolume!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.losslessRuleAligned != nil {
            map["LosslessRuleAligned"] = self.losslessRuleAligned!
        }
        if self.losslessRuleDelayTime != nil {
            map["LosslessRuleDelayTime"] = self.losslessRuleDelayTime!
        }
        if self.losslessRuleFuncType != nil {
            map["LosslessRuleFuncType"] = self.losslessRuleFuncType!
        }
        if self.losslessRuleRelated != nil {
            map["LosslessRuleRelated"] = self.losslessRuleRelated!
        }
        if self.losslessRuleWarmupTime != nil {
            map["LosslessRuleWarmupTime"] = self.losslessRuleWarmupTime!
        }
        if self.mountDescs != nil {
            map["MountDescs"] = self.mountDescs!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.pvcMountDescs != nil {
            map["PvcMountDescs"] = self.pvcMountDescs!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.repoId != nil {
            map["RepoId"] = self.repoId!
        }
        if self.requestsCpu != nil {
            map["RequestsCpu"] = self.requestsCpu!
        }
        if self.requestsEphemeralStorage != nil {
            map["RequestsEphemeralStorage"] = self.requestsEphemeralStorage!
        }
        if self.requestsMem != nil {
            map["RequestsMem"] = self.requestsMem!
        }
        if self.requestsmCpu != nil {
            map["RequestsmCpu"] = self.requestsmCpu!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.runtimeClassName != nil {
            map["RuntimeClassName"] = self.runtimeClassName!
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        if self.serviceConfigs != nil {
            map["ServiceConfigs"] = self.serviceConfigs!
        }
        if self.sidecars != nil {
            map["Sidecars"] = self.sidecars!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.startup != nil {
            map["Startup"] = self.startup!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        if self.terminateGracePeriod != nil {
            map["TerminateGracePeriod"] = self.terminateGracePeriod!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.uriEncoding != nil {
            map["UriEncoding"] = self.uriEncoding!
        }
        if self.useBodyEncoding != nil {
            map["UseBodyEncoding"] = self.useBodyEncoding!
        }
        if self.userBaseImageUrl != nil {
            map["UserBaseImageUrl"] = self.userBaseImageUrl!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        if self.webContainerConfig != nil {
            map["WebContainerConfig"] = self.webContainerConfig!
        }
        if self.workloadType != nil {
            map["WorkloadType"] = self.workloadType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("AppConfig") && dict["AppConfig"] != nil {
            self.appConfig = dict["AppConfig"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppTemplateName") && dict["AppTemplateName"] != nil {
            self.appTemplateName = dict["AppTemplateName"] as! String
        }
        if dict.keys.contains("ApplicationDescription") && dict["ApplicationDescription"] != nil {
            self.applicationDescription = dict["ApplicationDescription"] as! String
        }
        if dict.keys.contains("BuildPackId") && dict["BuildPackId"] != nil {
            self.buildPackId = dict["BuildPackId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Command") && dict["Command"] != nil {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("CommandArgs") && dict["CommandArgs"] != nil {
            self.commandArgs = dict["CommandArgs"] as! String
        }
        if dict.keys.contains("ConfigMountDescs") && dict["ConfigMountDescs"] != nil {
            self.configMountDescs = dict["ConfigMountDescs"] as! String
        }
        if dict.keys.contains("ContainerRegistryId") && dict["ContainerRegistryId"] != nil {
            self.containerRegistryId = dict["ContainerRegistryId"] as! String
        }
        if dict.keys.contains("CsClusterId") && dict["CsClusterId"] != nil {
            self.csClusterId = dict["CsClusterId"] as! String
        }
        if dict.keys.contains("CustomAffinity") && dict["CustomAffinity"] != nil {
            self.customAffinity = dict["CustomAffinity"] as! String
        }
        if dict.keys.contains("CustomTolerations") && dict["CustomTolerations"] != nil {
            self.customTolerations = dict["CustomTolerations"] as! String
        }
        if dict.keys.contains("DeployAcrossNodes") && dict["DeployAcrossNodes"] != nil {
            self.deployAcrossNodes = dict["DeployAcrossNodes"] as! String
        }
        if dict.keys.contains("DeployAcrossZones") && dict["DeployAcrossZones"] != nil {
            self.deployAcrossZones = dict["DeployAcrossZones"] as! String
        }
        if dict.keys.contains("EdasContainerVersion") && dict["EdasContainerVersion"] != nil {
            self.edasContainerVersion = dict["EdasContainerVersion"] as! String
        }
        if dict.keys.contains("EmptyDirs") && dict["EmptyDirs"] != nil {
            self.emptyDirs = dict["EmptyDirs"] as! String
        }
        if dict.keys.contains("EnableAhas") && dict["EnableAhas"] != nil {
            self.enableAhas = dict["EnableAhas"] as! Bool
        }
        if dict.keys.contains("EnableAsm") && dict["EnableAsm"] != nil {
            self.enableAsm = dict["EnableAsm"] as! Bool
        }
        if dict.keys.contains("EnableEmptyPushReject") && dict["EnableEmptyPushReject"] != nil {
            self.enableEmptyPushReject = dict["EnableEmptyPushReject"] as! Bool
        }
        if dict.keys.contains("EnableLosslessRule") && dict["EnableLosslessRule"] != nil {
            self.enableLosslessRule = dict["EnableLosslessRule"] as! Bool
        }
        if dict.keys.contains("EnvFroms") && dict["EnvFroms"] != nil {
            self.envFroms = dict["EnvFroms"] as! String
        }
        if dict.keys.contains("Envs") && dict["Envs"] != nil {
            self.envs = dict["Envs"] as! String
        }
        if dict.keys.contains("ImagePlatforms") && dict["ImagePlatforms"] != nil {
            self.imagePlatforms = dict["ImagePlatforms"] as! String
        }
        if dict.keys.contains("ImageUrl") && dict["ImageUrl"] != nil {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("InitContainers") && dict["InitContainers"] != nil {
            self.initContainers = dict["InitContainers"] as! String
        }
        if dict.keys.contains("InternetSlbId") && dict["InternetSlbId"] != nil {
            self.internetSlbId = dict["InternetSlbId"] as! String
        }
        if dict.keys.contains("InternetSlbPort") && dict["InternetSlbPort"] != nil {
            self.internetSlbPort = dict["InternetSlbPort"] as! Int32
        }
        if dict.keys.contains("InternetSlbProtocol") && dict["InternetSlbProtocol"] != nil {
            self.internetSlbProtocol = dict["InternetSlbProtocol"] as! String
        }
        if dict.keys.contains("InternetTargetPort") && dict["InternetTargetPort"] != nil {
            self.internetTargetPort = dict["InternetTargetPort"] as! Int32
        }
        if dict.keys.contains("IntranetSlbId") && dict["IntranetSlbId"] != nil {
            self.intranetSlbId = dict["IntranetSlbId"] as! String
        }
        if dict.keys.contains("IntranetSlbPort") && dict["IntranetSlbPort"] != nil {
            self.intranetSlbPort = dict["IntranetSlbPort"] as! Int32
        }
        if dict.keys.contains("IntranetSlbProtocol") && dict["IntranetSlbProtocol"] != nil {
            self.intranetSlbProtocol = dict["IntranetSlbProtocol"] as! String
        }
        if dict.keys.contains("IntranetTargetPort") && dict["IntranetTargetPort"] != nil {
            self.intranetTargetPort = dict["IntranetTargetPort"] as! Int32
        }
        if dict.keys.contains("IsMultilingualApp") && dict["IsMultilingualApp"] != nil {
            self.isMultilingualApp = dict["IsMultilingualApp"] as! Bool
        }
        if dict.keys.contains("JDK") && dict["JDK"] != nil {
            self.JDK = dict["JDK"] as! String
        }
        if dict.keys.contains("JavaStartUpConfig") && dict["JavaStartUpConfig"] != nil {
            self.javaStartUpConfig = dict["JavaStartUpConfig"] as! String
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("LimitCpu") && dict["LimitCpu"] != nil {
            self.limitCpu = dict["LimitCpu"] as! Int32
        }
        if dict.keys.contains("LimitEphemeralStorage") && dict["LimitEphemeralStorage"] != nil {
            self.limitEphemeralStorage = dict["LimitEphemeralStorage"] as! Int32
        }
        if dict.keys.contains("LimitMem") && dict["LimitMem"] != nil {
            self.limitMem = dict["LimitMem"] as! Int32
        }
        if dict.keys.contains("LimitmCpu") && dict["LimitmCpu"] != nil {
            self.limitmCpu = dict["LimitmCpu"] as! Int32
        }
        if dict.keys.contains("Liveness") && dict["Liveness"] != nil {
            self.liveness = dict["Liveness"] as! String
        }
        if dict.keys.contains("LocalVolume") && dict["LocalVolume"] != nil {
            self.localVolume = dict["LocalVolume"] as! String
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
        if dict.keys.contains("LosslessRuleAligned") && dict["LosslessRuleAligned"] != nil {
            self.losslessRuleAligned = dict["LosslessRuleAligned"] as! Bool
        }
        if dict.keys.contains("LosslessRuleDelayTime") && dict["LosslessRuleDelayTime"] != nil {
            self.losslessRuleDelayTime = dict["LosslessRuleDelayTime"] as! Int32
        }
        if dict.keys.contains("LosslessRuleFuncType") && dict["LosslessRuleFuncType"] != nil {
            self.losslessRuleFuncType = dict["LosslessRuleFuncType"] as! Int32
        }
        if dict.keys.contains("LosslessRuleRelated") && dict["LosslessRuleRelated"] != nil {
            self.losslessRuleRelated = dict["LosslessRuleRelated"] as! Bool
        }
        if dict.keys.contains("LosslessRuleWarmupTime") && dict["LosslessRuleWarmupTime"] != nil {
            self.losslessRuleWarmupTime = dict["LosslessRuleWarmupTime"] as! Int32
        }
        if dict.keys.contains("MountDescs") && dict["MountDescs"] != nil {
            self.mountDescs = dict["MountDescs"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NasId") && dict["NasId"] != nil {
            self.nasId = dict["NasId"] as! String
        }
        if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
            self.packageType = dict["PackageType"] as! String
        }
        if dict.keys.contains("PackageUrl") && dict["PackageUrl"] != nil {
            self.packageUrl = dict["PackageUrl"] as! String
        }
        if dict.keys.contains("PackageVersion") && dict["PackageVersion"] != nil {
            self.packageVersion = dict["PackageVersion"] as! String
        }
        if dict.keys.contains("PostStart") && dict["PostStart"] != nil {
            self.postStart = dict["PostStart"] as! String
        }
        if dict.keys.contains("PreStop") && dict["PreStop"] != nil {
            self.preStop = dict["PreStop"] as! String
        }
        if dict.keys.contains("PvcMountDescs") && dict["PvcMountDescs"] != nil {
            self.pvcMountDescs = dict["PvcMountDescs"] as! String
        }
        if dict.keys.contains("Readiness") && dict["Readiness"] != nil {
            self.readiness = dict["Readiness"] as! String
        }
        if dict.keys.contains("Replicas") && dict["Replicas"] != nil {
            self.replicas = dict["Replicas"] as! Int32
        }
        if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
            self.repoId = dict["RepoId"] as! String
        }
        if dict.keys.contains("RequestsCpu") && dict["RequestsCpu"] != nil {
            self.requestsCpu = dict["RequestsCpu"] as! Int32
        }
        if dict.keys.contains("RequestsEphemeralStorage") && dict["RequestsEphemeralStorage"] != nil {
            self.requestsEphemeralStorage = dict["RequestsEphemeralStorage"] as! Int32
        }
        if dict.keys.contains("RequestsMem") && dict["RequestsMem"] != nil {
            self.requestsMem = dict["RequestsMem"] as! Int32
        }
        if dict.keys.contains("RequestsmCpu") && dict["RequestsmCpu"] != nil {
            self.requestsmCpu = dict["RequestsmCpu"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RuntimeClassName") && dict["RuntimeClassName"] != nil {
            self.runtimeClassName = dict["RuntimeClassName"] as! String
        }
        if dict.keys.contains("SecretName") && dict["SecretName"] != nil {
            self.secretName = dict["SecretName"] as! String
        }
        if dict.keys.contains("ServiceConfigs") && dict["ServiceConfigs"] != nil {
            self.serviceConfigs = dict["ServiceConfigs"] as! String
        }
        if dict.keys.contains("Sidecars") && dict["Sidecars"] != nil {
            self.sidecars = dict["Sidecars"] as! String
        }
        if dict.keys.contains("SlsConfigs") && dict["SlsConfigs"] != nil {
            self.slsConfigs = dict["SlsConfigs"] as! String
        }
        if dict.keys.contains("Startup") && dict["Startup"] != nil {
            self.startup = dict["Startup"] as! String
        }
        if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
            self.storageType = dict["StorageType"] as! String
        }
        if dict.keys.contains("TerminateGracePeriod") && dict["TerminateGracePeriod"] != nil {
            self.terminateGracePeriod = dict["TerminateGracePeriod"] as! Int32
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UriEncoding") && dict["UriEncoding"] != nil {
            self.uriEncoding = dict["UriEncoding"] as! String
        }
        if dict.keys.contains("UseBodyEncoding") && dict["UseBodyEncoding"] != nil {
            self.useBodyEncoding = dict["UseBodyEncoding"] as! Bool
        }
        if dict.keys.contains("UserBaseImageUrl") && dict["UserBaseImageUrl"] != nil {
            self.userBaseImageUrl = dict["UserBaseImageUrl"] as! String
        }
        if dict.keys.contains("WebContainer") && dict["WebContainer"] != nil {
            self.webContainer = dict["WebContainer"] as! String
        }
        if dict.keys.contains("WebContainerConfig") && dict["WebContainerConfig"] != nil {
            self.webContainerConfig = dict["WebContainerConfig"] as! String
        }
        if dict.keys.contains("WorkloadType") && dict["WorkloadType"] != nil {
            self.workloadType = dict["WorkloadType"] as! String
        }
    }
}

public class InsertK8sApplicationResponseBody : Tea.TeaModel {
    public class ApplicationInfo : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var changeOrderId: String?

        public var clusterType: Int32?

        public var dockerize: Bool?

        public var edasId: String?

        public var owner: String?

        public var regionId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.dockerize != nil {
                map["Dockerize"] = self.dockerize!
            }
            if self.edasId != nil {
                map["EdasId"] = self.edasId!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! Int32
            }
            if dict.keys.contains("Dockerize") && dict["Dockerize"] != nil {
                self.dockerize = dict["Dockerize"] as! Bool
            }
            if dict.keys.contains("EdasId") && dict["EdasId"] != nil {
                self.edasId = dict["EdasId"] as! String
            }
            if dict.keys.contains("Owner") && dict["Owner"] != nil {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var applicationInfo: InsertK8sApplicationResponseBody.ApplicationInfo?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationInfo != nil {
            map["ApplicationInfo"] = self.applicationInfo?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationInfo") && dict["ApplicationInfo"] != nil {
            var model = InsertK8sApplicationResponseBody.ApplicationInfo()
            model.fromMap(dict["ApplicationInfo"] as! [String: Any])
            self.applicationInfo = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InsertK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertK8sApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertOrUpdateRegionRequest : Tea.TeaModel {
    public var debugEnable: Bool?

    public var description_: String?

    public var id: Int64?

    public var mseInstanceId: String?

    public var regionName: String?

    public var regionTag: String?

    public var registryType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.debugEnable != nil {
            map["DebugEnable"] = self.debugEnable!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseInstanceId != nil {
            map["MseInstanceId"] = self.mseInstanceId!
        }
        if self.regionName != nil {
            map["RegionName"] = self.regionName!
        }
        if self.regionTag != nil {
            map["RegionTag"] = self.regionTag!
        }
        if self.registryType != nil {
            map["RegistryType"] = self.registryType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DebugEnable") && dict["DebugEnable"] != nil {
            self.debugEnable = dict["DebugEnable"] as! Bool
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MseInstanceId") && dict["MseInstanceId"] != nil {
            self.mseInstanceId = dict["MseInstanceId"] as! String
        }
        if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
            self.regionName = dict["RegionName"] as! String
        }
        if dict.keys.contains("RegionTag") && dict["RegionTag"] != nil {
            self.regionTag = dict["RegionTag"] as! String
        }
        if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
            self.registryType = dict["RegistryType"] as! String
        }
    }
}

public class InsertOrUpdateRegionResponseBody : Tea.TeaModel {
    public class UserDefineRegionEntity : Tea.TeaModel {
        public var belongRegion: String?

        public var debugEnable: Bool?

        public var description_: String?

        public var id: Int64?

        public var regionId: String?

        public var regionName: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.belongRegion != nil {
                map["BelongRegion"] = self.belongRegion!
            }
            if self.debugEnable != nil {
                map["DebugEnable"] = self.debugEnable!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BelongRegion") && dict["BelongRegion"] != nil {
                self.belongRegion = dict["BelongRegion"] as! String
            }
            if dict.keys.contains("DebugEnable") && dict["DebugEnable"] != nil {
                self.debugEnable = dict["DebugEnable"] as! Bool
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var userDefineRegionEntity: InsertOrUpdateRegionResponseBody.UserDefineRegionEntity?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userDefineRegionEntity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userDefineRegionEntity != nil {
            map["UserDefineRegionEntity"] = self.userDefineRegionEntity?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserDefineRegionEntity") && dict["UserDefineRegionEntity"] != nil {
            var model = InsertOrUpdateRegionResponseBody.UserDefineRegionEntity()
            model.fromMap(dict["UserDefineRegionEntity"] as! [String: Any])
            self.userDefineRegionEntity = model
        }
    }
}

public class InsertOrUpdateRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertOrUpdateRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertOrUpdateRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertRoleRequest : Tea.TeaModel {
    public var actionData: String?

    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionData != nil {
            map["ActionData"] = self.actionData!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionData") && dict["ActionData"] != nil {
            self.actionData = dict["ActionData"] as! String
        }
        if dict.keys.contains("RoleName") && dict["RoleName"] != nil {
            self.roleName = dict["RoleName"] as! String
        }
    }
}

public class InsertRoleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var roleId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
            self.roleId = dict["RoleId"] as! Int32
        }
    }
}

public class InsertRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertServiceGroupRequest : Tea.TeaModel {
    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
    }
}

public class InsertServiceGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InsertServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertSwimmingLaneRequest : Tea.TeaModel {
    public var appInfos: String?

    public var enableRules: Bool?

    public var entryRules: String?

    public var groupId: Int64?

    public var logicalRegionId: String?

    public var name: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfos != nil {
            map["AppInfos"] = self.appInfos!
        }
        if self.enableRules != nil {
            map["EnableRules"] = self.enableRules!
        }
        if self.entryRules != nil {
            map["EntryRules"] = self.entryRules!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppInfos") && dict["AppInfos"] != nil {
            self.appInfos = dict["AppInfos"] as! String
        }
        if dict.keys.contains("EnableRules") && dict["EnableRules"] != nil {
            self.enableRules = dict["EnableRules"] as! Bool
        }
        if dict.keys.contains("EntryRules") && dict["EntryRules"] != nil {
            self.entryRules = dict["EntryRules"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class InsertSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SwimmingLaneAppRelationShipList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var laneId: Int64?

            public var rules: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.laneId != nil {
                    map["LaneId"] = self.laneId!
                }
                if self.rules != nil {
                    map["Rules"] = self.rules!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("LaneId") && dict["LaneId"] != nil {
                    self.laneId = dict["LaneId"] as! Int64
                }
                if dict.keys.contains("Rules") && dict["Rules"] != nil {
                    self.rules = dict["Rules"] as! String
                }
            }
        }
        public var appInfos: String?

        public var entryRule: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public var swimmingLaneAppRelationShipList: [InsertSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList]?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appInfos != nil {
                map["AppInfos"] = self.appInfos!
            }
            if self.entryRule != nil {
                map["EntryRule"] = self.entryRule!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.swimmingLaneAppRelationShipList != nil {
                var tmp : [Any] = []
                for k in self.swimmingLaneAppRelationShipList! {
                    tmp.append(k.toMap())
                }
                map["SwimmingLaneAppRelationShipList"] = tmp
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppInfos") && dict["AppInfos"] != nil {
                self.appInfos = dict["AppInfos"] as! String
            }
            if dict.keys.contains("EntryRule") && dict["EntryRule"] != nil {
                self.entryRule = dict["EntryRule"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("SwimmingLaneAppRelationShipList") && dict["SwimmingLaneAppRelationShipList"] != nil {
                var tmp : [InsertSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList] = []
                for v in dict["SwimmingLaneAppRelationShipList"] as! [Any] {
                    var model = InsertSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.swimmingLaneAppRelationShipList = tmp
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: InsertSwimmingLaneResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = InsertSwimmingLaneResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InsertSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertSwimmingLaneGroupRequest : Tea.TeaModel {
    public var appIds: String?

    public var entryApp: String?

    public var logicalRegionId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.entryApp != nil {
            map["EntryApp"] = self.entryApp!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("EntryApp") && dict["EntryApp"] != nil {
            self.entryApp = dict["EntryApp"] as! String
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class InsertSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApplicationList : Tea.TeaModel {
            public class Application : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("AppName") && dict["AppName"] != nil {
                        self.appName = dict["AppName"] as! String
                    }
                }
            }
            public var application: [InsertSwimmingLaneGroupResponseBody.Data.ApplicationList.Application]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.application != nil {
                    var tmp : [Any] = []
                    for k in self.application! {
                        tmp.append(k.toMap())
                    }
                    map["Application"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Application") && dict["Application"] != nil {
                    var tmp : [InsertSwimmingLaneGroupResponseBody.Data.ApplicationList.Application] = []
                    for v in dict["Application"] as! [Any] {
                        var model = InsertSwimmingLaneGroupResponseBody.Data.ApplicationList.Application()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.application = tmp
                }
            }
        }
        public class EntryApplication : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
            }
        }
        public var applicationList: InsertSwimmingLaneGroupResponseBody.Data.ApplicationList?

        public var entryApplication: InsertSwimmingLaneGroupResponseBody.Data.EntryApplication?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.applicationList?.validate()
            try self.entryApplication?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationList != nil {
                map["ApplicationList"] = self.applicationList?.toMap()
            }
            if self.entryApplication != nil {
                map["EntryApplication"] = self.entryApplication?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationList") && dict["ApplicationList"] != nil {
                var model = InsertSwimmingLaneGroupResponseBody.Data.ApplicationList()
                model.fromMap(dict["ApplicationList"] as! [String: Any])
                self.applicationList = model
            }
            if dict.keys.contains("EntryApplication") && dict["EntryApplication"] != nil {
                var model = InsertSwimmingLaneGroupResponseBody.Data.EntryApplication()
                model.fromMap(dict["EntryApplication"] as! [String: Any])
                self.entryApplication = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                self.namespaceId = dict["NamespaceId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: InsertSwimmingLaneGroupResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = InsertSwimmingLaneGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InsertSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallAgentRequest : Tea.TeaModel {
    public var clusterId: String?

    public var doAsync: Bool?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.doAsync != nil {
            map["DoAsync"] = self.doAsync!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DoAsync") && dict["DoAsync"] != nil {
            self.doAsync = dict["DoAsync"] as! Bool
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
    }
}

public class InstallAgentResponseBody : Tea.TeaModel {
    public class ExecutionResultList : Tea.TeaModel {
        public class ExecutionResult : Tea.TeaModel {
            public var finishedTime: String?

            public var instanceId: String?

            public var invokeRecordStatus: String?

            public var status: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.invokeRecordStatus != nil {
                    map["InvokeRecordStatus"] = self.invokeRecordStatus!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FinishedTime") && dict["FinishedTime"] != nil {
                    self.finishedTime = dict["FinishedTime"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InvokeRecordStatus") && dict["InvokeRecordStatus"] != nil {
                    self.invokeRecordStatus = dict["InvokeRecordStatus"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var executionResult: [InstallAgentResponseBody.ExecutionResultList.ExecutionResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.executionResult != nil {
                var tmp : [Any] = []
                for k in self.executionResult! {
                    tmp.append(k.toMap())
                }
                map["ExecutionResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExecutionResult") && dict["ExecutionResult"] != nil {
                var tmp : [InstallAgentResponseBody.ExecutionResultList.ExecutionResult] = []
                for v in dict["ExecutionResult"] as! [Any] {
                    var model = InstallAgentResponseBody.ExecutionResultList.ExecutionResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.executionResult = tmp
            }
        }
    }
    public var code: Int32?

    public var executionResultList: InstallAgentResponseBody.ExecutionResultList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.executionResultList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.executionResultList != nil {
            map["ExecutionResultList"] = self.executionResultList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ExecutionResultList") && dict["ExecutionResultList"] != nil {
            var model = InstallAgentResponseBody.ExecutionResultList()
            model.fromMap(dict["ExecutionResultList"] as! [String: Any])
            self.executionResultList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InstallAgentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallAgentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallAgentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAliyunRegionResponseBody : Tea.TeaModel {
    public class RegionEntityList : Tea.TeaModel {
        public class RegionEntity : Tea.TeaModel {
            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var regionEntity: [ListAliyunRegionResponseBody.RegionEntityList.RegionEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.regionEntity != nil {
                var tmp : [Any] = []
                for k in self.regionEntity! {
                    tmp.append(k.toMap())
                }
                map["RegionEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RegionEntity") && dict["RegionEntity"] != nil {
                var tmp : [ListAliyunRegionResponseBody.RegionEntityList.RegionEntity] = []
                for v in dict["RegionEntity"] as! [Any] {
                    var model = ListAliyunRegionResponseBody.RegionEntityList.RegionEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.regionEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regionEntityList: ListAliyunRegionResponseBody.RegionEntityList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regionEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regionEntityList != nil {
            map["RegionEntityList"] = self.regionEntityList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RegionEntityList") && dict["RegionEntityList"] != nil {
            var model = ListAliyunRegionResponseBody.RegionEntityList()
            model.fromMap(dict["RegionEntityList"] as! [String: Any])
            self.regionEntityList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAliyunRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAliyunRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAliyunRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationRequest : Tea.TeaModel {
    public var appIds: String?

    public var appName: String?

    public var clusterId: String?

    public var currentPage: Int32?

    public var logicalRegionId: String?

    public var logicalRegionIdFilter: String?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.logicalRegionIdFilter != nil {
            map["LogicalRegionIdFilter"] = self.logicalRegionIdFilter!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
        if dict.keys.contains("LogicalRegionIdFilter") && dict["LogicalRegionIdFilter"] != nil {
            self.logicalRegionIdFilter = dict["LogicalRegionIdFilter"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ListApplicationResponseBody : Tea.TeaModel {
    public class ApplicationList : Tea.TeaModel {
        public class Application : Tea.TeaModel {
            public var appId: String?

            public var applicationType: String?

            public var buildPackageId: Int64?

            public var clusterId: String?

            public var clusterType: Int32?

            public var createTime: Int64?

            public var extSlbIp: String?

            public var extSlbListenerPort: Int32?

            public var instances: Int32?

            public var k8sNamespace: String?

            public var name: String?

            public var namespaceId: String?

            public var port: Int32?

            public var regionId: String?

            public var resourceGroupId: String?

            public var runningInstanceCount: Int32?

            public var slbIp: String?

            public var slbListenerPort: Int32?

            public var slbPort: Int32?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.applicationType != nil {
                    map["ApplicationType"] = self.applicationType!
                }
                if self.buildPackageId != nil {
                    map["BuildPackageId"] = self.buildPackageId!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.extSlbIp != nil {
                    map["ExtSlbIp"] = self.extSlbIp!
                }
                if self.extSlbListenerPort != nil {
                    map["ExtSlbListenerPort"] = self.extSlbListenerPort!
                }
                if self.instances != nil {
                    map["Instances"] = self.instances!
                }
                if self.k8sNamespace != nil {
                    map["K8sNamespace"] = self.k8sNamespace!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.runningInstanceCount != nil {
                    map["RunningInstanceCount"] = self.runningInstanceCount!
                }
                if self.slbIp != nil {
                    map["SlbIp"] = self.slbIp!
                }
                if self.slbListenerPort != nil {
                    map["SlbListenerPort"] = self.slbListenerPort!
                }
                if self.slbPort != nil {
                    map["SlbPort"] = self.slbPort!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("ApplicationType") && dict["ApplicationType"] != nil {
                    self.applicationType = dict["ApplicationType"] as! String
                }
                if dict.keys.contains("BuildPackageId") && dict["BuildPackageId"] != nil {
                    self.buildPackageId = dict["BuildPackageId"] as! Int64
                }
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                    self.clusterType = dict["ClusterType"] as! Int32
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("ExtSlbIp") && dict["ExtSlbIp"] != nil {
                    self.extSlbIp = dict["ExtSlbIp"] as! String
                }
                if dict.keys.contains("ExtSlbListenerPort") && dict["ExtSlbListenerPort"] != nil {
                    self.extSlbListenerPort = dict["ExtSlbListenerPort"] as! Int32
                }
                if dict.keys.contains("Instances") && dict["Instances"] != nil {
                    self.instances = dict["Instances"] as! Int32
                }
                if dict.keys.contains("K8sNamespace") && dict["K8sNamespace"] != nil {
                    self.k8sNamespace = dict["K8sNamespace"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RunningInstanceCount") && dict["RunningInstanceCount"] != nil {
                    self.runningInstanceCount = dict["RunningInstanceCount"] as! Int32
                }
                if dict.keys.contains("SlbIp") && dict["SlbIp"] != nil {
                    self.slbIp = dict["SlbIp"] as! String
                }
                if dict.keys.contains("SlbListenerPort") && dict["SlbListenerPort"] != nil {
                    self.slbListenerPort = dict["SlbListenerPort"] as! Int32
                }
                if dict.keys.contains("SlbPort") && dict["SlbPort"] != nil {
                    self.slbPort = dict["SlbPort"] as! Int32
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var application: [ListApplicationResponseBody.ApplicationList.Application]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.application != nil {
                var tmp : [Any] = []
                for k in self.application! {
                    tmp.append(k.toMap())
                }
                map["Application"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Application") && dict["Application"] != nil {
                var tmp : [ListApplicationResponseBody.ApplicationList.Application] = []
                for v in dict["Application"] as! [Any] {
                    var model = ListApplicationResponseBody.ApplicationList.Application()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.application = tmp
            }
        }
    }
    public var applicationList: ListApplicationResponseBody.ApplicationList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationList != nil {
            map["ApplicationList"] = self.applicationList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationList") && dict["ApplicationList"] != nil {
            var model = ListApplicationResponseBody.ApplicationList()
            model.fromMap(dict["ApplicationList"] as! [String: Any])
            self.applicationList = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationEcuRequest : Tea.TeaModel {
    public var appId: String?

    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
    }
}

public class ListApplicationEcuResponseBody : Tea.TeaModel {
    public class EcuInfoList : Tea.TeaModel {
        public class EcuEntity : Tea.TeaModel {
            public var appId: String?

            public var availableCpu: Int32?

            public var availableMem: Int32?

            public var cpu: Int32?

            public var createTime: Int64?

            public var dockerEnv: Bool?

            public var ecuId: String?

            public var heartbeatTime: Int64?

            public var instanceId: String?

            public var ipAddr: String?

            public var mem: Int32?

            public var name: String?

            public var online: Bool?

            public var regionId: String?

            public var updateTime: Int64?

            public var userId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.availableCpu != nil {
                    map["AvailableCpu"] = self.availableCpu!
                }
                if self.availableMem != nil {
                    map["AvailableMem"] = self.availableMem!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerEnv != nil {
                    map["DockerEnv"] = self.dockerEnv!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.heartbeatTime != nil {
                    map["HeartbeatTime"] = self.heartbeatTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipAddr != nil {
                    map["IpAddr"] = self.ipAddr!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AvailableCpu") && dict["AvailableCpu"] != nil {
                    self.availableCpu = dict["AvailableCpu"] as! Int32
                }
                if dict.keys.contains("AvailableMem") && dict["AvailableMem"] != nil {
                    self.availableMem = dict["AvailableMem"] as! Int32
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DockerEnv") && dict["DockerEnv"] != nil {
                    self.dockerEnv = dict["DockerEnv"] as! Bool
                }
                if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                    self.ecuId = dict["EcuId"] as! String
                }
                if dict.keys.contains("HeartbeatTime") && dict["HeartbeatTime"] != nil {
                    self.heartbeatTime = dict["HeartbeatTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IpAddr") && dict["IpAddr"] != nil {
                    self.ipAddr = dict["IpAddr"] as! String
                }
                if dict.keys.contains("Mem") && dict["Mem"] != nil {
                    self.mem = dict["Mem"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Online") && dict["Online"] != nil {
                    self.online = dict["Online"] as! Bool
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var ecuEntity: [ListApplicationEcuResponseBody.EcuInfoList.EcuEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecuEntity != nil {
                var tmp : [Any] = []
                for k in self.ecuEntity! {
                    tmp.append(k.toMap())
                }
                map["EcuEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EcuEntity") && dict["EcuEntity"] != nil {
                var tmp : [ListApplicationEcuResponseBody.EcuInfoList.EcuEntity] = []
                for v in dict["EcuEntity"] as! [Any] {
                    var model = ListApplicationEcuResponseBody.EcuInfoList.EcuEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ecuEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var ecuInfoList: ListApplicationEcuResponseBody.EcuInfoList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecuInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecuInfoList != nil {
            map["EcuInfoList"] = self.ecuInfoList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EcuInfoList") && dict["EcuInfoList"] != nil {
            var model = ListApplicationEcuResponseBody.EcuInfoList()
            model.fromMap(dict["EcuInfoList"] as! [String: Any])
            self.ecuInfoList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListApplicationEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListApplicationEcuResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuthorityResponseBody : Tea.TeaModel {
    public class AuthorityList : Tea.TeaModel {
        public class Authority : Tea.TeaModel {
            public class ActionList : Tea.TeaModel {
                public class Action : Tea.TeaModel {
                    public var code: String?

                    public var description_: String?

                    public var groupId: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.groupId != nil {
                            map["GroupId"] = self.groupId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") && dict["Code"] != nil {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                            self.groupId = dict["GroupId"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var action: [ListAuthorityResponseBody.AuthorityList.Authority.ActionList.Action]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        var tmp : [Any] = []
                        for k in self.action! {
                            tmp.append(k.toMap())
                        }
                        map["Action"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Action") && dict["Action"] != nil {
                        var tmp : [ListAuthorityResponseBody.AuthorityList.Authority.ActionList.Action] = []
                        for v in dict["Action"] as! [Any] {
                            var model = ListAuthorityResponseBody.AuthorityList.Authority.ActionList.Action()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.action = tmp
                    }
                }
            }
            public var actionList: ListAuthorityResponseBody.AuthorityList.Authority.ActionList?

            public var description_: String?

            public var groupId: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.actionList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionList != nil {
                    map["ActionList"] = self.actionList?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActionList") && dict["ActionList"] != nil {
                    var model = ListAuthorityResponseBody.AuthorityList.Authority.ActionList()
                    model.fromMap(dict["ActionList"] as! [String: Any])
                    self.actionList = model
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var authority: [ListAuthorityResponseBody.AuthorityList.Authority]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authority != nil {
                var tmp : [Any] = []
                for k in self.authority! {
                    tmp.append(k.toMap())
                }
                map["Authority"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Authority") && dict["Authority"] != nil {
                var tmp : [ListAuthorityResponseBody.AuthorityList.Authority] = []
                for v in dict["Authority"] as! [Any] {
                    var model = ListAuthorityResponseBody.AuthorityList.Authority()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authority = tmp
            }
        }
    }
    public var authorityList: ListAuthorityResponseBody.AuthorityList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityList != nil {
            map["AuthorityList"] = self.authorityList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorityList") && dict["AuthorityList"] != nil {
            var model = ListAuthorityResponseBody.AuthorityList()
            model.fromMap(dict["AuthorityList"] as! [String: Any])
            self.authorityList = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAuthorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBuildPackResponseBody : Tea.TeaModel {
    public class BuildPackList : Tea.TeaModel {
        public class BuildPack : Tea.TeaModel {
            public var configId: Int64?

            public var disabled: Bool?

            public var feature: String?

            public var imageId: String?

            public var multipleTenant: Bool?

            public var packVersion: String?

            public var pandoraDesc: String?

            public var pandoraDownloadUrl: String?

            public var pandoraVersion: String?

            public var pluginInfo: String?

            public var scriptName: String?

            public var scriptVersion: String?

            public var supportFeatures: String?

            public var tengineDownloadUrl: String?

            public var tengineImageId: String?

            public var tomcatDesc: String?

            public var tomcatDownloadUrl: String?

            public var tomcatPath: String?

            public var tomcatVersion: String?

            public var withTengine: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.disabled != nil {
                    map["Disabled"] = self.disabled!
                }
                if self.feature != nil {
                    map["Feature"] = self.feature!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.multipleTenant != nil {
                    map["MultipleTenant"] = self.multipleTenant!
                }
                if self.packVersion != nil {
                    map["PackVersion"] = self.packVersion!
                }
                if self.pandoraDesc != nil {
                    map["PandoraDesc"] = self.pandoraDesc!
                }
                if self.pandoraDownloadUrl != nil {
                    map["PandoraDownloadUrl"] = self.pandoraDownloadUrl!
                }
                if self.pandoraVersion != nil {
                    map["PandoraVersion"] = self.pandoraVersion!
                }
                if self.pluginInfo != nil {
                    map["PluginInfo"] = self.pluginInfo!
                }
                if self.scriptName != nil {
                    map["ScriptName"] = self.scriptName!
                }
                if self.scriptVersion != nil {
                    map["ScriptVersion"] = self.scriptVersion!
                }
                if self.supportFeatures != nil {
                    map["SupportFeatures"] = self.supportFeatures!
                }
                if self.tengineDownloadUrl != nil {
                    map["TengineDownloadUrl"] = self.tengineDownloadUrl!
                }
                if self.tengineImageId != nil {
                    map["TengineImageId"] = self.tengineImageId!
                }
                if self.tomcatDesc != nil {
                    map["TomcatDesc"] = self.tomcatDesc!
                }
                if self.tomcatDownloadUrl != nil {
                    map["TomcatDownloadUrl"] = self.tomcatDownloadUrl!
                }
                if self.tomcatPath != nil {
                    map["TomcatPath"] = self.tomcatPath!
                }
                if self.tomcatVersion != nil {
                    map["TomcatVersion"] = self.tomcatVersion!
                }
                if self.withTengine != nil {
                    map["WithTengine"] = self.withTengine!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigId") && dict["ConfigId"] != nil {
                    self.configId = dict["ConfigId"] as! Int64
                }
                if dict.keys.contains("Disabled") && dict["Disabled"] != nil {
                    self.disabled = dict["Disabled"] as! Bool
                }
                if dict.keys.contains("Feature") && dict["Feature"] != nil {
                    self.feature = dict["Feature"] as! String
                }
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("MultipleTenant") && dict["MultipleTenant"] != nil {
                    self.multipleTenant = dict["MultipleTenant"] as! Bool
                }
                if dict.keys.contains("PackVersion") && dict["PackVersion"] != nil {
                    self.packVersion = dict["PackVersion"] as! String
                }
                if dict.keys.contains("PandoraDesc") && dict["PandoraDesc"] != nil {
                    self.pandoraDesc = dict["PandoraDesc"] as! String
                }
                if dict.keys.contains("PandoraDownloadUrl") && dict["PandoraDownloadUrl"] != nil {
                    self.pandoraDownloadUrl = dict["PandoraDownloadUrl"] as! String
                }
                if dict.keys.contains("PandoraVersion") && dict["PandoraVersion"] != nil {
                    self.pandoraVersion = dict["PandoraVersion"] as! String
                }
                if dict.keys.contains("PluginInfo") && dict["PluginInfo"] != nil {
                    self.pluginInfo = dict["PluginInfo"] as! String
                }
                if dict.keys.contains("ScriptName") && dict["ScriptName"] != nil {
                    self.scriptName = dict["ScriptName"] as! String
                }
                if dict.keys.contains("ScriptVersion") && dict["ScriptVersion"] != nil {
                    self.scriptVersion = dict["ScriptVersion"] as! String
                }
                if dict.keys.contains("SupportFeatures") && dict["SupportFeatures"] != nil {
                    self.supportFeatures = dict["SupportFeatures"] as! String
                }
                if dict.keys.contains("TengineDownloadUrl") && dict["TengineDownloadUrl"] != nil {
                    self.tengineDownloadUrl = dict["TengineDownloadUrl"] as! String
                }
                if dict.keys.contains("TengineImageId") && dict["TengineImageId"] != nil {
                    self.tengineImageId = dict["TengineImageId"] as! String
                }
                if dict.keys.contains("TomcatDesc") && dict["TomcatDesc"] != nil {
                    self.tomcatDesc = dict["TomcatDesc"] as! String
                }
                if dict.keys.contains("TomcatDownloadUrl") && dict["TomcatDownloadUrl"] != nil {
                    self.tomcatDownloadUrl = dict["TomcatDownloadUrl"] as! String
                }
                if dict.keys.contains("TomcatPath") && dict["TomcatPath"] != nil {
                    self.tomcatPath = dict["TomcatPath"] as! String
                }
                if dict.keys.contains("TomcatVersion") && dict["TomcatVersion"] != nil {
                    self.tomcatVersion = dict["TomcatVersion"] as! String
                }
                if dict.keys.contains("WithTengine") && dict["WithTengine"] != nil {
                    self.withTengine = dict["WithTengine"] as! Bool
                }
            }
        }
        public var buildPack: [ListBuildPackResponseBody.BuildPackList.BuildPack]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buildPack != nil {
                var tmp : [Any] = []
                for k in self.buildPack! {
                    tmp.append(k.toMap())
                }
                map["BuildPack"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BuildPack") && dict["BuildPack"] != nil {
                var tmp : [ListBuildPackResponseBody.BuildPackList.BuildPack] = []
                for v in dict["BuildPack"] as! [Any] {
                    var model = ListBuildPackResponseBody.BuildPackList.BuildPack()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.buildPack = tmp
            }
        }
    }
    public var buildPackList: ListBuildPackResponseBody.BuildPackList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.buildPackList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.buildPackList != nil {
            map["BuildPackList"] = self.buildPackList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BuildPackList") && dict["BuildPackList"] != nil {
            var model = ListBuildPackResponseBody.BuildPackList()
            model.fromMap(dict["BuildPackList"] as! [String: Any])
            self.buildPackList = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListBuildPackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBuildPackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListBuildPackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterRequest : Tea.TeaModel {
    public var logicalRegionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ListClusterResponseBody : Tea.TeaModel {
    public class ClusterList : Tea.TeaModel {
        public class Cluster : Tea.TeaModel {
            public var clusterId: String?

            public var clusterName: String?

            public var clusterType: Int32?

            public var cpu: Int32?

            public var cpuUsed: Int32?

            public var createTime: Int64?

            public var csClusterId: String?

            public var description_: String?

            public var iaasProvider: String?

            public var mem: Int32?

            public var memUsed: Int32?

            public var networkMode: Int32?

            public var nodeNum: Int32?

            public var oversoldFactor: Int32?

            public var regionId: String?

            public var resourceGroupId: String?

            public var updateTime: Int64?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.cpuUsed != nil {
                    map["CpuUsed"] = self.cpuUsed!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.csClusterId != nil {
                    map["CsClusterId"] = self.csClusterId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.iaasProvider != nil {
                    map["IaasProvider"] = self.iaasProvider!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.memUsed != nil {
                    map["MemUsed"] = self.memUsed!
                }
                if self.networkMode != nil {
                    map["NetworkMode"] = self.networkMode!
                }
                if self.nodeNum != nil {
                    map["NodeNum"] = self.nodeNum!
                }
                if self.oversoldFactor != nil {
                    map["OversoldFactor"] = self.oversoldFactor!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                    self.clusterType = dict["ClusterType"] as! Int32
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("CpuUsed") && dict["CpuUsed"] != nil {
                    self.cpuUsed = dict["CpuUsed"] as! Int32
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CsClusterId") && dict["CsClusterId"] != nil {
                    self.csClusterId = dict["CsClusterId"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("IaasProvider") && dict["IaasProvider"] != nil {
                    self.iaasProvider = dict["IaasProvider"] as! String
                }
                if dict.keys.contains("Mem") && dict["Mem"] != nil {
                    self.mem = dict["Mem"] as! Int32
                }
                if dict.keys.contains("MemUsed") && dict["MemUsed"] != nil {
                    self.memUsed = dict["MemUsed"] as! Int32
                }
                if dict.keys.contains("NetworkMode") && dict["NetworkMode"] != nil {
                    self.networkMode = dict["NetworkMode"] as! Int32
                }
                if dict.keys.contains("NodeNum") && dict["NodeNum"] != nil {
                    self.nodeNum = dict["NodeNum"] as! Int32
                }
                if dict.keys.contains("OversoldFactor") && dict["OversoldFactor"] != nil {
                    self.oversoldFactor = dict["OversoldFactor"] as! Int32
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var cluster: [ListClusterResponseBody.ClusterList.Cluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cluster != nil {
                var tmp : [Any] = []
                for k in self.cluster! {
                    tmp.append(k.toMap())
                }
                map["Cluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cluster") && dict["Cluster"] != nil {
                var tmp : [ListClusterResponseBody.ClusterList.Cluster] = []
                for v in dict["Cluster"] as! [Any] {
                    var model = ListClusterResponseBody.ClusterList.Cluster()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cluster = tmp
            }
        }
    }
    public var clusterList: ListClusterResponseBody.ClusterList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterList != nil {
            map["ClusterList"] = self.clusterList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterList") && dict["ClusterList"] != nil {
            var model = ListClusterResponseBody.ClusterList()
            model.fromMap(dict["ClusterList"] as! [String: Any])
            self.clusterList = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterMembersRequest : Tea.TeaModel {
    public var clusterId: String?

    public var currentPage: Int32?

    public var ecsList: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.ecsList != nil {
            map["EcsList"] = self.ecsList!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EcsList") && dict["EcsList"] != nil {
            self.ecsList = dict["EcsList"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListClusterMembersResponseBody : Tea.TeaModel {
    public class ClusterMemberPage : Tea.TeaModel {
        public class ClusterMemberList : Tea.TeaModel {
            public class ClusterMember : Tea.TeaModel {
                public var clusterId: String?

                public var clusterMemberId: String?

                public var createTime: Int64?

                public var ecsId: String?

                public var ecuId: String?

                public var privateIp: String?

                public var status: Int32?

                public var updateTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterId != nil {
                        map["ClusterId"] = self.clusterId!
                    }
                    if self.clusterMemberId != nil {
                        map["ClusterMemberId"] = self.clusterMemberId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.ecsId != nil {
                        map["EcsId"] = self.ecsId!
                    }
                    if self.ecuId != nil {
                        map["EcuId"] = self.ecuId!
                    }
                    if self.privateIp != nil {
                        map["PrivateIp"] = self.privateIp!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                        self.clusterId = dict["ClusterId"] as! String
                    }
                    if dict.keys.contains("ClusterMemberId") && dict["ClusterMemberId"] != nil {
                        self.clusterMemberId = dict["ClusterMemberId"] as! String
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("EcsId") && dict["EcsId"] != nil {
                        self.ecsId = dict["EcsId"] as! String
                    }
                    if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                        self.ecuId = dict["EcuId"] as! String
                    }
                    if dict.keys.contains("PrivateIp") && dict["PrivateIp"] != nil {
                        self.privateIp = dict["PrivateIp"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! Int32
                    }
                    if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                        self.updateTime = dict["UpdateTime"] as! Int64
                    }
                }
            }
            public var clusterMember: [ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList.ClusterMember]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterMember != nil {
                    var tmp : [Any] = []
                    for k in self.clusterMember! {
                        tmp.append(k.toMap())
                    }
                    map["ClusterMember"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterMember") && dict["ClusterMember"] != nil {
                    var tmp : [ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList.ClusterMember] = []
                    for v in dict["ClusterMember"] as! [Any] {
                        var model = ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList.ClusterMember()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.clusterMember = tmp
                }
            }
        }
        public var clusterMemberList: ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clusterMemberList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterMemberList != nil {
                map["ClusterMemberList"] = self.clusterMemberList?.toMap()
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterMemberList") && dict["ClusterMemberList"] != nil {
                var model = ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList()
                model.fromMap(dict["ClusterMemberList"] as! [String: Any])
                self.clusterMemberList = model
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var clusterMemberPage: ListClusterMembersResponseBody.ClusterMemberPage?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterMemberPage?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterMemberPage != nil {
            map["ClusterMemberPage"] = self.clusterMemberPage?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterMemberPage") && dict["ClusterMemberPage"] != nil {
            var model = ListClusterMembersResponseBody.ClusterMemberPage()
            model.fromMap(dict["ClusterMemberPage"] as! [String: Any])
            self.clusterMemberPage = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClusterMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListComponentsResponseBody : Tea.TeaModel {
    public class ComponentList : Tea.TeaModel {
        public class Component : Tea.TeaModel {
            public var componentId: String?

            public var componentKey: String?

            public var desc: String?

            public var expired: Bool?

            public var type: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.componentId != nil {
                    map["ComponentId"] = self.componentId!
                }
                if self.componentKey != nil {
                    map["ComponentKey"] = self.componentKey!
                }
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComponentId") && dict["ComponentId"] != nil {
                    self.componentId = dict["ComponentId"] as! String
                }
                if dict.keys.contains("ComponentKey") && dict["ComponentKey"] != nil {
                    self.componentKey = dict["ComponentKey"] as! String
                }
                if dict.keys.contains("Desc") && dict["Desc"] != nil {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Expired") && dict["Expired"] != nil {
                    self.expired = dict["Expired"] as! Bool
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var component: [ListComponentsResponseBody.ComponentList.Component]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.component != nil {
                var tmp : [Any] = []
                for k in self.component! {
                    tmp.append(k.toMap())
                }
                map["Component"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Component") && dict["Component"] != nil {
                var tmp : [ListComponentsResponseBody.ComponentList.Component] = []
                for v in dict["Component"] as! [Any] {
                    var model = ListComponentsResponseBody.ComponentList.Component()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.component = tmp
            }
        }
    }
    public var code: Int32?

    public var componentList: ListComponentsResponseBody.ComponentList?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.componentList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.componentList != nil {
            map["ComponentList"] = self.componentList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ComponentList") && dict["ComponentList"] != nil {
            var model = ListComponentsResponseBody.ComponentList()
            model.fromMap(dict["ComponentList"] as! [String: Any])
            self.componentList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
    }
}

public class ListComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListComponentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConfigTemplatesRequest : Tea.TeaModel {
    public var currentPage: Int64?

    public var id: Int64?

    public var name: String?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class ListConfigTemplatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var content: String?

            public var description_: String?

            public var format: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Format") && dict["Format"] != nil {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var result: [ListConfigTemplatesResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                var tmp : [ListConfigTemplatesResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListConfigTemplatesResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListConfigTemplatesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListConfigTemplatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListConfigTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListConfigTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConsumedServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListConsumedServicesResponseBody : Tea.TeaModel {
    public class ConsumedServicesList : Tea.TeaModel {
        public class ListConsumedServices : Tea.TeaModel {
            public class Groups : Tea.TeaModel {
                public var group: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.group != nil {
                        map["group"] = self.group!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("group") && dict["group"] != nil {
                        self.group = dict["group"] as! [String]
                    }
                }
            }
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ip") && dict["ip"] != nil {
                        self.ip = dict["ip"] as! [String]
                    }
                }
            }
            public var appId: String?

            public var dockerApplication: Bool?

            public var group2Ip: String?

            public var groups: ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices.Groups?

            public var ips: ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices.Ips?

            public var name: String?

            public var type: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groups?.validate()
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.dockerApplication != nil {
                    map["DockerApplication"] = self.dockerApplication!
                }
                if self.group2Ip != nil {
                    map["Group2Ip"] = self.group2Ip!
                }
                if self.groups != nil {
                    map["Groups"] = self.groups?.toMap()
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("DockerApplication") && dict["DockerApplication"] != nil {
                    self.dockerApplication = dict["DockerApplication"] as! Bool
                }
                if dict.keys.contains("Group2Ip") && dict["Group2Ip"] != nil {
                    self.group2Ip = dict["Group2Ip"] as! String
                }
                if dict.keys.contains("Groups") && dict["Groups"] != nil {
                    var model = ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices.Groups()
                    model.fromMap(dict["Groups"] as! [String: Any])
                    self.groups = model
                }
                if dict.keys.contains("Ips") && dict["Ips"] != nil {
                    var model = ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var listConsumedServices: [ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.listConsumedServices != nil {
                var tmp : [Any] = []
                for k in self.listConsumedServices! {
                    tmp.append(k.toMap())
                }
                map["ListConsumedServices"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ListConsumedServices") && dict["ListConsumedServices"] != nil {
                var tmp : [ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices] = []
                for v in dict["ListConsumedServices"] as! [Any] {
                    var model = ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.listConsumedServices = tmp
            }
        }
    }
    public var code: Int32?

    public var consumedServicesList: ListConsumedServicesResponseBody.ConsumedServicesList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.consumedServicesList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.consumedServicesList != nil {
            map["ConsumedServicesList"] = self.consumedServicesList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ConsumedServicesList") && dict["ConsumedServicesList"] != nil {
            var model = ListConsumedServicesResponseBody.ConsumedServicesList()
            model.fromMap(dict["ConsumedServicesList"] as! [String: Any])
            self.consumedServicesList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListConsumedServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConsumedServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListConsumedServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConvertableEcuRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["clusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clusterId") && dict["clusterId"] != nil {
            self.clusterId = dict["clusterId"] as! String
        }
    }
}

public class ListConvertableEcuResponseBody : Tea.TeaModel {
    public class InstanceList : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var cpu: Int32?

            public var ecuId: String?

            public var eip: String?

            public var expired: Bool?

            public var innerIp: String?

            public var instanceId: String?

            public var instanceName: String?

            public var mem: Int32?

            public var privateIp: String?

            public var publicIp: String?

            public var regionId: String?

            public var status: String?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.eip != nil {
                    map["Eip"] = self.eip!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.innerIp != nil {
                    map["InnerIp"] = self.innerIp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.privateIp != nil {
                    map["PrivateIp"] = self.privateIp!
                }
                if self.publicIp != nil {
                    map["PublicIp"] = self.publicIp!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                    self.ecuId = dict["EcuId"] as! String
                }
                if dict.keys.contains("Eip") && dict["Eip"] != nil {
                    self.eip = dict["Eip"] as! String
                }
                if dict.keys.contains("Expired") && dict["Expired"] != nil {
                    self.expired = dict["Expired"] as! Bool
                }
                if dict.keys.contains("InnerIp") && dict["InnerIp"] != nil {
                    self.innerIp = dict["InnerIp"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Mem") && dict["Mem"] != nil {
                    self.mem = dict["Mem"] as! Int32
                }
                if dict.keys.contains("PrivateIp") && dict["PrivateIp"] != nil {
                    self.privateIp = dict["PrivateIp"] as! String
                }
                if dict.keys.contains("PublicIp") && dict["PublicIp"] != nil {
                    self.publicIp = dict["PublicIp"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
                    self.vpcName = dict["VpcName"] as! String
                }
            }
        }
        public var instance: [ListConvertableEcuResponseBody.InstanceList.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") && dict["Instance"] != nil {
                var tmp : [ListConvertableEcuResponseBody.InstanceList.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = ListConvertableEcuResponseBody.InstanceList.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var code: Int32?

    public var instanceList: ListConvertableEcuResponseBody.InstanceList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceList != nil {
            map["InstanceList"] = self.instanceList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("InstanceList") && dict["InstanceList"] != nil {
            var model = ListConvertableEcuResponseBody.InstanceList()
            model.fromMap(dict["InstanceList"] as! [String: Any])
            self.instanceList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListConvertableEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConvertableEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListConvertableEcuResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDeployGroupRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListDeployGroupResponseBody : Tea.TeaModel {
    public class DeployGroupList : Tea.TeaModel {
        public class DeployGroup : Tea.TeaModel {
            public var appId: String?

            public var appVersionId: String?

            public var baseComponentMetaName: String?

            public var clusterId: String?

            public var clusterName: String?

            public var cpuLimit: String?

            public var cpuRequest: String?

            public var createTime: Int64?

            public var csClusterId: String?

            public var deploymentName: String?

            public var env: String?

            public var ephemeralStorageLimit: String?

            public var ephemeralStorageRequest: String?

            public var groupId: String?

            public var groupName: String?

            public var groupType: Int32?

            public var labels: String?

            public var lastUpdateTime: Int64?

            public var memoryLimit: String?

            public var memoryRequest: String?

            public var nameSpace: String?

            public var packagePublicUrl: String?

            public var packageUrl: String?

            public var packageVersion: String?

            public var packageVersionId: String?

            public var postStart: String?

            public var preStop: String?

            public var reversion: String?

            public var selector: String?

            public var status: String?

            public var strategy: String?

            public var updateTime: Int64?

            public var VExtServerGroupId: String?

            public var VServerGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appVersionId != nil {
                    map["AppVersionId"] = self.appVersionId!
                }
                if self.baseComponentMetaName != nil {
                    map["BaseComponentMetaName"] = self.baseComponentMetaName!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.cpuLimit != nil {
                    map["CpuLimit"] = self.cpuLimit!
                }
                if self.cpuRequest != nil {
                    map["CpuRequest"] = self.cpuRequest!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.csClusterId != nil {
                    map["CsClusterId"] = self.csClusterId!
                }
                if self.deploymentName != nil {
                    map["DeploymentName"] = self.deploymentName!
                }
                if self.env != nil {
                    map["Env"] = self.env!
                }
                if self.ephemeralStorageLimit != nil {
                    map["EphemeralStorageLimit"] = self.ephemeralStorageLimit!
                }
                if self.ephemeralStorageRequest != nil {
                    map["EphemeralStorageRequest"] = self.ephemeralStorageRequest!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.lastUpdateTime != nil {
                    map["LastUpdateTime"] = self.lastUpdateTime!
                }
                if self.memoryLimit != nil {
                    map["MemoryLimit"] = self.memoryLimit!
                }
                if self.memoryRequest != nil {
                    map["MemoryRequest"] = self.memoryRequest!
                }
                if self.nameSpace != nil {
                    map["NameSpace"] = self.nameSpace!
                }
                if self.packagePublicUrl != nil {
                    map["PackagePublicUrl"] = self.packagePublicUrl!
                }
                if self.packageUrl != nil {
                    map["PackageUrl"] = self.packageUrl!
                }
                if self.packageVersion != nil {
                    map["PackageVersion"] = self.packageVersion!
                }
                if self.packageVersionId != nil {
                    map["PackageVersionId"] = self.packageVersionId!
                }
                if self.postStart != nil {
                    map["PostStart"] = self.postStart!
                }
                if self.preStop != nil {
                    map["PreStop"] = self.preStop!
                }
                if self.reversion != nil {
                    map["Reversion"] = self.reversion!
                }
                if self.selector != nil {
                    map["Selector"] = self.selector!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.VExtServerGroupId != nil {
                    map["VExtServerGroupId"] = self.VExtServerGroupId!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppVersionId") && dict["AppVersionId"] != nil {
                    self.appVersionId = dict["AppVersionId"] as! String
                }
                if dict.keys.contains("BaseComponentMetaName") && dict["BaseComponentMetaName"] != nil {
                    self.baseComponentMetaName = dict["BaseComponentMetaName"] as! String
                }
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("CpuLimit") && dict["CpuLimit"] != nil {
                    self.cpuLimit = dict["CpuLimit"] as! String
                }
                if dict.keys.contains("CpuRequest") && dict["CpuRequest"] != nil {
                    self.cpuRequest = dict["CpuRequest"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CsClusterId") && dict["CsClusterId"] != nil {
                    self.csClusterId = dict["CsClusterId"] as! String
                }
                if dict.keys.contains("DeploymentName") && dict["DeploymentName"] != nil {
                    self.deploymentName = dict["DeploymentName"] as! String
                }
                if dict.keys.contains("Env") && dict["Env"] != nil {
                    self.env = dict["Env"] as! String
                }
                if dict.keys.contains("EphemeralStorageLimit") && dict["EphemeralStorageLimit"] != nil {
                    self.ephemeralStorageLimit = dict["EphemeralStorageLimit"] as! String
                }
                if dict.keys.contains("EphemeralStorageRequest") && dict["EphemeralStorageRequest"] != nil {
                    self.ephemeralStorageRequest = dict["EphemeralStorageRequest"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") && dict["GroupType"] != nil {
                    self.groupType = dict["GroupType"] as! Int32
                }
                if dict.keys.contains("Labels") && dict["Labels"] != nil {
                    self.labels = dict["Labels"] as! String
                }
                if dict.keys.contains("LastUpdateTime") && dict["LastUpdateTime"] != nil {
                    self.lastUpdateTime = dict["LastUpdateTime"] as! Int64
                }
                if dict.keys.contains("MemoryLimit") && dict["MemoryLimit"] != nil {
                    self.memoryLimit = dict["MemoryLimit"] as! String
                }
                if dict.keys.contains("MemoryRequest") && dict["MemoryRequest"] != nil {
                    self.memoryRequest = dict["MemoryRequest"] as! String
                }
                if dict.keys.contains("NameSpace") && dict["NameSpace"] != nil {
                    self.nameSpace = dict["NameSpace"] as! String
                }
                if dict.keys.contains("PackagePublicUrl") && dict["PackagePublicUrl"] != nil {
                    self.packagePublicUrl = dict["PackagePublicUrl"] as! String
                }
                if dict.keys.contains("PackageUrl") && dict["PackageUrl"] != nil {
                    self.packageUrl = dict["PackageUrl"] as! String
                }
                if dict.keys.contains("PackageVersion") && dict["PackageVersion"] != nil {
                    self.packageVersion = dict["PackageVersion"] as! String
                }
                if dict.keys.contains("PackageVersionId") && dict["PackageVersionId"] != nil {
                    self.packageVersionId = dict["PackageVersionId"] as! String
                }
                if dict.keys.contains("PostStart") && dict["PostStart"] != nil {
                    self.postStart = dict["PostStart"] as! String
                }
                if dict.keys.contains("PreStop") && dict["PreStop"] != nil {
                    self.preStop = dict["PreStop"] as! String
                }
                if dict.keys.contains("Reversion") && dict["Reversion"] != nil {
                    self.reversion = dict["Reversion"] as! String
                }
                if dict.keys.contains("Selector") && dict["Selector"] != nil {
                    self.selector = dict["Selector"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Strategy") && dict["Strategy"] != nil {
                    self.strategy = dict["Strategy"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("VExtServerGroupId") && dict["VExtServerGroupId"] != nil {
                    self.VExtServerGroupId = dict["VExtServerGroupId"] as! String
                }
                if dict.keys.contains("VServerGroupId") && dict["VServerGroupId"] != nil {
                    self.VServerGroupId = dict["VServerGroupId"] as! String
                }
            }
        }
        public var deployGroup: [ListDeployGroupResponseBody.DeployGroupList.DeployGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployGroup != nil {
                var tmp : [Any] = []
                for k in self.deployGroup! {
                    tmp.append(k.toMap())
                }
                map["DeployGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeployGroup") && dict["DeployGroup"] != nil {
                var tmp : [ListDeployGroupResponseBody.DeployGroupList.DeployGroup] = []
                for v in dict["DeployGroup"] as! [Any] {
                    var model = ListDeployGroupResponseBody.DeployGroupList.DeployGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deployGroup = tmp
            }
        }
    }
    public var code: Int32?

    public var deployGroupList: ListDeployGroupResponseBody.DeployGroupList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployGroupList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.deployGroupList != nil {
            map["DeployGroupList"] = self.deployGroupList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("DeployGroupList") && dict["DeployGroupList"] != nil {
            var model = ListDeployGroupResponseBody.DeployGroupList()
            model.fromMap(dict["DeployGroupList"] as! [String: Any])
            self.deployGroupList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDeployGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDeployGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDeployGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEcsNotInClusterRequest : Tea.TeaModel {
    public var networkMode: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkMode != nil {
            map["NetworkMode"] = self.networkMode!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkMode") && dict["NetworkMode"] != nil {
            self.networkMode = dict["NetworkMode"] as! Int32
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ListEcsNotInClusterResponseBody : Tea.TeaModel {
    public class EcsEntityList : Tea.TeaModel {
        public class EcsEntity : Tea.TeaModel {
            public var cpu: Int32?

            public var eip: String?

            public var expired: Bool?

            public var innerIp: String?

            public var instanceId: String?

            public var instanceName: String?

            public var mem: Int32?

            public var privateIp: String?

            public var publicIp: String?

            public var regionId: String?

            public var status: String?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.eip != nil {
                    map["Eip"] = self.eip!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.innerIp != nil {
                    map["InnerIp"] = self.innerIp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.privateIp != nil {
                    map["PrivateIp"] = self.privateIp!
                }
                if self.publicIp != nil {
                    map["PublicIp"] = self.publicIp!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("Eip") && dict["Eip"] != nil {
                    self.eip = dict["Eip"] as! String
                }
                if dict.keys.contains("Expired") && dict["Expired"] != nil {
                    self.expired = dict["Expired"] as! Bool
                }
                if dict.keys.contains("InnerIp") && dict["InnerIp"] != nil {
                    self.innerIp = dict["InnerIp"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Mem") && dict["Mem"] != nil {
                    self.mem = dict["Mem"] as! Int32
                }
                if dict.keys.contains("PrivateIp") && dict["PrivateIp"] != nil {
                    self.privateIp = dict["PrivateIp"] as! String
                }
                if dict.keys.contains("PublicIp") && dict["PublicIp"] != nil {
                    self.publicIp = dict["PublicIp"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
                    self.vpcName = dict["VpcName"] as! String
                }
            }
        }
        public var ecsEntity: [ListEcsNotInClusterResponseBody.EcsEntityList.EcsEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecsEntity != nil {
                var tmp : [Any] = []
                for k in self.ecsEntity! {
                    tmp.append(k.toMap())
                }
                map["EcsEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EcsEntity") && dict["EcsEntity"] != nil {
                var tmp : [ListEcsNotInClusterResponseBody.EcsEntityList.EcsEntity] = []
                for v in dict["EcsEntity"] as! [Any] {
                    var model = ListEcsNotInClusterResponseBody.EcsEntityList.EcsEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ecsEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var ecsEntityList: ListEcsNotInClusterResponseBody.EcsEntityList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecsEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecsEntityList != nil {
            map["EcsEntityList"] = self.ecsEntityList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EcsEntityList") && dict["EcsEntityList"] != nil {
            var model = ListEcsNotInClusterResponseBody.EcsEntityList()
            model.fromMap(dict["EcsEntityList"] as! [String: Any])
            self.ecsEntityList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEcsNotInClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEcsNotInClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEcsNotInClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEcuByRegionRequest : Tea.TeaModel {
    public var act: String?

    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.act != nil {
            map["Act"] = self.act!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Act") && dict["Act"] != nil {
            self.act = dict["Act"] as! String
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
    }
}

public class ListEcuByRegionResponseBody : Tea.TeaModel {
    public class EcuEntityList : Tea.TeaModel {
        public class EcuEntity : Tea.TeaModel {
            public var availableCpu: Int32?

            public var availableMem: Int32?

            public var cpu: Int32?

            public var createTime: Int64?

            public var dockerEnv: Bool?

            public var ecuId: String?

            public var heartbeatTime: Int64?

            public var instanceId: String?

            public var ipAddr: String?

            public var mem: Int32?

            public var name: String?

            public var online: Bool?

            public var regionId: String?

            public var updateTime: Int64?

            public var userId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableCpu != nil {
                    map["AvailableCpu"] = self.availableCpu!
                }
                if self.availableMem != nil {
                    map["AvailableMem"] = self.availableMem!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerEnv != nil {
                    map["DockerEnv"] = self.dockerEnv!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.heartbeatTime != nil {
                    map["HeartbeatTime"] = self.heartbeatTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipAddr != nil {
                    map["IpAddr"] = self.ipAddr!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableCpu") && dict["AvailableCpu"] != nil {
                    self.availableCpu = dict["AvailableCpu"] as! Int32
                }
                if dict.keys.contains("AvailableMem") && dict["AvailableMem"] != nil {
                    self.availableMem = dict["AvailableMem"] as! Int32
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DockerEnv") && dict["DockerEnv"] != nil {
                    self.dockerEnv = dict["DockerEnv"] as! Bool
                }
                if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                    self.ecuId = dict["EcuId"] as! String
                }
                if dict.keys.contains("HeartbeatTime") && dict["HeartbeatTime"] != nil {
                    self.heartbeatTime = dict["HeartbeatTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IpAddr") && dict["IpAddr"] != nil {
                    self.ipAddr = dict["IpAddr"] as! String
                }
                if dict.keys.contains("Mem") && dict["Mem"] != nil {
                    self.mem = dict["Mem"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Online") && dict["Online"] != nil {
                    self.online = dict["Online"] as! Bool
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var ecuEntity: [ListEcuByRegionResponseBody.EcuEntityList.EcuEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecuEntity != nil {
                var tmp : [Any] = []
                for k in self.ecuEntity! {
                    tmp.append(k.toMap())
                }
                map["EcuEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EcuEntity") && dict["EcuEntity"] != nil {
                var tmp : [ListEcuByRegionResponseBody.EcuEntityList.EcuEntity] = []
                for v in dict["EcuEntity"] as! [Any] {
                    var model = ListEcuByRegionResponseBody.EcuEntityList.EcuEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ecuEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var ecuEntityList: ListEcuByRegionResponseBody.EcuEntityList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecuEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecuEntityList != nil {
            map["EcuEntityList"] = self.ecuEntityList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EcuEntityList") && dict["EcuEntityList"] != nil {
            var model = ListEcuByRegionResponseBody.EcuEntityList()
            model.fromMap(dict["EcuEntityList"] as! [String: Any])
            self.ecuEntityList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEcuByRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEcuByRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEcuByRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHistoryDeployVersionRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListHistoryDeployVersionResponseBody : Tea.TeaModel {
    public class PackageVersionList : Tea.TeaModel {
        public class PackageVersion : Tea.TeaModel {
            public var appId: String?

            public var createTime: Int64?

            public var description_: String?

            public var id: String?

            public var packageVersion: String?

            public var publicUrl: String?

            public var type: String?

            public var updateTime: Int64?

            public var warUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.packageVersion != nil {
                    map["PackageVersion"] = self.packageVersion!
                }
                if self.publicUrl != nil {
                    map["PublicUrl"] = self.publicUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.warUrl != nil {
                    map["WarUrl"] = self.warUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("PackageVersion") && dict["PackageVersion"] != nil {
                    self.packageVersion = dict["PackageVersion"] as! String
                }
                if dict.keys.contains("PublicUrl") && dict["PublicUrl"] != nil {
                    self.publicUrl = dict["PublicUrl"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("WarUrl") && dict["WarUrl"] != nil {
                    self.warUrl = dict["WarUrl"] as! String
                }
            }
        }
        public var packageVersion: [ListHistoryDeployVersionResponseBody.PackageVersionList.PackageVersion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.packageVersion != nil {
                var tmp : [Any] = []
                for k in self.packageVersion! {
                    tmp.append(k.toMap())
                }
                map["PackageVersion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PackageVersion") && dict["PackageVersion"] != nil {
                var tmp : [ListHistoryDeployVersionResponseBody.PackageVersionList.PackageVersion] = []
                for v in dict["PackageVersion"] as! [Any] {
                    var model = ListHistoryDeployVersionResponseBody.PackageVersionList.PackageVersion()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.packageVersion = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var packageVersionList: ListHistoryDeployVersionResponseBody.PackageVersionList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageVersionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.packageVersionList != nil {
            map["PackageVersionList"] = self.packageVersionList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PackageVersionList") && dict["PackageVersionList"] != nil {
            var model = ListHistoryDeployVersionResponseBody.PackageVersionList()
            model.fromMap(dict["PackageVersionList"] as! [String: Any])
            self.packageVersionList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListHistoryDeployVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHistoryDeployVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHistoryDeployVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListK8sConfigMapsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var condition: [String: Any]?

    public var namespace: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var showRelatedApps: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.condition != nil {
            map["Condition"] = self.condition!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showRelatedApps != nil {
            map["ShowRelatedApps"] = self.showRelatedApps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Condition") && dict["Condition"] != nil {
            self.condition = dict["Condition"] as! [String: Any]
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ShowRelatedApps") && dict["ShowRelatedApps"] != nil {
            self.showRelatedApps = dict["ShowRelatedApps"] as! Bool
        }
    }
}

public class ListK8sConfigMapsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ConfigMaps : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RelatedApps : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("AppName") && dict["AppName"] != nil {
                        self.appName = dict["AppName"] as! String
                    }
                }
            }
            public var clusterId: String?

            public var clusterName: String?

            public var creationTime: String?

            public var data: [ListK8sConfigMapsResponseBody.Result.ConfigMaps.Data]?

            public var name: String?

            public var namespace: String?

            public var relatedApps: [ListK8sConfigMapsResponseBody.Result.ConfigMaps.RelatedApps]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["Data"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.relatedApps != nil {
                    var tmp : [Any] = []
                    for k in self.relatedApps! {
                        tmp.append(k.toMap())
                    }
                    map["RelatedApps"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Data") && dict["Data"] != nil {
                    var tmp : [ListK8sConfigMapsResponseBody.Result.ConfigMaps.Data] = []
                    for v in dict["Data"] as! [Any] {
                        var model = ListK8sConfigMapsResponseBody.Result.ConfigMaps.Data()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.data = tmp
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RelatedApps") && dict["RelatedApps"] != nil {
                    var tmp : [ListK8sConfigMapsResponseBody.Result.ConfigMaps.RelatedApps] = []
                    for v in dict["RelatedApps"] as! [Any] {
                        var model = ListK8sConfigMapsResponseBody.Result.ConfigMaps.RelatedApps()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.relatedApps = tmp
                }
            }
        }
        public var configMaps: [ListK8sConfigMapsResponseBody.Result.ConfigMaps]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMaps != nil {
                var tmp : [Any] = []
                for k in self.configMaps! {
                    tmp.append(k.toMap())
                }
                map["ConfigMaps"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigMaps") && dict["ConfigMaps"] != nil {
                var tmp : [ListK8sConfigMapsResponseBody.Result.ConfigMaps] = []
                for v in dict["ConfigMaps"] as! [Any] {
                    var model = ListK8sConfigMapsResponseBody.Result.ConfigMaps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configMaps = tmp
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var result: ListK8sConfigMapsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            var model = ListK8sConfigMapsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ListK8sConfigMapsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListK8sConfigMapsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListK8sConfigMapsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListK8sIngressRulesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var condition: String?

    public var namespace: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.condition != nil {
            map["Condition"] = self.condition!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Condition") && dict["Condition"] != nil {
            self.condition = dict["Condition"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListK8sIngressRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class IngressConfs : Tea.TeaModel {
            public class Rules : Tea.TeaModel {
                public class Paths : Tea.TeaModel {
                    public class Backend : Tea.TeaModel {
                        public var serviceName: String?

                        public var servicePort: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.serviceName != nil {
                                map["ServiceName"] = self.serviceName!
                            }
                            if self.servicePort != nil {
                                map["ServicePort"] = self.servicePort!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                                self.serviceName = dict["ServiceName"] as! String
                            }
                            if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                                self.servicePort = dict["ServicePort"] as! String
                            }
                        }
                    }
                    public var appId: String?

                    public var appName: String?

                    public var backend: ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths.Backend?

                    public var collectRate: Int32?

                    public var path: String?

                    public var pathType: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.backend?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appId != nil {
                            map["AppId"] = self.appId!
                        }
                        if self.appName != nil {
                            map["AppName"] = self.appName!
                        }
                        if self.backend != nil {
                            map["Backend"] = self.backend?.toMap()
                        }
                        if self.collectRate != nil {
                            map["CollectRate"] = self.collectRate!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.pathType != nil {
                            map["PathType"] = self.pathType!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AppId") && dict["AppId"] != nil {
                            self.appId = dict["AppId"] as! String
                        }
                        if dict.keys.contains("AppName") && dict["AppName"] != nil {
                            self.appName = dict["AppName"] as! String
                        }
                        if dict.keys.contains("Backend") && dict["Backend"] != nil {
                            var model = ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths.Backend()
                            model.fromMap(dict["Backend"] as! [String: Any])
                            self.backend = model
                        }
                        if dict.keys.contains("CollectRate") && dict["CollectRate"] != nil {
                            self.collectRate = dict["CollectRate"] as! Int32
                        }
                        if dict.keys.contains("Path") && dict["Path"] != nil {
                            self.path = dict["Path"] as! String
                        }
                        if dict.keys.contains("PathType") && dict["PathType"] != nil {
                            self.pathType = dict["PathType"] as! String
                        }
                        if dict.keys.contains("Status") && dict["Status"] != nil {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var enableTls: Bool?

                public var host: String?

                public var paths: [ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths]?

                public var secretName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableTls != nil {
                        map["EnableTls"] = self.enableTls!
                    }
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    if self.paths != nil {
                        var tmp : [Any] = []
                        for k in self.paths! {
                            tmp.append(k.toMap())
                        }
                        map["Paths"] = tmp
                    }
                    if self.secretName != nil {
                        map["SecretName"] = self.secretName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnableTls") && dict["EnableTls"] != nil {
                        self.enableTls = dict["EnableTls"] as! Bool
                    }
                    if dict.keys.contains("Host") && dict["Host"] != nil {
                        self.host = dict["Host"] as! String
                    }
                    if dict.keys.contains("Paths") && dict["Paths"] != nil {
                        var tmp : [ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths] = []
                        for v in dict["Paths"] as! [Any] {
                            var model = ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.paths = tmp
                    }
                    if dict.keys.contains("SecretName") && dict["SecretName"] != nil {
                        self.secretName = dict["SecretName"] as! String
                    }
                }
            }
            public var albId: String?

            public var annotations: String?

            public var creationTime: String?

            public var dashboardUrl: String?

            public var endpoint: String?

            public var ingressType: String?

            public var labels: String?

            public var mseGatewayId: String?

            public var mseGatewayName: String?

            public var name: String?

            public var namespace: String?

            public var officalBasicUrl: String?

            public var officalRequestUrl: String?

            public var rules: [ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules]?

            public var sslRedirect: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albId != nil {
                    map["AlbId"] = self.albId!
                }
                if self.annotations != nil {
                    map["Annotations"] = self.annotations!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.dashboardUrl != nil {
                    map["DashboardUrl"] = self.dashboardUrl!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.ingressType != nil {
                    map["IngressType"] = self.ingressType!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.mseGatewayId != nil {
                    map["MseGatewayId"] = self.mseGatewayId!
                }
                if self.mseGatewayName != nil {
                    map["MseGatewayName"] = self.mseGatewayName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.officalBasicUrl != nil {
                    map["OfficalBasicUrl"] = self.officalBasicUrl!
                }
                if self.officalRequestUrl != nil {
                    map["OfficalRequestUrl"] = self.officalRequestUrl!
                }
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["Rules"] = tmp
                }
                if self.sslRedirect != nil {
                    map["SslRedirect"] = self.sslRedirect!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlbId") && dict["AlbId"] != nil {
                    self.albId = dict["AlbId"] as! String
                }
                if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
                    self.annotations = dict["Annotations"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DashboardUrl") && dict["DashboardUrl"] != nil {
                    self.dashboardUrl = dict["DashboardUrl"] as! String
                }
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("IngressType") && dict["IngressType"] != nil {
                    self.ingressType = dict["IngressType"] as! String
                }
                if dict.keys.contains("Labels") && dict["Labels"] != nil {
                    self.labels = dict["Labels"] as! String
                }
                if dict.keys.contains("MseGatewayId") && dict["MseGatewayId"] != nil {
                    self.mseGatewayId = dict["MseGatewayId"] as! String
                }
                if dict.keys.contains("MseGatewayName") && dict["MseGatewayName"] != nil {
                    self.mseGatewayName = dict["MseGatewayName"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("OfficalBasicUrl") && dict["OfficalBasicUrl"] != nil {
                    self.officalBasicUrl = dict["OfficalBasicUrl"] as! String
                }
                if dict.keys.contains("OfficalRequestUrl") && dict["OfficalRequestUrl"] != nil {
                    self.officalRequestUrl = dict["OfficalRequestUrl"] as! String
                }
                if dict.keys.contains("Rules") && dict["Rules"] != nil {
                    var tmp : [ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules] = []
                    for v in dict["Rules"] as! [Any] {
                        var model = ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rules = tmp
                }
                if dict.keys.contains("SslRedirect") && dict["SslRedirect"] != nil {
                    self.sslRedirect = dict["SslRedirect"] as! Bool
                }
            }
        }
        public var clusterId: String?

        public var clusterName: String?

        public var ingressConfs: [ListK8sIngressRulesResponseBody.Data.IngressConfs]?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.ingressConfs != nil {
                var tmp : [Any] = []
                for k in self.ingressConfs! {
                    tmp.append(k.toMap())
                }
                map["IngressConfs"] = tmp
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("IngressConfs") && dict["IngressConfs"] != nil {
                var tmp : [ListK8sIngressRulesResponseBody.Data.IngressConfs] = []
                for v in dict["IngressConfs"] as! [Any] {
                    var model = ListK8sIngressRulesResponseBody.Data.IngressConfs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ingressConfs = tmp
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListK8sIngressRulesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListK8sIngressRulesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListK8sIngressRulesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListK8sIngressRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListK8sIngressRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListK8sIngressRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListK8sNamespacesRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class ListK8sNamespacesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var namespace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListK8sNamespacesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListK8sNamespacesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListK8sNamespacesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListK8sNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListK8sNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListK8sNamespacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListK8sSecretsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var condition: String?

    public var namespace: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var showRelatedApps: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.condition != nil {
            map["Condition"] = self.condition!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showRelatedApps != nil {
            map["ShowRelatedApps"] = self.showRelatedApps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Condition") && dict["Condition"] != nil {
            self.condition = dict["Condition"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ShowRelatedApps") && dict["ShowRelatedApps"] != nil {
            self.showRelatedApps = dict["ShowRelatedApps"] as! Bool
        }
    }
}

public class ListK8sSecretsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Secrets : Tea.TeaModel {
            public class CertDetail : Tea.TeaModel {
                public var domainNames: [String]?

                public var endTime: String?

                public var issuer: String?

                public var startTime: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.domainNames != nil {
                        map["DomainNames"] = self.domainNames!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.issuer != nil {
                        map["Issuer"] = self.issuer!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DomainNames") && dict["DomainNames"] != nil {
                        self.domainNames = dict["DomainNames"] as! [String]
                    }
                    if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("Issuer") && dict["Issuer"] != nil {
                        self.issuer = dict["Issuer"] as! String
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class Data : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RelatedApps : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("AppName") && dict["AppName"] != nil {
                        self.appName = dict["AppName"] as! String
                    }
                }
            }
            public class RelatedIngressRules : Tea.TeaModel {
                public class RelatedApps : Tea.TeaModel {
                    public var appId: String?

                    public var appName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appId != nil {
                            map["AppId"] = self.appId!
                        }
                        if self.appName != nil {
                            map["AppName"] = self.appName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AppId") && dict["AppId"] != nil {
                            self.appId = dict["AppId"] as! String
                        }
                        if dict.keys.contains("AppName") && dict["AppName"] != nil {
                            self.appName = dict["AppName"] as! String
                        }
                    }
                }
                public var name: String?

                public var namespace: String?

                public var relatedApps: [ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules.RelatedApps]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.relatedApps != nil {
                        var tmp : [Any] = []
                        for k in self.relatedApps! {
                            tmp.append(k.toMap())
                        }
                        map["RelatedApps"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("RelatedApps") && dict["RelatedApps"] != nil {
                        var tmp : [ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules.RelatedApps] = []
                        for v in dict["RelatedApps"] as! [Any] {
                            var model = ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules.RelatedApps()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.relatedApps = tmp
                    }
                }
            }
            public var base64Encoded: Bool?

            public var certDetail: ListK8sSecretsResponseBody.Result.Secrets.CertDetail?

            public var certId: String?

            public var certRegionId: String?

            public var clusterId: String?

            public var clusterName: String?

            public var creationTime: String?

            public var data: [ListK8sSecretsResponseBody.Result.Secrets.Data]?

            public var name: String?

            public var namespace: String?

            public var relatedApps: [ListK8sSecretsResponseBody.Result.Secrets.RelatedApps]?

            public var relatedIngressRules: [ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.certDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.base64Encoded != nil {
                    map["Base64Encoded"] = self.base64Encoded!
                }
                if self.certDetail != nil {
                    map["CertDetail"] = self.certDetail?.toMap()
                }
                if self.certId != nil {
                    map["CertId"] = self.certId!
                }
                if self.certRegionId != nil {
                    map["CertRegionId"] = self.certRegionId!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["Data"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.relatedApps != nil {
                    var tmp : [Any] = []
                    for k in self.relatedApps! {
                        tmp.append(k.toMap())
                    }
                    map["RelatedApps"] = tmp
                }
                if self.relatedIngressRules != nil {
                    var tmp : [Any] = []
                    for k in self.relatedIngressRules! {
                        tmp.append(k.toMap())
                    }
                    map["RelatedIngressRules"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Base64Encoded") && dict["Base64Encoded"] != nil {
                    self.base64Encoded = dict["Base64Encoded"] as! Bool
                }
                if dict.keys.contains("CertDetail") && dict["CertDetail"] != nil {
                    var model = ListK8sSecretsResponseBody.Result.Secrets.CertDetail()
                    model.fromMap(dict["CertDetail"] as! [String: Any])
                    self.certDetail = model
                }
                if dict.keys.contains("CertId") && dict["CertId"] != nil {
                    self.certId = dict["CertId"] as! String
                }
                if dict.keys.contains("CertRegionId") && dict["CertRegionId"] != nil {
                    self.certRegionId = dict["CertRegionId"] as! String
                }
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Data") && dict["Data"] != nil {
                    var tmp : [ListK8sSecretsResponseBody.Result.Secrets.Data] = []
                    for v in dict["Data"] as! [Any] {
                        var model = ListK8sSecretsResponseBody.Result.Secrets.Data()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.data = tmp
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RelatedApps") && dict["RelatedApps"] != nil {
                    var tmp : [ListK8sSecretsResponseBody.Result.Secrets.RelatedApps] = []
                    for v in dict["RelatedApps"] as! [Any] {
                        var model = ListK8sSecretsResponseBody.Result.Secrets.RelatedApps()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.relatedApps = tmp
                }
                if dict.keys.contains("RelatedIngressRules") && dict["RelatedIngressRules"] != nil {
                    var tmp : [ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules] = []
                    for v in dict["RelatedIngressRules"] as! [Any] {
                        var model = ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.relatedIngressRules = tmp
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var secrets: [ListK8sSecretsResponseBody.Result.Secrets]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secrets != nil {
                var tmp : [Any] = []
                for k in self.secrets! {
                    tmp.append(k.toMap())
                }
                map["Secrets"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Secrets") && dict["Secrets"] != nil {
                var tmp : [ListK8sSecretsResponseBody.Result.Secrets] = []
                for v in dict["Secrets"] as! [Any] {
                    var model = ListK8sSecretsResponseBody.Result.Secrets()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.secrets = tmp
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var result: ListK8sSecretsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            var model = ListK8sSecretsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ListK8sSecretsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListK8sSecretsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListK8sSecretsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMethodsRequest : Tea.TeaModel {
    public var appId: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListMethodsResponseBody : Tea.TeaModel {
    public class ServiceMethodList : Tea.TeaModel {
        public class ServiceMethod : Tea.TeaModel {
            public class InputParams : Tea.TeaModel {
                public var inputParam: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputParam != nil {
                        map["InputParam"] = self.inputParam!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputParam") && dict["InputParam"] != nil {
                        self.inputParam = dict["InputParam"] as! [String]
                    }
                }
            }
            public class ParamTypes : Tea.TeaModel {
                public var paramType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.paramType != nil {
                        map["ParamType"] = self.paramType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ParamType") && dict["ParamType"] != nil {
                        self.paramType = dict["ParamType"] as! [String]
                    }
                }
            }
            public var appName: String?

            public var inputParams: ListMethodsResponseBody.ServiceMethodList.ServiceMethod.InputParams?

            public var methodName: String?

            public var output: String?

            public var paramTypes: ListMethodsResponseBody.ServiceMethodList.ServiceMethod.ParamTypes?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inputParams?.validate()
                try self.paramTypes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.inputParams != nil {
                    map["InputParams"] = self.inputParams?.toMap()
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.output != nil {
                    map["Output"] = self.output!
                }
                if self.paramTypes != nil {
                    map["ParamTypes"] = self.paramTypes?.toMap()
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("InputParams") && dict["InputParams"] != nil {
                    var model = ListMethodsResponseBody.ServiceMethodList.ServiceMethod.InputParams()
                    model.fromMap(dict["InputParams"] as! [String: Any])
                    self.inputParams = model
                }
                if dict.keys.contains("MethodName") && dict["MethodName"] != nil {
                    self.methodName = dict["MethodName"] as! String
                }
                if dict.keys.contains("Output") && dict["Output"] != nil {
                    self.output = dict["Output"] as! String
                }
                if dict.keys.contains("ParamTypes") && dict["ParamTypes"] != nil {
                    var model = ListMethodsResponseBody.ServiceMethodList.ServiceMethod.ParamTypes()
                    model.fromMap(dict["ParamTypes"] as! [String: Any])
                    self.paramTypes = model
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public var serviceMethod: [ListMethodsResponseBody.ServiceMethodList.ServiceMethod]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceMethod != nil {
                var tmp : [Any] = []
                for k in self.serviceMethod! {
                    tmp.append(k.toMap())
                }
                map["ServiceMethod"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceMethod") && dict["ServiceMethod"] != nil {
                var tmp : [ListMethodsResponseBody.ServiceMethodList.ServiceMethod] = []
                for v in dict["ServiceMethod"] as! [Any] {
                    var model = ListMethodsResponseBody.ServiceMethodList.ServiceMethod()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceMethod = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var serviceMethodList: ListMethodsResponseBody.ServiceMethodList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serviceMethodList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceMethodList != nil {
            map["ServiceMethodList"] = self.serviceMethodList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceMethodList") && dict["ServiceMethodList"] != nil {
            var model = ListMethodsResponseBody.ServiceMethodList()
            model.fromMap(dict["ServiceMethodList"] as! [String: Any])
            self.serviceMethodList = model
        }
    }
}

public class ListMethodsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMethodsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMethodsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPublishedServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListPublishedServicesResponseBody : Tea.TeaModel {
    public class PublishedServicesList : Tea.TeaModel {
        public class ListPublishedServices : Tea.TeaModel {
            public class Groups : Tea.TeaModel {
                public var group: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.group != nil {
                        map["group"] = self.group!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("group") && dict["group"] != nil {
                        self.group = dict["group"] as! [String]
                    }
                }
            }
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ip") && dict["ip"] != nil {
                        self.ip = dict["ip"] as! [String]
                    }
                }
            }
            public var appId: String?

            public var dockerApplication: Bool?

            public var group2Ip: String?

            public var groups: ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices.Groups?

            public var ips: ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices.Ips?

            public var name: String?

            public var type: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groups?.validate()
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.dockerApplication != nil {
                    map["DockerApplication"] = self.dockerApplication!
                }
                if self.group2Ip != nil {
                    map["Group2Ip"] = self.group2Ip!
                }
                if self.groups != nil {
                    map["Groups"] = self.groups?.toMap()
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("DockerApplication") && dict["DockerApplication"] != nil {
                    self.dockerApplication = dict["DockerApplication"] as! Bool
                }
                if dict.keys.contains("Group2Ip") && dict["Group2Ip"] != nil {
                    self.group2Ip = dict["Group2Ip"] as! String
                }
                if dict.keys.contains("Groups") && dict["Groups"] != nil {
                    var model = ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices.Groups()
                    model.fromMap(dict["Groups"] as! [String: Any])
                    self.groups = model
                }
                if dict.keys.contains("Ips") && dict["Ips"] != nil {
                    var model = ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var listPublishedServices: [ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.listPublishedServices != nil {
                var tmp : [Any] = []
                for k in self.listPublishedServices! {
                    tmp.append(k.toMap())
                }
                map["ListPublishedServices"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ListPublishedServices") && dict["ListPublishedServices"] != nil {
                var tmp : [ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices] = []
                for v in dict["ListPublishedServices"] as! [Any] {
                    var model = ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.listPublishedServices = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var publishedServicesList: ListPublishedServicesResponseBody.PublishedServicesList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.publishedServicesList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.publishedServicesList != nil {
            map["PublishedServicesList"] = self.publishedServicesList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PublishedServicesList") && dict["PublishedServicesList"] != nil {
            var model = ListPublishedServicesResponseBody.PublishedServicesList()
            model.fromMap(dict["PublishedServicesList"] as! [String: Any])
            self.publishedServicesList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPublishedServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublishedServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPublishedServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRecentChangeOrderRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListRecentChangeOrderResponseBody : Tea.TeaModel {
    public class ChangeOrderList : Tea.TeaModel {
        public class ChangeOrder : Tea.TeaModel {
            public var appId: String?

            public var batchCount: Int32?

            public var batchType: String?

            public var changeOrderDescription: String?

            public var changeOrderId: String?

            public var coType: String?

            public var coTypeCode: String?

            public var createTime: String?

            public var createUserId: String?

            public var finishTime: String?

            public var groupId: String?

            public var source: String?

            public var status: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.batchCount != nil {
                    map["BatchCount"] = self.batchCount!
                }
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.changeOrderDescription != nil {
                    map["ChangeOrderDescription"] = self.changeOrderDescription!
                }
                if self.changeOrderId != nil {
                    map["ChangeOrderId"] = self.changeOrderId!
                }
                if self.coType != nil {
                    map["CoType"] = self.coType!
                }
                if self.coTypeCode != nil {
                    map["CoTypeCode"] = self.coTypeCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("BatchCount") && dict["BatchCount"] != nil {
                    self.batchCount = dict["BatchCount"] as! Int32
                }
                if dict.keys.contains("BatchType") && dict["BatchType"] != nil {
                    self.batchType = dict["BatchType"] as! String
                }
                if dict.keys.contains("ChangeOrderDescription") && dict["ChangeOrderDescription"] != nil {
                    self.changeOrderDescription = dict["ChangeOrderDescription"] as! String
                }
                if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
                    self.changeOrderId = dict["ChangeOrderId"] as! String
                }
                if dict.keys.contains("CoType") && dict["CoType"] != nil {
                    self.coType = dict["CoType"] as! String
                }
                if dict.keys.contains("CoTypeCode") && dict["CoTypeCode"] != nil {
                    self.coTypeCode = dict["CoTypeCode"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateUserId") && dict["CreateUserId"] != nil {
                    self.createUserId = dict["CreateUserId"] as! String
                }
                if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var changeOrder: [ListRecentChangeOrderResponseBody.ChangeOrderList.ChangeOrder]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrder != nil {
                var tmp : [Any] = []
                for k in self.changeOrder! {
                    tmp.append(k.toMap())
                }
                map["ChangeOrder"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrder") && dict["ChangeOrder"] != nil {
                var tmp : [ListRecentChangeOrderResponseBody.ChangeOrderList.ChangeOrder] = []
                for v in dict["ChangeOrder"] as! [Any] {
                    var model = ListRecentChangeOrderResponseBody.ChangeOrderList.ChangeOrder()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.changeOrder = tmp
            }
        }
    }
    public var changeOrderList: ListRecentChangeOrderResponseBody.ChangeOrderList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.changeOrderList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderList != nil {
            map["ChangeOrderList"] = self.changeOrderList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderList") && dict["ChangeOrderList"] != nil {
            var model = ListRecentChangeOrderResponseBody.ChangeOrderList()
            model.fromMap(dict["ChangeOrderList"] as! [String: Any])
            self.changeOrderList = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRecentChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRecentChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRecentChangeOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListResourceGroupResponseBody : Tea.TeaModel {
    public class ResourceGroupList : Tea.TeaModel {
        public class ResGroupEntity : Tea.TeaModel {
            public class SlbList : Tea.TeaModel {
                public class SlbEntity : Tea.TeaModel {
                    public var address: String?

                    public var addressType: String?

                    public var expired: Bool?

                    public var groupId: Int32?

                    public var networkType: String?

                    public var regionId: String?

                    public var slbId: String?

                    public var slbName: String?

                    public var slbStatus: String?

                    public var userId: String?

                    public var vpcId: String?

                    public var vswitchId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.addressType != nil {
                            map["AddressType"] = self.addressType!
                        }
                        if self.expired != nil {
                            map["Expired"] = self.expired!
                        }
                        if self.groupId != nil {
                            map["GroupId"] = self.groupId!
                        }
                        if self.networkType != nil {
                            map["NetworkType"] = self.networkType!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.slbId != nil {
                            map["SlbId"] = self.slbId!
                        }
                        if self.slbName != nil {
                            map["SlbName"] = self.slbName!
                        }
                        if self.slbStatus != nil {
                            map["SlbStatus"] = self.slbStatus!
                        }
                        if self.userId != nil {
                            map["UserId"] = self.userId!
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        if self.vswitchId != nil {
                            map["VswitchId"] = self.vswitchId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") && dict["Address"] != nil {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("AddressType") && dict["AddressType"] != nil {
                            self.addressType = dict["AddressType"] as! String
                        }
                        if dict.keys.contains("Expired") && dict["Expired"] != nil {
                            self.expired = dict["Expired"] as! Bool
                        }
                        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                            self.groupId = dict["GroupId"] as! Int32
                        }
                        if dict.keys.contains("NetworkType") && dict["NetworkType"] != nil {
                            self.networkType = dict["NetworkType"] as! String
                        }
                        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                            self.regionId = dict["RegionId"] as! String
                        }
                        if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
                            self.slbId = dict["SlbId"] as! String
                        }
                        if dict.keys.contains("SlbName") && dict["SlbName"] != nil {
                            self.slbName = dict["SlbName"] as! String
                        }
                        if dict.keys.contains("SlbStatus") && dict["SlbStatus"] != nil {
                            self.slbStatus = dict["SlbStatus"] as! String
                        }
                        if dict.keys.contains("UserId") && dict["UserId"] != nil {
                            self.userId = dict["UserId"] as! String
                        }
                        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                            self.vpcId = dict["VpcId"] as! String
                        }
                        if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                            self.vswitchId = dict["VswitchId"] as! String
                        }
                    }
                }
                public var slbEntity: [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList.SlbEntity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.slbEntity != nil {
                        var tmp : [Any] = []
                        for k in self.slbEntity! {
                            tmp.append(k.toMap())
                        }
                        map["SlbEntity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SlbEntity") && dict["SlbEntity"] != nil {
                        var tmp : [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList.SlbEntity] = []
                        for v in dict["SlbEntity"] as! [Any] {
                            var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList.SlbEntity()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.slbEntity = tmp
                    }
                }
            }
            public class EcsList : Tea.TeaModel {
                public class EcsEntity : Tea.TeaModel {
                    public class EcuEntity : Tea.TeaModel {
                        public var availableCpu: Int32?

                        public var availableMem: Int32?

                        public var cpu: Int32?

                        public var createTime: Int64?

                        public var dockerEnv: Bool?

                        public var ecuId: String?

                        public var heartbeatTime: Int64?

                        public var instanceId: String?

                        public var ipAddr: String?

                        public var mem: Int32?

                        public var name: String?

                        public var online: Bool?

                        public var regionId: String?

                        public var updateTime: Int64?

                        public var userId: String?

                        public var vpcId: String?

                        public var zoneId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableCpu != nil {
                                map["AvailableCpu"] = self.availableCpu!
                            }
                            if self.availableMem != nil {
                                map["AvailableMem"] = self.availableMem!
                            }
                            if self.cpu != nil {
                                map["Cpu"] = self.cpu!
                            }
                            if self.createTime != nil {
                                map["CreateTime"] = self.createTime!
                            }
                            if self.dockerEnv != nil {
                                map["DockerEnv"] = self.dockerEnv!
                            }
                            if self.ecuId != nil {
                                map["EcuId"] = self.ecuId!
                            }
                            if self.heartbeatTime != nil {
                                map["HeartbeatTime"] = self.heartbeatTime!
                            }
                            if self.instanceId != nil {
                                map["InstanceId"] = self.instanceId!
                            }
                            if self.ipAddr != nil {
                                map["IpAddr"] = self.ipAddr!
                            }
                            if self.mem != nil {
                                map["Mem"] = self.mem!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            if self.online != nil {
                                map["Online"] = self.online!
                            }
                            if self.regionId != nil {
                                map["RegionId"] = self.regionId!
                            }
                            if self.updateTime != nil {
                                map["UpdateTime"] = self.updateTime!
                            }
                            if self.userId != nil {
                                map["UserId"] = self.userId!
                            }
                            if self.vpcId != nil {
                                map["VpcId"] = self.vpcId!
                            }
                            if self.zoneId != nil {
                                map["ZoneId"] = self.zoneId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AvailableCpu") && dict["AvailableCpu"] != nil {
                                self.availableCpu = dict["AvailableCpu"] as! Int32
                            }
                            if dict.keys.contains("AvailableMem") && dict["AvailableMem"] != nil {
                                self.availableMem = dict["AvailableMem"] as! Int32
                            }
                            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                                self.cpu = dict["Cpu"] as! Int32
                            }
                            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                                self.createTime = dict["CreateTime"] as! Int64
                            }
                            if dict.keys.contains("DockerEnv") && dict["DockerEnv"] != nil {
                                self.dockerEnv = dict["DockerEnv"] as! Bool
                            }
                            if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                                self.ecuId = dict["EcuId"] as! String
                            }
                            if dict.keys.contains("HeartbeatTime") && dict["HeartbeatTime"] != nil {
                                self.heartbeatTime = dict["HeartbeatTime"] as! Int64
                            }
                            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                                self.instanceId = dict["InstanceId"] as! String
                            }
                            if dict.keys.contains("IpAddr") && dict["IpAddr"] != nil {
                                self.ipAddr = dict["IpAddr"] as! String
                            }
                            if dict.keys.contains("Mem") && dict["Mem"] != nil {
                                self.mem = dict["Mem"] as! Int32
                            }
                            if dict.keys.contains("Name") && dict["Name"] != nil {
                                self.name = dict["Name"] as! String
                            }
                            if dict.keys.contains("Online") && dict["Online"] != nil {
                                self.online = dict["Online"] as! Bool
                            }
                            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                                self.regionId = dict["RegionId"] as! String
                            }
                            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                                self.updateTime = dict["UpdateTime"] as! Int64
                            }
                            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                                self.userId = dict["UserId"] as! String
                            }
                            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                                self.vpcId = dict["VpcId"] as! String
                            }
                            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                                self.zoneId = dict["ZoneId"] as! String
                            }
                        }
                    }
                    public class VpcEntity : Tea.TeaModel {
                        public var cidrblock: String?

                        public var description_: String?

                        public var ecsNum: Int32?

                        public var expired: Bool?

                        public var regionId: String?

                        public var status: String?

                        public var userId: String?

                        public var vpcId: String?

                        public var vpcName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.cidrblock != nil {
                                map["Cidrblock"] = self.cidrblock!
                            }
                            if self.description_ != nil {
                                map["Description"] = self.description_!
                            }
                            if self.ecsNum != nil {
                                map["EcsNum"] = self.ecsNum!
                            }
                            if self.expired != nil {
                                map["Expired"] = self.expired!
                            }
                            if self.regionId != nil {
                                map["RegionId"] = self.regionId!
                            }
                            if self.status != nil {
                                map["Status"] = self.status!
                            }
                            if self.userId != nil {
                                map["UserId"] = self.userId!
                            }
                            if self.vpcId != nil {
                                map["VpcId"] = self.vpcId!
                            }
                            if self.vpcName != nil {
                                map["VpcName"] = self.vpcName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Cidrblock") && dict["Cidrblock"] != nil {
                                self.cidrblock = dict["Cidrblock"] as! String
                            }
                            if dict.keys.contains("Description") && dict["Description"] != nil {
                                self.description_ = dict["Description"] as! String
                            }
                            if dict.keys.contains("EcsNum") && dict["EcsNum"] != nil {
                                self.ecsNum = dict["EcsNum"] as! Int32
                            }
                            if dict.keys.contains("Expired") && dict["Expired"] != nil {
                                self.expired = dict["Expired"] as! Bool
                            }
                            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                                self.regionId = dict["RegionId"] as! String
                            }
                            if dict.keys.contains("Status") && dict["Status"] != nil {
                                self.status = dict["Status"] as! String
                            }
                            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                                self.userId = dict["UserId"] as! String
                            }
                            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                                self.vpcId = dict["VpcId"] as! String
                            }
                            if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
                                self.vpcName = dict["VpcName"] as! String
                            }
                        }
                    }
                    public var cpu: Int32?

                    public var description_: String?

                    public var ecuEntity: ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity.EcuEntity?

                    public var eip: String?

                    public var expired: Bool?

                    public var groupId: String?

                    public var hostName: String?

                    public var innerIp: String?

                    public var instanceId: String?

                    public var instanceName: String?

                    public var mem: Int32?

                    public var privateIp: String?

                    public var publicIp: String?

                    public var regionId: String?

                    public var serialNum: String?

                    public var sgId: String?

                    public var status: String?

                    public var userId: String?

                    public var vpcEntity: ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity.VpcEntity?

                    public var vpcId: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.ecuEntity?.validate()
                        try self.vpcEntity?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cpu != nil {
                            map["Cpu"] = self.cpu!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.ecuEntity != nil {
                            map["EcuEntity"] = self.ecuEntity?.toMap()
                        }
                        if self.eip != nil {
                            map["Eip"] = self.eip!
                        }
                        if self.expired != nil {
                            map["Expired"] = self.expired!
                        }
                        if self.groupId != nil {
                            map["GroupId"] = self.groupId!
                        }
                        if self.hostName != nil {
                            map["HostName"] = self.hostName!
                        }
                        if self.innerIp != nil {
                            map["InnerIp"] = self.innerIp!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceName != nil {
                            map["InstanceName"] = self.instanceName!
                        }
                        if self.mem != nil {
                            map["Mem"] = self.mem!
                        }
                        if self.privateIp != nil {
                            map["PrivateIp"] = self.privateIp!
                        }
                        if self.publicIp != nil {
                            map["PublicIp"] = self.publicIp!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.serialNum != nil {
                            map["SerialNum"] = self.serialNum!
                        }
                        if self.sgId != nil {
                            map["SgId"] = self.sgId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.userId != nil {
                            map["UserId"] = self.userId!
                        }
                        if self.vpcEntity != nil {
                            map["VpcEntity"] = self.vpcEntity?.toMap()
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                            self.cpu = dict["Cpu"] as! Int32
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("EcuEntity") && dict["EcuEntity"] != nil {
                            var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity.EcuEntity()
                            model.fromMap(dict["EcuEntity"] as! [String: Any])
                            self.ecuEntity = model
                        }
                        if dict.keys.contains("Eip") && dict["Eip"] != nil {
                            self.eip = dict["Eip"] as! String
                        }
                        if dict.keys.contains("Expired") && dict["Expired"] != nil {
                            self.expired = dict["Expired"] as! Bool
                        }
                        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                            self.groupId = dict["GroupId"] as! String
                        }
                        if dict.keys.contains("HostName") && dict["HostName"] != nil {
                            self.hostName = dict["HostName"] as! String
                        }
                        if dict.keys.contains("InnerIp") && dict["InnerIp"] != nil {
                            self.innerIp = dict["InnerIp"] as! String
                        }
                        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                            self.instanceName = dict["InstanceName"] as! String
                        }
                        if dict.keys.contains("Mem") && dict["Mem"] != nil {
                            self.mem = dict["Mem"] as! Int32
                        }
                        if dict.keys.contains("PrivateIp") && dict["PrivateIp"] != nil {
                            self.privateIp = dict["PrivateIp"] as! String
                        }
                        if dict.keys.contains("PublicIp") && dict["PublicIp"] != nil {
                            self.publicIp = dict["PublicIp"] as! String
                        }
                        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                            self.regionId = dict["RegionId"] as! String
                        }
                        if dict.keys.contains("SerialNum") && dict["SerialNum"] != nil {
                            self.serialNum = dict["SerialNum"] as! String
                        }
                        if dict.keys.contains("SgId") && dict["SgId"] != nil {
                            self.sgId = dict["SgId"] as! String
                        }
                        if dict.keys.contains("Status") && dict["Status"] != nil {
                            self.status = dict["Status"] as! String
                        }
                        if dict.keys.contains("UserId") && dict["UserId"] != nil {
                            self.userId = dict["UserId"] as! String
                        }
                        if dict.keys.contains("VpcEntity") && dict["VpcEntity"] != nil {
                            var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity.VpcEntity()
                            model.fromMap(dict["VpcEntity"] as! [String: Any])
                            self.vpcEntity = model
                        }
                        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                            self.vpcId = dict["VpcId"] as! String
                        }
                        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                            self.zoneId = dict["ZoneId"] as! String
                        }
                    }
                }
                public var ecsEntity: [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ecsEntity != nil {
                        var tmp : [Any] = []
                        for k in self.ecsEntity! {
                            tmp.append(k.toMap())
                        }
                        map["EcsEntity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EcsEntity") && dict["EcsEntity"] != nil {
                        var tmp : [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity] = []
                        for v in dict["EcsEntity"] as! [Any] {
                            var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ecsEntity = tmp
                    }
                }
            }
            public var adminUserId: String?

            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var name: String?

            public var regionId: String?

            public var slbList: ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList?

            public var updateTime: Int64?

            public var ecsList: ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.slbList?.validate()
                try self.ecsList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adminUserId != nil {
                    map["AdminUserId"] = self.adminUserId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.slbList != nil {
                    map["SlbList"] = self.slbList?.toMap()
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.ecsList != nil {
                    map["ecsList"] = self.ecsList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdminUserId") && dict["AdminUserId"] != nil {
                    self.adminUserId = dict["AdminUserId"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SlbList") && dict["SlbList"] != nil {
                    var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList()
                    model.fromMap(dict["SlbList"] as! [String: Any])
                    self.slbList = model
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("ecsList") && dict["ecsList"] != nil {
                    var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList()
                    model.fromMap(dict["ecsList"] as! [String: Any])
                    self.ecsList = model
                }
            }
        }
        public var resGroupEntity: [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resGroupEntity != nil {
                var tmp : [Any] = []
                for k in self.resGroupEntity! {
                    tmp.append(k.toMap())
                }
                map["ResGroupEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResGroupEntity") && dict["ResGroupEntity"] != nil {
                var tmp : [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity] = []
                for v in dict["ResGroupEntity"] as! [Any] {
                    var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resGroupEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var resourceGroupList: ListResourceGroupResponseBody.ResourceGroupList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceGroupList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupList != nil {
            map["ResourceGroupList"] = self.resourceGroupList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupList") && dict["ResourceGroupList"] != nil {
            var model = ListResourceGroupResponseBody.ResourceGroupList()
            model.fromMap(dict["ResourceGroupList"] as! [String: Any])
            self.resourceGroupList = model
        }
    }
}

public class ListResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRoleResponseBody : Tea.TeaModel {
    public class RoleList : Tea.TeaModel {
        public class RoleItem : Tea.TeaModel {
            public class ActionList : Tea.TeaModel {
                public class Action : Tea.TeaModel {
                    public var code: String?

                    public var description_: String?

                    public var groupId: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.groupId != nil {
                            map["GroupId"] = self.groupId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") && dict["Code"] != nil {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                            self.groupId = dict["GroupId"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var action: [ListRoleResponseBody.RoleList.RoleItem.ActionList.Action]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        var tmp : [Any] = []
                        for k in self.action! {
                            tmp.append(k.toMap())
                        }
                        map["Action"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Action") && dict["Action"] != nil {
                        var tmp : [ListRoleResponseBody.RoleList.RoleItem.ActionList.Action] = []
                        for v in dict["Action"] as! [Any] {
                            var model = ListRoleResponseBody.RoleList.RoleItem.ActionList.Action()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.action = tmp
                    }
                }
            }
            public class Role : Tea.TeaModel {
                public var adminUserId: String?

                public var createTime: Int64?

                public var id: Int32?

                public var isDefault: Bool?

                public var name: String?

                public var updateTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adminUserId != nil {
                        map["AdminUserId"] = self.adminUserId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.isDefault != nil {
                        map["IsDefault"] = self.isDefault!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdminUserId") && dict["AdminUserId"] != nil {
                        self.adminUserId = dict["AdminUserId"] as! String
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int32
                    }
                    if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                        self.isDefault = dict["IsDefault"] as! Bool
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                        self.updateTime = dict["UpdateTime"] as! Int64
                    }
                }
            }
            public var actionList: ListRoleResponseBody.RoleList.RoleItem.ActionList?

            public var role: ListRoleResponseBody.RoleList.RoleItem.Role?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.actionList?.validate()
                try self.role?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionList != nil {
                    map["ActionList"] = self.actionList?.toMap()
                }
                if self.role != nil {
                    map["Role"] = self.role?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActionList") && dict["ActionList"] != nil {
                    var model = ListRoleResponseBody.RoleList.RoleItem.ActionList()
                    model.fromMap(dict["ActionList"] as! [String: Any])
                    self.actionList = model
                }
                if dict.keys.contains("Role") && dict["Role"] != nil {
                    var model = ListRoleResponseBody.RoleList.RoleItem.Role()
                    model.fromMap(dict["Role"] as! [String: Any])
                    self.role = model
                }
            }
        }
        public var roleItem: [ListRoleResponseBody.RoleList.RoleItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roleItem != nil {
                var tmp : [Any] = []
                for k in self.roleItem! {
                    tmp.append(k.toMap())
                }
                map["RoleItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RoleItem") && dict["RoleItem"] != nil {
                var tmp : [ListRoleResponseBody.RoleList.RoleItem] = []
                for v in dict["RoleItem"] as! [Any] {
                    var model = ListRoleResponseBody.RoleList.RoleItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roleItem = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var roleList: ListRoleResponseBody.RoleList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.roleList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.roleList != nil {
            map["RoleList"] = self.roleList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RoleList") && dict["RoleList"] != nil {
            var model = ListRoleResponseBody.RoleList()
            model.fromMap(dict["RoleList"] as! [String: Any])
            self.roleList = model
        }
    }
}

public class ListRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScaleOutEcuRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var cpu: Int32?

    public var groupId: String?

    public var instanceNum: Int32?

    public var logicalRegionId: String?

    public var mem: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceNum != nil {
            map["InstanceNum"] = self.instanceNum!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.mem != nil {
            map["Mem"] = self.mem!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("InstanceNum") && dict["InstanceNum"] != nil {
            self.instanceNum = dict["InstanceNum"] as! Int32
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
        if dict.keys.contains("Mem") && dict["Mem"] != nil {
            self.mem = dict["Mem"] as! Int32
        }
    }
}

public class ListScaleOutEcuResponseBody : Tea.TeaModel {
    public class EcuInfoList : Tea.TeaModel {
        public class EcuInfo : Tea.TeaModel {
            public var availableCpu: Int32?

            public var availableMem: Int32?

            public var createTime: Int64?

            public var dockerEnv: Bool?

            public var ecuId: String?

            public var heartbeatTime: Int64?

            public var instanceId: String?

            public var ipAddr: String?

            public var name: String?

            public var online: Bool?

            public var regionId: String?

            public var updateTime: Int64?

            public var userId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableCpu != nil {
                    map["AvailableCpu"] = self.availableCpu!
                }
                if self.availableMem != nil {
                    map["AvailableMem"] = self.availableMem!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerEnv != nil {
                    map["DockerEnv"] = self.dockerEnv!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.heartbeatTime != nil {
                    map["HeartbeatTime"] = self.heartbeatTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipAddr != nil {
                    map["IpAddr"] = self.ipAddr!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableCpu") && dict["AvailableCpu"] != nil {
                    self.availableCpu = dict["AvailableCpu"] as! Int32
                }
                if dict.keys.contains("AvailableMem") && dict["AvailableMem"] != nil {
                    self.availableMem = dict["AvailableMem"] as! Int32
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DockerEnv") && dict["DockerEnv"] != nil {
                    self.dockerEnv = dict["DockerEnv"] as! Bool
                }
                if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                    self.ecuId = dict["EcuId"] as! String
                }
                if dict.keys.contains("HeartbeatTime") && dict["HeartbeatTime"] != nil {
                    self.heartbeatTime = dict["HeartbeatTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IpAddr") && dict["IpAddr"] != nil {
                    self.ipAddr = dict["IpAddr"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Online") && dict["Online"] != nil {
                    self.online = dict["Online"] as! Bool
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var ecuInfo: [ListScaleOutEcuResponseBody.EcuInfoList.EcuInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecuInfo != nil {
                var tmp : [Any] = []
                for k in self.ecuInfo! {
                    tmp.append(k.toMap())
                }
                map["EcuInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EcuInfo") && dict["EcuInfo"] != nil {
                var tmp : [ListScaleOutEcuResponseBody.EcuInfoList.EcuInfo] = []
                for v in dict["EcuInfo"] as! [Any] {
                    var model = ListScaleOutEcuResponseBody.EcuInfoList.EcuInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ecuInfo = tmp
            }
        }
    }
    public var code: Int32?

    public var ecuInfoList: ListScaleOutEcuResponseBody.EcuInfoList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecuInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecuInfoList != nil {
            map["EcuInfoList"] = self.ecuInfoList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EcuInfoList") && dict["EcuInfoList"] != nil {
            var model = ListScaleOutEcuResponseBody.EcuInfoList()
            model.fromMap(dict["EcuInfoList"] as! [String: Any])
            self.ecuInfoList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListScaleOutEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScaleOutEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListScaleOutEcuResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceGroupsResponseBody : Tea.TeaModel {
    public class ServiceGroupsList : Tea.TeaModel {
        public class ListServiceGroups : Tea.TeaModel {
            public var createTime: String?

            public var groupId: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
            }
        }
        public var listServiceGroups: [ListServiceGroupsResponseBody.ServiceGroupsList.ListServiceGroups]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.listServiceGroups != nil {
                var tmp : [Any] = []
                for k in self.listServiceGroups! {
                    tmp.append(k.toMap())
                }
                map["ListServiceGroups"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ListServiceGroups") && dict["ListServiceGroups"] != nil {
                var tmp : [ListServiceGroupsResponseBody.ServiceGroupsList.ListServiceGroups] = []
                for v in dict["ListServiceGroups"] as! [Any] {
                    var model = ListServiceGroupsResponseBody.ServiceGroupsList.ListServiceGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.listServiceGroups = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var serviceGroupsList: ListServiceGroupsResponseBody.ServiceGroupsList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serviceGroupsList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceGroupsList != nil {
            map["ServiceGroupsList"] = self.serviceGroupsList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceGroupsList") && dict["ServiceGroupsList"] != nil {
            var model = ListServiceGroupsResponseBody.ServiceGroupsList()
            model.fromMap(dict["ServiceGroupsList"] as! [String: Any])
            self.serviceGroupsList = model
        }
    }
}

public class ListServiceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListServiceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSlbRequest : Tea.TeaModel {
    public var addressType: String?

    public var slbType: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressType != nil {
            map["AddressType"] = self.addressType!
        }
        if self.slbType != nil {
            map["SlbType"] = self.slbType!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressType") && dict["AddressType"] != nil {
            self.addressType = dict["AddressType"] as! String
        }
        if dict.keys.contains("SlbType") && dict["SlbType"] != nil {
            self.slbType = dict["SlbType"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ListSlbResponseBody : Tea.TeaModel {
    public class SlbList : Tea.TeaModel {
        public class SlbEntity : Tea.TeaModel {
            public var address: String?

            public var addressType: String?

            public var expired: Bool?

            public var groupId: Int32?

            public var networkType: String?

            public var regionId: String?

            public var reusable: Bool?

            public var slbId: String?

            public var slbName: String?

            public var slbStatus: String?

            public var tags: String?

            public var userId: String?

            public var vpcId: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressType != nil {
                    map["AddressType"] = self.addressType!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reusable != nil {
                    map["Reusable"] = self.reusable!
                }
                if self.slbId != nil {
                    map["SlbId"] = self.slbId!
                }
                if self.slbName != nil {
                    map["SlbName"] = self.slbName!
                }
                if self.slbStatus != nil {
                    map["SlbStatus"] = self.slbStatus!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vswitchId != nil {
                    map["VswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("AddressType") && dict["AddressType"] != nil {
                    self.addressType = dict["AddressType"] as! String
                }
                if dict.keys.contains("Expired") && dict["Expired"] != nil {
                    self.expired = dict["Expired"] as! Bool
                }
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int32
                }
                if dict.keys.contains("NetworkType") && dict["NetworkType"] != nil {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Reusable") && dict["Reusable"] != nil {
                    self.reusable = dict["Reusable"] as! Bool
                }
                if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
                    self.slbId = dict["SlbId"] as! String
                }
                if dict.keys.contains("SlbName") && dict["SlbName"] != nil {
                    self.slbName = dict["SlbName"] as! String
                }
                if dict.keys.contains("SlbStatus") && dict["SlbStatus"] != nil {
                    self.slbStatus = dict["SlbStatus"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                    self.vswitchId = dict["VswitchId"] as! String
                }
            }
        }
        public var slbEntity: [ListSlbResponseBody.SlbList.SlbEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbEntity != nil {
                var tmp : [Any] = []
                for k in self.slbEntity! {
                    tmp.append(k.toMap())
                }
                map["SlbEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbEntity") && dict["SlbEntity"] != nil {
                var tmp : [ListSlbResponseBody.SlbList.SlbEntity] = []
                for v in dict["SlbEntity"] as! [Any] {
                    var model = ListSlbResponseBody.SlbList.SlbEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.slbEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var slbList: ListSlbResponseBody.SlbList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.slbList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slbList != nil {
            map["SlbList"] = self.slbList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SlbList") && dict["SlbList"] != nil {
            var model = ListSlbResponseBody.SlbList()
            model.fromMap(dict["SlbList"] as! [String: Any])
            self.slbList = model
        }
    }
}

public class ListSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSubAccountResponseBody : Tea.TeaModel {
    public class SubAccountList : Tea.TeaModel {
        public class SubAccount : Tea.TeaModel {
            public var adminEdasId: String?

            public var adminUserId: String?

            public var adminUserKp: String?

            public var email: String?

            public var phone: String?

            public var subEdasId: String?

            public var subUserId: String?

            public var subUserKp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adminEdasId != nil {
                    map["AdminEdasId"] = self.adminEdasId!
                }
                if self.adminUserId != nil {
                    map["AdminUserId"] = self.adminUserId!
                }
                if self.adminUserKp != nil {
                    map["AdminUserKp"] = self.adminUserKp!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.subEdasId != nil {
                    map["SubEdasId"] = self.subEdasId!
                }
                if self.subUserId != nil {
                    map["SubUserId"] = self.subUserId!
                }
                if self.subUserKp != nil {
                    map["SubUserKp"] = self.subUserKp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdminEdasId") && dict["AdminEdasId"] != nil {
                    self.adminEdasId = dict["AdminEdasId"] as! String
                }
                if dict.keys.contains("AdminUserId") && dict["AdminUserId"] != nil {
                    self.adminUserId = dict["AdminUserId"] as! String
                }
                if dict.keys.contains("AdminUserKp") && dict["AdminUserKp"] != nil {
                    self.adminUserKp = dict["AdminUserKp"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Phone") && dict["Phone"] != nil {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("SubEdasId") && dict["SubEdasId"] != nil {
                    self.subEdasId = dict["SubEdasId"] as! String
                }
                if dict.keys.contains("SubUserId") && dict["SubUserId"] != nil {
                    self.subUserId = dict["SubUserId"] as! String
                }
                if dict.keys.contains("SubUserKp") && dict["SubUserKp"] != nil {
                    self.subUserKp = dict["SubUserKp"] as! String
                }
            }
        }
        public var subAccount: [ListSubAccountResponseBody.SubAccountList.SubAccount]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subAccount != nil {
                var tmp : [Any] = []
                for k in self.subAccount! {
                    tmp.append(k.toMap())
                }
                map["SubAccount"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SubAccount") && dict["SubAccount"] != nil {
                var tmp : [ListSubAccountResponseBody.SubAccountList.SubAccount] = []
                for v in dict["SubAccount"] as! [Any] {
                    var model = ListSubAccountResponseBody.SubAccountList.SubAccount()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subAccount = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var subAccountList: ListSubAccountResponseBody.SubAccountList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subAccountList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subAccountList != nil {
            map["SubAccountList"] = self.subAccountList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubAccountList") && dict["SubAccountList"] != nil {
            var model = ListSubAccountResponseBody.SubAccountList()
            model.fromMap(dict["SubAccountList"] as! [String: Any])
            self.subAccountList = model
        }
    }
}

public class ListSubAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSubAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSubAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSwimmingLaneRequest : Tea.TeaModel {
    public var groupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
    }
}

public class ListSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SwimmingLaneAppRelationShipList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var extra: String?

            public var laneId: Int64?

            public var rules: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.extra != nil {
                    map["Extra"] = self.extra!
                }
                if self.laneId != nil {
                    map["LaneId"] = self.laneId!
                }
                if self.rules != nil {
                    map["Rules"] = self.rules!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Extra") && dict["Extra"] != nil {
                    self.extra = dict["Extra"] as! String
                }
                if dict.keys.contains("LaneId") && dict["LaneId"] != nil {
                    self.laneId = dict["LaneId"] as! Int64
                }
                if dict.keys.contains("Rules") && dict["Rules"] != nil {
                    self.rules = dict["Rules"] as! String
                }
            }
        }
        public var enableRules: Bool?

        public var entryRule: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public var scenarioSign: String?

        public var swimmingLaneAppRelationShipList: [ListSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList]?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableRules != nil {
                map["EnableRules"] = self.enableRules!
            }
            if self.entryRule != nil {
                map["EntryRule"] = self.entryRule!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.scenarioSign != nil {
                map["ScenarioSign"] = self.scenarioSign!
            }
            if self.swimmingLaneAppRelationShipList != nil {
                var tmp : [Any] = []
                for k in self.swimmingLaneAppRelationShipList! {
                    tmp.append(k.toMap())
                }
                map["SwimmingLaneAppRelationShipList"] = tmp
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableRules") && dict["EnableRules"] != nil {
                self.enableRules = dict["EnableRules"] as! Bool
            }
            if dict.keys.contains("EntryRule") && dict["EntryRule"] != nil {
                self.entryRule = dict["EntryRule"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("ScenarioSign") && dict["ScenarioSign"] != nil {
                self.scenarioSign = dict["ScenarioSign"] as! String
            }
            if dict.keys.contains("SwimmingLaneAppRelationShipList") && dict["SwimmingLaneAppRelationShipList"] != nil {
                var tmp : [ListSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList] = []
                for v in dict["SwimmingLaneAppRelationShipList"] as! [Any] {
                    var model = ListSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.swimmingLaneAppRelationShipList = tmp
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSwimmingLaneResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListSwimmingLaneResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListSwimmingLaneResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSwimmingLaneGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
    }
}

public class ListSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApplicationList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
            }
        }
        public class EntryApplication : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var source: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
            }
        }
        public var applicationList: [ListSwimmingLaneGroupResponseBody.Data.ApplicationList]?

        public var entryApplication: ListSwimmingLaneGroupResponseBody.Data.EntryApplication?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.entryApplication?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationList != nil {
                var tmp : [Any] = []
                for k in self.applicationList! {
                    tmp.append(k.toMap())
                }
                map["ApplicationList"] = tmp
            }
            if self.entryApplication != nil {
                map["EntryApplication"] = self.entryApplication?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationList") && dict["ApplicationList"] != nil {
                var tmp : [ListSwimmingLaneGroupResponseBody.Data.ApplicationList] = []
                for v in dict["ApplicationList"] as! [Any] {
                    var model = ListSwimmingLaneGroupResponseBody.Data.ApplicationList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applicationList = tmp
            }
            if dict.keys.contains("EntryApplication") && dict["EntryApplication"] != nil {
                var model = ListSwimmingLaneGroupResponseBody.Data.EntryApplication()
                model.fromMap(dict["EntryApplication"] as! [String: Any])
                self.entryApplication = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                self.namespaceId = dict["NamespaceId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSwimmingLaneGroupResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListSwimmingLaneGroupResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListSwimmingLaneGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public var resourceIds: [String: Any]?

    public var resourceRegionId: String?

    public var resourceType: String?

    public var tags: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceRegionId != nil {
            map["ResourceRegionId"] = self.resourceRegionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceIds") && dict["ResourceIds"] != nil {
            self.resourceIds = dict["ResourceIds"] as! [String: Any]
        }
        if dict.keys.contains("ResourceRegionId") && dict["ResourceRegionId"] != nil {
            self.resourceRegionId = dict["ResourceRegionId"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! [String: Any]
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") && dict["TagResource"] != nil {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") && dict["TagResources"] != nil {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserDefineRegionRequest : Tea.TeaModel {
    public var debugEnable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.debugEnable != nil {
            map["DebugEnable"] = self.debugEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DebugEnable") && dict["DebugEnable"] != nil {
            self.debugEnable = dict["DebugEnable"] as! Bool
        }
    }
}

public class ListUserDefineRegionResponseBody : Tea.TeaModel {
    public class UserDefineRegionList : Tea.TeaModel {
        public class UserDefineRegionEntity : Tea.TeaModel {
            public var belongRegion: String?

            public var debugEnable: Bool?

            public var description_: String?

            public var id: Int64?

            public var mseInstanceId: String?

            public var regionId: String?

            public var regionName: String?

            public var registryType: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.belongRegion != nil {
                    map["BelongRegion"] = self.belongRegion!
                }
                if self.debugEnable != nil {
                    map["DebugEnable"] = self.debugEnable!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.mseInstanceId != nil {
                    map["MseInstanceId"] = self.mseInstanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.regionName != nil {
                    map["RegionName"] = self.regionName!
                }
                if self.registryType != nil {
                    map["RegistryType"] = self.registryType!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BelongRegion") && dict["BelongRegion"] != nil {
                    self.belongRegion = dict["BelongRegion"] as! String
                }
                if dict.keys.contains("DebugEnable") && dict["DebugEnable"] != nil {
                    self.debugEnable = dict["DebugEnable"] as! Bool
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MseInstanceId") && dict["MseInstanceId"] != nil {
                    self.mseInstanceId = dict["MseInstanceId"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                    self.regionName = dict["RegionName"] as! String
                }
                if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                    self.registryType = dict["RegistryType"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var userDefineRegionEntity: [ListUserDefineRegionResponseBody.UserDefineRegionList.UserDefineRegionEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userDefineRegionEntity != nil {
                var tmp : [Any] = []
                for k in self.userDefineRegionEntity! {
                    tmp.append(k.toMap())
                }
                map["UserDefineRegionEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserDefineRegionEntity") && dict["UserDefineRegionEntity"] != nil {
                var tmp : [ListUserDefineRegionResponseBody.UserDefineRegionList.UserDefineRegionEntity] = []
                for v in dict["UserDefineRegionEntity"] as! [Any] {
                    var model = ListUserDefineRegionResponseBody.UserDefineRegionList.UserDefineRegionEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userDefineRegionEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var userDefineRegionList: ListUserDefineRegionResponseBody.UserDefineRegionList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userDefineRegionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userDefineRegionList != nil {
            map["UserDefineRegionList"] = self.userDefineRegionList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserDefineRegionList") && dict["UserDefineRegionList"] != nil {
            var model = ListUserDefineRegionResponseBody.UserDefineRegionList()
            model.fromMap(dict["UserDefineRegionList"] as! [String: Any])
            self.userDefineRegionList = model
        }
    }
}

public class ListUserDefineRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserDefineRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUserDefineRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVpcResponseBody : Tea.TeaModel {
    public class VpcList : Tea.TeaModel {
        public class VpcEntity : Tea.TeaModel {
            public var ecsNum: Int32?

            public var expired: Bool?

            public var regionId: String?

            public var userId: String?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecsNum != nil {
                    map["EcsNum"] = self.ecsNum!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EcsNum") && dict["EcsNum"] != nil {
                    self.ecsNum = dict["EcsNum"] as! Int32
                }
                if dict.keys.contains("Expired") && dict["Expired"] != nil {
                    self.expired = dict["Expired"] as! Bool
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
                    self.vpcName = dict["VpcName"] as! String
                }
            }
        }
        public var vpcEntity: [ListVpcResponseBody.VpcList.VpcEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpcEntity != nil {
                var tmp : [Any] = []
                for k in self.vpcEntity! {
                    tmp.append(k.toMap())
                }
                map["VpcEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpcEntity") && dict["VpcEntity"] != nil {
                var tmp : [ListVpcResponseBody.VpcList.VpcEntity] = []
                for v in dict["VpcEntity"] as! [Any] {
                    var model = ListVpcResponseBody.VpcList.VpcEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpcEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var vpcList: ListVpcResponseBody.VpcList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpcList != nil {
            map["VpcList"] = self.vpcList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpcList") && dict["VpcList"] != nil {
            var model = ListVpcResponseBody.VpcList()
            model.fromMap(dict["VpcList"] as! [String: Any])
            self.vpcList = model
        }
    }
}

public class ListVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MigrateEcuRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
    }
}

public class MigrateEcuResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MigrateEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = MigrateEcuResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScalingRuleRequest : Tea.TeaModel {
    public var acceptEULA: Bool?

    public var appId: String?

    public var groupId: String?

    public var inCondition: String?

    public var inCpu: Int32?

    public var inDuration: Int32?

    public var inEnable: Bool?

    public var inInstanceNum: Int32?

    public var inLoad: Int32?

    public var inRT: Int32?

    public var inStep: Int32?

    public var keyPairName: String?

    public var multiAzPolicy: String?

    public var outCPU: Int32?

    public var outCondition: String?

    public var outDuration: Int32?

    public var outEnable: Bool?

    public var outInstanceNum: Int32?

    public var outLoad: Int32?

    public var outRT: Int32?

    public var outStep: Int32?

    public var password: String?

    public var resourceFrom: String?

    public var scalingPolicy: String?

    public var templateId: String?

    public var templateInstanceId: String?

    public var templateInstanceName: String?

    public var templateVersion: Int32?

    public var vSwitchIds: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptEULA != nil {
            map["AcceptEULA"] = self.acceptEULA!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.inCondition != nil {
            map["InCondition"] = self.inCondition!
        }
        if self.inCpu != nil {
            map["InCpu"] = self.inCpu!
        }
        if self.inDuration != nil {
            map["InDuration"] = self.inDuration!
        }
        if self.inEnable != nil {
            map["InEnable"] = self.inEnable!
        }
        if self.inInstanceNum != nil {
            map["InInstanceNum"] = self.inInstanceNum!
        }
        if self.inLoad != nil {
            map["InLoad"] = self.inLoad!
        }
        if self.inRT != nil {
            map["InRT"] = self.inRT!
        }
        if self.inStep != nil {
            map["InStep"] = self.inStep!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.multiAzPolicy != nil {
            map["MultiAzPolicy"] = self.multiAzPolicy!
        }
        if self.outCPU != nil {
            map["OutCPU"] = self.outCPU!
        }
        if self.outCondition != nil {
            map["OutCondition"] = self.outCondition!
        }
        if self.outDuration != nil {
            map["OutDuration"] = self.outDuration!
        }
        if self.outEnable != nil {
            map["OutEnable"] = self.outEnable!
        }
        if self.outInstanceNum != nil {
            map["OutInstanceNum"] = self.outInstanceNum!
        }
        if self.outLoad != nil {
            map["OutLoad"] = self.outLoad!
        }
        if self.outRT != nil {
            map["OutRT"] = self.outRT!
        }
        if self.outStep != nil {
            map["OutStep"] = self.outStep!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.resourceFrom != nil {
            map["ResourceFrom"] = self.resourceFrom!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateInstanceId != nil {
            map["TemplateInstanceId"] = self.templateInstanceId!
        }
        if self.templateInstanceName != nil {
            map["TemplateInstanceName"] = self.templateInstanceName!
        }
        if self.templateVersion != nil {
            map["TemplateVersion"] = self.templateVersion!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptEULA") && dict["AcceptEULA"] != nil {
            self.acceptEULA = dict["AcceptEULA"] as! Bool
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("InCondition") && dict["InCondition"] != nil {
            self.inCondition = dict["InCondition"] as! String
        }
        if dict.keys.contains("InCpu") && dict["InCpu"] != nil {
            self.inCpu = dict["InCpu"] as! Int32
        }
        if dict.keys.contains("InDuration") && dict["InDuration"] != nil {
            self.inDuration = dict["InDuration"] as! Int32
        }
        if dict.keys.contains("InEnable") && dict["InEnable"] != nil {
            self.inEnable = dict["InEnable"] as! Bool
        }
        if dict.keys.contains("InInstanceNum") && dict["InInstanceNum"] != nil {
            self.inInstanceNum = dict["InInstanceNum"] as! Int32
        }
        if dict.keys.contains("InLoad") && dict["InLoad"] != nil {
            self.inLoad = dict["InLoad"] as! Int32
        }
        if dict.keys.contains("InRT") && dict["InRT"] != nil {
            self.inRT = dict["InRT"] as! Int32
        }
        if dict.keys.contains("InStep") && dict["InStep"] != nil {
            self.inStep = dict["InStep"] as! Int32
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("MultiAzPolicy") && dict["MultiAzPolicy"] != nil {
            self.multiAzPolicy = dict["MultiAzPolicy"] as! String
        }
        if dict.keys.contains("OutCPU") && dict["OutCPU"] != nil {
            self.outCPU = dict["OutCPU"] as! Int32
        }
        if dict.keys.contains("OutCondition") && dict["OutCondition"] != nil {
            self.outCondition = dict["OutCondition"] as! String
        }
        if dict.keys.contains("OutDuration") && dict["OutDuration"] != nil {
            self.outDuration = dict["OutDuration"] as! Int32
        }
        if dict.keys.contains("OutEnable") && dict["OutEnable"] != nil {
            self.outEnable = dict["OutEnable"] as! Bool
        }
        if dict.keys.contains("OutInstanceNum") && dict["OutInstanceNum"] != nil {
            self.outInstanceNum = dict["OutInstanceNum"] as! Int32
        }
        if dict.keys.contains("OutLoad") && dict["OutLoad"] != nil {
            self.outLoad = dict["OutLoad"] as! Int32
        }
        if dict.keys.contains("OutRT") && dict["OutRT"] != nil {
            self.outRT = dict["OutRT"] as! Int32
        }
        if dict.keys.contains("OutStep") && dict["OutStep"] != nil {
            self.outStep = dict["OutStep"] as! Int32
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("ResourceFrom") && dict["ResourceFrom"] != nil {
            self.resourceFrom = dict["ResourceFrom"] as! String
        }
        if dict.keys.contains("ScalingPolicy") && dict["ScalingPolicy"] != nil {
            self.scalingPolicy = dict["ScalingPolicy"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateInstanceId") && dict["TemplateInstanceId"] != nil {
            self.templateInstanceId = dict["TemplateInstanceId"] as! String
        }
        if dict.keys.contains("TemplateInstanceName") && dict["TemplateInstanceName"] != nil {
            self.templateInstanceName = dict["TemplateInstanceName"] as! String
        }
        if dict.keys.contains("TemplateVersion") && dict["TemplateVersion"] != nil {
            self.templateVersion = dict["TemplateVersion"] as! Int32
        }
        if dict.keys.contains("VSwitchIds") && dict["VSwitchIds"] != nil {
            self.vSwitchIds = dict["VSwitchIds"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ModifyScalingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryApplicationStatusRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class QueryApplicationStatusResponseBody : Tea.TeaModel {
    public class AppInfo : Tea.TeaModel {
        public class Application : Tea.TeaModel {
            public var applicationId: String?

            public var buildPackageId: Int32?

            public var clusterId: String?

            public var cpu: Int32?

            public var createTime: Int64?

            public var dockerize: Bool?

            public var email: String?

            public var healthCheckUrl: String?

            public var instanceCount: Int32?

            public var launchTime: Int64?

            public var memory: Int32?

            public var name: String?

            public var owner: String?

            public var phone: String?

            public var port: Int32?

            public var regionId: String?

            public var runningInstanceCount: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationId != nil {
                    map["ApplicationId"] = self.applicationId!
                }
                if self.buildPackageId != nil {
                    map["BuildPackageId"] = self.buildPackageId!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerize != nil {
                    map["Dockerize"] = self.dockerize!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.healthCheckUrl != nil {
                    map["HealthCheckUrl"] = self.healthCheckUrl!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.launchTime != nil {
                    map["LaunchTime"] = self.launchTime!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.runningInstanceCount != nil {
                    map["RunningInstanceCount"] = self.runningInstanceCount!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplicationId") && dict["ApplicationId"] != nil {
                    self.applicationId = dict["ApplicationId"] as! String
                }
                if dict.keys.contains("BuildPackageId") && dict["BuildPackageId"] != nil {
                    self.buildPackageId = dict["BuildPackageId"] as! Int32
                }
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Dockerize") && dict["Dockerize"] != nil {
                    self.dockerize = dict["Dockerize"] as! Bool
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("HealthCheckUrl") && dict["HealthCheckUrl"] != nil {
                    self.healthCheckUrl = dict["HealthCheckUrl"] as! String
                }
                if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                    self.instanceCount = dict["InstanceCount"] as! Int32
                }
                if dict.keys.contains("LaunchTime") && dict["LaunchTime"] != nil {
                    self.launchTime = dict["LaunchTime"] as! Int64
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") && dict["Owner"] != nil {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Phone") && dict["Phone"] != nil {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RunningInstanceCount") && dict["RunningInstanceCount"] != nil {
                    self.runningInstanceCount = dict["RunningInstanceCount"] as! Int32
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class DeployRecordList : Tea.TeaModel {
            public class DeployRecord : Tea.TeaModel {
                public var createTime: Int64?

                public var deployRecordId: String?

                public var eccId: String?

                public var ecuId: String?

                public var packageMd5: String?

                public var packageVersionId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.deployRecordId != nil {
                        map["DeployRecordId"] = self.deployRecordId!
                    }
                    if self.eccId != nil {
                        map["EccId"] = self.eccId!
                    }
                    if self.ecuId != nil {
                        map["EcuId"] = self.ecuId!
                    }
                    if self.packageMd5 != nil {
                        map["PackageMd5"] = self.packageMd5!
                    }
                    if self.packageVersionId != nil {
                        map["PackageVersionId"] = self.packageVersionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("DeployRecordId") && dict["DeployRecordId"] != nil {
                        self.deployRecordId = dict["DeployRecordId"] as! String
                    }
                    if dict.keys.contains("EccId") && dict["EccId"] != nil {
                        self.eccId = dict["EccId"] as! String
                    }
                    if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                        self.ecuId = dict["EcuId"] as! String
                    }
                    if dict.keys.contains("PackageMd5") && dict["PackageMd5"] != nil {
                        self.packageMd5 = dict["PackageMd5"] as! String
                    }
                    if dict.keys.contains("PackageVersionId") && dict["PackageVersionId"] != nil {
                        self.packageVersionId = dict["PackageVersionId"] as! String
                    }
                }
            }
            public var deployRecord: [QueryApplicationStatusResponseBody.AppInfo.DeployRecordList.DeployRecord]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deployRecord != nil {
                    var tmp : [Any] = []
                    for k in self.deployRecord! {
                        tmp.append(k.toMap())
                    }
                    map["DeployRecord"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeployRecord") && dict["DeployRecord"] != nil {
                    var tmp : [QueryApplicationStatusResponseBody.AppInfo.DeployRecordList.DeployRecord] = []
                    for v in dict["DeployRecord"] as! [Any] {
                        var model = QueryApplicationStatusResponseBody.AppInfo.DeployRecordList.DeployRecord()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.deployRecord = tmp
                }
            }
        }
        public class EccList : Tea.TeaModel {
            public class Ecc : Tea.TeaModel {
                public var appId: String?

                public var appState: Int32?

                public var containerStatus: String?

                public var createTime: Int64?

                public var eccId: String?

                public var ecuId: String?

                public var groupId: String?

                public var ip: String?

                public var taskState: Int32?

                public var updateTime: Int64?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appState != nil {
                        map["AppState"] = self.appState!
                    }
                    if self.containerStatus != nil {
                        map["ContainerStatus"] = self.containerStatus!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.eccId != nil {
                        map["EccId"] = self.eccId!
                    }
                    if self.ecuId != nil {
                        map["EcuId"] = self.ecuId!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.taskState != nil {
                        map["TaskState"] = self.taskState!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("AppState") && dict["AppState"] != nil {
                        self.appState = dict["AppState"] as! Int32
                    }
                    if dict.keys.contains("ContainerStatus") && dict["ContainerStatus"] != nil {
                        self.containerStatus = dict["ContainerStatus"] as! String
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("EccId") && dict["EccId"] != nil {
                        self.eccId = dict["EccId"] as! String
                    }
                    if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                        self.ecuId = dict["EcuId"] as! String
                    }
                    if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                        self.groupId = dict["GroupId"] as! String
                    }
                    if dict.keys.contains("Ip") && dict["Ip"] != nil {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("TaskState") && dict["TaskState"] != nil {
                        self.taskState = dict["TaskState"] as! Int32
                    }
                    if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                        self.updateTime = dict["UpdateTime"] as! Int64
                    }
                    if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public var ecc: [QueryApplicationStatusResponseBody.AppInfo.EccList.Ecc]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecc != nil {
                    var tmp : [Any] = []
                    for k in self.ecc! {
                        tmp.append(k.toMap())
                    }
                    map["Ecc"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ecc") && dict["Ecc"] != nil {
                    var tmp : [QueryApplicationStatusResponseBody.AppInfo.EccList.Ecc] = []
                    for v in dict["Ecc"] as! [Any] {
                        var model = QueryApplicationStatusResponseBody.AppInfo.EccList.Ecc()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ecc = tmp
                }
            }
        }
        public class EcuList : Tea.TeaModel {
            public class Ecu : Tea.TeaModel {
                public var availableCpu: Int32?

                public var availableMem: Int32?

                public var createTime: Int64?

                public var dockerEnv: Bool?

                public var ecuId: String?

                public var groupId: String?

                public var heartbeatTime: Int64?

                public var instanceId: String?

                public var ipAddr: String?

                public var name: String?

                public var online: Bool?

                public var regionId: String?

                public var updateTime: Int64?

                public var userId: String?

                public var vpcId: String?

                public var zoneId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableCpu != nil {
                        map["AvailableCpu"] = self.availableCpu!
                    }
                    if self.availableMem != nil {
                        map["AvailableMem"] = self.availableMem!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.dockerEnv != nil {
                        map["DockerEnv"] = self.dockerEnv!
                    }
                    if self.ecuId != nil {
                        map["EcuId"] = self.ecuId!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.heartbeatTime != nil {
                        map["HeartbeatTime"] = self.heartbeatTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.ipAddr != nil {
                        map["IpAddr"] = self.ipAddr!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.online != nil {
                        map["Online"] = self.online!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    if self.zoneId != nil {
                        map["ZoneId"] = self.zoneId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableCpu") && dict["AvailableCpu"] != nil {
                        self.availableCpu = dict["AvailableCpu"] as! Int32
                    }
                    if dict.keys.contains("AvailableMem") && dict["AvailableMem"] != nil {
                        self.availableMem = dict["AvailableMem"] as! Int32
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("DockerEnv") && dict["DockerEnv"] != nil {
                        self.dockerEnv = dict["DockerEnv"] as! Bool
                    }
                    if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                        self.ecuId = dict["EcuId"] as! String
                    }
                    if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                        self.groupId = dict["GroupId"] as! String
                    }
                    if dict.keys.contains("HeartbeatTime") && dict["HeartbeatTime"] != nil {
                        self.heartbeatTime = dict["HeartbeatTime"] as! Int64
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("IpAddr") && dict["IpAddr"] != nil {
                        self.ipAddr = dict["IpAddr"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Online") && dict["Online"] != nil {
                        self.online = dict["Online"] as! Bool
                    }
                    if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                        self.updateTime = dict["UpdateTime"] as! Int64
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                    if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                        self.vpcId = dict["VpcId"] as! String
                    }
                    if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                        self.zoneId = dict["ZoneId"] as! String
                    }
                }
            }
            public var ecu: [QueryApplicationStatusResponseBody.AppInfo.EcuList.Ecu]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecu != nil {
                    var tmp : [Any] = []
                    for k in self.ecu! {
                        tmp.append(k.toMap())
                    }
                    map["Ecu"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ecu") && dict["Ecu"] != nil {
                    var tmp : [QueryApplicationStatusResponseBody.AppInfo.EcuList.Ecu] = []
                    for v in dict["Ecu"] as! [Any] {
                        var model = QueryApplicationStatusResponseBody.AppInfo.EcuList.Ecu()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ecu = tmp
                }
            }
        }
        public class GroupList : Tea.TeaModel {
            public class Group : Tea.TeaModel {
                public var appId: String?

                public var appVersionId: String?

                public var clusterId: String?

                public var createTime: Int64?

                public var groupId: String?

                public var groupName: String?

                public var groupType: Int32?

                public var packageVersionId: String?

                public var updateTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appVersionId != nil {
                        map["AppVersionId"] = self.appVersionId!
                    }
                    if self.clusterId != nil {
                        map["ClusterId"] = self.clusterId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.groupType != nil {
                        map["GroupType"] = self.groupType!
                    }
                    if self.packageVersionId != nil {
                        map["PackageVersionId"] = self.packageVersionId!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("AppVersionId") && dict["AppVersionId"] != nil {
                        self.appVersionId = dict["AppVersionId"] as! String
                    }
                    if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                        self.clusterId = dict["ClusterId"] as! String
                    }
                    if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                        self.groupId = dict["GroupId"] as! String
                    }
                    if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("GroupType") && dict["GroupType"] != nil {
                        self.groupType = dict["GroupType"] as! Int32
                    }
                    if dict.keys.contains("PackageVersionId") && dict["PackageVersionId"] != nil {
                        self.packageVersionId = dict["PackageVersionId"] as! String
                    }
                    if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                        self.updateTime = dict["UpdateTime"] as! Int64
                    }
                }
            }
            public var group: [QueryApplicationStatusResponseBody.AppInfo.GroupList.Group]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.group != nil {
                    var tmp : [Any] = []
                    for k in self.group! {
                        tmp.append(k.toMap())
                    }
                    map["Group"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Group") && dict["Group"] != nil {
                    var tmp : [QueryApplicationStatusResponseBody.AppInfo.GroupList.Group] = []
                    for v in dict["Group"] as! [Any] {
                        var model = QueryApplicationStatusResponseBody.AppInfo.GroupList.Group()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.group = tmp
                }
            }
        }
        public var application: QueryApplicationStatusResponseBody.AppInfo.Application?

        public var deployRecordList: QueryApplicationStatusResponseBody.AppInfo.DeployRecordList?

        public var eccList: QueryApplicationStatusResponseBody.AppInfo.EccList?

        public var ecuList: QueryApplicationStatusResponseBody.AppInfo.EcuList?

        public var groupList: QueryApplicationStatusResponseBody.AppInfo.GroupList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.application?.validate()
            try self.deployRecordList?.validate()
            try self.eccList?.validate()
            try self.ecuList?.validate()
            try self.groupList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.application != nil {
                map["Application"] = self.application?.toMap()
            }
            if self.deployRecordList != nil {
                map["DeployRecordList"] = self.deployRecordList?.toMap()
            }
            if self.eccList != nil {
                map["EccList"] = self.eccList?.toMap()
            }
            if self.ecuList != nil {
                map["EcuList"] = self.ecuList?.toMap()
            }
            if self.groupList != nil {
                map["GroupList"] = self.groupList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Application") && dict["Application"] != nil {
                var model = QueryApplicationStatusResponseBody.AppInfo.Application()
                model.fromMap(dict["Application"] as! [String: Any])
                self.application = model
            }
            if dict.keys.contains("DeployRecordList") && dict["DeployRecordList"] != nil {
                var model = QueryApplicationStatusResponseBody.AppInfo.DeployRecordList()
                model.fromMap(dict["DeployRecordList"] as! [String: Any])
                self.deployRecordList = model
            }
            if dict.keys.contains("EccList") && dict["EccList"] != nil {
                var model = QueryApplicationStatusResponseBody.AppInfo.EccList()
                model.fromMap(dict["EccList"] as! [String: Any])
                self.eccList = model
            }
            if dict.keys.contains("EcuList") && dict["EcuList"] != nil {
                var model = QueryApplicationStatusResponseBody.AppInfo.EcuList()
                model.fromMap(dict["EcuList"] as! [String: Any])
                self.ecuList = model
            }
            if dict.keys.contains("GroupList") && dict["GroupList"] != nil {
                var model = QueryApplicationStatusResponseBody.AppInfo.GroupList()
                model.fromMap(dict["GroupList"] as! [String: Any])
                self.groupList = model
            }
        }
    }
    public var appInfo: QueryApplicationStatusResponseBody.AppInfo?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfo != nil {
            map["AppInfo"] = self.appInfo?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppInfo") && dict["AppInfo"] != nil {
            var model = QueryApplicationStatusResponseBody.AppInfo()
            model.fromMap(dict["AppInfo"] as! [String: Any])
            self.appInfo = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryApplicationStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryApplicationStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryApplicationStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryEccInfoRequest : Tea.TeaModel {
    public var eccId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eccId != nil {
            map["EccId"] = self.eccId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EccId") && dict["EccId"] != nil {
            self.eccId = dict["EccId"] as! String
        }
    }
}

public class QueryEccInfoResponseBody : Tea.TeaModel {
    public class EccInfo : Tea.TeaModel {
        public var appId: String?

        public var eccId: String?

        public var ecuId: String?

        public var groupId: String?

        public var groupName: String?

        public var packageMd5: String?

        public var packageVersion: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.eccId != nil {
                map["EccId"] = self.eccId!
            }
            if self.ecuId != nil {
                map["EcuId"] = self.ecuId!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.packageMd5 != nil {
                map["PackageMd5"] = self.packageMd5!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("EccId") && dict["EccId"] != nil {
                self.eccId = dict["EccId"] as! String
            }
            if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                self.ecuId = dict["EcuId"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("PackageMd5") && dict["PackageMd5"] != nil {
                self.packageMd5 = dict["PackageMd5"] as! String
            }
            if dict.keys.contains("PackageVersion") && dict["PackageVersion"] != nil {
                self.packageVersion = dict["PackageVersion"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: Int32?

    public var eccInfo: QueryEccInfoResponseBody.EccInfo?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eccInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EccInfo") && dict["EccInfo"] != nil {
            var model = QueryEccInfoResponseBody.EccInfo()
            model.fromMap(dict["EccInfo"] as! [String: Any])
            self.eccInfo = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryEccInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryEccInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryEccInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMigrateEcuListRequest : Tea.TeaModel {
    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
    }
}

public class QueryMigrateEcuListResponseBody : Tea.TeaModel {
    public class EcuEntityList : Tea.TeaModel {
        public class EcuEntity : Tea.TeaModel {
            public var availableCpu: Int32?

            public var availableMem: Int32?

            public var cpu: Int32?

            public var createTime: Int64?

            public var dockerEnv: Bool?

            public var ecuId: String?

            public var heartbeatTime: Int64?

            public var instanceId: String?

            public var ipAddr: String?

            public var mem: Int32?

            public var name: String?

            public var online: Bool?

            public var regionId: String?

            public var updateTime: Int64?

            public var userId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableCpu != nil {
                    map["AvailableCpu"] = self.availableCpu!
                }
                if self.availableMem != nil {
                    map["AvailableMem"] = self.availableMem!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerEnv != nil {
                    map["DockerEnv"] = self.dockerEnv!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.heartbeatTime != nil {
                    map["HeartbeatTime"] = self.heartbeatTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipAddr != nil {
                    map["IpAddr"] = self.ipAddr!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableCpu") && dict["AvailableCpu"] != nil {
                    self.availableCpu = dict["AvailableCpu"] as! Int32
                }
                if dict.keys.contains("AvailableMem") && dict["AvailableMem"] != nil {
                    self.availableMem = dict["AvailableMem"] as! Int32
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DockerEnv") && dict["DockerEnv"] != nil {
                    self.dockerEnv = dict["DockerEnv"] as! Bool
                }
                if dict.keys.contains("EcuId") && dict["EcuId"] != nil {
                    self.ecuId = dict["EcuId"] as! String
                }
                if dict.keys.contains("HeartbeatTime") && dict["HeartbeatTime"] != nil {
                    self.heartbeatTime = dict["HeartbeatTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IpAddr") && dict["IpAddr"] != nil {
                    self.ipAddr = dict["IpAddr"] as! String
                }
                if dict.keys.contains("Mem") && dict["Mem"] != nil {
                    self.mem = dict["Mem"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Online") && dict["Online"] != nil {
                    self.online = dict["Online"] as! Bool
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var ecuEntity: [QueryMigrateEcuListResponseBody.EcuEntityList.EcuEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecuEntity != nil {
                var tmp : [Any] = []
                for k in self.ecuEntity! {
                    tmp.append(k.toMap())
                }
                map["EcuEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EcuEntity") && dict["EcuEntity"] != nil {
                var tmp : [QueryMigrateEcuListResponseBody.EcuEntityList.EcuEntity] = []
                for v in dict["EcuEntity"] as! [Any] {
                    var model = QueryMigrateEcuListResponseBody.EcuEntityList.EcuEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ecuEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var ecuEntityList: QueryMigrateEcuListResponseBody.EcuEntityList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecuEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecuEntityList != nil {
            map["EcuEntityList"] = self.ecuEntityList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EcuEntityList") && dict["EcuEntityList"] != nil {
            var model = QueryMigrateEcuListResponseBody.EcuEntityList()
            model.fromMap(dict["EcuEntityList"] as! [String: Any])
            self.ecuEntityList = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMigrateEcuListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMigrateEcuListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMigrateEcuListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMigrateRegionListRequest : Tea.TeaModel {
    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogicalRegionId") && dict["LogicalRegionId"] != nil {
            self.logicalRegionId = dict["LogicalRegionId"] as! String
        }
    }
}

public class QueryMigrateRegionListResponseBody : Tea.TeaModel {
    public class RegionEntityList : Tea.TeaModel {
        public class RegionEntity : Tea.TeaModel {
            public var regionName: String?

            public var regionNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.regionName != nil {
                    map["RegionName"] = self.regionName!
                }
                if self.regionNo != nil {
                    map["RegionNo"] = self.regionNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                    self.regionName = dict["RegionName"] as! String
                }
                if dict.keys.contains("RegionNo") && dict["RegionNo"] != nil {
                    self.regionNo = dict["RegionNo"] as! String
                }
            }
        }
        public var regionEntity: [QueryMigrateRegionListResponseBody.RegionEntityList.RegionEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.regionEntity != nil {
                var tmp : [Any] = []
                for k in self.regionEntity! {
                    tmp.append(k.toMap())
                }
                map["RegionEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RegionEntity") && dict["RegionEntity"] != nil {
                var tmp : [QueryMigrateRegionListResponseBody.RegionEntityList.RegionEntity] = []
                for v in dict["RegionEntity"] as! [Any] {
                    var model = QueryMigrateRegionListResponseBody.RegionEntityList.RegionEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.regionEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regionEntityList: QueryMigrateRegionListResponseBody.RegionEntityList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regionEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regionEntityList != nil {
            map["RegionEntityList"] = self.regionEntityList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RegionEntityList") && dict["RegionEntityList"] != nil {
            var model = QueryMigrateRegionListResponseBody.RegionEntityList()
            model.fromMap(dict["RegionEntityList"] as! [String: Any])
            self.regionEntityList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMigrateRegionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMigrateRegionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMigrateRegionListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRegionConfigResponseBody : Tea.TeaModel {
    public class RegionConfig : Tea.TeaModel {
        public class FileServerConfig : Tea.TeaModel {
            public var bucket: String?

            public var internalUrl: String?

            public var publicUrl: String?

            public var vpcUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.internalUrl != nil {
                    map["InternalUrl"] = self.internalUrl!
                }
                if self.publicUrl != nil {
                    map["PublicUrl"] = self.publicUrl!
                }
                if self.vpcUrl != nil {
                    map["VpcUrl"] = self.vpcUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("InternalUrl") && dict["InternalUrl"] != nil {
                    self.internalUrl = dict["InternalUrl"] as! String
                }
                if dict.keys.contains("PublicUrl") && dict["PublicUrl"] != nil {
                    self.publicUrl = dict["PublicUrl"] as! String
                }
                if dict.keys.contains("VpcUrl") && dict["VpcUrl"] != nil {
                    self.vpcUrl = dict["VpcUrl"] as! String
                }
            }
        }
        public var addressServerHost: String?

        public var agentInstallScript: String?

        public var fileServerConfig: QueryRegionConfigResponseBody.RegionConfig.FileServerConfig?

        public var fileServerType: String?

        public var id: String?

        public var imageId: String?

        public var name: String?

        public var no: Int32?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.fileServerConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressServerHost != nil {
                map["AddressServerHost"] = self.addressServerHost!
            }
            if self.agentInstallScript != nil {
                map["AgentInstallScript"] = self.agentInstallScript!
            }
            if self.fileServerConfig != nil {
                map["FileServerConfig"] = self.fileServerConfig?.toMap()
            }
            if self.fileServerType != nil {
                map["FileServerType"] = self.fileServerType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.no != nil {
                map["No"] = self.no!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressServerHost") && dict["AddressServerHost"] != nil {
                self.addressServerHost = dict["AddressServerHost"] as! String
            }
            if dict.keys.contains("AgentInstallScript") && dict["AgentInstallScript"] != nil {
                self.agentInstallScript = dict["AgentInstallScript"] as! String
            }
            if dict.keys.contains("FileServerConfig") && dict["FileServerConfig"] != nil {
                var model = QueryRegionConfigResponseBody.RegionConfig.FileServerConfig()
                model.fromMap(dict["FileServerConfig"] as! [String: Any])
                self.fileServerConfig = model
            }
            if dict.keys.contains("FileServerType") && dict["FileServerType"] != nil {
                self.fileServerType = dict["FileServerType"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("No") && dict["No"] != nil {
                self.no = dict["No"] as! Int32
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regionConfig: QueryRegionConfigResponseBody.RegionConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regionConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regionConfig != nil {
            map["RegionConfig"] = self.regionConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RegionConfig") && dict["RegionConfig"] != nil {
            var model = QueryRegionConfigResponseBody.RegionConfig()
            model.fromMap(dict["RegionConfig"] as! [String: Any])
            self.regionConfig = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryRegionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRegionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryRegionConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySlsLogStoreListRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class QuerySlsLogStoreListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consumerSide: String?

        public var createTime: String?

        public var link: String?

        public var logstore: String?

        public var project: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumerSide != nil {
                map["ConsumerSide"] = self.consumerSide!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.logstore != nil {
                map["Logstore"] = self.logstore!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumerSide") && dict["ConsumerSide"] != nil {
                self.consumerSide = dict["ConsumerSide"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Link") && dict["Link"] != nil {
                self.link = dict["Link"] as! String
            }
            if dict.keys.contains("Logstore") && dict["Logstore"] != nil {
                self.logstore = dict["Logstore"] as! String
            }
            if dict.keys.contains("Project") && dict["Project"] != nil {
                self.project = dict["Project"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var result: [QuerySlsLogStoreListResponseBody.Result]?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            var tmp : [QuerySlsLogStoreListResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = QuerySlsLogStoreListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
            self.totalSize = dict["TotalSize"] as! Int32
        }
    }
}

public class QuerySlsLogStoreListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySlsLogStoreListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QuerySlsLogStoreListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EccInfo") && dict["EccInfo"] != nil {
            self.eccInfo = dict["EccInfo"] as! String
        }
    }
}

public class ResetApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResetApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EccInfo") && dict["EccInfo"] != nil {
            self.eccInfo = dict["EccInfo"] as! String
        }
    }
}

public class RestartApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RestartApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RestartApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class RestartK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RestartK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RestartK8sApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryChangeOrderTaskRequest : Tea.TeaModel {
    public var retryStatus: Bool?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.retryStatus != nil {
            map["RetryStatus"] = self.retryStatus!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RetryStatus") && dict["RetryStatus"] != nil {
            self.retryStatus = dict["RetryStatus"] as! Bool
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class RetryChangeOrderTaskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RetryChangeOrderTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryChangeOrderTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RetryChangeOrderTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var batch: Int32?

    public var batchWaitTime: Int32?

    public var groupId: String?

    public var historyVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.batch != nil {
            map["Batch"] = self.batch!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.historyVersion != nil {
            map["HistoryVersion"] = self.historyVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Batch") && dict["Batch"] != nil {
            self.batch = dict["Batch"] as! Int32
        }
        if dict.keys.contains("BatchWaitTime") && dict["BatchWaitTime"] != nil {
            self.batchWaitTime = dict["BatchWaitTime"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HistoryVersion") && dict["HistoryVersion"] != nil {
            self.historyVersion = dict["HistoryVersion"] as! String
        }
    }
}

public class RollbackApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RollbackApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RollbackApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
    }
}

public class RollbackChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: RollbackChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = RollbackChangeOrderResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TraceId") && dict["TraceId"] != nil {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class RollbackChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RollbackChangeOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ScaleInApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public var forceStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        if self.forceStatus != nil {
            map["ForceStatus"] = self.forceStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EccInfo") && dict["EccInfo"] != nil {
            self.eccInfo = dict["EccInfo"] as! String
        }
        if dict.keys.contains("ForceStatus") && dict["ForceStatus"] != nil {
            self.forceStatus = dict["ForceStatus"] as! Bool
        }
    }
}

public class ScaleInApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
    }
}

public class ScaleInApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleInApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ScaleInApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ScaleK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var replicas: Int32?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Replicas") && dict["Replicas"] != nil {
            self.replicas = dict["Replicas"] as! Int32
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class ScaleK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ScaleK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ScaleK8sApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ScaleOutApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var deployGroup: String?

    public var ecuInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deployGroup != nil {
            map["DeployGroup"] = self.deployGroup!
        }
        if self.ecuInfo != nil {
            map["EcuInfo"] = self.ecuInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeployGroup") && dict["DeployGroup"] != nil {
            self.deployGroup = dict["DeployGroup"] as! String
        }
        if dict.keys.contains("EcuInfo") && dict["EcuInfo"] != nil {
            self.ecuInfo = dict["EcuInfo"] as! String
        }
    }
}

public class ScaleOutApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ScaleOutApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleOutApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ScaleOutApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ScaleoutApplicationWithNewInstancesRequest : Tea.TeaModel {
    public var appId: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clusterId: String?

    public var groupId: String?

    public var instanceChargePeriod: Int32?

    public var instanceChargePeriodUnit: String?

    public var instanceChargeType: String?

    public var scalingNum: Int32?

    public var scalingPolicy: String?

    public var templateId: String?

    public var templateInstanceId: String?

    public var templateVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceChargePeriod != nil {
            map["InstanceChargePeriod"] = self.instanceChargePeriod!
        }
        if self.instanceChargePeriodUnit != nil {
            map["InstanceChargePeriodUnit"] = self.instanceChargePeriodUnit!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.scalingNum != nil {
            map["ScalingNum"] = self.scalingNum!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateInstanceId != nil {
            map["TemplateInstanceId"] = self.templateInstanceId!
        }
        if self.templateVersion != nil {
            map["TemplateVersion"] = self.templateVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") && dict["AutoRenewPeriod"] != nil {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("InstanceChargePeriod") && dict["InstanceChargePeriod"] != nil {
            self.instanceChargePeriod = dict["InstanceChargePeriod"] as! Int32
        }
        if dict.keys.contains("InstanceChargePeriodUnit") && dict["InstanceChargePeriodUnit"] != nil {
            self.instanceChargePeriodUnit = dict["InstanceChargePeriodUnit"] as! String
        }
        if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("ScalingNum") && dict["ScalingNum"] != nil {
            self.scalingNum = dict["ScalingNum"] as! Int32
        }
        if dict.keys.contains("ScalingPolicy") && dict["ScalingPolicy"] != nil {
            self.scalingPolicy = dict["ScalingPolicy"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateInstanceId") && dict["TemplateInstanceId"] != nil {
            self.templateInstanceId = dict["TemplateInstanceId"] as! String
        }
        if dict.keys.contains("TemplateVersion") && dict["TemplateVersion"] != nil {
            self.templateVersion = dict["TemplateVersion"] as! String
        }
    }
}

public class ScaleoutApplicationWithNewInstancesResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var instanceIds: [String]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ScaleoutApplicationWithNewInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleoutApplicationWithNewInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ScaleoutApplicationWithNewInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EccInfo") && dict["EccInfo"] != nil {
            self.eccInfo = dict["EccInfo"] as! String
        }
    }
}

public class StartApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartK8sAppPrecheckRequest : Tea.TeaModel {
    public var annotations: String?

    public var appId: String?

    public var appName: String?

    public var clusterId: String?

    public var componentIds: String?

    public var configMountDescs: String?

    public var emptyDirs: String?

    public var envFroms: String?

    public var envs: String?

    public var imageUrl: String?

    public var javaStartUpConfig: String?

    public var labels: String?

    public var limitEphemeralStorage: Int32?

    public var limitMem: Int32?

    public var limitmCpu: Int32?

    public var localVolume: String?

    public var namespace: String?

    public var packageUrl: String?

    public var pvcMountDescs: String?

    public var regionId: String?

    public var replicas: Int32?

    public var requestsEphemeralStorage: Int32?

    public var requestsMem: Int32?

    public var requestsmCpu: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentIds != nil {
            map["ComponentIds"] = self.componentIds!
        }
        if self.configMountDescs != nil {
            map["ConfigMountDescs"] = self.configMountDescs!
        }
        if self.emptyDirs != nil {
            map["EmptyDirs"] = self.emptyDirs!
        }
        if self.envFroms != nil {
            map["EnvFroms"] = self.envFroms!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.limitEphemeralStorage != nil {
            map["LimitEphemeralStorage"] = self.limitEphemeralStorage!
        }
        if self.limitMem != nil {
            map["LimitMem"] = self.limitMem!
        }
        if self.limitmCpu != nil {
            map["LimitmCpu"] = self.limitmCpu!
        }
        if self.localVolume != nil {
            map["LocalVolume"] = self.localVolume!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.pvcMountDescs != nil {
            map["PvcMountDescs"] = self.pvcMountDescs!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.requestsEphemeralStorage != nil {
            map["RequestsEphemeralStorage"] = self.requestsEphemeralStorage!
        }
        if self.requestsMem != nil {
            map["RequestsMem"] = self.requestsMem!
        }
        if self.requestsmCpu != nil {
            map["RequestsmCpu"] = self.requestsmCpu!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentIds") && dict["ComponentIds"] != nil {
            self.componentIds = dict["ComponentIds"] as! String
        }
        if dict.keys.contains("ConfigMountDescs") && dict["ConfigMountDescs"] != nil {
            self.configMountDescs = dict["ConfigMountDescs"] as! String
        }
        if dict.keys.contains("EmptyDirs") && dict["EmptyDirs"] != nil {
            self.emptyDirs = dict["EmptyDirs"] as! String
        }
        if dict.keys.contains("EnvFroms") && dict["EnvFroms"] != nil {
            self.envFroms = dict["EnvFroms"] as! String
        }
        if dict.keys.contains("Envs") && dict["Envs"] != nil {
            self.envs = dict["Envs"] as! String
        }
        if dict.keys.contains("ImageUrl") && dict["ImageUrl"] != nil {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("JavaStartUpConfig") && dict["JavaStartUpConfig"] != nil {
            self.javaStartUpConfig = dict["JavaStartUpConfig"] as! String
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("LimitEphemeralStorage") && dict["LimitEphemeralStorage"] != nil {
            self.limitEphemeralStorage = dict["LimitEphemeralStorage"] as! Int32
        }
        if dict.keys.contains("LimitMem") && dict["LimitMem"] != nil {
            self.limitMem = dict["LimitMem"] as! Int32
        }
        if dict.keys.contains("LimitmCpu") && dict["LimitmCpu"] != nil {
            self.limitmCpu = dict["LimitmCpu"] as! Int32
        }
        if dict.keys.contains("LocalVolume") && dict["LocalVolume"] != nil {
            self.localVolume = dict["LocalVolume"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PackageUrl") && dict["PackageUrl"] != nil {
            self.packageUrl = dict["PackageUrl"] as! String
        }
        if dict.keys.contains("PvcMountDescs") && dict["PvcMountDescs"] != nil {
            self.pvcMountDescs = dict["PvcMountDescs"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Replicas") && dict["Replicas"] != nil {
            self.replicas = dict["Replicas"] as! Int32
        }
        if dict.keys.contains("RequestsEphemeralStorage") && dict["RequestsEphemeralStorage"] != nil {
            self.requestsEphemeralStorage = dict["RequestsEphemeralStorage"] as! Int32
        }
        if dict.keys.contains("RequestsMem") && dict["RequestsMem"] != nil {
            self.requestsMem = dict["RequestsMem"] as! Int32
        }
        if dict.keys.contains("RequestsmCpu") && dict["RequestsmCpu"] != nil {
            self.requestsmCpu = dict["RequestsmCpu"] as! Int32
        }
    }
}

public class StartK8sAppPrecheckResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobs: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobs != nil {
                map["Jobs"] = self.jobs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Jobs") && dict["Jobs"] != nil {
                self.jobs = dict["Jobs"] as! [String]
            }
        }
    }
    public var code: Int32?

    public var data: StartK8sAppPrecheckResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = StartK8sAppPrecheckResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartK8sAppPrecheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartK8sAppPrecheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartK8sAppPrecheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var replicas: Int32?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Replicas") && dict["Replicas"] != nil {
            self.replicas = dict["Replicas"] as! Int32
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class StartK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartK8sApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EccInfo") && dict["EccInfo"] != nil {
            self.eccInfo = dict["EccInfo"] as! String
        }
    }
}

public class StopApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class StopK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopK8sApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchAdvancedMonitoringRequest : Tea.TeaModel {
    public var appId: String?

    public var enableAdvancedMonitoring: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.enableAdvancedMonitoring != nil {
            map["EnableAdvancedMonitoring"] = self.enableAdvancedMonitoring!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EnableAdvancedMonitoring") && dict["EnableAdvancedMonitoring"] != nil {
            self.enableAdvancedMonitoring = dict["EnableAdvancedMonitoring"] as! Bool
        }
    }
}

public class SwitchAdvancedMonitoringResponseBody : Tea.TeaModel {
    public var advancedMonitoringEnabled: Bool?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedMonitoringEnabled != nil {
            map["AdvancedMonitoringEnabled"] = self.advancedMonitoringEnabled!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdvancedMonitoringEnabled") && dict["AdvancedMonitoringEnabled"] != nil {
            self.advancedMonitoringEnabled = dict["AdvancedMonitoringEnabled"] as! Bool
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SwitchAdvancedMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchAdvancedMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SwitchAdvancedMonitoringResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SynchronizeResourceRequest : Tea.TeaModel {
    public var resourceIds: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceIds") && dict["ResourceIds"] != nil {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class SynchronizeResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SynchronizeResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SynchronizeResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SynchronizeResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public var resourceIds: String?

    public var resourceRegionId: String?

    public var resourceType: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceRegionId != nil {
            map["ResourceRegionId"] = self.resourceRegionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceIds") && dict["ResourceIds"] != nil {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("ResourceRegionId") && dict["ResourceRegionId"] != nil {
            self.resourceRegionId = dict["ResourceRegionId"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TransformClusterMemberRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var password: String?

    public var targetClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.targetClusterId != nil {
            map["TargetClusterId"] = self.targetClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("TargetClusterId") && dict["TargetClusterId"] != nil {
            self.targetClusterId = dict["TargetClusterId"] as! String
        }
    }
}

public class TransformClusterMemberResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TransformClusterMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransformClusterMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TransformClusterMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindK8sSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var slbName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.slbName != nil {
            map["SlbName"] = self.slbName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("SlbName") && dict["SlbName"] != nil {
            self.slbName = dict["SlbName"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UnbindK8sSlbResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindK8sSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindK8sSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnbindK8sSlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var deleteListener: String?

    public var slbId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deleteListener != nil {
            map["DeleteListener"] = self.deleteListener!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeleteListener") && dict["DeleteListener"] != nil {
            self.deleteListener = dict["DeleteListener"] as! String
        }
        if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
            self.slbId = dict["SlbId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UnbindSlbResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnbindSlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var deleteAll: Bool?

    public var resourceIds: String?

    public var resourceRegionId: String?

    public var resourceType: String?

    public var tagKeys: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteAll != nil {
            map["DeleteAll"] = self.deleteAll!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceRegionId != nil {
            map["ResourceRegionId"] = self.resourceRegionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteAll") && dict["DeleteAll"] != nil {
            self.deleteAll = dict["DeleteAll"] as! Bool
        }
        if dict.keys.contains("ResourceIds") && dict["ResourceIds"] != nil {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("ResourceRegionId") && dict["ResourceRegionId"] != nil {
            self.resourceRegionId = dict["ResourceRegionId"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKeys") && dict["TagKeys"] != nil {
            self.tagKeys = dict["TagKeys"] as! String
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAccountInfoRequest : Tea.TeaModel {
    public var email: String?

    public var name: String?

    public var telephone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.telephone != nil {
            map["Telephone"] = self.telephone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Email") && dict["Email"] != nil {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Telephone") && dict["Telephone"] != nil {
            self.telephone = dict["Telephone"] as! String
        }
    }
}

public class UpdateAccountInfoResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAccountInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAccountInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAccountInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApplicationBaseInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var desc: String?

    public var owner: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Owner") && dict["Owner"] != nil {
            self.owner = dict["Owner"] as! String
        }
    }
}

public class UpdateApplicationBaseInfoResponseBody : Tea.TeaModel {
    public class Applcation : Tea.TeaModel {
        public var appId: String?

        public var applicationType: String?

        public var buildPackageId: Int64?

        public var clusterId: String?

        public var clusterType: Int32?

        public var cpu: Int32?

        public var createTime: Int64?

        public var description_: String?

        public var dockerize: Bool?

        public var extSlbId: String?

        public var extSlbIp: String?

        public var extSlbName: String?

        public var healthCheckUrl: String?

        public var instanceCount: Int32?

        public var memory: Int32?

        public var name: String?

        public var owner: String?

        public var port: Int32?

        public var regionId: String?

        public var runningInstanceCount: Int32?

        public var slbId: String?

        public var slbIp: String?

        public var slbName: String?

        public var slbPort: Int32?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.applicationType != nil {
                map["ApplicationType"] = self.applicationType!
            }
            if self.buildPackageId != nil {
                map["BuildPackageId"] = self.buildPackageId!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dockerize != nil {
                map["Dockerize"] = self.dockerize!
            }
            if self.extSlbId != nil {
                map["ExtSlbId"] = self.extSlbId!
            }
            if self.extSlbIp != nil {
                map["ExtSlbIp"] = self.extSlbIp!
            }
            if self.extSlbName != nil {
                map["ExtSlbName"] = self.extSlbName!
            }
            if self.healthCheckUrl != nil {
                map["HealthCheckUrl"] = self.healthCheckUrl!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.runningInstanceCount != nil {
                map["RunningInstanceCount"] = self.runningInstanceCount!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbIp != nil {
                map["SlbIp"] = self.slbIp!
            }
            if self.slbName != nil {
                map["SlbName"] = self.slbName!
            }
            if self.slbPort != nil {
                map["SlbPort"] = self.slbPort!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("ApplicationType") && dict["ApplicationType"] != nil {
                self.applicationType = dict["ApplicationType"] as! String
            }
            if dict.keys.contains("BuildPackageId") && dict["BuildPackageId"] != nil {
                self.buildPackageId = dict["BuildPackageId"] as! Int64
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! Int32
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Dockerize") && dict["Dockerize"] != nil {
                self.dockerize = dict["Dockerize"] as! Bool
            }
            if dict.keys.contains("ExtSlbId") && dict["ExtSlbId"] != nil {
                self.extSlbId = dict["ExtSlbId"] as! String
            }
            if dict.keys.contains("ExtSlbIp") && dict["ExtSlbIp"] != nil {
                self.extSlbIp = dict["ExtSlbIp"] as! String
            }
            if dict.keys.contains("ExtSlbName") && dict["ExtSlbName"] != nil {
                self.extSlbName = dict["ExtSlbName"] as! String
            }
            if dict.keys.contains("HealthCheckUrl") && dict["HealthCheckUrl"] != nil {
                self.healthCheckUrl = dict["HealthCheckUrl"] as! String
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") && dict["Owner"] != nil {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RunningInstanceCount") && dict["RunningInstanceCount"] != nil {
                self.runningInstanceCount = dict["RunningInstanceCount"] as! Int32
            }
            if dict.keys.contains("SlbId") && dict["SlbId"] != nil {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbIp") && dict["SlbIp"] != nil {
                self.slbIp = dict["SlbIp"] as! String
            }
            if dict.keys.contains("SlbName") && dict["SlbName"] != nil {
                self.slbName = dict["SlbName"] as! String
            }
            if dict.keys.contains("SlbPort") && dict["SlbPort"] != nil {
                self.slbPort = dict["SlbPort"] as! Int32
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var applcation: UpdateApplicationBaseInfoResponseBody.Applcation?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applcation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applcation != nil {
            map["Applcation"] = self.applcation?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Applcation") && dict["Applcation"] != nil {
            var model = UpdateApplicationBaseInfoResponseBody.Applcation()
            model.fromMap(dict["Applcation"] as! [String: Any])
            self.applcation = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateApplicationBaseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationBaseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateApplicationBaseInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingBehaviour: String?

    public var scalingRuleEnable: Bool?

    public var scalingRuleMetric: String?

    public var scalingRuleName: String?

    public var scalingRuleTimer: String?

    public var scalingRuleTrigger: String?

    public var scalingRuleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingBehaviour != nil {
            map["ScalingBehaviour"] = self.scalingBehaviour!
        }
        if self.scalingRuleEnable != nil {
            map["ScalingRuleEnable"] = self.scalingRuleEnable!
        }
        if self.scalingRuleMetric != nil {
            map["ScalingRuleMetric"] = self.scalingRuleMetric!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleTimer != nil {
            map["ScalingRuleTimer"] = self.scalingRuleTimer!
        }
        if self.scalingRuleTrigger != nil {
            map["ScalingRuleTrigger"] = self.scalingRuleTrigger!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ScalingBehaviour") && dict["ScalingBehaviour"] != nil {
            self.scalingBehaviour = dict["ScalingBehaviour"] as! String
        }
        if dict.keys.contains("ScalingRuleEnable") && dict["ScalingRuleEnable"] != nil {
            self.scalingRuleEnable = dict["ScalingRuleEnable"] as! Bool
        }
        if dict.keys.contains("ScalingRuleMetric") && dict["ScalingRuleMetric"] != nil {
            self.scalingRuleMetric = dict["ScalingRuleMetric"] as! String
        }
        if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("ScalingRuleTimer") && dict["ScalingRuleTimer"] != nil {
            self.scalingRuleTimer = dict["ScalingRuleTimer"] as! String
        }
        if dict.keys.contains("ScalingRuleTrigger") && dict["ScalingRuleTrigger"] != nil {
            self.scalingRuleTrigger = dict["ScalingRuleTrigger"] as! String
        }
        if dict.keys.contains("ScalingRuleType") && dict["ScalingRuleType"] != nil {
            self.scalingRuleType = dict["ScalingRuleType"] as! String
        }
    }
}

public class UpdateApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class AppScalingRule : Tea.TeaModel {
        public class Behaviour : Tea.TeaModel {
            public class ScaleDown : Tea.TeaModel {
                public class Policies : Tea.TeaModel {
                    public var periodSeconds: Int32?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.periodSeconds != nil {
                            map["PeriodSeconds"] = self.periodSeconds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                            self.periodSeconds = dict["PeriodSeconds"] as! Int32
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var policies: [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies]?

                public var selectPolicy: String?

                public var stabilizationWindowSeconds: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.policies != nil {
                        var tmp : [Any] = []
                        for k in self.policies! {
                            tmp.append(k.toMap())
                        }
                        map["Policies"] = tmp
                    }
                    if self.selectPolicy != nil {
                        map["SelectPolicy"] = self.selectPolicy!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Policies") && dict["Policies"] != nil {
                        var tmp : [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies] = []
                        for v in dict["Policies"] as! [Any] {
                            var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.policies = tmp
                    }
                    if dict.keys.contains("SelectPolicy") && dict["SelectPolicy"] != nil {
                        self.selectPolicy = dict["SelectPolicy"] as! String
                    }
                    if dict.keys.contains("StabilizationWindowSeconds") && dict["StabilizationWindowSeconds"] != nil {
                        self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int32
                    }
                }
            }
            public class ScaleUp : Tea.TeaModel {
                public class Policies : Tea.TeaModel {
                    public var periodSeconds: Int32?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.periodSeconds != nil {
                            map["PeriodSeconds"] = self.periodSeconds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("PeriodSeconds") && dict["PeriodSeconds"] != nil {
                            self.periodSeconds = dict["PeriodSeconds"] as! Int32
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var policies: [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies]?

                public var selectPolicy: String?

                public var stabilizationWindowSeconds: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.policies != nil {
                        var tmp : [Any] = []
                        for k in self.policies! {
                            tmp.append(k.toMap())
                        }
                        map["Policies"] = tmp
                    }
                    if self.selectPolicy != nil {
                        map["SelectPolicy"] = self.selectPolicy!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Policies") && dict["Policies"] != nil {
                        var tmp : [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies] = []
                        for v in dict["Policies"] as! [Any] {
                            var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.policies = tmp
                    }
                    if dict.keys.contains("SelectPolicy") && dict["SelectPolicy"] != nil {
                        self.selectPolicy = dict["SelectPolicy"] as! String
                    }
                    if dict.keys.contains("StabilizationWindowSeconds") && dict["StabilizationWindowSeconds"] != nil {
                        self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int32
                    }
                }
            }
            public var scaleDown: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown?

            public var scaleUp: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scaleDown?.validate()
                try self.scaleUp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scaleDown != nil {
                    map["ScaleDown"] = self.scaleDown?.toMap()
                }
                if self.scaleUp != nil {
                    map["ScaleUp"] = self.scaleUp?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ScaleDown") && dict["ScaleDown"] != nil {
                    var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown()
                    model.fromMap(dict["ScaleDown"] as! [String: Any])
                    self.scaleDown = model
                }
                if dict.keys.contains("ScaleUp") && dict["ScaleUp"] != nil {
                    var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp()
                    model.fromMap(dict["ScaleUp"] as! [String: Any])
                    self.scaleUp = model
                }
            }
        }
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetricTargetAverageUtilization") && dict["MetricTargetAverageUtilization"] != nil {
                        self.metricTargetAverageUtilization = dict["MetricTargetAverageUtilization"] as! Int32
                    }
                    if dict.keys.contains("MetricType") && dict["MetricType"] != nil {
                        self.metricType = dict["MetricType"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("Metrics") && dict["Metrics"] != nil {
                    var tmp : [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics] = []
                    for v in dict["Metrics"] as! [Any] {
                        var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.metrics = tmp
                }
                if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public class Triggers : Tea.TeaModel {
                public var metaData: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metaData != nil {
                        map["MetaData"] = self.metaData!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetaData") && dict["MetaData"] != nil {
                        self.metaData = dict["MetaData"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var minReplicas: Int32?

            public var triggers: [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.triggers != nil {
                    var tmp : [Any] = []
                    for k in self.triggers! {
                        tmp.append(k.toMap())
                    }
                    map["Triggers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
                if dict.keys.contains("Triggers") && dict["Triggers"] != nil {
                    var tmp : [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers] = []
                    for v in dict["Triggers"] as! [Any] {
                        var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.triggers = tmp
                }
            }
        }
        public var appId: String?

        public var behaviour: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var maxReplicas: Int32?

        public var metric: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric?

        public var minReplicas: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var trigger: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.behaviour?.validate()
            try self.metric?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.behaviour != nil {
                map["Behaviour"] = self.behaviour?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReplicas != nil {
                map["MinReplicas"] = self.minReplicas!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Behaviour") && dict["Behaviour"] != nil {
                var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour()
                model.fromMap(dict["Behaviour"] as! [String: Any])
                self.behaviour = model
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("LastDisableTime") && dict["LastDisableTime"] != nil {
                self.lastDisableTime = dict["LastDisableTime"] as! Int64
            }
            if dict.keys.contains("MaxReplicas") && dict["MaxReplicas"] != nil {
                self.maxReplicas = dict["MaxReplicas"] as! Int32
            }
            if dict.keys.contains("Metric") && dict["Metric"] != nil {
                var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric()
                model.fromMap(dict["Metric"] as! [String: Any])
                self.metric = model
            }
            if dict.keys.contains("MinReplicas") && dict["MinReplicas"] != nil {
                self.minReplicas = dict["MinReplicas"] as! Int32
            }
            if dict.keys.contains("ScaleRuleEnabled") && dict["ScaleRuleEnabled"] != nil {
                self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
            }
            if dict.keys.contains("ScaleRuleName") && dict["ScaleRuleName"] != nil {
                self.scaleRuleName = dict["ScaleRuleName"] as! String
            }
            if dict.keys.contains("ScaleRuleType") && dict["ScaleRuleType"] != nil {
                self.scaleRuleType = dict["ScaleRuleType"] as! String
            }
            if dict.keys.contains("Trigger") && dict["Trigger"] != nil {
                var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger()
                model.fromMap(dict["Trigger"] as! [String: Any])
                self.trigger = model
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var appScalingRule: UpdateApplicationScalingRuleResponseBody.AppScalingRule?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRule != nil {
            map["AppScalingRule"] = self.appScalingRule?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppScalingRule") && dict["AppScalingRule"] != nil {
            var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule()
            model.fromMap(dict["AppScalingRule"] as! [String: Any])
            self.appScalingRule = model
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateConfigTemplateRequest : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var format: String?

    public var id: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Format") && dict["Format"] != nil {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateConfigTemplateResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateConfigTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateConfigTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateContainerRequest : Tea.TeaModel {
    public var appId: String?

    public var buildPackId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BuildPackId") && dict["BuildPackId"] != nil {
            self.buildPackId = dict["BuildPackId"] as! Int32
        }
    }
}

public class UpdateContainerResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateContainerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateContainerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateContainerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateContainerConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var contextPath: String?

    public var groupId: String?

    public var httpPort: Int32?

    public var maxThreads: Int32?

    public var URIEncoding: String?

    public var useBodyEncoding: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.contextPath != nil {
            map["ContextPath"] = self.contextPath!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.httpPort != nil {
            map["HttpPort"] = self.httpPort!
        }
        if self.maxThreads != nil {
            map["MaxThreads"] = self.maxThreads!
        }
        if self.URIEncoding != nil {
            map["URIEncoding"] = self.URIEncoding!
        }
        if self.useBodyEncoding != nil {
            map["UseBodyEncoding"] = self.useBodyEncoding!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ContextPath") && dict["ContextPath"] != nil {
            self.contextPath = dict["ContextPath"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HttpPort") && dict["HttpPort"] != nil {
            self.httpPort = dict["HttpPort"] as! Int32
        }
        if dict.keys.contains("MaxThreads") && dict["MaxThreads"] != nil {
            self.maxThreads = dict["MaxThreads"] as! Int32
        }
        if dict.keys.contains("URIEncoding") && dict["URIEncoding"] != nil {
            self.URIEncoding = dict["URIEncoding"] as! String
        }
        if dict.keys.contains("UseBodyEncoding") && dict["UseBodyEncoding"] != nil {
            self.useBodyEncoding = dict["UseBodyEncoding"] as! Bool
        }
    }
}

public class UpdateContainerConfigurationResponseBody : Tea.TeaModel {
    public class ContainerConfiguration : Tea.TeaModel {
        public var contextPath: String?

        public var httpPort: Int32?

        public var maxThreads: Int32?

        public var URIEncoding: String?

        public var useBodyEncoding: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contextPath != nil {
                map["ContextPath"] = self.contextPath!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.maxThreads != nil {
                map["MaxThreads"] = self.maxThreads!
            }
            if self.URIEncoding != nil {
                map["URIEncoding"] = self.URIEncoding!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContextPath") && dict["ContextPath"] != nil {
                self.contextPath = dict["ContextPath"] as! String
            }
            if dict.keys.contains("HttpPort") && dict["HttpPort"] != nil {
                self.httpPort = dict["HttpPort"] as! Int32
            }
            if dict.keys.contains("MaxThreads") && dict["MaxThreads"] != nil {
                self.maxThreads = dict["MaxThreads"] as! Int32
            }
            if dict.keys.contains("URIEncoding") && dict["URIEncoding"] != nil {
                self.URIEncoding = dict["URIEncoding"] as! String
            }
            if dict.keys.contains("UseBodyEncoding") && dict["UseBodyEncoding"] != nil {
                self.useBodyEncoding = dict["UseBodyEncoding"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var containerConfiguration: UpdateContainerConfigurationResponseBody.ContainerConfiguration?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.containerConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.containerConfiguration != nil {
            map["ContainerConfiguration"] = self.containerConfiguration?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ContainerConfiguration") && dict["ContainerConfiguration"] != nil {
            var model = UpdateContainerConfigurationResponseBody.ContainerConfiguration()
            model.fromMap(dict["ContainerConfiguration"] as! [String: Any])
            self.containerConfiguration = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateContainerConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateContainerConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateContainerConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateHealthCheckUrlRequest : Tea.TeaModel {
    public var appId: String?

    public var hcURL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.hcURL != nil {
            map["hcURL"] = self.hcURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("hcURL") && dict["hcURL"] != nil {
            self.hcURL = dict["hcURL"] as! String
        }
    }
}

public class UpdateHealthCheckUrlResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var healthCheckURL: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.healthCheckURL != nil {
            map["HealthCheckURL"] = self.healthCheckURL!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HealthCheckURL") && dict["HealthCheckURL"] != nil {
            self.healthCheckURL = dict["HealthCheckURL"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateHealthCheckUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHealthCheckUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateHealthCheckUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateHookConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var hooks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.hooks != nil {
            map["Hooks"] = self.hooks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Hooks") && dict["Hooks"] != nil {
            self.hooks = dict["Hooks"] as! String
        }
    }
}

public class UpdateHookConfigurationResponseBody : Tea.TeaModel {
    public class HooksConfiguration : Tea.TeaModel {
        public var ignoreFail: Bool?

        public var name: String?

        public var script: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoreFail != nil {
                map["IgnoreFail"] = self.ignoreFail!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.script != nil {
                map["Script"] = self.script!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IgnoreFail") && dict["IgnoreFail"] != nil {
                self.ignoreFail = dict["IgnoreFail"] as! Bool
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Script") && dict["Script"] != nil {
                self.script = dict["Script"] as! String
            }
        }
    }
    public var code: Int32?

    public var hooksConfiguration: [UpdateHookConfigurationResponseBody.HooksConfiguration]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.hooksConfiguration != nil {
            var tmp : [Any] = []
            for k in self.hooksConfiguration! {
                tmp.append(k.toMap())
            }
            map["HooksConfiguration"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HooksConfiguration") && dict["HooksConfiguration"] != nil {
            var tmp : [UpdateHookConfigurationResponseBody.HooksConfiguration] = []
            for v in dict["HooksConfiguration"] as! [Any] {
                var model = UpdateHookConfigurationResponseBody.HooksConfiguration()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hooksConfiguration = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateHookConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHookConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateHookConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateJvmConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var maxHeapSize: Int32?

    public var maxPermSize: Int32?

    public var minHeapSize: Int32?

    public var options: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.maxHeapSize != nil {
            map["MaxHeapSize"] = self.maxHeapSize!
        }
        if self.maxPermSize != nil {
            map["MaxPermSize"] = self.maxPermSize!
        }
        if self.minHeapSize != nil {
            map["MinHeapSize"] = self.minHeapSize!
        }
        if self.options != nil {
            map["Options"] = self.options!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("MaxHeapSize") && dict["MaxHeapSize"] != nil {
            self.maxHeapSize = dict["MaxHeapSize"] as! Int32
        }
        if dict.keys.contains("MaxPermSize") && dict["MaxPermSize"] != nil {
            self.maxPermSize = dict["MaxPermSize"] as! Int32
        }
        if dict.keys.contains("MinHeapSize") && dict["MinHeapSize"] != nil {
            self.minHeapSize = dict["MinHeapSize"] as! Int32
        }
        if dict.keys.contains("Options") && dict["Options"] != nil {
            self.options = dict["Options"] as! String
        }
    }
}

public class UpdateJvmConfigurationResponseBody : Tea.TeaModel {
    public class JvmConfiguration : Tea.TeaModel {
        public var maxHeapSize: Int32?

        public var maxPermSize: Int32?

        public var minHeapSize: Int32?

        public var options: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxHeapSize != nil {
                map["MaxHeapSize"] = self.maxHeapSize!
            }
            if self.maxPermSize != nil {
                map["MaxPermSize"] = self.maxPermSize!
            }
            if self.minHeapSize != nil {
                map["MinHeapSize"] = self.minHeapSize!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaxHeapSize") && dict["MaxHeapSize"] != nil {
                self.maxHeapSize = dict["MaxHeapSize"] as! Int32
            }
            if dict.keys.contains("MaxPermSize") && dict["MaxPermSize"] != nil {
                self.maxPermSize = dict["MaxPermSize"] as! Int32
            }
            if dict.keys.contains("MinHeapSize") && dict["MinHeapSize"] != nil {
                self.minHeapSize = dict["MinHeapSize"] as! Int32
            }
            if dict.keys.contains("Options") && dict["Options"] != nil {
                self.options = dict["Options"] as! String
            }
        }
    }
    public var code: Int32?

    public var jvmConfiguration: UpdateJvmConfigurationResponseBody.JvmConfiguration?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jvmConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.jvmConfiguration != nil {
            map["JvmConfiguration"] = self.jvmConfiguration?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("JvmConfiguration") && dict["JvmConfiguration"] != nil {
            var model = UpdateJvmConfigurationResponseBody.JvmConfiguration()
            model.fromMap(dict["JvmConfiguration"] as! [String: Any])
            self.jvmConfiguration = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateJvmConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateJvmConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateJvmConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateK8sApplicationBaseInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var description_: String?

    public var email: String?

    public var owner: String?

    public var phoneNumber: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Email") && dict["Email"] != nil {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("Owner") && dict["Owner"] != nil {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
            self.phoneNumber = dict["PhoneNumber"] as! String
        }
    }
}

public class UpdateK8sApplicationBaseInfoResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateK8sApplicationBaseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sApplicationBaseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateK8sApplicationBaseInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateK8sApplicationConfigRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var cpuLimit: String?

    public var cpuRequest: String?

    public var ephemeralStorageLimit: String?

    public var ephemeralStorageRequest: String?

    public var mcpuLimit: String?

    public var mcpuRequest: String?

    public var memoryLimit: String?

    public var memoryRequest: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cpuLimit != nil {
            map["CpuLimit"] = self.cpuLimit!
        }
        if self.cpuRequest != nil {
            map["CpuRequest"] = self.cpuRequest!
        }
        if self.ephemeralStorageLimit != nil {
            map["EphemeralStorageLimit"] = self.ephemeralStorageLimit!
        }
        if self.ephemeralStorageRequest != nil {
            map["EphemeralStorageRequest"] = self.ephemeralStorageRequest!
        }
        if self.mcpuLimit != nil {
            map["McpuLimit"] = self.mcpuLimit!
        }
        if self.mcpuRequest != nil {
            map["McpuRequest"] = self.mcpuRequest!
        }
        if self.memoryLimit != nil {
            map["MemoryLimit"] = self.memoryLimit!
        }
        if self.memoryRequest != nil {
            map["MemoryRequest"] = self.memoryRequest!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CpuLimit") && dict["CpuLimit"] != nil {
            self.cpuLimit = dict["CpuLimit"] as! String
        }
        if dict.keys.contains("CpuRequest") && dict["CpuRequest"] != nil {
            self.cpuRequest = dict["CpuRequest"] as! String
        }
        if dict.keys.contains("EphemeralStorageLimit") && dict["EphemeralStorageLimit"] != nil {
            self.ephemeralStorageLimit = dict["EphemeralStorageLimit"] as! String
        }
        if dict.keys.contains("EphemeralStorageRequest") && dict["EphemeralStorageRequest"] != nil {
            self.ephemeralStorageRequest = dict["EphemeralStorageRequest"] as! String
        }
        if dict.keys.contains("McpuLimit") && dict["McpuLimit"] != nil {
            self.mcpuLimit = dict["McpuLimit"] as! String
        }
        if dict.keys.contains("McpuRequest") && dict["McpuRequest"] != nil {
            self.mcpuRequest = dict["McpuRequest"] as! String
        }
        if dict.keys.contains("MemoryLimit") && dict["MemoryLimit"] != nil {
            self.memoryLimit = dict["MemoryLimit"] as! String
        }
        if dict.keys.contains("MemoryRequest") && dict["MemoryRequest"] != nil {
            self.memoryRequest = dict["MemoryRequest"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpdateK8sApplicationConfigResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateK8sApplicationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sApplicationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateK8sApplicationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateK8sConfigMapRequest : Tea.TeaModel {
    public var clusterId: String?

    public var data: [String: Any]?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String: Any]
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class UpdateK8sConfigMapResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateK8sConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateK8sConfigMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateK8sIngressRuleRequest : Tea.TeaModel {
    public var annotations: String?

    public var clusterId: String?

    public var ingressConf: [String: Any]?

    public var labels: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ingressConf != nil {
            map["IngressConf"] = self.ingressConf!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Annotations") && dict["Annotations"] != nil {
            self.annotations = dict["Annotations"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("IngressConf") && dict["IngressConf"] != nil {
            self.ingressConf = dict["IngressConf"] as! [String: Any]
        }
        if dict.keys.contains("Labels") && dict["Labels"] != nil {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class UpdateK8sIngressRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
    }
}

public class UpdateK8sIngressRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sIngressRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateK8sIngressRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateK8sResourceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var namespace: String?

    public var resourceContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.resourceContent != nil {
            map["ResourceContent"] = self.resourceContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("ResourceContent") && dict["ResourceContent"] != nil {
            self.resourceContent = dict["ResourceContent"] as! String
        }
    }
}

public class UpdateK8sResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateK8sResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateK8sResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateK8sSecretRequest : Tea.TeaModel {
    public var base64Encoded: Bool?

    public var certId: String?

    public var certRegionId: String?

    public var clusterId: String?

    public var data: String?

    public var name: String?

    public var namespace: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.base64Encoded != nil {
            map["Base64Encoded"] = self.base64Encoded!
        }
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certRegionId != nil {
            map["CertRegionId"] = self.certRegionId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Base64Encoded") && dict["Base64Encoded"] != nil {
            self.base64Encoded = dict["Base64Encoded"] as! Bool
        }
        if dict.keys.contains("CertId") && dict["CertId"] != nil {
            self.certId = dict["CertId"] as! String
        }
        if dict.keys.contains("CertRegionId") && dict["CertRegionId"] != nil {
            self.certRegionId = dict["CertRegionId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateK8sSecretResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateK8sSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateK8sSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateK8sServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var externalTrafficPolicy: String?

    public var name: String?

    public var servicePorts: [String: Any]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.externalTrafficPolicy != nil {
            map["ExternalTrafficPolicy"] = self.externalTrafficPolicy!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.servicePorts != nil {
            map["ServicePorts"] = self.servicePorts!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ExternalTrafficPolicy") && dict["ExternalTrafficPolicy"] != nil {
            self.externalTrafficPolicy = dict["ExternalTrafficPolicy"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServicePorts") && dict["ServicePorts"] != nil {
            self.servicePorts = dict["ServicePorts"] as! [String: Any]
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateK8sServiceResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateK8sServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateK8sServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateK8sSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var disableForceOverride: Bool?

    public var port: String?

    public var scheduler: String?

    public var servicePortInfos: String?

    public var slbName: String?

    public var slbProtocol: String?

    public var specification: String?

    public var targetPort: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.disableForceOverride != nil {
            map["DisableForceOverride"] = self.disableForceOverride!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.servicePortInfos != nil {
            map["ServicePortInfos"] = self.servicePortInfos!
        }
        if self.slbName != nil {
            map["SlbName"] = self.slbName!
        }
        if self.slbProtocol != nil {
            map["SlbProtocol"] = self.slbProtocol!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.targetPort != nil {
            map["TargetPort"] = self.targetPort!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DisableForceOverride") && dict["DisableForceOverride"] != nil {
            self.disableForceOverride = dict["DisableForceOverride"] as! Bool
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServicePortInfos") && dict["ServicePortInfos"] != nil {
            self.servicePortInfos = dict["ServicePortInfos"] as! String
        }
        if dict.keys.contains("SlbName") && dict["SlbName"] != nil {
            self.slbName = dict["SlbName"] as! String
        }
        if dict.keys.contains("SlbProtocol") && dict["SlbProtocol"] != nil {
            self.slbProtocol = dict["SlbProtocol"] as! String
        }
        if dict.keys.contains("Specification") && dict["Specification"] != nil {
            self.specification = dict["Specification"] as! String
        }
        if dict.keys.contains("TargetPort") && dict["TargetPort"] != nil {
            self.targetPort = dict["TargetPort"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateK8sSlbResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") && dict["ChangeOrderId"] != nil {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateK8sSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateK8sSlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRoleRequest : Tea.TeaModel {
    public var actionData: String?

    public var roleId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionData != nil {
            map["ActionData"] = self.actionData!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionData") && dict["ActionData"] != nil {
            self.actionData = dict["ActionData"] as! String
        }
        if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
            self.roleId = dict["RoleId"] as! Int32
        }
    }
}

public class UpdateRoleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSlsLogStoreRequest : Tea.TeaModel {
    public var appId: String?

    public var configs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.configs != nil {
            map["Configs"] = self.configs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Configs") && dict["Configs"] != nil {
            self.configs = dict["Configs"] as! String
        }
    }
}

public class UpdateSlsLogStoreResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateSlsLogStoreResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSlsLogStoreResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSlsLogStoreResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSwimmingLaneRequest : Tea.TeaModel {
    public var appInfos: String?

    public var enableRules: Bool?

    public var entryRules: String?

    public var laneId: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfos != nil {
            map["AppInfos"] = self.appInfos!
        }
        if self.enableRules != nil {
            map["EnableRules"] = self.enableRules!
        }
        if self.entryRules != nil {
            map["EntryRules"] = self.entryRules!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppInfos") && dict["AppInfos"] != nil {
            self.appInfos = dict["AppInfos"] as! String
        }
        if dict.keys.contains("EnableRules") && dict["EnableRules"] != nil {
            self.enableRules = dict["EnableRules"] as! Bool
        }
        if dict.keys.contains("EntryRules") && dict["EntryRules"] != nil {
            self.entryRules = dict["EntryRules"] as! String
        }
        if dict.keys.contains("LaneId") && dict["LaneId"] != nil {
            self.laneId = dict["LaneId"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SwimmingLaneAppRelationShipList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var laneId: Int64?

            public var rules: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.laneId != nil {
                    map["LaneId"] = self.laneId!
                }
                if self.rules != nil {
                    map["Rules"] = self.rules!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("LaneId") && dict["LaneId"] != nil {
                    self.laneId = dict["LaneId"] as! Int64
                }
                if dict.keys.contains("Rules") && dict["Rules"] != nil {
                    self.rules = dict["Rules"] as! String
                }
            }
        }
        public var entryRule: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public var swimmingLaneAppRelationShipList: [UpdateSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList]?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entryRule != nil {
                map["EntryRule"] = self.entryRule!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.swimmingLaneAppRelationShipList != nil {
                var tmp : [Any] = []
                for k in self.swimmingLaneAppRelationShipList! {
                    tmp.append(k.toMap())
                }
                map["SwimmingLaneAppRelationShipList"] = tmp
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EntryRule") && dict["EntryRule"] != nil {
                self.entryRule = dict["EntryRule"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("SwimmingLaneAppRelationShipList") && dict["SwimmingLaneAppRelationShipList"] != nil {
                var tmp : [UpdateSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList] = []
                for v in dict["SwimmingLaneAppRelationShipList"] as! [Any] {
                    var model = UpdateSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.swimmingLaneAppRelationShipList = tmp
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: UpdateSwimmingLaneResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateSwimmingLaneResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSwimmingLaneGroupRequest : Tea.TeaModel {
    public var appIds: String?

    public var entryApp: String?

    public var groupId: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.entryApp != nil {
            map["EntryApp"] = self.entryApp!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("EntryApp") && dict["EntryApp"] != nil {
            self.entryApp = dict["EntryApp"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApplicationList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
            }
        }
        public class EntryApplication : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
            }
        }
        public var applicationList: [UpdateSwimmingLaneGroupResponseBody.Data.ApplicationList]?

        public var entryApplication: UpdateSwimmingLaneGroupResponseBody.Data.EntryApplication?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.entryApplication?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationList != nil {
                var tmp : [Any] = []
                for k in self.applicationList! {
                    tmp.append(k.toMap())
                }
                map["ApplicationList"] = tmp
            }
            if self.entryApplication != nil {
                map["EntryApplication"] = self.entryApplication?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationList") && dict["ApplicationList"] != nil {
                var tmp : [UpdateSwimmingLaneGroupResponseBody.Data.ApplicationList] = []
                for v in dict["ApplicationList"] as! [Any] {
                    var model = UpdateSwimmingLaneGroupResponseBody.Data.ApplicationList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applicationList = tmp
            }
            if dict.keys.contains("EntryApplication") && dict["EntryApplication"] != nil {
                var model = UpdateSwimmingLaneGroupResponseBody.Data.EntryApplication()
                model.fromMap(dict["EntryApplication"] as! [String: Any])
                self.entryApplication = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                self.namespaceId = dict["NamespaceId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: UpdateSwimmingLaneGroupResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateSwimmingLaneGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
