import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AppConfig : Tea.TeaModel {
    public class ConfigMountDescs : Tea.TeaModel {
        public class MountItems : Tea.TeaModel {
            public var key: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Path"] as? String {
                    self.path = value
                }
            }
        }
        public var mountItems: [AppConfig.ConfigMountDescs.MountItems]?

        public var mountPath: String?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountItems != nil {
                var tmp : [Any] = []
                for k in self.mountItems! {
                    tmp.append(k.toMap())
                }
                map["MountItems"] = tmp
            }
            if self.mountPath != nil {
                map["MountPath"] = self.mountPath!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MountItems"] as? [Any?] {
                var tmp : [AppConfig.ConfigMountDescs.MountItems] = []
                for v in value {
                    if v != nil {
                        var model = AppConfig.ConfigMountDescs.MountItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.mountItems = tmp
            }
            if let value = dict["MountPath"] as? String {
                self.mountPath = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class EmptyDirs : Tea.TeaModel {
        public var mountPath: String?

        public var name: String?

        public var readOnly: Bool?

        public var subPathExpr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountPath != nil {
                map["MountPath"] = self.mountPath!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.readOnly != nil {
                map["ReadOnly"] = self.readOnly!
            }
            if self.subPathExpr != nil {
                map["SubPathExpr"] = self.subPathExpr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MountPath"] as? String {
                self.mountPath = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ReadOnly"] as? Bool {
                self.readOnly = value
            }
            if let value = dict["SubPathExpr"] as? String {
                self.subPathExpr = value
            }
        }
    }
    public class EnvFroms : Tea.TeaModel {
        public var configMapRef: String?

        public var secretRef: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapRef != nil {
                map["ConfigMapRef"] = self.configMapRef!
            }
            if self.secretRef != nil {
                map["SecretRef"] = self.secretRef!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigMapRef"] as? String {
                self.configMapRef = value
            }
            if let value = dict["SecretRef"] as? String {
                self.secretRef = value
            }
        }
    }
    public class Envs : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public var valueFrom: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            if self.valueFrom != nil {
                map["ValueFrom"] = self.valueFrom!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
            if let value = dict["ValueFrom"] as? String {
                self.valueFrom = value
            }
        }
    }
    public class ImageConfig : Tea.TeaModel {
        public var containerRegistryId: String?

        public var crInstanceId: String?

        public var crRegionId: String?

        public var imageUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.containerRegistryId != nil {
                map["ContainerRegistryId"] = self.containerRegistryId!
            }
            if self.crInstanceId != nil {
                map["CrInstanceId"] = self.crInstanceId!
            }
            if self.crRegionId != nil {
                map["CrRegionId"] = self.crRegionId!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ContainerRegistryId"] as? String {
                self.containerRegistryId = value
            }
            if let value = dict["CrInstanceId"] as? String {
                self.crInstanceId = value
            }
            if let value = dict["CrRegionId"] as? String {
                self.crRegionId = value
            }
            if let value = dict["ImageUrl"] as? String {
                self.imageUrl = value
            }
        }
    }
    public class LocalVolumes : Tea.TeaModel {
        public var mountPath: String?

        public var name: String?

        public var nodePath: String?

        public var opsAuth: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountPath != nil {
                map["MountPath"] = self.mountPath!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodePath != nil {
                map["NodePath"] = self.nodePath!
            }
            if self.opsAuth != nil {
                map["OpsAuth"] = self.opsAuth!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MountPath"] as? String {
                self.mountPath = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NodePath"] as? String {
                self.nodePath = value
            }
            if let value = dict["OpsAuth"] as? Int64 {
                self.opsAuth = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class NasMountDescs : Tea.TeaModel {
        public var mountPath: String?

        public var nasPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountPath != nil {
                map["MountPath"] = self.mountPath!
            }
            if self.nasPath != nil {
                map["NasPath"] = self.nasPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MountPath"] as? String {
                self.mountPath = value
            }
            if let value = dict["NasPath"] as? String {
                self.nasPath = value
            }
        }
    }
    public class PackageConfig : Tea.TeaModel {
        public var edasContainerVersion: String?

        public var jdk: String?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public var timezone: String?

        public var uriEncoding: String?

        public var useBodyEncoding: Bool?

        public var webContainer: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            if self.jdk != nil {
                map["Jdk"] = self.jdk!
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.timezone != nil {
                map["Timezone"] = self.timezone!
            }
            if self.uriEncoding != nil {
                map["UriEncoding"] = self.uriEncoding!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            if self.webContainer != nil {
                map["WebContainer"] = self.webContainer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EdasContainerVersion"] as? String {
                self.edasContainerVersion = value
            }
            if let value = dict["Jdk"] as? String {
                self.jdk = value
            }
            if let value = dict["PackageType"] as? String {
                self.packageType = value
            }
            if let value = dict["PackageUrl"] as? String {
                self.packageUrl = value
            }
            if let value = dict["PackageVersion"] as? String {
                self.packageVersion = value
            }
            if let value = dict["Timezone"] as? String {
                self.timezone = value
            }
            if let value = dict["UriEncoding"] as? String {
                self.uriEncoding = value
            }
            if let value = dict["UseBodyEncoding"] as? Bool {
                self.useBodyEncoding = value
            }
            if let value = dict["WebContainer"] as? String {
                self.webContainer = value
            }
        }
    }
    public class PvcMountDescs : Tea.TeaModel {
        public class MountPaths : Tea.TeaModel {
            public var mountPath: String?

            public var readOnly: Bool?

            public var subPathExpr: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.subPathExpr != nil {
                    map["SubPathExpr"] = self.subPathExpr!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["ReadOnly"] as? Bool {
                    self.readOnly = value
                }
                if let value = dict["SubPathExpr"] as? String {
                    self.subPathExpr = value
                }
            }
        }
        public var mountPaths: [AppConfig.PvcMountDescs.MountPaths]?

        public var pvcName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mountPaths != nil {
                var tmp : [Any] = []
                for k in self.mountPaths! {
                    tmp.append(k.toMap())
                }
                map["MountPaths"] = tmp
            }
            if self.pvcName != nil {
                map["PvcName"] = self.pvcName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MountPaths"] as? [Any?] {
                var tmp : [AppConfig.PvcMountDescs.MountPaths] = []
                for v in value {
                    if v != nil {
                        var model = AppConfig.PvcMountDescs.MountPaths()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.mountPaths = tmp
            }
            if let value = dict["PvcName"] as? String {
                self.pvcName = value
            }
        }
    }
    public class SlsConfigs : Tea.TeaModel {
        public var logDir: String?

        public var logstore: String?

        public var project: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logDir != nil {
                map["LogDir"] = self.logDir!
            }
            if self.logstore != nil {
                map["Logstore"] = self.logstore!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LogDir"] as? String {
                self.logDir = value
            }
            if let value = dict["Logstore"] as? String {
                self.logstore = value
            }
            if let value = dict["Project"] as? String {
                self.project = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class WebContainerConfig : Tea.TeaModel {
        public var connectorType: String?

        public var contextInputType: String?

        public var contextPath: String?

        public var httpPort: Int64?

        public var maxThreads: Int64?

        public var serverXml: String?

        public var uriEncoding: String?

        public var useAdvancedServerXml: Bool?

        public var useBodyEncoding: Bool?

        public var useDefaultConfig: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectorType != nil {
                map["ConnectorType"] = self.connectorType!
            }
            if self.contextInputType != nil {
                map["ContextInputType"] = self.contextInputType!
            }
            if self.contextPath != nil {
                map["ContextPath"] = self.contextPath!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.maxThreads != nil {
                map["MaxThreads"] = self.maxThreads!
            }
            if self.serverXml != nil {
                map["ServerXml"] = self.serverXml!
            }
            if self.uriEncoding != nil {
                map["UriEncoding"] = self.uriEncoding!
            }
            if self.useAdvancedServerXml != nil {
                map["UseAdvancedServerXml"] = self.useAdvancedServerXml!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            if self.useDefaultConfig != nil {
                map["UseDefaultConfig"] = self.useDefaultConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnectorType"] as? String {
                self.connectorType = value
            }
            if let value = dict["ContextInputType"] as? String {
                self.contextInputType = value
            }
            if let value = dict["ContextPath"] as? String {
                self.contextPath = value
            }
            if let value = dict["HttpPort"] as? Int64 {
                self.httpPort = value
            }
            if let value = dict["MaxThreads"] as? Int64 {
                self.maxThreads = value
            }
            if let value = dict["ServerXml"] as? String {
                self.serverXml = value
            }
            if let value = dict["UriEncoding"] as? String {
                self.uriEncoding = value
            }
            if let value = dict["UseAdvancedServerXml"] as? Bool {
                self.useAdvancedServerXml = value
            }
            if let value = dict["UseBodyEncoding"] as? Bool {
                self.useBodyEncoding = value
            }
            if let value = dict["UseDefaultConfig"] as? Bool {
                self.useDefaultConfig = value
            }
        }
    }
    public var command: String?

    public var commandArgs: [String]?

    public var configMountDescs: [AppConfig.ConfigMountDescs]?

    public var deployAcrossNodes: Bool?

    public var deployAcrossZones: Bool?

    public var emptyDirs: [AppConfig.EmptyDirs]?

    public var enableAhas: Bool?

    public var envFroms: [AppConfig.EnvFroms]?

    public var envs: [AppConfig.Envs]?

    public var imageConfig: AppConfig.ImageConfig?

    public var isMultilingualApp: Bool?

    public var javaStartUpConfig: String?

    public var limitCpu: String?

    public var limitMem: String?

    public var liveness: String?

    public var localVolumes: [AppConfig.LocalVolumes]?

    public var nasId: String?

    public var nasMountDescs: [AppConfig.NasMountDescs]?

    public var nasStorageType: String?

    public var packageConfig: AppConfig.PackageConfig?

    public var postStart: String?

    public var preStop: String?

    public var pvcMountDescs: [AppConfig.PvcMountDescs]?

    public var readiness: String?

    public var replicas: Int64?

    public var requestCpu: String?

    public var requestMem: String?

    public var runtimeClassName: String?

    public var slsConfigs: [AppConfig.SlsConfigs]?

    public var webContainerConfig: AppConfig.WebContainerConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageConfig?.validate()
        try self.packageConfig?.validate()
        try self.webContainerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMountDescs != nil {
            var tmp : [Any] = []
            for k in self.configMountDescs! {
                tmp.append(k.toMap())
            }
            map["ConfigMountDescs"] = tmp
        }
        if self.deployAcrossNodes != nil {
            map["DeployAcrossNodes"] = self.deployAcrossNodes!
        }
        if self.deployAcrossZones != nil {
            map["DeployAcrossZones"] = self.deployAcrossZones!
        }
        if self.emptyDirs != nil {
            var tmp : [Any] = []
            for k in self.emptyDirs! {
                tmp.append(k.toMap())
            }
            map["EmptyDirs"] = tmp
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        if self.envFroms != nil {
            var tmp : [Any] = []
            for k in self.envFroms! {
                tmp.append(k.toMap())
            }
            map["EnvFroms"] = tmp
        }
        if self.envs != nil {
            var tmp : [Any] = []
            for k in self.envs! {
                tmp.append(k.toMap())
            }
            map["Envs"] = tmp
        }
        if self.imageConfig != nil {
            map["ImageConfig"] = self.imageConfig?.toMap()
        }
        if self.isMultilingualApp != nil {
            map["IsMultilingualApp"] = self.isMultilingualApp!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig!
        }
        if self.limitCpu != nil {
            map["LimitCpu"] = self.limitCpu!
        }
        if self.limitMem != nil {
            map["LimitMem"] = self.limitMem!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.localVolumes != nil {
            var tmp : [Any] = []
            for k in self.localVolumes! {
                tmp.append(k.toMap())
            }
            map["LocalVolumes"] = tmp
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.nasMountDescs != nil {
            var tmp : [Any] = []
            for k in self.nasMountDescs! {
                tmp.append(k.toMap())
            }
            map["NasMountDescs"] = tmp
        }
        if self.nasStorageType != nil {
            map["NasStorageType"] = self.nasStorageType!
        }
        if self.packageConfig != nil {
            map["PackageConfig"] = self.packageConfig?.toMap()
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.pvcMountDescs != nil {
            var tmp : [Any] = []
            for k in self.pvcMountDescs! {
                tmp.append(k.toMap())
            }
            map["PvcMountDescs"] = tmp
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.requestCpu != nil {
            map["RequestCpu"] = self.requestCpu!
        }
        if self.requestMem != nil {
            map["RequestMem"] = self.requestMem!
        }
        if self.runtimeClassName != nil {
            map["RuntimeClassName"] = self.runtimeClassName!
        }
        if self.slsConfigs != nil {
            var tmp : [Any] = []
            for k in self.slsConfigs! {
                tmp.append(k.toMap())
            }
            map["SlsConfigs"] = tmp
        }
        if self.webContainerConfig != nil {
            map["WebContainerConfig"] = self.webContainerConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? [String] {
            self.commandArgs = value
        }
        if let value = dict["ConfigMountDescs"] as? [Any?] {
            var tmp : [AppConfig.ConfigMountDescs] = []
            for v in value {
                if v != nil {
                    var model = AppConfig.ConfigMountDescs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configMountDescs = tmp
        }
        if let value = dict["DeployAcrossNodes"] as? Bool {
            self.deployAcrossNodes = value
        }
        if let value = dict["DeployAcrossZones"] as? Bool {
            self.deployAcrossZones = value
        }
        if let value = dict["EmptyDirs"] as? [Any?] {
            var tmp : [AppConfig.EmptyDirs] = []
            for v in value {
                if v != nil {
                    var model = AppConfig.EmptyDirs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.emptyDirs = tmp
        }
        if let value = dict["EnableAhas"] as? Bool {
            self.enableAhas = value
        }
        if let value = dict["EnvFroms"] as? [Any?] {
            var tmp : [AppConfig.EnvFroms] = []
            for v in value {
                if v != nil {
                    var model = AppConfig.EnvFroms()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.envFroms = tmp
        }
        if let value = dict["Envs"] as? [Any?] {
            var tmp : [AppConfig.Envs] = []
            for v in value {
                if v != nil {
                    var model = AppConfig.Envs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.envs = tmp
        }
        if let value = dict["ImageConfig"] as? [String: Any?] {
            var model = AppConfig.ImageConfig()
            model.fromMap(value)
            self.imageConfig = model
        }
        if let value = dict["IsMultilingualApp"] as? Bool {
            self.isMultilingualApp = value
        }
        if let value = dict["JavaStartUpConfig"] as? String {
            self.javaStartUpConfig = value
        }
        if let value = dict["LimitCpu"] as? String {
            self.limitCpu = value
        }
        if let value = dict["LimitMem"] as? String {
            self.limitMem = value
        }
        if let value = dict["Liveness"] as? String {
            self.liveness = value
        }
        if let value = dict["LocalVolumes"] as? [Any?] {
            var tmp : [AppConfig.LocalVolumes] = []
            for v in value {
                if v != nil {
                    var model = AppConfig.LocalVolumes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.localVolumes = tmp
        }
        if let value = dict["NasId"] as? String {
            self.nasId = value
        }
        if let value = dict["NasMountDescs"] as? [Any?] {
            var tmp : [AppConfig.NasMountDescs] = []
            for v in value {
                if v != nil {
                    var model = AppConfig.NasMountDescs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nasMountDescs = tmp
        }
        if let value = dict["NasStorageType"] as? String {
            self.nasStorageType = value
        }
        if let value = dict["PackageConfig"] as? [String: Any?] {
            var model = AppConfig.PackageConfig()
            model.fromMap(value)
            self.packageConfig = model
        }
        if let value = dict["PostStart"] as? String {
            self.postStart = value
        }
        if let value = dict["PreStop"] as? String {
            self.preStop = value
        }
        if let value = dict["PvcMountDescs"] as? [Any?] {
            var tmp : [AppConfig.PvcMountDescs] = []
            for v in value {
                if v != nil {
                    var model = AppConfig.PvcMountDescs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.pvcMountDescs = tmp
        }
        if let value = dict["Readiness"] as? String {
            self.readiness = value
        }
        if let value = dict["Replicas"] as? Int64 {
            self.replicas = value
        }
        if let value = dict["RequestCpu"] as? String {
            self.requestCpu = value
        }
        if let value = dict["RequestMem"] as? String {
            self.requestMem = value
        }
        if let value = dict["RuntimeClassName"] as? String {
            self.runtimeClassName = value
        }
        if let value = dict["SlsConfigs"] as? [Any?] {
            var tmp : [AppConfig.SlsConfigs] = []
            for v in value {
                if v != nil {
                    var model = AppConfig.SlsConfigs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.slsConfigs = tmp
        }
        if let value = dict["WebContainerConfig"] as? [String: Any?] {
            var model = AppConfig.WebContainerConfig()
            model.fromMap(value)
            self.webContainerConfig = model
        }
    }
}

public class AbortAndRollbackChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
    }
}

public class AbortAndRollbackChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: Int32?

    public var data: AbortAndRollbackChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = AbortAndRollbackChangeOrderResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class AbortAndRollbackChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortAndRollbackChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AbortAndRollbackChangeOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AbortChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
    }
}

public class AbortChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: Int32?

    public var data: AbortChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = AbortChangeOrderResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class AbortChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AbortChangeOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLogPathRequest : Tea.TeaModel {
    public var appId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Path"] as? String {
            self.path = value
        }
    }
}

public class AddLogPathResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLogPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLogPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLogPathResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AuthorizeApplicationRequest : Tea.TeaModel {
    public var appIds: String?

    public var targetUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIds"] as? String {
            self.appIds = value
        }
        if let value = dict["TargetUserId"] as? String {
            self.targetUserId = value
        }
    }
}

public class AuthorizeApplicationResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AuthorizeApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AuthorizeApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AuthorizeResourceGroupRequest : Tea.TeaModel {
    public var resourceGroupIds: String?

    public var targetUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceGroupIds != nil {
            map["ResourceGroupIds"] = self.resourceGroupIds!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ResourceGroupIds"] as? String {
            self.resourceGroupIds = value
        }
        if let value = dict["TargetUserId"] as? String {
            self.targetUserId = value
        }
    }
}

public class AuthorizeResourceGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AuthorizeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AuthorizeResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AuthorizeRoleRequest : Tea.TeaModel {
    public var roleIds: String?

    public var targetUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roleIds != nil {
            map["RoleIds"] = self.roleIds!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RoleIds"] as? String {
            self.roleIds = value
        }
        if let value = dict["TargetUserId"] as? String {
            self.targetUserId = value
        }
    }
}

public class AuthorizeRoleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AuthorizeRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AuthorizeRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BindEcsSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var deployGroupId: String?

    public var listenerHealthCheckUrl: String?

    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var slbId: String?

    public var VForwardingUrlRule: String?

    public var VServerGroupId: String?

    public var VServerGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deployGroupId != nil {
            map["DeployGroupId"] = self.deployGroupId!
        }
        if self.listenerHealthCheckUrl != nil {
            map["ListenerHealthCheckUrl"] = self.listenerHealthCheckUrl!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.VForwardingUrlRule != nil {
            map["VForwardingUrlRule"] = self.VForwardingUrlRule!
        }
        if self.VServerGroupId != nil {
            map["VServerGroupId"] = self.VServerGroupId!
        }
        if self.VServerGroupName != nil {
            map["VServerGroupName"] = self.VServerGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DeployGroupId"] as? String {
            self.deployGroupId = value
        }
        if let value = dict["ListenerHealthCheckUrl"] as? String {
            self.listenerHealthCheckUrl = value
        }
        if let value = dict["ListenerPort"] as? Int32 {
            self.listenerPort = value
        }
        if let value = dict["ListenerProtocol"] as? String {
            self.listenerProtocol = value
        }
        if let value = dict["SlbId"] as? String {
            self.slbId = value
        }
        if let value = dict["VForwardingUrlRule"] as? String {
            self.VForwardingUrlRule = value
        }
        if let value = dict["VServerGroupId"] as? String {
            self.VServerGroupId = value
        }
        if let value = dict["VServerGroupName"] as? String {
            self.VServerGroupName = value
        }
    }
}

public class BindEcsSlbResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class BindEcsSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindEcsSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BindEcsSlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BindK8sSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var port: String?

    public var scheduler: String?

    public var servicePortInfos: String?

    public var slbId: String?

    public var slbProtocol: String?

    public var specification: String?

    public var targetPort: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.servicePortInfos != nil {
            map["ServicePortInfos"] = self.servicePortInfos!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.slbProtocol != nil {
            map["SlbProtocol"] = self.slbProtocol!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.targetPort != nil {
            map["TargetPort"] = self.targetPort!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["Scheduler"] as? String {
            self.scheduler = value
        }
        if let value = dict["ServicePortInfos"] as? String {
            self.servicePortInfos = value
        }
        if let value = dict["SlbId"] as? String {
            self.slbId = value
        }
        if let value = dict["SlbProtocol"] as? String {
            self.slbProtocol = value
        }
        if let value = dict["Specification"] as? String {
            self.specification = value
        }
        if let value = dict["TargetPort"] as? String {
            self.targetPort = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class BindK8sSlbResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class BindK8sSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindK8sSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BindK8sSlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BindSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var listenerPort: Int32?

    public var slbId: String?

    public var slbIp: String?

    public var type: String?

    public var VServerGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.slbIp != nil {
            map["SlbIp"] = self.slbIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.VServerGroupId != nil {
            map["VServerGroupId"] = self.VServerGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ListenerPort"] as? Int32 {
            self.listenerPort = value
        }
        if let value = dict["SlbId"] as? String {
            self.slbId = value
        }
        if let value = dict["SlbIp"] as? String {
            self.slbIp = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["VServerGroupId"] as? String {
            self.VServerGroupId = value
        }
    }
}

public class BindSlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var extSlbId: String?

        public var extSlbIp: String?

        public var extSlbName: String?

        public var extVServerGroupId: String?

        public var slbId: String?

        public var slbIp: String?

        public var slbName: String?

        public var slbPort: Int32?

        public var VServerGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extSlbId != nil {
                map["ExtSlbId"] = self.extSlbId!
            }
            if self.extSlbIp != nil {
                map["ExtSlbIp"] = self.extSlbIp!
            }
            if self.extSlbName != nil {
                map["ExtSlbName"] = self.extSlbName!
            }
            if self.extVServerGroupId != nil {
                map["ExtVServerGroupId"] = self.extVServerGroupId!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbIp != nil {
                map["SlbIp"] = self.slbIp!
            }
            if self.slbName != nil {
                map["SlbName"] = self.slbName!
            }
            if self.slbPort != nil {
                map["SlbPort"] = self.slbPort!
            }
            if self.VServerGroupId != nil {
                map["VServerGroupId"] = self.VServerGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ExtSlbId"] as? String {
                self.extSlbId = value
            }
            if let value = dict["ExtSlbIp"] as? String {
                self.extSlbIp = value
            }
            if let value = dict["ExtSlbName"] as? String {
                self.extSlbName = value
            }
            if let value = dict["ExtVServerGroupId"] as? String {
                self.extVServerGroupId = value
            }
            if let value = dict["SlbId"] as? String {
                self.slbId = value
            }
            if let value = dict["SlbIp"] as? String {
                self.slbIp = value
            }
            if let value = dict["SlbName"] as? String {
                self.slbName = value
            }
            if let value = dict["SlbPort"] as? Int32 {
                self.slbPort = value
            }
            if let value = dict["VServerGroupId"] as? String {
                self.VServerGroupId = value
            }
        }
    }
    public var code: Int32?

    public var data: BindSlbResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = BindSlbResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class BindSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BindSlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ChangeDeployGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public var forceStatus: Bool?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        if self.forceStatus != nil {
            map["ForceStatus"] = self.forceStatus!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EccInfo"] as? String {
            self.eccInfo = value
        }
        if let value = dict["ForceStatus"] as? Bool {
            self.forceStatus = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
    }
}

public class ChangeDeployGroupResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ChangeDeployGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeDeployGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ChangeDeployGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ContinuePipelineRequest : Tea.TeaModel {
    public var confirm: Bool?

    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confirm != nil {
            map["Confirm"] = self.confirm!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Confirm"] as? Bool {
            self.confirm = value
        }
        if let value = dict["PipelineId"] as? String {
            self.pipelineId = value
        }
    }
}

public class ContinuePipelineResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ContinuePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ContinuePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ContinuePipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ConvertK8sResourceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var namespace: String?

    public var resourceName: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.resourceName != nil {
            map["ResourceName"] = self.resourceName!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["ResourceName"] as? String {
            self.resourceName = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ConvertK8sResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ConvertK8sResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConvertK8sResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ConvertK8sResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingBehaviour: String?

    public var scalingRuleEnable: Bool?

    public var scalingRuleMetric: String?

    public var scalingRuleName: String?

    public var scalingRuleTimer: String?

    public var scalingRuleTrigger: String?

    public var scalingRuleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingBehaviour != nil {
            map["ScalingBehaviour"] = self.scalingBehaviour!
        }
        if self.scalingRuleEnable != nil {
            map["ScalingRuleEnable"] = self.scalingRuleEnable!
        }
        if self.scalingRuleMetric != nil {
            map["ScalingRuleMetric"] = self.scalingRuleMetric!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleTimer != nil {
            map["ScalingRuleTimer"] = self.scalingRuleTimer!
        }
        if self.scalingRuleTrigger != nil {
            map["ScalingRuleTrigger"] = self.scalingRuleTrigger!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ScalingBehaviour"] as? String {
            self.scalingBehaviour = value
        }
        if let value = dict["ScalingRuleEnable"] as? Bool {
            self.scalingRuleEnable = value
        }
        if let value = dict["ScalingRuleMetric"] as? String {
            self.scalingRuleMetric = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
        if let value = dict["ScalingRuleTimer"] as? String {
            self.scalingRuleTimer = value
        }
        if let value = dict["ScalingRuleTrigger"] as? String {
            self.scalingRuleTrigger = value
        }
        if let value = dict["ScalingRuleType"] as? String {
            self.scalingRuleType = value
        }
    }
}

public class CreateApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class AppScalingRule : Tea.TeaModel {
        public class Behaviour : Tea.TeaModel {
            public class ScaleDown : Tea.TeaModel {
                public class Policies : Tea.TeaModel {
                    public var periodSeconds: Int32?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.periodSeconds != nil {
                            map["PeriodSeconds"] = self.periodSeconds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["PeriodSeconds"] as? Int32 {
                            self.periodSeconds = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var policies: [CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies]?

                public var selectPolicy: String?

                public var stabilizationWindowSeconds: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.policies != nil {
                        var tmp : [Any] = []
                        for k in self.policies! {
                            tmp.append(k.toMap())
                        }
                        map["Policies"] = tmp
                    }
                    if self.selectPolicy != nil {
                        map["SelectPolicy"] = self.selectPolicy!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Policies"] as? [Any?] {
                        var tmp : [CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies] = []
                        for v in value {
                            if v != nil {
                                var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.policies = tmp
                    }
                    if let value = dict["SelectPolicy"] as? String {
                        self.selectPolicy = value
                    }
                    if let value = dict["StabilizationWindowSeconds"] as? Int32 {
                        self.stabilizationWindowSeconds = value
                    }
                }
            }
            public class ScaleUp : Tea.TeaModel {
                public class Policies : Tea.TeaModel {
                    public var periodSeconds: Int32?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.periodSeconds != nil {
                            map["PeriodSeconds"] = self.periodSeconds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["PeriodSeconds"] as? Int32 {
                            self.periodSeconds = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var policies: [CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies]?

                public var selectPolicy: String?

                public var stabilizationWindowSeconds: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.policies != nil {
                        var tmp : [Any] = []
                        for k in self.policies! {
                            tmp.append(k.toMap())
                        }
                        map["Policies"] = tmp
                    }
                    if self.selectPolicy != nil {
                        map["SelectPolicy"] = self.selectPolicy!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Policies"] as? [Any?] {
                        var tmp : [CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies] = []
                        for v in value {
                            if v != nil {
                                var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.policies = tmp
                    }
                    if let value = dict["SelectPolicy"] as? String {
                        self.selectPolicy = value
                    }
                    if let value = dict["StabilizationWindowSeconds"] as? Int32 {
                        self.stabilizationWindowSeconds = value
                    }
                }
            }
            public var scaleDown: CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown?

            public var scaleUp: CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scaleDown?.validate()
                try self.scaleUp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scaleDown != nil {
                    map["ScaleDown"] = self.scaleDown?.toMap()
                }
                if self.scaleUp != nil {
                    map["ScaleUp"] = self.scaleUp?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ScaleDown"] as? [String: Any?] {
                    var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown()
                    model.fromMap(value)
                    self.scaleDown = model
                }
                if let value = dict["ScaleUp"] as? [String: Any?] {
                    var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp()
                    model.fromMap(value)
                    self.scaleUp = model
                }
            }
        }
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricTargetAverageUtilization"] as? Int32 {
                        self.metricTargetAverageUtilization = value
                    }
                    if let value = dict["MetricType"] as? String {
                        self.metricType = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["Metrics"] as? [Any?] {
                    var tmp : [CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics] = []
                    for v in value {
                        if v != nil {
                            var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.metrics = tmp
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public class Triggers : Tea.TeaModel {
                public var metaData: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metaData != nil {
                        map["MetaData"] = self.metaData!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetaData"] as? String {
                        self.metaData = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var minReplicas: Int32?

            public var triggers: [CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.triggers != nil {
                    var tmp : [Any] = []
                    for k in self.triggers! {
                        tmp.append(k.toMap())
                    }
                    map["Triggers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
                if let value = dict["Triggers"] as? [Any?] {
                    var tmp : [CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers] = []
                    for v in value {
                        if v != nil {
                            var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.triggers = tmp
                }
            }
        }
        public var appId: String?

        public var behaviour: CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var maxReplicas: Int32?

        public var metric: CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric?

        public var minReplicas: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var trigger: CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.behaviour?.validate()
            try self.metric?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.behaviour != nil {
                map["Behaviour"] = self.behaviour?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReplicas != nil {
                map["MinReplicas"] = self.minReplicas!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Behaviour"] as? [String: Any?] {
                var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour()
                model.fromMap(value)
                self.behaviour = model
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["LastDisableTime"] as? Int64 {
                self.lastDisableTime = value
            }
            if let value = dict["MaxReplicas"] as? Int32 {
                self.maxReplicas = value
            }
            if let value = dict["Metric"] as? [String: Any?] {
                var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Metric()
                model.fromMap(value)
                self.metric = model
            }
            if let value = dict["MinReplicas"] as? Int32 {
                self.minReplicas = value
            }
            if let value = dict["ScaleRuleEnabled"] as? Bool {
                self.scaleRuleEnabled = value
            }
            if let value = dict["ScaleRuleName"] as? String {
                self.scaleRuleName = value
            }
            if let value = dict["ScaleRuleType"] as? String {
                self.scaleRuleType = value
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = CreateApplicationScalingRuleResponseBody.AppScalingRule.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var appScalingRule: CreateApplicationScalingRuleResponseBody.AppScalingRule?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRule != nil {
            map["AppScalingRule"] = self.appScalingRule?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppScalingRule"] as? [String: Any?] {
            var model = CreateApplicationScalingRuleResponseBody.AppScalingRule()
            model.fromMap(value)
            self.appScalingRule = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateConfigTemplateRequest : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var format: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Format"] as? String {
            self.format = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class CreateConfigTemplateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
        }
    }
    public var code: Int32?

    public var data: CreateConfigTemplateResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateConfigTemplateResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateConfigTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConfigTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateConfigTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIDCImportCommandRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
    }
}

public class CreateIDCImportCommandResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateIDCImportCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIDCImportCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIDCImportCommandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateK8sConfigMapRequest : Tea.TeaModel {
    public var clusterId: String?

    public var data: [String: Any]?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Data"] as? [String: Any] {
            self.data = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
    }
}

public class CreateK8sConfigMapResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateK8sConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateK8sConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateK8sConfigMapResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateK8sIngressRuleRequest : Tea.TeaModel {
    public var annotations: String?

    public var clusterId: String?

    public var ingressConf: [String: Any]?

    public var labels: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ingressConf != nil {
            map["IngressConf"] = self.ingressConf!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Annotations"] as? String {
            self.annotations = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["IngressConf"] as? [String: Any] {
            self.ingressConf = value
        }
        if let value = dict["Labels"] as? String {
            self.labels = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
    }
}

public class CreateK8sIngressRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
    }
}

public class CreateK8sIngressRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateK8sIngressRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateK8sIngressRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateK8sSecretRequest : Tea.TeaModel {
    public var base64Encoded: Bool?

    public var certId: String?

    public var certRegionId: String?

    public var clusterId: String?

    public var data: String?

    public var name: String?

    public var namespace: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.base64Encoded != nil {
            map["Base64Encoded"] = self.base64Encoded!
        }
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certRegionId != nil {
            map["CertRegionId"] = self.certRegionId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Base64Encoded"] as? Bool {
            self.base64Encoded = value
        }
        if let value = dict["CertId"] as? String {
            self.certId = value
        }
        if let value = dict["CertRegionId"] as? String {
            self.certRegionId = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreateK8sSecretResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateK8sSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateK8sSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateK8sSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateK8sServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var externalTrafficPolicy: String?

    public var name: String?

    public var servicePorts: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.externalTrafficPolicy != nil {
            map["ExternalTrafficPolicy"] = self.externalTrafficPolicy!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.servicePorts != nil {
            map["ServicePorts"] = self.servicePorts!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ExternalTrafficPolicy"] as? String {
            self.externalTrafficPolicy = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ServicePorts"] as? String {
            self.servicePorts = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreateK8sServiceResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateK8sServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateK8sServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateK8sServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DeleteApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
    }
}

public class DeleteApplicationScalingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var mode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Mode"] as? Int32 {
            self.mode = value
        }
    }
}

public class DeleteClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteClusterMemberRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterMemberId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterMemberId != nil {
            map["ClusterMemberId"] = self.clusterMemberId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["ClusterMemberId"] as? String {
            self.clusterMemberId = value
        }
    }
}

public class DeleteClusterMemberResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteClusterMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClusterMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteClusterMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteConfigTemplateRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteConfigTemplateResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteConfigTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConfigTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteConfigTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDeployGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
    }
}

public class DeleteDeployGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDeployGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDeployGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDeployGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteEcuRequest : Tea.TeaModel {
    public var ecuId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ecuId != nil {
            map["EcuId"] = self.ecuId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EcuId"] as? String {
            self.ecuId = value
        }
    }
}

public class DeleteEcuResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteEcuResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
    }
}

public class DeleteK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteK8sApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteK8sConfigMapRequest : Tea.TeaModel {
    public var clusterId: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
    }
}

public class DeleteK8sConfigMapResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteK8sConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteK8sConfigMapResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteK8sIngressRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
    }
}

public class DeleteK8sIngressRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
    }
}

public class DeleteK8sIngressRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sIngressRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteK8sIngressRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteK8sSecretRequest : Tea.TeaModel {
    public var clusterId: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
    }
}

public class DeleteK8sSecretResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteK8sSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteK8sSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteK8sServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class DeleteK8sServiceResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteK8sServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteK8sServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteK8sServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLogPathRequest : Tea.TeaModel {
    public var appId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Path"] as? String {
            self.path = value
        }
    }
}

public class DeleteLogPathResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLogPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLogPathResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRoleRequest : Tea.TeaModel {
    public var roleId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RoleId"] as? Int32 {
            self.roleId = value
        }
    }
}

public class DeleteRoleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteServiceGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class DeleteServiceGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteServiceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSwimmingLaneRequest : Tea.TeaModel {
    public var laneId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaneId"] as? Int64 {
            self.laneId = value
        }
    }
}

public class DeleteSwimmingLaneResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? Int32 {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSwimmingLaneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteUserDefineRegionRequest : Tea.TeaModel {
    public var id: Int64?

    public var regionTag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionTag != nil {
            map["RegionTag"] = self.regionTag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RegionTag"] as? String {
            self.regionTag = value
        }
    }
}

public class DeleteUserDefineRegionResponseBody : Tea.TeaModel {
    public class RegionDefine : Tea.TeaModel {
        public var belongRegion: String?

        public var description_: String?

        public var id: Int64?

        public var regionId: String?

        public var regionName: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.belongRegion != nil {
                map["BelongRegion"] = self.belongRegion!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BelongRegion"] as? String {
                self.belongRegion = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RegionName"] as? String {
                self.regionName = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regionDefine: DeleteUserDefineRegionResponseBody.RegionDefine?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regionDefine?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regionDefine != nil {
            map["RegionDefine"] = self.regionDefine?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RegionDefine"] as? [String: Any?] {
            var model = DeleteUserDefineRegionResponseBody.RegionDefine()
            model.fromMap(value)
            self.regionDefine = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteUserDefineRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserDefineRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteUserDefineRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeployApplicationRequest : Tea.TeaModel {
    public var appEnv: String?

    public var appId: String?

    public var batch: Int32?

    public var batchWaitTime: Int32?

    public var buildPackId: Int64?

    public var componentIds: String?

    public var deployType: String?

    public var desc: String?

    public var gray: Bool?

    public var groupId: String?

    public var imageUrl: String?

    public var packageVersion: String?

    public var releaseType: Int64?

    public var trafficControlStrategy: String?

    public var warUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appEnv != nil {
            map["AppEnv"] = self.appEnv!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.batch != nil {
            map["Batch"] = self.batch!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        if self.componentIds != nil {
            map["ComponentIds"] = self.componentIds!
        }
        if self.deployType != nil {
            map["DeployType"] = self.deployType!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.gray != nil {
            map["Gray"] = self.gray!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.releaseType != nil {
            map["ReleaseType"] = self.releaseType!
        }
        if self.trafficControlStrategy != nil {
            map["TrafficControlStrategy"] = self.trafficControlStrategy!
        }
        if self.warUrl != nil {
            map["WarUrl"] = self.warUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppEnv"] as? String {
            self.appEnv = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Batch"] as? Int32 {
            self.batch = value
        }
        if let value = dict["BatchWaitTime"] as? Int32 {
            self.batchWaitTime = value
        }
        if let value = dict["BuildPackId"] as? Int64 {
            self.buildPackId = value
        }
        if let value = dict["ComponentIds"] as? String {
            self.componentIds = value
        }
        if let value = dict["DeployType"] as? String {
            self.deployType = value
        }
        if let value = dict["Desc"] as? String {
            self.desc = value
        }
        if let value = dict["Gray"] as? Bool {
            self.gray = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["PackageVersion"] as? String {
            self.packageVersion = value
        }
        if let value = dict["ReleaseType"] as? Int64 {
            self.releaseType = value
        }
        if let value = dict["TrafficControlStrategy"] as? String {
            self.trafficControlStrategy = value
        }
        if let value = dict["WarUrl"] as? String {
            self.warUrl = value
        }
    }
}

public class DeployApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeployApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeployApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeployK8sApplicationRequest : Tea.TeaModel {
    public var annotations: String?

    public var appId: String?

    public var args: String?

    public var batchTimeout: Int32?

    public var batchWaitTime: Int32?

    public var buildPackId: String?

    public var canaryRuleId: String?

    public var changeOrderDesc: String?

    public var command: String?

    public var configMountDescs: String?

    public var cpuLimit: Int32?

    public var cpuRequest: Int32?

    public var customAffinity: String?

    public var customAgentVersion: String?

    public var customTolerations: String?

    public var deployAcrossNodes: String?

    public var deployAcrossZones: String?

    public var edasContainerVersion: String?

    public var emptyDirs: String?

    public var enableAhas: Bool?

    public var enableEmptyPushReject: Bool?

    public var enableLosslessRule: Bool?

    public var envFroms: String?

    public var envs: String?

    public var image: String?

    public var imagePlatforms: String?

    public var imageTag: String?

    public var initContainers: String?

    public var JDK: String?

    public var javaStartUpConfig: String?

    public var labels: String?

    public var limitEphemeralStorage: Int32?

    public var liveness: String?

    public var localVolume: String?

    public var losslessRuleAligned: Bool?

    public var losslessRuleDelayTime: Int32?

    public var losslessRuleFuncType: Int32?

    public var losslessRuleRelated: Bool?

    public var losslessRuleWarmupTime: Int32?

    public var mcpuLimit: Int32?

    public var mcpuRequest: Int32?

    public var memoryLimit: Int32?

    public var memoryRequest: Int32?

    public var mountDescs: String?

    public var nasId: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var packageVersionId: String?

    public var postStart: String?

    public var preStop: String?

    public var pvcMountDescs: String?

    public var readiness: String?

    public var replicas: Int32?

    public var requestsEphemeralStorage: Int32?

    public var runtimeClassName: String?

    public var sidecars: String?

    public var slsConfigs: String?

    public var startup: String?

    public var storageType: String?

    public var terminateGracePeriod: Int32?

    public var trafficControlStrategy: String?

    public var updateStrategy: String?

    public var uriEncoding: String?

    public var useBodyEncoding: Bool?

    public var userBaseImageUrl: String?

    public var volumesStr: String?

    public var webContainer: String?

    public var webContainerConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.args != nil {
            map["Args"] = self.args!
        }
        if self.batchTimeout != nil {
            map["BatchTimeout"] = self.batchTimeout!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        if self.canaryRuleId != nil {
            map["CanaryRuleId"] = self.canaryRuleId!
        }
        if self.changeOrderDesc != nil {
            map["ChangeOrderDesc"] = self.changeOrderDesc!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.configMountDescs != nil {
            map["ConfigMountDescs"] = self.configMountDescs!
        }
        if self.cpuLimit != nil {
            map["CpuLimit"] = self.cpuLimit!
        }
        if self.cpuRequest != nil {
            map["CpuRequest"] = self.cpuRequest!
        }
        if self.customAffinity != nil {
            map["CustomAffinity"] = self.customAffinity!
        }
        if self.customAgentVersion != nil {
            map["CustomAgentVersion"] = self.customAgentVersion!
        }
        if self.customTolerations != nil {
            map["CustomTolerations"] = self.customTolerations!
        }
        if self.deployAcrossNodes != nil {
            map["DeployAcrossNodes"] = self.deployAcrossNodes!
        }
        if self.deployAcrossZones != nil {
            map["DeployAcrossZones"] = self.deployAcrossZones!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.emptyDirs != nil {
            map["EmptyDirs"] = self.emptyDirs!
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        if self.enableEmptyPushReject != nil {
            map["EnableEmptyPushReject"] = self.enableEmptyPushReject!
        }
        if self.enableLosslessRule != nil {
            map["EnableLosslessRule"] = self.enableLosslessRule!
        }
        if self.envFroms != nil {
            map["EnvFroms"] = self.envFroms!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.image != nil {
            map["Image"] = self.image!
        }
        if self.imagePlatforms != nil {
            map["ImagePlatforms"] = self.imagePlatforms!
        }
        if self.imageTag != nil {
            map["ImageTag"] = self.imageTag!
        }
        if self.initContainers != nil {
            map["InitContainers"] = self.initContainers!
        }
        if self.JDK != nil {
            map["JDK"] = self.JDK!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.limitEphemeralStorage != nil {
            map["LimitEphemeralStorage"] = self.limitEphemeralStorage!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.localVolume != nil {
            map["LocalVolume"] = self.localVolume!
        }
        if self.losslessRuleAligned != nil {
            map["LosslessRuleAligned"] = self.losslessRuleAligned!
        }
        if self.losslessRuleDelayTime != nil {
            map["LosslessRuleDelayTime"] = self.losslessRuleDelayTime!
        }
        if self.losslessRuleFuncType != nil {
            map["LosslessRuleFuncType"] = self.losslessRuleFuncType!
        }
        if self.losslessRuleRelated != nil {
            map["LosslessRuleRelated"] = self.losslessRuleRelated!
        }
        if self.losslessRuleWarmupTime != nil {
            map["LosslessRuleWarmupTime"] = self.losslessRuleWarmupTime!
        }
        if self.mcpuLimit != nil {
            map["McpuLimit"] = self.mcpuLimit!
        }
        if self.mcpuRequest != nil {
            map["McpuRequest"] = self.mcpuRequest!
        }
        if self.memoryLimit != nil {
            map["MemoryLimit"] = self.memoryLimit!
        }
        if self.memoryRequest != nil {
            map["MemoryRequest"] = self.memoryRequest!
        }
        if self.mountDescs != nil {
            map["MountDescs"] = self.mountDescs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.packageVersionId != nil {
            map["PackageVersionId"] = self.packageVersionId!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.pvcMountDescs != nil {
            map["PvcMountDescs"] = self.pvcMountDescs!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.requestsEphemeralStorage != nil {
            map["RequestsEphemeralStorage"] = self.requestsEphemeralStorage!
        }
        if self.runtimeClassName != nil {
            map["RuntimeClassName"] = self.runtimeClassName!
        }
        if self.sidecars != nil {
            map["Sidecars"] = self.sidecars!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.startup != nil {
            map["Startup"] = self.startup!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        if self.terminateGracePeriod != nil {
            map["TerminateGracePeriod"] = self.terminateGracePeriod!
        }
        if self.trafficControlStrategy != nil {
            map["TrafficControlStrategy"] = self.trafficControlStrategy!
        }
        if self.updateStrategy != nil {
            map["UpdateStrategy"] = self.updateStrategy!
        }
        if self.uriEncoding != nil {
            map["UriEncoding"] = self.uriEncoding!
        }
        if self.useBodyEncoding != nil {
            map["UseBodyEncoding"] = self.useBodyEncoding!
        }
        if self.userBaseImageUrl != nil {
            map["UserBaseImageUrl"] = self.userBaseImageUrl!
        }
        if self.volumesStr != nil {
            map["VolumesStr"] = self.volumesStr!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        if self.webContainerConfig != nil {
            map["WebContainerConfig"] = self.webContainerConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Annotations"] as? String {
            self.annotations = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Args"] as? String {
            self.args = value
        }
        if let value = dict["BatchTimeout"] as? Int32 {
            self.batchTimeout = value
        }
        if let value = dict["BatchWaitTime"] as? Int32 {
            self.batchWaitTime = value
        }
        if let value = dict["BuildPackId"] as? String {
            self.buildPackId = value
        }
        if let value = dict["CanaryRuleId"] as? String {
            self.canaryRuleId = value
        }
        if let value = dict["ChangeOrderDesc"] as? String {
            self.changeOrderDesc = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["ConfigMountDescs"] as? String {
            self.configMountDescs = value
        }
        if let value = dict["CpuLimit"] as? Int32 {
            self.cpuLimit = value
        }
        if let value = dict["CpuRequest"] as? Int32 {
            self.cpuRequest = value
        }
        if let value = dict["CustomAffinity"] as? String {
            self.customAffinity = value
        }
        if let value = dict["CustomAgentVersion"] as? String {
            self.customAgentVersion = value
        }
        if let value = dict["CustomTolerations"] as? String {
            self.customTolerations = value
        }
        if let value = dict["DeployAcrossNodes"] as? String {
            self.deployAcrossNodes = value
        }
        if let value = dict["DeployAcrossZones"] as? String {
            self.deployAcrossZones = value
        }
        if let value = dict["EdasContainerVersion"] as? String {
            self.edasContainerVersion = value
        }
        if let value = dict["EmptyDirs"] as? String {
            self.emptyDirs = value
        }
        if let value = dict["EnableAhas"] as? Bool {
            self.enableAhas = value
        }
        if let value = dict["EnableEmptyPushReject"] as? Bool {
            self.enableEmptyPushReject = value
        }
        if let value = dict["EnableLosslessRule"] as? Bool {
            self.enableLosslessRule = value
        }
        if let value = dict["EnvFroms"] as? String {
            self.envFroms = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["Image"] as? String {
            self.image = value
        }
        if let value = dict["ImagePlatforms"] as? String {
            self.imagePlatforms = value
        }
        if let value = dict["ImageTag"] as? String {
            self.imageTag = value
        }
        if let value = dict["InitContainers"] as? String {
            self.initContainers = value
        }
        if let value = dict["JDK"] as? String {
            self.JDK = value
        }
        if let value = dict["JavaStartUpConfig"] as? String {
            self.javaStartUpConfig = value
        }
        if let value = dict["Labels"] as? String {
            self.labels = value
        }
        if let value = dict["LimitEphemeralStorage"] as? Int32 {
            self.limitEphemeralStorage = value
        }
        if let value = dict["Liveness"] as? String {
            self.liveness = value
        }
        if let value = dict["LocalVolume"] as? String {
            self.localVolume = value
        }
        if let value = dict["LosslessRuleAligned"] as? Bool {
            self.losslessRuleAligned = value
        }
        if let value = dict["LosslessRuleDelayTime"] as? Int32 {
            self.losslessRuleDelayTime = value
        }
        if let value = dict["LosslessRuleFuncType"] as? Int32 {
            self.losslessRuleFuncType = value
        }
        if let value = dict["LosslessRuleRelated"] as? Bool {
            self.losslessRuleRelated = value
        }
        if let value = dict["LosslessRuleWarmupTime"] as? Int32 {
            self.losslessRuleWarmupTime = value
        }
        if let value = dict["McpuLimit"] as? Int32 {
            self.mcpuLimit = value
        }
        if let value = dict["McpuRequest"] as? Int32 {
            self.mcpuRequest = value
        }
        if let value = dict["MemoryLimit"] as? Int32 {
            self.memoryLimit = value
        }
        if let value = dict["MemoryRequest"] as? Int32 {
            self.memoryRequest = value
        }
        if let value = dict["MountDescs"] as? String {
            self.mountDescs = value
        }
        if let value = dict["NasId"] as? String {
            self.nasId = value
        }
        if let value = dict["PackageUrl"] as? String {
            self.packageUrl = value
        }
        if let value = dict["PackageVersion"] as? String {
            self.packageVersion = value
        }
        if let value = dict["PackageVersionId"] as? String {
            self.packageVersionId = value
        }
        if let value = dict["PostStart"] as? String {
            self.postStart = value
        }
        if let value = dict["PreStop"] as? String {
            self.preStop = value
        }
        if let value = dict["PvcMountDescs"] as? String {
            self.pvcMountDescs = value
        }
        if let value = dict["Readiness"] as? String {
            self.readiness = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["RequestsEphemeralStorage"] as? Int32 {
            self.requestsEphemeralStorage = value
        }
        if let value = dict["RuntimeClassName"] as? String {
            self.runtimeClassName = value
        }
        if let value = dict["Sidecars"] as? String {
            self.sidecars = value
        }
        if let value = dict["SlsConfigs"] as? String {
            self.slsConfigs = value
        }
        if let value = dict["Startup"] as? String {
            self.startup = value
        }
        if let value = dict["StorageType"] as? String {
            self.storageType = value
        }
        if let value = dict["TerminateGracePeriod"] as? Int32 {
            self.terminateGracePeriod = value
        }
        if let value = dict["TrafficControlStrategy"] as? String {
            self.trafficControlStrategy = value
        }
        if let value = dict["UpdateStrategy"] as? String {
            self.updateStrategy = value
        }
        if let value = dict["UriEncoding"] as? String {
            self.uriEncoding = value
        }
        if let value = dict["UseBodyEncoding"] as? Bool {
            self.useBodyEncoding = value
        }
        if let value = dict["UserBaseImageUrl"] as? String {
            self.userBaseImageUrl = value
        }
        if let value = dict["VolumesStr"] as? String {
            self.volumesStr = value
        }
        if let value = dict["WebContainer"] as? String {
            self.webContainer = value
        }
        if let value = dict["WebContainerConfig"] as? String {
            self.webContainerConfig = value
        }
    }
}

public class DeployK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeployK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeployK8sApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAppInstanceListRequest : Tea.TeaModel {
    public var appId: String?

    public var withNodeInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.withNodeInfo != nil {
            map["WithNodeInfo"] = self.withNodeInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["WithNodeInfo"] as? Bool {
            self.withNodeInfo = value
        }
    }
}

public class DescribeAppInstanceListResponseBody : Tea.TeaModel {
    public class InstanceList : Tea.TeaModel {
        public var appId: String?

        public var canary: Bool?

        public var groupId: String?

        public var groupName: String?

        public var nodeLabels: String?

        public var nodeName: String?

        public var podRaw: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.canary != nil {
                map["Canary"] = self.canary!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.nodeLabels != nil {
                map["NodeLabels"] = self.nodeLabels!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.podRaw != nil {
                map["PodRaw"] = self.podRaw!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Canary"] as? Bool {
                self.canary = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["NodeLabels"] as? String {
                self.nodeLabels = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["PodRaw"] as? String {
                self.podRaw = value
            }
            if let value = dict["Version"] as? String {
                self.version = value
            }
        }
    }
    public var code: Int32?

    public var instanceList: [DescribeAppInstanceListResponseBody.InstanceList]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceList != nil {
            var tmp : [Any] = []
            for k in self.instanceList! {
                tmp.append(k.toMap())
            }
            map["InstanceList"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["InstanceList"] as? [Any?] {
            var tmp : [DescribeAppInstanceListResponseBody.InstanceList] = []
            for v in value {
                if v != nil {
                    var model = DescribeAppInstanceListResponseBody.InstanceList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceList = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAppInstanceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppInstanceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAppInstanceListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationScalingRulesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DescribeApplicationScalingRulesResponseBody : Tea.TeaModel {
    public class AppScalingRules : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class Behaviour : Tea.TeaModel {
                public class ScaleDown : Tea.TeaModel {
                    public class Policies : Tea.TeaModel {
                        public var periodSeconds: Int32?

                        public var type: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.periodSeconds != nil {
                                map["PeriodSeconds"] = self.periodSeconds!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["PeriodSeconds"] as? Int32 {
                                self.periodSeconds = value
                            }
                            if let value = dict["Type"] as? String {
                                self.type = value
                            }
                            if let value = dict["Value"] as? String {
                                self.value = value
                            }
                        }
                    }
                    public var policies: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown.Policies]?

                    public var selectPolicy: String?

                    public var stabilizationWindowSeconds: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.policies != nil {
                            var tmp : [Any] = []
                            for k in self.policies! {
                                tmp.append(k.toMap())
                            }
                            map["Policies"] = tmp
                        }
                        if self.selectPolicy != nil {
                            map["SelectPolicy"] = self.selectPolicy!
                        }
                        if self.stabilizationWindowSeconds != nil {
                            map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Policies"] as? [Any?] {
                            var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown.Policies] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown.Policies()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.policies = tmp
                        }
                        if let value = dict["SelectPolicy"] as? String {
                            self.selectPolicy = value
                        }
                        if let value = dict["StabilizationWindowSeconds"] as? Int32 {
                            self.stabilizationWindowSeconds = value
                        }
                    }
                }
                public class ScaleUp : Tea.TeaModel {
                    public class Policies : Tea.TeaModel {
                        public var periodSeconds: Int32?

                        public var type: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.periodSeconds != nil {
                                map["PeriodSeconds"] = self.periodSeconds!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["PeriodSeconds"] as? Int32 {
                                self.periodSeconds = value
                            }
                            if let value = dict["Type"] as? String {
                                self.type = value
                            }
                            if let value = dict["Value"] as? String {
                                self.value = value
                            }
                        }
                    }
                    public var policies: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp.Policies]?

                    public var selectPolicy: String?

                    public var stabilizationWindowSeconds: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.policies != nil {
                            var tmp : [Any] = []
                            for k in self.policies! {
                                tmp.append(k.toMap())
                            }
                            map["Policies"] = tmp
                        }
                        if self.selectPolicy != nil {
                            map["SelectPolicy"] = self.selectPolicy!
                        }
                        if self.stabilizationWindowSeconds != nil {
                            map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Policies"] as? [Any?] {
                            var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp.Policies] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp.Policies()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.policies = tmp
                        }
                        if let value = dict["SelectPolicy"] as? String {
                            self.selectPolicy = value
                        }
                        if let value = dict["StabilizationWindowSeconds"] as? Int32 {
                            self.stabilizationWindowSeconds = value
                        }
                    }
                }
                public var scaleDown: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown?

                public var scaleUp: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.scaleDown?.validate()
                    try self.scaleUp?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.scaleDown != nil {
                        map["ScaleDown"] = self.scaleDown?.toMap()
                    }
                    if self.scaleUp != nil {
                        map["ScaleUp"] = self.scaleUp?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ScaleDown"] as? [String: Any?] {
                        var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleDown()
                        model.fromMap(value)
                        self.scaleDown = model
                    }
                    if let value = dict["ScaleUp"] as? [String: Any?] {
                        var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour.ScaleUp()
                        model.fromMap(value)
                        self.scaleUp = model
                    }
                }
            }
            public class Metric : Tea.TeaModel {
                public class Metrics : Tea.TeaModel {
                    public var metricTargetAverageUtilization: Int32?

                    public var metricType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.metricTargetAverageUtilization != nil {
                            map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                        }
                        if self.metricType != nil {
                            map["MetricType"] = self.metricType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["MetricTargetAverageUtilization"] as? Int32 {
                            self.metricTargetAverageUtilization = value
                        }
                        if let value = dict["MetricType"] as? String {
                            self.metricType = value
                        }
                    }
                }
                public var maxReplicas: Int32?

                public var metrics: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric.Metrics]?

                public var minReplicas: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.metrics != nil {
                        var tmp : [Any] = []
                        for k in self.metrics! {
                            tmp.append(k.toMap())
                        }
                        map["Metrics"] = tmp
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MaxReplicas"] as? Int32 {
                        self.maxReplicas = value
                    }
                    if let value = dict["Metrics"] as? [Any?] {
                        var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric.Metrics] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric.Metrics()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.metrics = tmp
                    }
                    if let value = dict["MinReplicas"] as? Int32 {
                        self.minReplicas = value
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public class Triggers : Tea.TeaModel {
                    public var metaData: String?

                    public var name: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.metaData != nil {
                            map["MetaData"] = self.metaData!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["MetaData"] as? String {
                            self.metaData = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var maxReplicas: Int32?

                public var minReplicas: Int32?

                public var triggers: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger.Triggers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.triggers != nil {
                        var tmp : [Any] = []
                        for k in self.triggers! {
                            tmp.append(k.toMap())
                        }
                        map["Triggers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MaxReplicas"] as? Int32 {
                        self.maxReplicas = value
                    }
                    if let value = dict["MinReplicas"] as? Int32 {
                        self.minReplicas = value
                    }
                    if let value = dict["Triggers"] as? [Any?] {
                        var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger.Triggers] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger.Triggers()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.triggers = tmp
                    }
                }
            }
            public var appId: String?

            public var behaviour: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour?

            public var createTime: Int64?

            public var lastDisableTime: Int64?

            public var maxReplicas: Int32?

            public var metric: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric?

            public var minReplicas: Int32?

            public var scaleRuleEnabled: Bool?

            public var scaleRuleName: String?

            public var scaleRuleType: String?

            public var trigger: DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.behaviour?.validate()
                try self.metric?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.behaviour != nil {
                    map["Behaviour"] = self.behaviour?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.lastDisableTime != nil {
                    map["LastDisableTime"] = self.lastDisableTime!
                }
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metric != nil {
                    map["Metric"] = self.metric?.toMap()
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.scaleRuleEnabled != nil {
                    map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
                }
                if self.scaleRuleName != nil {
                    map["ScaleRuleName"] = self.scaleRuleName!
                }
                if self.scaleRuleType != nil {
                    map["ScaleRuleType"] = self.scaleRuleType!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["Behaviour"] as? [String: Any?] {
                    var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Behaviour()
                    model.fromMap(value)
                    self.behaviour = model
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["LastDisableTime"] as? Int64 {
                    self.lastDisableTime = value
                }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["Metric"] as? [String: Any?] {
                    var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Metric()
                    model.fromMap(value)
                    self.metric = model
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
                if let value = dict["ScaleRuleEnabled"] as? Bool {
                    self.scaleRuleEnabled = value
                }
                if let value = dict["ScaleRuleName"] as? String {
                    self.scaleRuleName = value
                }
                if let value = dict["ScaleRuleType"] as? String {
                    self.scaleRuleType = value
                }
                if let value = dict["Trigger"] as? [String: Any?] {
                    var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result.Trigger()
                    model.fromMap(value)
                    self.trigger = model
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
            }
        }
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var result: [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
            if let value = dict["TotalSize"] as? Int64 {
                self.totalSize = value
            }
        }
    }
    public var appScalingRules: DescribeApplicationScalingRulesResponseBody.AppScalingRules?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRules != nil {
            map["AppScalingRules"] = self.appScalingRules?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppScalingRules"] as? [String: Any?] {
            var model = DescribeApplicationScalingRulesResponseBody.AppScalingRules()
            model.fromMap(value)
            self.appScalingRules = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeApplicationScalingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationScalingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationScalingRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
    }
}

public class DisableApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class AppScalingRule : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricTargetAverageUtilization"] as? Int32 {
                        self.metricTargetAverageUtilization = value
                    }
                    if let value = dict["MetricType"] as? String {
                        self.metricType = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["Metrics"] as? [Any?] {
                    var tmp : [DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics] = []
                    for v in value {
                        if v != nil {
                            var model = DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.metrics = tmp
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public class Triggers : Tea.TeaModel {
                public var metaData: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metaData != nil {
                        map["MetaData"] = self.metaData!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetaData"] as? String {
                        self.metaData = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var minReplicas: Int32?

            public var triggers: [DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.triggers != nil {
                    var tmp : [Any] = []
                    for k in self.triggers! {
                        tmp.append(k.toMap())
                    }
                    map["Triggers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
                if let value = dict["Triggers"] as? [Any?] {
                    var tmp : [DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers] = []
                    for v in value {
                        if v != nil {
                            var model = DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.triggers = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var maxReplicas: Int32?

        public var metric: DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric?

        public var minReplicas: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var trigger: DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReplicas != nil {
                map["MinReplicas"] = self.minReplicas!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["LastDisableTime"] as? Int64 {
                self.lastDisableTime = value
            }
            if let value = dict["MaxReplicas"] as? Int32 {
                self.maxReplicas = value
            }
            if let value = dict["Metric"] as? [String: Any?] {
                var model = DisableApplicationScalingRuleResponseBody.AppScalingRule.Metric()
                model.fromMap(value)
                self.metric = model
            }
            if let value = dict["MinReplicas"] as? Int32 {
                self.minReplicas = value
            }
            if let value = dict["ScaleRuleEnabled"] as? Bool {
                self.scaleRuleEnabled = value
            }
            if let value = dict["ScaleRuleName"] as? String {
                self.scaleRuleName = value
            }
            if let value = dict["ScaleRuleType"] as? String {
                self.scaleRuleType = value
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = DisableApplicationScalingRuleResponseBody.AppScalingRule.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var appScalingRule: DisableApplicationScalingRuleResponseBody.AppScalingRule?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRule != nil {
            map["AppScalingRule"] = self.appScalingRule?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppScalingRule"] as? [String: Any?] {
            var model = DisableApplicationScalingRuleResponseBody.AppScalingRule()
            model.fromMap(value)
            self.appScalingRule = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
    }
}

public class EnableApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class AppScalingRule : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricTargetAverageUtilization"] as? Int32 {
                        self.metricTargetAverageUtilization = value
                    }
                    if let value = dict["MetricType"] as? String {
                        self.metricType = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["Metrics"] as? [Any?] {
                    var tmp : [EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics] = []
                    for v in value {
                        if v != nil {
                            var model = EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.metrics = tmp
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public class Triggers : Tea.TeaModel {
                public var metaData: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metaData != nil {
                        map["MetaData"] = self.metaData!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetaData"] as? String {
                        self.metaData = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var minReplicas: Int32?

            public var triggers: [EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.triggers != nil {
                    var tmp : [Any] = []
                    for k in self.triggers! {
                        tmp.append(k.toMap())
                    }
                    map["Triggers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
                if let value = dict["Triggers"] as? [Any?] {
                    var tmp : [EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers] = []
                    for v in value {
                        if v != nil {
                            var model = EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.triggers = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var maxReplicas: Int32?

        public var metric: EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric?

        public var minReplicas: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var trigger: EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReplicas != nil {
                map["MinReplicas"] = self.minReplicas!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["LastDisableTime"] as? Int64 {
                self.lastDisableTime = value
            }
            if let value = dict["MaxReplicas"] as? Int32 {
                self.maxReplicas = value
            }
            if let value = dict["Metric"] as? [String: Any?] {
                var model = EnableApplicationScalingRuleResponseBody.AppScalingRule.Metric()
                model.fromMap(value)
                self.metric = model
            }
            if let value = dict["MinReplicas"] as? Int32 {
                self.minReplicas = value
            }
            if let value = dict["ScaleRuleEnabled"] as? Bool {
                self.scaleRuleEnabled = value
            }
            if let value = dict["ScaleRuleName"] as? String {
                self.scaleRuleName = value
            }
            if let value = dict["ScaleRuleType"] as? String {
                self.scaleRuleType = value
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = EnableApplicationScalingRuleResponseBody.AppScalingRule.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var appScalingRule: EnableApplicationScalingRuleResponseBody.AppScalingRule?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRule != nil {
            map["AppScalingRule"] = self.appScalingRule?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppScalingRule"] as? [String: Any?] {
            var model = EnableApplicationScalingRuleResponseBody.AppScalingRule()
            model.fromMap(value)
            self.appScalingRule = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAppDeploymentRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class GetAppDeploymentResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAppDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAppDeploymentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class GetApplicationResponseBody : Tea.TeaModel {
    public class Application : Tea.TeaModel {
        public var appId: String?

        public var appPhase: String?

        public var applicationType: String?

        public var buildPackageId: Int64?

        public var clusterId: String?

        public var clusterType: String?

        public var cpu: Int32?

        public var createTime: Int64?

        public var description_: String?

        public var dockerize: Bool?

        public var email: String?

        public var enablePortCheck: Bool?

        public var enableUrlCheck: Bool?

        public var extSlbId: String?

        public var extSlbIp: String?

        public var extSlbName: String?

        public var haveManageAccess: String?

        public var healthCheckUrl: String?

        public var instanceCount: Int32?

        public var memory: Int32?

        public var name: String?

        public var nameSpace: String?

        public var owner: String?

        public var port: Int32?

        public var regionId: String?

        public var resourceGroupId: String?

        public var runningInstanceCount: Int32?

        public var slbId: String?

        public var slbInfo: String?

        public var slbIp: String?

        public var slbName: String?

        public var slbPort: Int32?

        public var userId: String?

        public var workloadType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appPhase != nil {
                map["AppPhase"] = self.appPhase!
            }
            if self.applicationType != nil {
                map["ApplicationType"] = self.applicationType!
            }
            if self.buildPackageId != nil {
                map["BuildPackageId"] = self.buildPackageId!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dockerize != nil {
                map["Dockerize"] = self.dockerize!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.enablePortCheck != nil {
                map["EnablePortCheck"] = self.enablePortCheck!
            }
            if self.enableUrlCheck != nil {
                map["EnableUrlCheck"] = self.enableUrlCheck!
            }
            if self.extSlbId != nil {
                map["ExtSlbId"] = self.extSlbId!
            }
            if self.extSlbIp != nil {
                map["ExtSlbIp"] = self.extSlbIp!
            }
            if self.extSlbName != nil {
                map["ExtSlbName"] = self.extSlbName!
            }
            if self.haveManageAccess != nil {
                map["HaveManageAccess"] = self.haveManageAccess!
            }
            if self.healthCheckUrl != nil {
                map["HealthCheckUrl"] = self.healthCheckUrl!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nameSpace != nil {
                map["NameSpace"] = self.nameSpace!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.runningInstanceCount != nil {
                map["RunningInstanceCount"] = self.runningInstanceCount!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbInfo != nil {
                map["SlbInfo"] = self.slbInfo!
            }
            if self.slbIp != nil {
                map["SlbIp"] = self.slbIp!
            }
            if self.slbName != nil {
                map["SlbName"] = self.slbName!
            }
            if self.slbPort != nil {
                map["SlbPort"] = self.slbPort!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workloadType != nil {
                map["WorkloadType"] = self.workloadType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppPhase"] as? String {
                self.appPhase = value
            }
            if let value = dict["ApplicationType"] as? String {
                self.applicationType = value
            }
            if let value = dict["BuildPackageId"] as? Int64 {
                self.buildPackageId = value
            }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["ClusterType"] as? String {
                self.clusterType = value
            }
            if let value = dict["Cpu"] as? Int32 {
                self.cpu = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Dockerize"] as? Bool {
                self.dockerize = value
            }
            if let value = dict["Email"] as? String {
                self.email = value
            }
            if let value = dict["EnablePortCheck"] as? Bool {
                self.enablePortCheck = value
            }
            if let value = dict["EnableUrlCheck"] as? Bool {
                self.enableUrlCheck = value
            }
            if let value = dict["ExtSlbId"] as? String {
                self.extSlbId = value
            }
            if let value = dict["ExtSlbIp"] as? String {
                self.extSlbIp = value
            }
            if let value = dict["ExtSlbName"] as? String {
                self.extSlbName = value
            }
            if let value = dict["HaveManageAccess"] as? String {
                self.haveManageAccess = value
            }
            if let value = dict["HealthCheckUrl"] as? String {
                self.healthCheckUrl = value
            }
            if let value = dict["InstanceCount"] as? Int32 {
                self.instanceCount = value
            }
            if let value = dict["Memory"] as? Int32 {
                self.memory = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NameSpace"] as? String {
                self.nameSpace = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["RunningInstanceCount"] as? Int32 {
                self.runningInstanceCount = value
            }
            if let value = dict["SlbId"] as? String {
                self.slbId = value
            }
            if let value = dict["SlbInfo"] as? String {
                self.slbInfo = value
            }
            if let value = dict["SlbIp"] as? String {
                self.slbIp = value
            }
            if let value = dict["SlbName"] as? String {
                self.slbName = value
            }
            if let value = dict["SlbPort"] as? Int32 {
                self.slbPort = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
            if let value = dict["WorkloadType"] as? String {
                self.workloadType = value
            }
        }
    }
    public var application: GetApplicationResponseBody.Application?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.application?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.application != nil {
            map["Application"] = self.application?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Application"] as? [String: Any?] {
            var model = GetApplicationResponseBody.Application()
            model.fromMap(value)
            self.application = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetChangeOrderInfoRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
    }
}

public class GetChangeOrderInfoResponseBody : Tea.TeaModel {
    public class ChangeOrderInfo : Tea.TeaModel {
        public class PipelineInfoList : Tea.TeaModel {
            public class PipelineInfo : Tea.TeaModel {
                public class StageDetailList : Tea.TeaModel {
                    public class StageDetailDTO : Tea.TeaModel {
                        public class TaskList : Tea.TeaModel {
                            public class TaskInfoDTO : Tea.TeaModel {
                                public var retryType: Int32?

                                public var showManualIgnorance: Bool?

                                public var taskErrorCode: String?

                                public var taskErrorIgnorance: Int32?

                                public var taskErrorMessage: String?

                                public var taskId: String?

                                public var taskMessage: String?

                                public var taskName: String?

                                public var taskStatus: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.retryType != nil {
                                        map["RetryType"] = self.retryType!
                                    }
                                    if self.showManualIgnorance != nil {
                                        map["ShowManualIgnorance"] = self.showManualIgnorance!
                                    }
                                    if self.taskErrorCode != nil {
                                        map["TaskErrorCode"] = self.taskErrorCode!
                                    }
                                    if self.taskErrorIgnorance != nil {
                                        map["TaskErrorIgnorance"] = self.taskErrorIgnorance!
                                    }
                                    if self.taskErrorMessage != nil {
                                        map["TaskErrorMessage"] = self.taskErrorMessage!
                                    }
                                    if self.taskId != nil {
                                        map["TaskId"] = self.taskId!
                                    }
                                    if self.taskMessage != nil {
                                        map["TaskMessage"] = self.taskMessage!
                                    }
                                    if self.taskName != nil {
                                        map["TaskName"] = self.taskName!
                                    }
                                    if self.taskStatus != nil {
                                        map["TaskStatus"] = self.taskStatus!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                    guard let dict else { return }
                                    if let value = dict["RetryType"] as? Int32 {
                                        self.retryType = value
                                    }
                                    if let value = dict["ShowManualIgnorance"] as? Bool {
                                        self.showManualIgnorance = value
                                    }
                                    if let value = dict["TaskErrorCode"] as? String {
                                        self.taskErrorCode = value
                                    }
                                    if let value = dict["TaskErrorIgnorance"] as? Int32 {
                                        self.taskErrorIgnorance = value
                                    }
                                    if let value = dict["TaskErrorMessage"] as? String {
                                        self.taskErrorMessage = value
                                    }
                                    if let value = dict["TaskId"] as? String {
                                        self.taskId = value
                                    }
                                    if let value = dict["TaskMessage"] as? String {
                                        self.taskMessage = value
                                    }
                                    if let value = dict["TaskName"] as? String {
                                        self.taskName = value
                                    }
                                    if let value = dict["TaskStatus"] as? String {
                                        self.taskStatus = value
                                    }
                                }
                            }
                            public var taskInfoDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList.TaskInfoDTO]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.taskInfoDTO != nil {
                                    var tmp : [Any] = []
                                    for k in self.taskInfoDTO! {
                                        tmp.append(k.toMap())
                                    }
                                    map["TaskInfoDTO"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["TaskInfoDTO"] as? [Any?] {
                                    var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList.TaskInfoDTO] = []
                                    for v in value {
                                        if v != nil {
                                            var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList.TaskInfoDTO()
                                            if v != nil {
                                                model.fromMap(v as? [String: Any?])
                                            }
                                            tmp.append(model)
                                        }
                                    }
                                    self.taskInfoDTO = tmp
                                }
                            }
                        }
                        public var stageId: String?

                        public var stageName: String?

                        public var stageStatus: Int32?

                        public var taskList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.taskList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.stageId != nil {
                                map["StageId"] = self.stageId!
                            }
                            if self.stageName != nil {
                                map["StageName"] = self.stageName!
                            }
                            if self.stageStatus != nil {
                                map["StageStatus"] = self.stageStatus!
                            }
                            if self.taskList != nil {
                                map["TaskList"] = self.taskList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["StageId"] as? String {
                                self.stageId = value
                            }
                            if let value = dict["StageName"] as? String {
                                self.stageName = value
                            }
                            if let value = dict["StageStatus"] as? Int32 {
                                self.stageStatus = value
                            }
                            if let value = dict["TaskList"] as? [String: Any?] {
                                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO.TaskList()
                                model.fromMap(value)
                                self.taskList = model
                            }
                        }
                    }
                    public var stageDetailDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.stageDetailDTO != nil {
                            var tmp : [Any] = []
                            for k in self.stageDetailDTO! {
                                tmp.append(k.toMap())
                            }
                            map["StageDetailDTO"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["StageDetailDTO"] as? [Any?] {
                            var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO] = []
                            for v in value {
                                if v != nil {
                                    var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList.StageDetailDTO()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.stageDetailDTO = tmp
                        }
                    }
                }
                public class StageList : Tea.TeaModel {
                    public class StageInfoDTO : Tea.TeaModel {
                        public class StageResultDTO : Tea.TeaModel {
                            public class InstanceDTOList : Tea.TeaModel {
                                public class InstanceDTO : Tea.TeaModel {
                                    public class InstanceStageDTOList : Tea.TeaModel {
                                        public class InstanceStageDTO : Tea.TeaModel {
                                            public var finishTime: String?

                                            public var stageId: String?

                                            public var stageMessage: String?

                                            public var stageName: String?

                                            public var startTime: String?

                                            public var status: Int32?

                                            public override init() {
                                                super.init()
                                            }

                                            public init(_ dict: [String: Any]) {
                                                super.init()
                                                self.fromMap(dict)
                                            }

                                            public override func validate() throws -> Void {
                                            }

                                            public override func toMap() -> [String : Any] {
                                                var map = super.toMap()
                                                if self.finishTime != nil {
                                                    map["FinishTime"] = self.finishTime!
                                                }
                                                if self.stageId != nil {
                                                    map["StageId"] = self.stageId!
                                                }
                                                if self.stageMessage != nil {
                                                    map["StageMessage"] = self.stageMessage!
                                                }
                                                if self.stageName != nil {
                                                    map["StageName"] = self.stageName!
                                                }
                                                if self.startTime != nil {
                                                    map["StartTime"] = self.startTime!
                                                }
                                                if self.status != nil {
                                                    map["Status"] = self.status!
                                                }
                                                return map
                                            }

                                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                                guard let dict else { return }
                                                if let value = dict["FinishTime"] as? String {
                                                    self.finishTime = value
                                                }
                                                if let value = dict["StageId"] as? String {
                                                    self.stageId = value
                                                }
                                                if let value = dict["StageMessage"] as? String {
                                                    self.stageMessage = value
                                                }
                                                if let value = dict["StageName"] as? String {
                                                    self.stageName = value
                                                }
                                                if let value = dict["StartTime"] as? String {
                                                    self.startTime = value
                                                }
                                                if let value = dict["Status"] as? Int32 {
                                                    self.status = value
                                                }
                                            }
                                        }
                                        public var instanceStageDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList.InstanceStageDTO]?

                                        public override init() {
                                            super.init()
                                        }

                                        public init(_ dict: [String: Any]) {
                                            super.init()
                                            self.fromMap(dict)
                                        }

                                        public override func validate() throws -> Void {
                                        }

                                        public override func toMap() -> [String : Any] {
                                            var map = super.toMap()
                                            if self.instanceStageDTO != nil {
                                                var tmp : [Any] = []
                                                for k in self.instanceStageDTO! {
                                                    tmp.append(k.toMap())
                                                }
                                                map["InstanceStageDTO"] = tmp
                                            }
                                            return map
                                        }

                                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                            guard let dict else { return }
                                            if let value = dict["InstanceStageDTO"] as? [Any?] {
                                                var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList.InstanceStageDTO] = []
                                                for v in value {
                                                    if v != nil {
                                                        var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList.InstanceStageDTO()
                                                        if v != nil {
                                                            model.fromMap(v as? [String: Any?])
                                                        }
                                                        tmp.append(model)
                                                    }
                                                }
                                                self.instanceStageDTO = tmp
                                            }
                                        }
                                    }
                                    public var instanceIp: String?

                                    public var instanceName: String?

                                    public var instanceStageDTOList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList?

                                    public var podName: String?

                                    public var podStatus: String?

                                    public var status: Int32?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                        try self.instanceStageDTOList?.validate()
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.instanceIp != nil {
                                            map["InstanceIp"] = self.instanceIp!
                                        }
                                        if self.instanceName != nil {
                                            map["InstanceName"] = self.instanceName!
                                        }
                                        if self.instanceStageDTOList != nil {
                                            map["InstanceStageDTOList"] = self.instanceStageDTOList?.toMap()
                                        }
                                        if self.podName != nil {
                                            map["PodName"] = self.podName!
                                        }
                                        if self.podStatus != nil {
                                            map["PodStatus"] = self.podStatus!
                                        }
                                        if self.status != nil {
                                            map["Status"] = self.status!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                        guard let dict else { return }
                                        if let value = dict["InstanceIp"] as? String {
                                            self.instanceIp = value
                                        }
                                        if let value = dict["InstanceName"] as? String {
                                            self.instanceName = value
                                        }
                                        if let value = dict["InstanceStageDTOList"] as? [String: Any?] {
                                            var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO.InstanceStageDTOList()
                                            model.fromMap(value)
                                            self.instanceStageDTOList = model
                                        }
                                        if let value = dict["PodName"] as? String {
                                            self.podName = value
                                        }
                                        if let value = dict["PodStatus"] as? String {
                                            self.podStatus = value
                                        }
                                        if let value = dict["Status"] as? Int32 {
                                            self.status = value
                                        }
                                    }
                                }
                                public var instanceDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.instanceDTO != nil {
                                        var tmp : [Any] = []
                                        for k in self.instanceDTO! {
                                            tmp.append(k.toMap())
                                        }
                                        map["InstanceDTO"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                    guard let dict else { return }
                                    if let value = dict["InstanceDTO"] as? [Any?] {
                                        var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO] = []
                                        for v in value {
                                            if v != nil {
                                                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList.InstanceDTO()
                                                if v != nil {
                                                    model.fromMap(v as? [String: Any?])
                                                }
                                                tmp.append(model)
                                            }
                                        }
                                        self.instanceDTO = tmp
                                    }
                                }
                            }
                            public class ServiceStage : Tea.TeaModel {
                                public var message: String?

                                public var stageId: String?

                                public var stageName: String?

                                public var status: Int32?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.message != nil {
                                        map["Message"] = self.message!
                                    }
                                    if self.stageId != nil {
                                        map["StageId"] = self.stageId!
                                    }
                                    if self.stageName != nil {
                                        map["StageName"] = self.stageName!
                                    }
                                    if self.status != nil {
                                        map["Status"] = self.status!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                    guard let dict else { return }
                                    if let value = dict["Message"] as? String {
                                        self.message = value
                                    }
                                    if let value = dict["StageId"] as? String {
                                        self.stageId = value
                                    }
                                    if let value = dict["StageName"] as? String {
                                        self.stageName = value
                                    }
                                    if let value = dict["Status"] as? Int32 {
                                        self.status = value
                                    }
                                }
                            }
                            public var instanceDTOList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList?

                            public var serviceStage: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.ServiceStage?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.instanceDTOList?.validate()
                                try self.serviceStage?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.instanceDTOList != nil {
                                    map["InstanceDTOList"] = self.instanceDTOList?.toMap()
                                }
                                if self.serviceStage != nil {
                                    map["ServiceStage"] = self.serviceStage?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["InstanceDTOList"] as? [String: Any?] {
                                    var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.InstanceDTOList()
                                    model.fromMap(value)
                                    self.instanceDTOList = model
                                }
                                if let value = dict["ServiceStage"] as? [String: Any?] {
                                    var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO.ServiceStage()
                                    model.fromMap(value)
                                    self.serviceStage = model
                                }
                            }
                        }
                        public var stageId: String?

                        public var stageName: String?

                        public var stageResultDTO: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO?

                        public var status: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.stageResultDTO?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.stageId != nil {
                                map["StageId"] = self.stageId!
                            }
                            if self.stageName != nil {
                                map["StageName"] = self.stageName!
                            }
                            if self.stageResultDTO != nil {
                                map["StageResultDTO"] = self.stageResultDTO?.toMap()
                            }
                            if self.status != nil {
                                map["Status"] = self.status!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["StageId"] as? String {
                                self.stageId = value
                            }
                            if let value = dict["StageName"] as? String {
                                self.stageName = value
                            }
                            if let value = dict["StageResultDTO"] as? [String: Any?] {
                                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO.StageResultDTO()
                                model.fromMap(value)
                                self.stageResultDTO = model
                            }
                            if let value = dict["Status"] as? Int32 {
                                self.status = value
                            }
                        }
                    }
                    public var stageInfoDTO: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.stageInfoDTO != nil {
                            var tmp : [Any] = []
                            for k in self.stageInfoDTO! {
                                tmp.append(k.toMap())
                            }
                            map["StageInfoDTO"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["StageInfoDTO"] as? [Any?] {
                            var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO] = []
                            for v in value {
                                if v != nil {
                                    var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList.StageInfoDTO()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.stageInfoDTO = tmp
                        }
                    }
                }
                public var pipelineId: String?

                public var pipelineName: String?

                public var pipelineStatus: Int32?

                public var stageDetailList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList?

                public var stageList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList?

                public var startTime: String?

                public var updateTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.stageDetailList?.validate()
                    try self.stageList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.pipelineName != nil {
                        map["PipelineName"] = self.pipelineName!
                    }
                    if self.pipelineStatus != nil {
                        map["PipelineStatus"] = self.pipelineStatus!
                    }
                    if self.stageDetailList != nil {
                        map["StageDetailList"] = self.stageDetailList?.toMap()
                    }
                    if self.stageList != nil {
                        map["StageList"] = self.stageList?.toMap()
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PipelineId"] as? String {
                        self.pipelineId = value
                    }
                    if let value = dict["PipelineName"] as? String {
                        self.pipelineName = value
                    }
                    if let value = dict["PipelineStatus"] as? Int32 {
                        self.pipelineStatus = value
                    }
                    if let value = dict["StageDetailList"] as? [String: Any?] {
                        var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageDetailList()
                        model.fromMap(value)
                        self.stageDetailList = model
                    }
                    if let value = dict["StageList"] as? [String: Any?] {
                        var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo.StageList()
                        model.fromMap(value)
                        self.stageList = model
                    }
                    if let value = dict["StartTime"] as? String {
                        self.startTime = value
                    }
                    if let value = dict["UpdateTime"] as? String {
                        self.updateTime = value
                    }
                }
            }
            public var pipelineInfo: [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pipelineInfo != nil {
                    var tmp : [Any] = []
                    for k in self.pipelineInfo! {
                        tmp.append(k.toMap())
                    }
                    map["PipelineInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PipelineInfo"] as? [Any?] {
                    var tmp : [GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo] = []
                    for v in value {
                        if v != nil {
                            var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList.PipelineInfo()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.pipelineInfo = tmp
                }
            }
        }
        public class Targets : Tea.TeaModel {
            public var items: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.items != nil {
                    map["Items"] = self.items!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Items"] as? [String] {
                    self.items = value
                }
            }
        }
        public class TrafficControl : Tea.TeaModel {
            public var routes: String?

            public var rules: String?

            public var tips: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.routes != nil {
                    map["Routes"] = self.routes!
                }
                if self.rules != nil {
                    map["Rules"] = self.rules!
                }
                if self.tips != nil {
                    map["Tips"] = self.tips!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Routes"] as? String {
                    self.routes = value
                }
                if let value = dict["Rules"] as? String {
                    self.rules = value
                }
                if let value = dict["Tips"] as? String {
                    self.tips = value
                }
            }
        }
        public var batchCount: Int32?

        public var batchType: String?

        public var changeOrderDescription: String?

        public var changeOrderId: String?

        public var coType: String?

        public var createTime: String?

        public var createUserId: String?

        public var desc: String?

        public var pipelineInfoList: GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList?

        public var status: Int32?

        public var supportRollback: Bool?

        public var targets: GetChangeOrderInfoResponseBody.ChangeOrderInfo.Targets?

        public var trafficControl: GetChangeOrderInfoResponseBody.ChangeOrderInfo.TrafficControl?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pipelineInfoList?.validate()
            try self.targets?.validate()
            try self.trafficControl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchCount != nil {
                map["BatchCount"] = self.batchCount!
            }
            if self.batchType != nil {
                map["BatchType"] = self.batchType!
            }
            if self.changeOrderDescription != nil {
                map["ChangeOrderDescription"] = self.changeOrderDescription!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.coType != nil {
                map["CoType"] = self.coType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUserId != nil {
                map["CreateUserId"] = self.createUserId!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.pipelineInfoList != nil {
                map["PipelineInfoList"] = self.pipelineInfoList?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.supportRollback != nil {
                map["SupportRollback"] = self.supportRollback!
            }
            if self.targets != nil {
                map["Targets"] = self.targets?.toMap()
            }
            if self.trafficControl != nil {
                map["TrafficControl"] = self.trafficControl?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BatchCount"] as? Int32 {
                self.batchCount = value
            }
            if let value = dict["BatchType"] as? String {
                self.batchType = value
            }
            if let value = dict["ChangeOrderDescription"] as? String {
                self.changeOrderDescription = value
            }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
            if let value = dict["CoType"] as? String {
                self.coType = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CreateUserId"] as? String {
                self.createUserId = value
            }
            if let value = dict["Desc"] as? String {
                self.desc = value
            }
            if let value = dict["PipelineInfoList"] as? [String: Any?] {
                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.PipelineInfoList()
                model.fromMap(value)
                self.pipelineInfoList = model
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
            if let value = dict["SupportRollback"] as? Bool {
                self.supportRollback = value
            }
            if let value = dict["Targets"] as? [String: Any?] {
                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.Targets()
                model.fromMap(value)
                self.targets = model
            }
            if let value = dict["TrafficControl"] as? [String: Any?] {
                var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo.TrafficControl()
                model.fromMap(value)
                self.trafficControl = model
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var changeOrderInfo: GetChangeOrderInfoResponseBody.ChangeOrderInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.changeOrderInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.changeOrderInfo != nil {
            map["changeOrderInfo"] = self.changeOrderInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["changeOrderInfo"] as? [String: Any?] {
            var model = GetChangeOrderInfoResponseBody.ChangeOrderInfo()
            model.fromMap(value)
            self.changeOrderInfo = model
        }
    }
}

public class GetChangeOrderInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetChangeOrderInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetChangeOrderInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
    }
}

public class GetClusterResponseBody : Tea.TeaModel {
    public class Cluster : Tea.TeaModel {
        public var clusterId: String?

        public var clusterImportStatus: Int32?

        public var clusterName: String?

        public var clusterType: Int32?

        public var cpu: Int32?

        public var cpuUsed: Int32?

        public var createTime: Int64?

        public var csClusterId: String?

        public var description_: String?

        public var iaasProvider: String?

        public var mem: Int32?

        public var memUsed: Int32?

        public var networkMode: Int32?

        public var nodeNum: Int32?

        public var oversoldFactor: Int32?

        public var regionId: String?

        public var subClusterType: String?

        public var updateTime: Int64?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterImportStatus != nil {
                map["ClusterImportStatus"] = self.clusterImportStatus!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuUsed != nil {
                map["CpuUsed"] = self.cpuUsed!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.csClusterId != nil {
                map["CsClusterId"] = self.csClusterId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.iaasProvider != nil {
                map["IaasProvider"] = self.iaasProvider!
            }
            if self.mem != nil {
                map["Mem"] = self.mem!
            }
            if self.memUsed != nil {
                map["MemUsed"] = self.memUsed!
            }
            if self.networkMode != nil {
                map["NetworkMode"] = self.networkMode!
            }
            if self.nodeNum != nil {
                map["NodeNum"] = self.nodeNum!
            }
            if self.oversoldFactor != nil {
                map["OversoldFactor"] = self.oversoldFactor!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.subClusterType != nil {
                map["SubClusterType"] = self.subClusterType!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["ClusterImportStatus"] as? Int32 {
                self.clusterImportStatus = value
            }
            if let value = dict["ClusterName"] as? String {
                self.clusterName = value
            }
            if let value = dict["ClusterType"] as? Int32 {
                self.clusterType = value
            }
            if let value = dict["Cpu"] as? Int32 {
                self.cpu = value
            }
            if let value = dict["CpuUsed"] as? Int32 {
                self.cpuUsed = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CsClusterId"] as? String {
                self.csClusterId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["IaasProvider"] as? String {
                self.iaasProvider = value
            }
            if let value = dict["Mem"] as? Int32 {
                self.mem = value
            }
            if let value = dict["MemUsed"] as? Int32 {
                self.memUsed = value
            }
            if let value = dict["NetworkMode"] as? Int32 {
                self.networkMode = value
            }
            if let value = dict["NodeNum"] as? Int32 {
                self.nodeNum = value
            }
            if let value = dict["OversoldFactor"] as? Int32 {
                self.oversoldFactor = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["SubClusterType"] as? String {
                self.subClusterType = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var cluster: GetClusterResponseBody.Cluster?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cluster?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cluster != nil {
            map["Cluster"] = self.cluster?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cluster"] as? [String: Any?] {
            var model = GetClusterResponseBody.Cluster()
            model.fromMap(value)
            self.cluster = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetContainerConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class GetContainerConfigurationResponseBody : Tea.TeaModel {
    public class ContainerConfiguration : Tea.TeaModel {
        public var contextPath: String?

        public var httpPort: Int32?

        public var maxThreads: Int32?

        public var URIEncoding: String?

        public var useBodyEncoding: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contextPath != nil {
                map["ContextPath"] = self.contextPath!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.maxThreads != nil {
                map["MaxThreads"] = self.maxThreads!
            }
            if self.URIEncoding != nil {
                map["URIEncoding"] = self.URIEncoding!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ContextPath"] as? String {
                self.contextPath = value
            }
            if let value = dict["HttpPort"] as? Int32 {
                self.httpPort = value
            }
            if let value = dict["MaxThreads"] as? Int32 {
                self.maxThreads = value
            }
            if let value = dict["URIEncoding"] as? String {
                self.URIEncoding = value
            }
            if let value = dict["UseBodyEncoding"] as? Bool {
                self.useBodyEncoding = value
            }
        }
    }
    public var code: Int32?

    public var containerConfiguration: GetContainerConfigurationResponseBody.ContainerConfiguration?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.containerConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.containerConfiguration != nil {
            map["ContainerConfiguration"] = self.containerConfiguration?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["ContainerConfiguration"] as? [String: Any?] {
            var model = GetContainerConfigurationResponseBody.ContainerConfiguration()
            model.fromMap(value)
            self.containerConfiguration = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetContainerConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetContainerConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetContainerConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetJavaStartUpConfigRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class GetJavaStartUpConfigResponseBody : Tea.TeaModel {
    public class JavaStartUpConfig : Tea.TeaModel {
        public var originalConfigs: String?

        public var startUpArgs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.originalConfigs != nil {
                map["OriginalConfigs"] = self.originalConfigs!
            }
            if self.startUpArgs != nil {
                map["StartUpArgs"] = self.startUpArgs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OriginalConfigs"] as? String {
                self.originalConfigs = value
            }
            if let value = dict["StartUpArgs"] as? String {
                self.startUpArgs = value
            }
        }
    }
    public var code: Int32?

    public var javaStartUpConfig: GetJavaStartUpConfigResponseBody.JavaStartUpConfig?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.javaStartUpConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["JavaStartUpConfig"] as? [String: Any?] {
            var model = GetJavaStartUpConfigResponseBody.JavaStartUpConfig()
            model.fromMap(value)
            self.javaStartUpConfig = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetJavaStartUpConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetJavaStartUpConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetJavaStartUpConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetJvmConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class GetJvmConfigurationResponseBody : Tea.TeaModel {
    public class JvmConfiguration : Tea.TeaModel {
        public var maxHeapSize: Int32?

        public var maxPermSize: Int32?

        public var minHeapSize: Int32?

        public var options: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxHeapSize != nil {
                map["MaxHeapSize"] = self.maxHeapSize!
            }
            if self.maxPermSize != nil {
                map["MaxPermSize"] = self.maxPermSize!
            }
            if self.minHeapSize != nil {
                map["MinHeapSize"] = self.minHeapSize!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxHeapSize"] as? Int32 {
                self.maxHeapSize = value
            }
            if let value = dict["MaxPermSize"] as? Int32 {
                self.maxPermSize = value
            }
            if let value = dict["MinHeapSize"] as? Int32 {
                self.minHeapSize = value
            }
            if let value = dict["Options"] as? String {
                self.options = value
            }
        }
    }
    public var code: Int32?

    public var jvmConfiguration: GetJvmConfigurationResponseBody.JvmConfiguration?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jvmConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.jvmConfiguration != nil {
            map["JvmConfiguration"] = self.jvmConfiguration?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["JvmConfiguration"] as? [String: Any?] {
            var model = GetJvmConfigurationResponseBody.JvmConfiguration()
            model.fromMap(value)
            self.jvmConfiguration = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetJvmConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetJvmConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetJvmConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetK8sAppPrecheckResultRequest : Tea.TeaModel {
    public var appName: String?

    public var clusterId: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
    }
}

public class GetK8sAppPrecheckResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class JobResults : Tea.TeaModel {
            public var interrupted: Bool?

            public var name: String?

            public var pass: Bool?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interrupted != nil {
                    map["Interrupted"] = self.interrupted!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pass != nil {
                    map["Pass"] = self.pass!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Interrupted"] as? Bool {
                    self.interrupted = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Pass"] as? Bool {
                    self.pass = value
                }
                if let value = dict["Reason"] as? String {
                    self.reason = value
                }
            }
        }
        public var jobResults: [GetK8sAppPrecheckResultResponseBody.Data.JobResults]?

        public var reason: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobResults != nil {
                var tmp : [Any] = []
                for k in self.jobResults! {
                    tmp.append(k.toMap())
                }
                map["JobResults"] = tmp
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["JobResults"] as? [Any?] {
                var tmp : [GetK8sAppPrecheckResultResponseBody.Data.JobResults] = []
                for v in value {
                    if v != nil {
                        var model = GetK8sAppPrecheckResultResponseBody.Data.JobResults()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.jobResults = tmp
            }
            if let value = dict["Reason"] as? String {
                self.reason = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var code: Int32?

    public var data: GetK8sAppPrecheckResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetK8sAppPrecheckResultResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetK8sAppPrecheckResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetK8sAppPrecheckResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetK8sAppPrecheckResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var from: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["From"] as? String {
            self.from = value
        }
    }
}

public class GetK8sApplicationResponseBody : Tea.TeaModel {
    public class Applcation : Tea.TeaModel {
        public class App : Tea.TeaModel {
            public class CmdArgs : Tea.TeaModel {
                public var cmdArg: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cmdArg != nil {
                        map["CmdArg"] = self.cmdArg!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CmdArg"] as? [String] {
                        self.cmdArg = value
                    }
                }
            }
            public class EnvList : Tea.TeaModel {
                public class Env : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var env: [GetK8sApplicationResponseBody.Applcation.App.EnvList.Env]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.env != nil {
                        var tmp : [Any] = []
                        for k in self.env! {
                            tmp.append(k.toMap())
                        }
                        map["Env"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Env"] as? [Any?] {
                        var tmp : [GetK8sApplicationResponseBody.Applcation.App.EnvList.Env] = []
                        for v in value {
                            if v != nil {
                                var model = GetK8sApplicationResponseBody.Applcation.App.EnvList.Env()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.env = tmp
                    }
                }
            }
            public var annotations: String?

            public var appId: String?

            public var applicationName: String?

            public var applicationType: String?

            public var buildpackId: Int32?

            public var clusterId: String?

            public var cmd: String?

            public var cmdArgs: GetK8sApplicationResponseBody.Applcation.App.CmdArgs?

            public var csClusterId: String?

            public var deployType: String?

            public var developType: String?

            public var edasContainerVersion: String?

            public var enableEmptyPushReject: Bool?

            public var enableLosslessRule: Bool?

            public var envList: GetK8sApplicationResponseBody.Applcation.App.EnvList?

            public var featureAnnotations: String?

            public var instances: Int32?

            public var instancesBeforeScaling: Int32?

            public var k8sNamespace: String?

            public var labels: String?

            public var limitCpuM: Int32?

            public var limitEphemeralStorage: String?

            public var limitMem: Int32?

            public var losslessRuleAligned: Bool?

            public var losslessRuleDelayTime: Int32?

            public var losslessRuleFuncType: Int32?

            public var losslessRuleRelated: Bool?

            public var losslessRuleWarmupTime: Int32?

            public var regionId: String?

            public var requestCpuM: Int32?

            public var requestEphemeralStorage: String?

            public var requestMem: Int32?

            public var slbInfo: String?

            public var tomcatVersion: String?

            public var workloadType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cmdArgs?.validate()
                try self.envList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotations != nil {
                    map["Annotations"] = self.annotations!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.applicationName != nil {
                    map["ApplicationName"] = self.applicationName!
                }
                if self.applicationType != nil {
                    map["ApplicationType"] = self.applicationType!
                }
                if self.buildpackId != nil {
                    map["BuildpackId"] = self.buildpackId!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.cmd != nil {
                    map["Cmd"] = self.cmd!
                }
                if self.cmdArgs != nil {
                    map["CmdArgs"] = self.cmdArgs?.toMap()
                }
                if self.csClusterId != nil {
                    map["CsClusterId"] = self.csClusterId!
                }
                if self.deployType != nil {
                    map["DeployType"] = self.deployType!
                }
                if self.developType != nil {
                    map["DevelopType"] = self.developType!
                }
                if self.edasContainerVersion != nil {
                    map["EdasContainerVersion"] = self.edasContainerVersion!
                }
                if self.enableEmptyPushReject != nil {
                    map["EnableEmptyPushReject"] = self.enableEmptyPushReject!
                }
                if self.enableLosslessRule != nil {
                    map["EnableLosslessRule"] = self.enableLosslessRule!
                }
                if self.envList != nil {
                    map["EnvList"] = self.envList?.toMap()
                }
                if self.featureAnnotations != nil {
                    map["FeatureAnnotations"] = self.featureAnnotations!
                }
                if self.instances != nil {
                    map["Instances"] = self.instances!
                }
                if self.instancesBeforeScaling != nil {
                    map["InstancesBeforeScaling"] = self.instancesBeforeScaling!
                }
                if self.k8sNamespace != nil {
                    map["K8sNamespace"] = self.k8sNamespace!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.limitCpuM != nil {
                    map["LimitCpuM"] = self.limitCpuM!
                }
                if self.limitEphemeralStorage != nil {
                    map["LimitEphemeralStorage"] = self.limitEphemeralStorage!
                }
                if self.limitMem != nil {
                    map["LimitMem"] = self.limitMem!
                }
                if self.losslessRuleAligned != nil {
                    map["LosslessRuleAligned"] = self.losslessRuleAligned!
                }
                if self.losslessRuleDelayTime != nil {
                    map["LosslessRuleDelayTime"] = self.losslessRuleDelayTime!
                }
                if self.losslessRuleFuncType != nil {
                    map["LosslessRuleFuncType"] = self.losslessRuleFuncType!
                }
                if self.losslessRuleRelated != nil {
                    map["LosslessRuleRelated"] = self.losslessRuleRelated!
                }
                if self.losslessRuleWarmupTime != nil {
                    map["LosslessRuleWarmupTime"] = self.losslessRuleWarmupTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.requestCpuM != nil {
                    map["RequestCpuM"] = self.requestCpuM!
                }
                if self.requestEphemeralStorage != nil {
                    map["RequestEphemeralStorage"] = self.requestEphemeralStorage!
                }
                if self.requestMem != nil {
                    map["RequestMem"] = self.requestMem!
                }
                if self.slbInfo != nil {
                    map["SlbInfo"] = self.slbInfo!
                }
                if self.tomcatVersion != nil {
                    map["TomcatVersion"] = self.tomcatVersion!
                }
                if self.workloadType != nil {
                    map["WorkloadType"] = self.workloadType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Annotations"] as? String {
                    self.annotations = value
                }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["ApplicationName"] as? String {
                    self.applicationName = value
                }
                if let value = dict["ApplicationType"] as? String {
                    self.applicationType = value
                }
                if let value = dict["BuildpackId"] as? Int32 {
                    self.buildpackId = value
                }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["Cmd"] as? String {
                    self.cmd = value
                }
                if let value = dict["CmdArgs"] as? [String: Any?] {
                    var model = GetK8sApplicationResponseBody.Applcation.App.CmdArgs()
                    model.fromMap(value)
                    self.cmdArgs = model
                }
                if let value = dict["CsClusterId"] as? String {
                    self.csClusterId = value
                }
                if let value = dict["DeployType"] as? String {
                    self.deployType = value
                }
                if let value = dict["DevelopType"] as? String {
                    self.developType = value
                }
                if let value = dict["EdasContainerVersion"] as? String {
                    self.edasContainerVersion = value
                }
                if let value = dict["EnableEmptyPushReject"] as? Bool {
                    self.enableEmptyPushReject = value
                }
                if let value = dict["EnableLosslessRule"] as? Bool {
                    self.enableLosslessRule = value
                }
                if let value = dict["EnvList"] as? [String: Any?] {
                    var model = GetK8sApplicationResponseBody.Applcation.App.EnvList()
                    model.fromMap(value)
                    self.envList = model
                }
                if let value = dict["FeatureAnnotations"] as? String {
                    self.featureAnnotations = value
                }
                if let value = dict["Instances"] as? Int32 {
                    self.instances = value
                }
                if let value = dict["InstancesBeforeScaling"] as? Int32 {
                    self.instancesBeforeScaling = value
                }
                if let value = dict["K8sNamespace"] as? String {
                    self.k8sNamespace = value
                }
                if let value = dict["Labels"] as? String {
                    self.labels = value
                }
                if let value = dict["LimitCpuM"] as? Int32 {
                    self.limitCpuM = value
                }
                if let value = dict["LimitEphemeralStorage"] as? String {
                    self.limitEphemeralStorage = value
                }
                if let value = dict["LimitMem"] as? Int32 {
                    self.limitMem = value
                }
                if let value = dict["LosslessRuleAligned"] as? Bool {
                    self.losslessRuleAligned = value
                }
                if let value = dict["LosslessRuleDelayTime"] as? Int32 {
                    self.losslessRuleDelayTime = value
                }
                if let value = dict["LosslessRuleFuncType"] as? Int32 {
                    self.losslessRuleFuncType = value
                }
                if let value = dict["LosslessRuleRelated"] as? Bool {
                    self.losslessRuleRelated = value
                }
                if let value = dict["LosslessRuleWarmupTime"] as? Int32 {
                    self.losslessRuleWarmupTime = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RequestCpuM"] as? Int32 {
                    self.requestCpuM = value
                }
                if let value = dict["RequestEphemeralStorage"] as? String {
                    self.requestEphemeralStorage = value
                }
                if let value = dict["RequestMem"] as? Int32 {
                    self.requestMem = value
                }
                if let value = dict["SlbInfo"] as? String {
                    self.slbInfo = value
                }
                if let value = dict["TomcatVersion"] as? String {
                    self.tomcatVersion = value
                }
                if let value = dict["WorkloadType"] as? String {
                    self.workloadType = value
                }
            }
        }
        public class Conf : Tea.TeaModel {
            public var affinity: String?

            public var ahasEnabled: Bool?

            public var deployAcrossNodes: String?

            public var deployAcrossZones: String?

            public var jarStartArgs: String?

            public var jarStartOptions: String?

            public var k8sCmd: String?

            public var k8sCmdArgs: String?

            public var k8sLocalvolumeInfo: String?

            public var k8sNasInfo: String?

            public var k8sVolumeInfo: String?

            public var liveness: String?

            public var postStart: String?

            public var preStop: String?

            public var readiness: String?

            public var runtimeClassName: String?

            public var tolerations: String?

            public var userBaseImageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.affinity != nil {
                    map["Affinity"] = self.affinity!
                }
                if self.ahasEnabled != nil {
                    map["AhasEnabled"] = self.ahasEnabled!
                }
                if self.deployAcrossNodes != nil {
                    map["DeployAcrossNodes"] = self.deployAcrossNodes!
                }
                if self.deployAcrossZones != nil {
                    map["DeployAcrossZones"] = self.deployAcrossZones!
                }
                if self.jarStartArgs != nil {
                    map["JarStartArgs"] = self.jarStartArgs!
                }
                if self.jarStartOptions != nil {
                    map["JarStartOptions"] = self.jarStartOptions!
                }
                if self.k8sCmd != nil {
                    map["K8sCmd"] = self.k8sCmd!
                }
                if self.k8sCmdArgs != nil {
                    map["K8sCmdArgs"] = self.k8sCmdArgs!
                }
                if self.k8sLocalvolumeInfo != nil {
                    map["K8sLocalvolumeInfo"] = self.k8sLocalvolumeInfo!
                }
                if self.k8sNasInfo != nil {
                    map["K8sNasInfo"] = self.k8sNasInfo!
                }
                if self.k8sVolumeInfo != nil {
                    map["K8sVolumeInfo"] = self.k8sVolumeInfo!
                }
                if self.liveness != nil {
                    map["Liveness"] = self.liveness!
                }
                if self.postStart != nil {
                    map["PostStart"] = self.postStart!
                }
                if self.preStop != nil {
                    map["PreStop"] = self.preStop!
                }
                if self.readiness != nil {
                    map["Readiness"] = self.readiness!
                }
                if self.runtimeClassName != nil {
                    map["RuntimeClassName"] = self.runtimeClassName!
                }
                if self.tolerations != nil {
                    map["Tolerations"] = self.tolerations!
                }
                if self.userBaseImageUrl != nil {
                    map["UserBaseImageUrl"] = self.userBaseImageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Affinity"] as? String {
                    self.affinity = value
                }
                if let value = dict["AhasEnabled"] as? Bool {
                    self.ahasEnabled = value
                }
                if let value = dict["DeployAcrossNodes"] as? String {
                    self.deployAcrossNodes = value
                }
                if let value = dict["DeployAcrossZones"] as? String {
                    self.deployAcrossZones = value
                }
                if let value = dict["JarStartArgs"] as? String {
                    self.jarStartArgs = value
                }
                if let value = dict["JarStartOptions"] as? String {
                    self.jarStartOptions = value
                }
                if let value = dict["K8sCmd"] as? String {
                    self.k8sCmd = value
                }
                if let value = dict["K8sCmdArgs"] as? String {
                    self.k8sCmdArgs = value
                }
                if let value = dict["K8sLocalvolumeInfo"] as? String {
                    self.k8sLocalvolumeInfo = value
                }
                if let value = dict["K8sNasInfo"] as? String {
                    self.k8sNasInfo = value
                }
                if let value = dict["K8sVolumeInfo"] as? String {
                    self.k8sVolumeInfo = value
                }
                if let value = dict["Liveness"] as? String {
                    self.liveness = value
                }
                if let value = dict["PostStart"] as? String {
                    self.postStart = value
                }
                if let value = dict["PreStop"] as? String {
                    self.preStop = value
                }
                if let value = dict["Readiness"] as? String {
                    self.readiness = value
                }
                if let value = dict["RuntimeClassName"] as? String {
                    self.runtimeClassName = value
                }
                if let value = dict["Tolerations"] as? String {
                    self.tolerations = value
                }
                if let value = dict["UserBaseImageUrl"] as? String {
                    self.userBaseImageUrl = value
                }
            }
        }
        public class DeployGroups : Tea.TeaModel {
            public class DeployGroup : Tea.TeaModel {
                public class Components : Tea.TeaModel {
                    public class Components : Tea.TeaModel {
                        public var componentId: String?

                        public var componentKey: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.componentId != nil {
                                map["ComponentId"] = self.componentId!
                            }
                            if self.componentKey != nil {
                                map["ComponentKey"] = self.componentKey!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["ComponentId"] as? String {
                                self.componentId = value
                            }
                            if let value = dict["ComponentKey"] as? String {
                                self.componentKey = value
                            }
                            if let value = dict["Type"] as? String {
                                self.type = value
                            }
                        }
                    }
                    public var components: [GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components.Components]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.components != nil {
                            var tmp : [Any] = []
                            for k in self.components! {
                                tmp.append(k.toMap())
                            }
                            map["Components"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Components"] as? [Any?] {
                            var tmp : [GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components.Components] = []
                            for v in value {
                                if v != nil {
                                    var model = GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components.Components()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.components = tmp
                        }
                    }
                }
                public var components: GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components?

                public var env: String?

                public var envFrom: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.components?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.components != nil {
                        map["Components"] = self.components?.toMap()
                    }
                    if self.env != nil {
                        map["Env"] = self.env!
                    }
                    if self.envFrom != nil {
                        map["EnvFrom"] = self.envFrom!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Components"] as? [String: Any?] {
                        var model = GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup.Components()
                        model.fromMap(value)
                        self.components = model
                    }
                    if let value = dict["Env"] as? String {
                        self.env = value
                    }
                    if let value = dict["EnvFrom"] as? String {
                        self.envFrom = value
                    }
                }
            }
            public var deployGroup: [GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deployGroup != nil {
                    var tmp : [Any] = []
                    for k in self.deployGroup! {
                        tmp.append(k.toMap())
                    }
                    map["DeployGroup"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DeployGroup"] as? [Any?] {
                    var tmp : [GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup] = []
                    for v in value {
                        if v != nil {
                            var model = GetK8sApplicationResponseBody.Applcation.DeployGroups.DeployGroup()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.deployGroup = tmp
                }
            }
        }
        public class ImageInfo : Tea.TeaModel {
            public var imageUrl: String?

            public var regionId: String?

            public var repoId: String?

            public var repoName: String?

            public var repoNamespace: String?

            public var repoOriginType: String?

            public var tag: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.repoId != nil {
                    map["RepoId"] = self.repoId!
                }
                if self.repoName != nil {
                    map["RepoName"] = self.repoName!
                }
                if self.repoNamespace != nil {
                    map["RepoNamespace"] = self.repoNamespace!
                }
                if self.repoOriginType != nil {
                    map["RepoOriginType"] = self.repoOriginType!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ImageUrl"] as? String {
                    self.imageUrl = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RepoId"] as? String {
                    self.repoId = value
                }
                if let value = dict["RepoName"] as? String {
                    self.repoName = value
                }
                if let value = dict["RepoNamespace"] as? String {
                    self.repoNamespace = value
                }
                if let value = dict["RepoOriginType"] as? String {
                    self.repoOriginType = value
                }
                if let value = dict["Tag"] as? String {
                    self.tag = value
                }
            }
        }
        public class LatestVersion : Tea.TeaModel {
            public var packageVersion: String?

            public var url: String?

            public var warUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.packageVersion != nil {
                    map["PackageVersion"] = self.packageVersion!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.warUrl != nil {
                    map["WarUrl"] = self.warUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PackageVersion"] as? String {
                    self.packageVersion = value
                }
                if let value = dict["Url"] as? String {
                    self.url = value
                }
                if let value = dict["WarUrl"] as? String {
                    self.warUrl = value
                }
            }
        }
        public var app: GetK8sApplicationResponseBody.Applcation.App?

        public var appId: String?

        public var conf: GetK8sApplicationResponseBody.Applcation.Conf?

        public var deployGroups: GetK8sApplicationResponseBody.Applcation.DeployGroups?

        public var imageInfo: GetK8sApplicationResponseBody.Applcation.ImageInfo?

        public var latestVersion: GetK8sApplicationResponseBody.Applcation.LatestVersion?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.app?.validate()
            try self.conf?.validate()
            try self.deployGroups?.validate()
            try self.imageInfo?.validate()
            try self.latestVersion?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app?.toMap()
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.conf != nil {
                map["Conf"] = self.conf?.toMap()
            }
            if self.deployGroups != nil {
                map["DeployGroups"] = self.deployGroups?.toMap()
            }
            if self.imageInfo != nil {
                map["ImageInfo"] = self.imageInfo?.toMap()
            }
            if self.latestVersion != nil {
                map["LatestVersion"] = self.latestVersion?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["App"] as? [String: Any?] {
                var model = GetK8sApplicationResponseBody.Applcation.App()
                model.fromMap(value)
                self.app = model
            }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Conf"] as? [String: Any?] {
                var model = GetK8sApplicationResponseBody.Applcation.Conf()
                model.fromMap(value)
                self.conf = model
            }
            if let value = dict["DeployGroups"] as? [String: Any?] {
                var model = GetK8sApplicationResponseBody.Applcation.DeployGroups()
                model.fromMap(value)
                self.deployGroups = model
            }
            if let value = dict["ImageInfo"] as? [String: Any?] {
                var model = GetK8sApplicationResponseBody.Applcation.ImageInfo()
                model.fromMap(value)
                self.imageInfo = model
            }
            if let value = dict["LatestVersion"] as? [String: Any?] {
                var model = GetK8sApplicationResponseBody.Applcation.LatestVersion()
                model.fromMap(value)
                self.latestVersion = model
            }
        }
    }
    public var applcation: GetK8sApplicationResponseBody.Applcation?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applcation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applcation != nil {
            map["Applcation"] = self.applcation?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Applcation"] as? [String: Any?] {
            var model = GetK8sApplicationResponseBody.Applcation()
            model.fromMap(value)
            self.applcation = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetK8sApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetK8sClusterRequest : Tea.TeaModel {
    public var clusterType: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var regionTag: String?

    public var subClusterType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionTag != nil {
            map["RegionTag"] = self.regionTag!
        }
        if self.subClusterType != nil {
            map["SubClusterType"] = self.subClusterType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterType"] as? Int32 {
            self.clusterType = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionTag"] as? String {
            self.regionTag = value
        }
        if let value = dict["SubClusterType"] as? String {
            self.subClusterType = value
        }
    }
}

public class GetK8sClusterResponseBody : Tea.TeaModel {
    public class ClusterPage : Tea.TeaModel {
        public class ClusterList : Tea.TeaModel {
            public class Cluster : Tea.TeaModel {
                public var clusterId: String?

                public var clusterImportStatus: Int32?

                public var clusterName: String?

                public var clusterStatus: Int32?

                public var clusterType: Int32?

                public var cpu: Int32?

                public var csClusterId: String?

                public var csClusterStatus: String?

                public var description_: String?

                public var mem: Int32?

                public var networkMode: Int32?

                public var nodeNum: Int32?

                public var regionId: String?

                public var subClusterType: String?

                public var subNetCidr: String?

                public var vpcId: String?

                public var vswitchId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterId != nil {
                        map["ClusterId"] = self.clusterId!
                    }
                    if self.clusterImportStatus != nil {
                        map["ClusterImportStatus"] = self.clusterImportStatus!
                    }
                    if self.clusterName != nil {
                        map["ClusterName"] = self.clusterName!
                    }
                    if self.clusterStatus != nil {
                        map["ClusterStatus"] = self.clusterStatus!
                    }
                    if self.clusterType != nil {
                        map["ClusterType"] = self.clusterType!
                    }
                    if self.cpu != nil {
                        map["Cpu"] = self.cpu!
                    }
                    if self.csClusterId != nil {
                        map["CsClusterId"] = self.csClusterId!
                    }
                    if self.csClusterStatus != nil {
                        map["CsClusterStatus"] = self.csClusterStatus!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.mem != nil {
                        map["Mem"] = self.mem!
                    }
                    if self.networkMode != nil {
                        map["NetworkMode"] = self.networkMode!
                    }
                    if self.nodeNum != nil {
                        map["NodeNum"] = self.nodeNum!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.subClusterType != nil {
                        map["SubClusterType"] = self.subClusterType!
                    }
                    if self.subNetCidr != nil {
                        map["SubNetCidr"] = self.subNetCidr!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    if self.vswitchId != nil {
                        map["VswitchId"] = self.vswitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ClusterId"] as? String {
                        self.clusterId = value
                    }
                    if let value = dict["ClusterImportStatus"] as? Int32 {
                        self.clusterImportStatus = value
                    }
                    if let value = dict["ClusterName"] as? String {
                        self.clusterName = value
                    }
                    if let value = dict["ClusterStatus"] as? Int32 {
                        self.clusterStatus = value
                    }
                    if let value = dict["ClusterType"] as? Int32 {
                        self.clusterType = value
                    }
                    if let value = dict["Cpu"] as? Int32 {
                        self.cpu = value
                    }
                    if let value = dict["CsClusterId"] as? String {
                        self.csClusterId = value
                    }
                    if let value = dict["CsClusterStatus"] as? String {
                        self.csClusterStatus = value
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["Mem"] as? Int32 {
                        self.mem = value
                    }
                    if let value = dict["NetworkMode"] as? Int32 {
                        self.networkMode = value
                    }
                    if let value = dict["NodeNum"] as? Int32 {
                        self.nodeNum = value
                    }
                    if let value = dict["RegionId"] as? String {
                        self.regionId = value
                    }
                    if let value = dict["SubClusterType"] as? String {
                        self.subClusterType = value
                    }
                    if let value = dict["SubNetCidr"] as? String {
                        self.subNetCidr = value
                    }
                    if let value = dict["VpcId"] as? String {
                        self.vpcId = value
                    }
                    if let value = dict["VswitchId"] as? String {
                        self.vswitchId = value
                    }
                }
            }
            public var cluster: [GetK8sClusterResponseBody.ClusterPage.ClusterList.Cluster]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cluster != nil {
                    var tmp : [Any] = []
                    for k in self.cluster! {
                        tmp.append(k.toMap())
                    }
                    map["Cluster"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cluster"] as? [Any?] {
                    var tmp : [GetK8sClusterResponseBody.ClusterPage.ClusterList.Cluster] = []
                    for v in value {
                        if v != nil {
                            var model = GetK8sClusterResponseBody.ClusterPage.ClusterList.Cluster()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.cluster = tmp
                }
            }
        }
        public var clusterList: GetK8sClusterResponseBody.ClusterPage.ClusterList?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clusterList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterList != nil {
                map["ClusterList"] = self.clusterList?.toMap()
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterList"] as? [String: Any?] {
                var model = GetK8sClusterResponseBody.ClusterPage.ClusterList()
                model.fromMap(value)
                self.clusterList = model
            }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var clusterPage: GetK8sClusterResponseBody.ClusterPage?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterPage?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterPage != nil {
            map["ClusterPage"] = self.clusterPage?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterPage"] as? [String: Any?] {
            var model = GetK8sClusterResponseBody.ClusterPage()
            model.fromMap(value)
            self.clusterPage = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetK8sClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetK8sClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetK8sClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetK8sServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class GetK8sServicesResponseBody : Tea.TeaModel {
    public class Services : Tea.TeaModel {
        public class ServicePorts : Tea.TeaModel {
            public var nodePort: Int32?

            public var port: Int32?

            public var protocol_: String?

            public var targetPort: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodePort != nil {
                    map["NodePort"] = self.nodePort!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NodePort"] as? Int32 {
                    self.nodePort = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["TargetPort"] as? String {
                    self.targetPort = value
                }
            }
        }
        public var clusterIP: String?

        public var name: String?

        public var servicePorts: [GetK8sServicesResponseBody.Services.ServicePorts]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterIP != nil {
                map["ClusterIP"] = self.clusterIP!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.servicePorts != nil {
                var tmp : [Any] = []
                for k in self.servicePorts! {
                    tmp.append(k.toMap())
                }
                map["ServicePorts"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterIP"] as? String {
                self.clusterIP = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ServicePorts"] as? [Any?] {
                var tmp : [GetK8sServicesResponseBody.Services.ServicePorts] = []
                for v in value {
                    if v != nil {
                        var model = GetK8sServicesResponseBody.Services.ServicePorts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.servicePorts = tmp
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var services: [GetK8sServicesResponseBody.Services]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Services"] as? [Any?] {
            var tmp : [GetK8sServicesResponseBody.Services] = []
            for v in value {
                if v != nil {
                    var model = GetK8sServicesResponseBody.Services()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.services = tmp
        }
    }
}

public class GetK8sServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetK8sServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetK8sServicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPackageStorageCredentialResponseBody : Tea.TeaModel {
    public class Credential : Tea.TeaModel {
        public var accessKeyId: String?

        public var accessKeySecret: String?

        public var bucket: String?

        public var expiration: String?

        public var keyPrefix: String?

        public var ossInternalEndpoint: String?

        public var ossPublicEndpoint: String?

        public var ossVpcEndpoint: String?

        public var regionId: String?

        public var securityToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.accessKeySecret != nil {
                map["AccessKeySecret"] = self.accessKeySecret!
            }
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.expiration != nil {
                map["Expiration"] = self.expiration!
            }
            if self.keyPrefix != nil {
                map["KeyPrefix"] = self.keyPrefix!
            }
            if self.ossInternalEndpoint != nil {
                map["OssInternalEndpoint"] = self.ossInternalEndpoint!
            }
            if self.ossPublicEndpoint != nil {
                map["OssPublicEndpoint"] = self.ossPublicEndpoint!
            }
            if self.ossVpcEndpoint != nil {
                map["OssVpcEndpoint"] = self.ossVpcEndpoint!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityToken != nil {
                map["SecurityToken"] = self.securityToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessKeyId"] as? String {
                self.accessKeyId = value
            }
            if let value = dict["AccessKeySecret"] as? String {
                self.accessKeySecret = value
            }
            if let value = dict["Bucket"] as? String {
                self.bucket = value
            }
            if let value = dict["Expiration"] as? String {
                self.expiration = value
            }
            if let value = dict["KeyPrefix"] as? String {
                self.keyPrefix = value
            }
            if let value = dict["OssInternalEndpoint"] as? String {
                self.ossInternalEndpoint = value
            }
            if let value = dict["OssPublicEndpoint"] as? String {
                self.ossPublicEndpoint = value
            }
            if let value = dict["OssVpcEndpoint"] as? String {
                self.ossVpcEndpoint = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["SecurityToken"] as? String {
                self.securityToken = value
            }
        }
    }
    public var code: Int32?

    public var credential: GetPackageStorageCredentialResponseBody.Credential?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.credential?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.credential != nil {
            map["Credential"] = self.credential?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Credential"] as? [String: Any?] {
            var model = GetPackageStorageCredentialResponseBody.Credential()
            model.fromMap(value)
            self.credential = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPackageStorageCredentialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPackageStorageCredentialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPackageStorageCredentialResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetScalingRulesRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var mode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["Mode"] as? String {
            self.mode = value
        }
    }
}

public class GetScalingRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RuleList : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var appId: String?

                public var cond: String?

                public var cpu: Int32?

                public var createTime: Int64?

                public var duration: Int32?

                public var enable: Bool?

                public var groupId: String?

                public var instNum: Int32?

                public var loadNum: Int32?

                public var metricType: String?

                public var mode: String?

                public var multiAzPolicy: String?

                public var resourceFrom: String?

                public var rt: Int32?

                public var specId: String?

                public var step: Int32?

                public var templateId: String?

                public var templateVersion: Int32?

                public var updateTime: Int64?

                public var vSwitchIds: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.cond != nil {
                        map["Cond"] = self.cond!
                    }
                    if self.cpu != nil {
                        map["Cpu"] = self.cpu!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.enable != nil {
                        map["Enable"] = self.enable!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.instNum != nil {
                        map["InstNum"] = self.instNum!
                    }
                    if self.loadNum != nil {
                        map["LoadNum"] = self.loadNum!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    if self.multiAzPolicy != nil {
                        map["MultiAzPolicy"] = self.multiAzPolicy!
                    }
                    if self.resourceFrom != nil {
                        map["ResourceFrom"] = self.resourceFrom!
                    }
                    if self.rt != nil {
                        map["Rt"] = self.rt!
                    }
                    if self.specId != nil {
                        map["SpecId"] = self.specId!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    if self.templateVersion != nil {
                        map["TemplateVersion"] = self.templateVersion!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    if self.vSwitchIds != nil {
                        map["VSwitchIds"] = self.vSwitchIds!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["Cond"] as? String {
                        self.cond = value
                    }
                    if let value = dict["Cpu"] as? Int32 {
                        self.cpu = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["Duration"] as? Int32 {
                        self.duration = value
                    }
                    if let value = dict["Enable"] as? Bool {
                        self.enable = value
                    }
                    if let value = dict["GroupId"] as? String {
                        self.groupId = value
                    }
                    if let value = dict["InstNum"] as? Int32 {
                        self.instNum = value
                    }
                    if let value = dict["LoadNum"] as? Int32 {
                        self.loadNum = value
                    }
                    if let value = dict["MetricType"] as? String {
                        self.metricType = value
                    }
                    if let value = dict["Mode"] as? String {
                        self.mode = value
                    }
                    if let value = dict["MultiAzPolicy"] as? String {
                        self.multiAzPolicy = value
                    }
                    if let value = dict["ResourceFrom"] as? String {
                        self.resourceFrom = value
                    }
                    if let value = dict["Rt"] as? Int32 {
                        self.rt = value
                    }
                    if let value = dict["SpecId"] as? String {
                        self.specId = value
                    }
                    if let value = dict["Step"] as? Int32 {
                        self.step = value
                    }
                    if let value = dict["TemplateId"] as? String {
                        self.templateId = value
                    }
                    if let value = dict["TemplateVersion"] as? Int32 {
                        self.templateVersion = value
                    }
                    if let value = dict["UpdateTime"] as? Int64 {
                        self.updateTime = value
                    }
                    if let value = dict["VSwitchIds"] as? String {
                        self.vSwitchIds = value
                    }
                    if let value = dict["VpcId"] as? String {
                        self.vpcId = value
                    }
                }
            }
            public var rule: [GetScalingRulesResponseBody.Data.RuleList.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Rule"] as? [Any?] {
                    var tmp : [GetScalingRulesResponseBody.Data.RuleList.Rule] = []
                    for v in value {
                        if v != nil {
                            var model = GetScalingRulesResponseBody.Data.RuleList.Rule()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rule = tmp
                }
            }
        }
        public var clusterType: Int32?

        public var oversoldFactor: Int32?

        public var ruleList: GetScalingRulesResponseBody.Data.RuleList?

        public var updateTime: Int64?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ruleList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.oversoldFactor != nil {
                map["OversoldFactor"] = self.oversoldFactor!
            }
            if self.ruleList != nil {
                map["RuleList"] = self.ruleList?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterType"] as? Int32 {
                self.clusterType = value
            }
            if let value = dict["OversoldFactor"] as? Int32 {
                self.oversoldFactor = value
            }
            if let value = dict["RuleList"] as? [String: Any?] {
                var model = GetScalingRulesResponseBody.Data.RuleList()
                model.fromMap(value)
                self.ruleList = model
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var code: Int32?

    public var data: GetScalingRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var updateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetScalingRulesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UpdateTime"] as? Int64 {
            self.updateTime = value
        }
    }
}

public class GetScalingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetScalingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetScalingRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSecureTokenRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class GetSecureTokenResponseBody : Tea.TeaModel {
    public class SecureToken : Tea.TeaModel {
        public var accessKey: String?

        public var addressServerHost: String?

        public var belongRegion: String?

        public var description_: String?

        public var edasId: String?

        public var id: Int64?

        public var mseInstanceId: String?

        public var mseInternetAddress: String?

        public var mseIntranetAddress: String?

        public var mseRegistryType: String?

        public var regionId: String?

        public var regionName: String?

        public var secretKey: String?

        public var tenantId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKey != nil {
                map["AccessKey"] = self.accessKey!
            }
            if self.addressServerHost != nil {
                map["AddressServerHost"] = self.addressServerHost!
            }
            if self.belongRegion != nil {
                map["BelongRegion"] = self.belongRegion!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.edasId != nil {
                map["EdasId"] = self.edasId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mseInstanceId != nil {
                map["MseInstanceId"] = self.mseInstanceId!
            }
            if self.mseInternetAddress != nil {
                map["MseInternetAddress"] = self.mseInternetAddress!
            }
            if self.mseIntranetAddress != nil {
                map["MseIntranetAddress"] = self.mseIntranetAddress!
            }
            if self.mseRegistryType != nil {
                map["MseRegistryType"] = self.mseRegistryType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.secretKey != nil {
                map["SecretKey"] = self.secretKey!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessKey"] as? String {
                self.accessKey = value
            }
            if let value = dict["AddressServerHost"] as? String {
                self.addressServerHost = value
            }
            if let value = dict["BelongRegion"] as? String {
                self.belongRegion = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EdasId"] as? String {
                self.edasId = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["MseInstanceId"] as? String {
                self.mseInstanceId = value
            }
            if let value = dict["MseInternetAddress"] as? String {
                self.mseInternetAddress = value
            }
            if let value = dict["MseIntranetAddress"] as? String {
                self.mseIntranetAddress = value
            }
            if let value = dict["MseRegistryType"] as? String {
                self.mseRegistryType = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RegionName"] as? String {
                self.regionName = value
            }
            if let value = dict["SecretKey"] as? String {
                self.secretKey = value
            }
            if let value = dict["TenantId"] as? String {
                self.tenantId = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var secureToken: GetSecureTokenResponseBody.SecureToken?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.secureToken?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.secureToken != nil {
            map["SecureToken"] = self.secureToken?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecureToken"] as? [String: Any?] {
            var model = GetSecureTokenResponseBody.SecureToken()
            model.fromMap(value)
            self.secureToken = model
        }
    }
}

public class GetSecureTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSecureTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSecureTokenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetServiceConsumersPageRequest : Tea.TeaModel {
    public var appId: String?

    public var group: String?

    public var ip: String?

    public var namespace: String?

    public var origin: String?

    public var page: Int32?

    public var region: String?

    public var registryType: String?

    public var serviceId: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public var size: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.group != nil {
            map["group"] = self.group!
        }
        if self.ip != nil {
            map["ip"] = self.ip!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.registryType != nil {
            map["registryType"] = self.registryType!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["serviceVersion"] = self.serviceVersion!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["appId"] as? String {
            self.appId = value
        }
        if let value = dict["group"] as? String {
            self.group = value
        }
        if let value = dict["ip"] as? String {
            self.ip = value
        }
        if let value = dict["namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["origin"] as? String {
            self.origin = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["region"] as? String {
            self.region = value
        }
        if let value = dict["registryType"] as? String {
            self.registryType = value
        }
        if let value = dict["serviceId"] as? String {
            self.serviceId = value
        }
        if let value = dict["serviceName"] as? String {
            self.serviceName = value
        }
        if let value = dict["serviceType"] as? String {
            self.serviceType = value
        }
        if let value = dict["serviceVersion"] as? String {
            self.serviceVersion = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["source"] as? String {
            self.source = value
        }
    }
}

public class GetServiceConsumersPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public var edasAppName: String?

            public var edassAppId: String?

            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.edasAppName != nil {
                    map["EdasAppName"] = self.edasAppName!
                }
                if self.edassAppId != nil {
                    map["EdassAppId"] = self.edassAppId!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EdasAppName"] as? String {
                    self.edasAppName = value
                }
                if let value = dict["EdassAppId"] as? String {
                    self.edassAppId = value
                }
                if let value = dict["Ip"] as? String {
                    self.ip = value
                }
            }
        }
        public var content: [GetServiceConsumersPageResponseBody.Data.Content]?

        public var size: Int32?

        public var totalElements: Int32?

        public var totalPages: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["Content"] = tmp
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.totalElements != nil {
                map["TotalElements"] = self.totalElements!
            }
            if self.totalPages != nil {
                map["TotalPages"] = self.totalPages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? [Any?] {
                var tmp : [GetServiceConsumersPageResponseBody.Data.Content] = []
                for v in value {
                    if v != nil {
                        var model = GetServiceConsumersPageResponseBody.Data.Content()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.content = tmp
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["TotalElements"] as? Int32 {
                self.totalElements = value
            }
            if let value = dict["TotalPages"] as? Int32 {
                self.totalPages = value
            }
        }
    }
    public var code: Int32?

    public var data: GetServiceConsumersPageResponseBody.Data?

    public var message: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetServiceConsumersPageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetServiceConsumersPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceConsumersPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetServiceConsumersPageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetServiceDetailRequest : Tea.TeaModel {
    public var appId: String?

    public var group: String?

    public var ip: String?

    public var namespace: String?

    public var origin: String?

    public var region: String?

    public var registryType: String?

    public var serviceId: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.group != nil {
            map["group"] = self.group!
        }
        if self.ip != nil {
            map["ip"] = self.ip!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.registryType != nil {
            map["registryType"] = self.registryType!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["serviceVersion"] = self.serviceVersion!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["appId"] as? String {
            self.appId = value
        }
        if let value = dict["group"] as? String {
            self.group = value
        }
        if let value = dict["ip"] as? String {
            self.ip = value
        }
        if let value = dict["namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["origin"] as? String {
            self.origin = value
        }
        if let value = dict["region"] as? String {
            self.region = value
        }
        if let value = dict["registryType"] as? String {
            self.registryType = value
        }
        if let value = dict["serviceId"] as? String {
            self.serviceId = value
        }
        if let value = dict["serviceName"] as? String {
            self.serviceName = value
        }
        if let value = dict["serviceType"] as? String {
            self.serviceType = value
        }
        if let value = dict["serviceVersion"] as? String {
            self.serviceVersion = value
        }
        if let value = dict["source"] as? String {
            self.source = value
        }
    }
}

public class GetServiceDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Methods : Tea.TeaModel {
            public class ReturnDefinition : Tea.TeaModel {
                public var id: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Id"] as? String {
                        self.id = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var methodController: String?

            public var name: String?

            public var nameDetail: String?

            public var parameterDefinitions: String?

            public var parameterDetails: String?

            public var parameterNames: String?

            public var parameterTypes: String?

            public var paths: String?

            public var requestMethods: String?

            public var returnDefinition: GetServiceDetailResponseBody.Data.Methods.ReturnDefinition?

            public var returnDetails: String?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.returnDefinition?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameDetail != nil {
                    map["NameDetail"] = self.nameDetail!
                }
                if self.parameterDefinitions != nil {
                    map["ParameterDefinitions"] = self.parameterDefinitions!
                }
                if self.parameterDetails != nil {
                    map["ParameterDetails"] = self.parameterDetails!
                }
                if self.parameterNames != nil {
                    map["ParameterNames"] = self.parameterNames!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnDefinition != nil {
                    map["ReturnDefinition"] = self.returnDefinition?.toMap()
                }
                if self.returnDetails != nil {
                    map["ReturnDetails"] = self.returnDetails!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MethodController"] as? String {
                    self.methodController = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NameDetail"] as? String {
                    self.nameDetail = value
                }
                if let value = dict["ParameterDefinitions"] as? String {
                    self.parameterDefinitions = value
                }
                if let value = dict["ParameterDetails"] as? String {
                    self.parameterDetails = value
                }
                if let value = dict["ParameterNames"] as? String {
                    self.parameterNames = value
                }
                if let value = dict["ParameterTypes"] as? String {
                    self.parameterTypes = value
                }
                if let value = dict["Paths"] as? String {
                    self.paths = value
                }
                if let value = dict["RequestMethods"] as? String {
                    self.requestMethods = value
                }
                if let value = dict["ReturnDefinition"] as? [String: Any?] {
                    var model = GetServiceDetailResponseBody.Data.Methods.ReturnDefinition()
                    model.fromMap(value)
                    self.returnDefinition = model
                }
                if let value = dict["ReturnDetails"] as? String {
                    self.returnDetails = value
                }
                if let value = dict["ReturnType"] as? String {
                    self.returnType = value
                }
            }
        }
        public var dubboApplicationName: String?

        public var edasAppName: String?

        public var group: String?

        public var metadata: String?

        public var methods: [GetServiceDetailResponseBody.Data.Methods]?

        public var registryType: String?

        public var serviceName: String?

        public var serviceType: String?

        public var springApplicationName: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dubboApplicationName != nil {
                map["DubboApplicationName"] = self.dubboApplicationName!
            }
            if self.edasAppName != nil {
                map["EdasAppName"] = self.edasAppName!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.methods != nil {
                var tmp : [Any] = []
                for k in self.methods! {
                    tmp.append(k.toMap())
                }
                map["Methods"] = tmp
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.springApplicationName != nil {
                map["SpringApplicationName"] = self.springApplicationName!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DubboApplicationName"] as? String {
                self.dubboApplicationName = value
            }
            if let value = dict["EdasAppName"] as? String {
                self.edasAppName = value
            }
            if let value = dict["Group"] as? String {
                self.group = value
            }
            if let value = dict["Metadata"] as? String {
                self.metadata = value
            }
            if let value = dict["Methods"] as? [Any?] {
                var tmp : [GetServiceDetailResponseBody.Data.Methods] = []
                for v in value {
                    if v != nil {
                        var model = GetServiceDetailResponseBody.Data.Methods()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.methods = tmp
            }
            if let value = dict["RegistryType"] as? String {
                self.registryType = value
            }
            if let value = dict["ServiceName"] as? String {
                self.serviceName = value
            }
            if let value = dict["ServiceType"] as? String {
                self.serviceType = value
            }
            if let value = dict["SpringApplicationName"] as? String {
                self.springApplicationName = value
            }
            if let value = dict["Version"] as? String {
                self.version = value
            }
        }
    }
    public var code: Int32?

    public var data: GetServiceDetailResponseBody.Data?

    public var message: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetServiceDetailResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetServiceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetServiceDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetServiceListPageRequest : Tea.TeaModel {
    public var namespace: String?

    public var origin: String?

    public var page: Int32?

    public var region: String?

    public var searchType: String?

    public var searchValue: String?

    public var serviceType: String?

    public var side: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.searchType != nil {
            map["searchType"] = self.searchType!
        }
        if self.searchValue != nil {
            map["searchValue"] = self.searchValue!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.side != nil {
            map["side"] = self.side!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["origin"] as? String {
            self.origin = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["region"] as? String {
            self.region = value
        }
        if let value = dict["searchType"] as? String {
            self.searchType = value
        }
        if let value = dict["searchValue"] as? String {
            self.searchValue = value
        }
        if let value = dict["serviceType"] as? String {
            self.serviceType = value
        }
        if let value = dict["side"] as? String {
            self.side = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class GetServiceListPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public var edasAppId: String?

            public var edasAppName: String?

            public var group: String?

            public var instanceNum: Int32?

            public var registerType: String?

            public var serviceId: String?

            public var serviceName: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.edasAppId != nil {
                    map["EdasAppId"] = self.edasAppId!
                }
                if self.edasAppName != nil {
                    map["EdasAppName"] = self.edasAppName!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                if self.instanceNum != nil {
                    map["InstanceNum"] = self.instanceNum!
                }
                if self.registerType != nil {
                    map["RegisterType"] = self.registerType!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EdasAppId"] as? String {
                    self.edasAppId = value
                }
                if let value = dict["EdasAppName"] as? String {
                    self.edasAppName = value
                }
                if let value = dict["Group"] as? String {
                    self.group = value
                }
                if let value = dict["InstanceNum"] as? Int32 {
                    self.instanceNum = value
                }
                if let value = dict["RegisterType"] as? String {
                    self.registerType = value
                }
                if let value = dict["ServiceId"] as? String {
                    self.serviceId = value
                }
                if let value = dict["ServiceName"] as? String {
                    self.serviceName = value
                }
                if let value = dict["Version"] as? String {
                    self.version = value
                }
            }
        }
        public var content: [GetServiceListPageResponseBody.Data.Content]?

        public var size: Int32?

        public var totalElements: Int32?

        public var totalPages: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["Content"] = tmp
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.totalElements != nil {
                map["TotalElements"] = self.totalElements!
            }
            if self.totalPages != nil {
                map["TotalPages"] = self.totalPages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? [Any?] {
                var tmp : [GetServiceListPageResponseBody.Data.Content] = []
                for v in value {
                    if v != nil {
                        var model = GetServiceListPageResponseBody.Data.Content()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.content = tmp
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["TotalElements"] as? Int32 {
                self.totalElements = value
            }
            if let value = dict["TotalPages"] as? Int32 {
                self.totalPages = value
            }
        }
    }
    public var code: Int32?

    public var data: GetServiceListPageResponseBody.Data?

    public var message: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetServiceListPageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetServiceListPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetServiceListPageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetServiceMethodPageRequest : Tea.TeaModel {
    public var appId: String?

    public var group: String?

    public var ip: String?

    public var methodController: String?

    public var name: String?

    public var namespace: String?

    public var origin: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var path: String?

    public var region: String?

    public var registryType: String?

    public var serviceId: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.group != nil {
            map["group"] = self.group!
        }
        if self.ip != nil {
            map["ip"] = self.ip!
        }
        if self.methodController != nil {
            map["methodController"] = self.methodController!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.registryType != nil {
            map["registryType"] = self.registryType!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["serviceVersion"] = self.serviceVersion!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["appId"] as? String {
            self.appId = value
        }
        if let value = dict["group"] as? String {
            self.group = value
        }
        if let value = dict["ip"] as? String {
            self.ip = value
        }
        if let value = dict["methodController"] as? String {
            self.methodController = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["origin"] as? String {
            self.origin = value
        }
        if let value = dict["pageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["pageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["path"] as? String {
            self.path = value
        }
        if let value = dict["region"] as? String {
            self.region = value
        }
        if let value = dict["registryType"] as? String {
            self.registryType = value
        }
        if let value = dict["serviceId"] as? String {
            self.serviceId = value
        }
        if let value = dict["serviceName"] as? String {
            self.serviceName = value
        }
        if let value = dict["serviceType"] as? String {
            self.serviceType = value
        }
        if let value = dict["serviceVersion"] as? String {
            self.serviceVersion = value
        }
        if let value = dict["source"] as? String {
            self.source = value
        }
    }
}

public class GetServiceMethodPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class ReturnDefinition : Tea.TeaModel {
                public var id: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Id"] as? String {
                        self.id = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var methodController: String?

            public var name: String?

            public var nameDetail: String?

            public var parameterDefinitions: String?

            public var parameterDetails: String?

            public var parameterNames: String?

            public var parameterTypes: String?

            public var paths: String?

            public var requestMethods: String?

            public var returnDefinition: GetServiceMethodPageResponseBody.Data.Result.ReturnDefinition?

            public var returnDetails: String?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.returnDefinition?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameDetail != nil {
                    map["NameDetail"] = self.nameDetail!
                }
                if self.parameterDefinitions != nil {
                    map["ParameterDefinitions"] = self.parameterDefinitions!
                }
                if self.parameterDetails != nil {
                    map["ParameterDetails"] = self.parameterDetails!
                }
                if self.parameterNames != nil {
                    map["ParameterNames"] = self.parameterNames!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnDefinition != nil {
                    map["ReturnDefinition"] = self.returnDefinition?.toMap()
                }
                if self.returnDetails != nil {
                    map["ReturnDetails"] = self.returnDetails!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MethodController"] as? String {
                    self.methodController = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NameDetail"] as? String {
                    self.nameDetail = value
                }
                if let value = dict["ParameterDefinitions"] as? String {
                    self.parameterDefinitions = value
                }
                if let value = dict["ParameterDetails"] as? String {
                    self.parameterDetails = value
                }
                if let value = dict["ParameterNames"] as? String {
                    self.parameterNames = value
                }
                if let value = dict["ParameterTypes"] as? String {
                    self.parameterTypes = value
                }
                if let value = dict["Paths"] as? String {
                    self.paths = value
                }
                if let value = dict["RequestMethods"] as? String {
                    self.requestMethods = value
                }
                if let value = dict["ReturnDefinition"] as? [String: Any?] {
                    var model = GetServiceMethodPageResponseBody.Data.Result.ReturnDefinition()
                    model.fromMap(value)
                    self.returnDefinition = model
                }
                if let value = dict["ReturnDetails"] as? String {
                    self.returnDetails = value
                }
                if let value = dict["ReturnType"] as? String {
                    self.returnType = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GetServiceMethodPageResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [GetServiceMethodPageResponseBody.Data.Result] = []
                for v in value {
                    if v != nil {
                        var model = GetServiceMethodPageResponseBody.Data.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: GetServiceMethodPageResponseBody.Data?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetServiceMethodPageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpCode"] as? String {
            self.httpCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetServiceMethodPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceMethodPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetServiceMethodPageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetServiceProvidersPageRequest : Tea.TeaModel {
    public var appId: String?

    public var group: String?

    public var ip: String?

    public var namespace: String?

    public var origin: String?

    public var page: Int32?

    public var region: String?

    public var registryType: String?

    public var serviceId: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public var size: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.group != nil {
            map["group"] = self.group!
        }
        if self.ip != nil {
            map["ip"] = self.ip!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.origin != nil {
            map["origin"] = self.origin!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.registryType != nil {
            map["registryType"] = self.registryType!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["serviceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["serviceVersion"] = self.serviceVersion!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["appId"] as? String {
            self.appId = value
        }
        if let value = dict["group"] as? String {
            self.group = value
        }
        if let value = dict["ip"] as? String {
            self.ip = value
        }
        if let value = dict["namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["origin"] as? String {
            self.origin = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["region"] as? String {
            self.region = value
        }
        if let value = dict["registryType"] as? String {
            self.registryType = value
        }
        if let value = dict["serviceId"] as? String {
            self.serviceId = value
        }
        if let value = dict["serviceName"] as? String {
            self.serviceName = value
        }
        if let value = dict["serviceType"] as? String {
            self.serviceType = value
        }
        if let value = dict["serviceVersion"] as? String {
            self.serviceVersion = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["source"] as? String {
            self.source = value
        }
    }
}

public class GetServiceProvidersPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public var iannotations: String?

            public var ip: String?

            public var port: String?

            public var serializeType: String?

            public var timeout: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.iannotations != nil {
                    map["Iannotations"] = self.iannotations!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serializeType != nil {
                    map["SerializeType"] = self.serializeType!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Iannotations"] as? String {
                    self.iannotations = value
                }
                if let value = dict["Ip"] as? String {
                    self.ip = value
                }
                if let value = dict["Port"] as? String {
                    self.port = value
                }
                if let value = dict["SerializeType"] as? String {
                    self.serializeType = value
                }
                if let value = dict["Timeout"] as? String {
                    self.timeout = value
                }
            }
        }
        public var content: [GetServiceProvidersPageResponseBody.Data.Content]?

        public var size: Int32?

        public var totalElements: Int32?

        public var totalPages: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["Content"] = tmp
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.totalElements != nil {
                map["TotalElements"] = self.totalElements!
            }
            if self.totalPages != nil {
                map["TotalPages"] = self.totalPages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? [Any?] {
                var tmp : [GetServiceProvidersPageResponseBody.Data.Content] = []
                for v in value {
                    if v != nil {
                        var model = GetServiceProvidersPageResponseBody.Data.Content()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.content = tmp
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["TotalElements"] as? Int32 {
                self.totalElements = value
            }
            if let value = dict["TotalPages"] as? Int32 {
                self.totalPages = value
            }
        }
    }
    public var code: Int32?

    public var data: GetServiceProvidersPageResponseBody.Data?

    public var message: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetServiceProvidersPageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetServiceProvidersPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceProvidersPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetServiceProvidersPageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWebContainerConfigRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class GetWebContainerConfigResponseBody : Tea.TeaModel {
    public class WebContainerConfig : Tea.TeaModel {
        public var contextInputType: String?

        public var contextPath: String?

        public var httpPort: Int32?

        public var maxThreads: Int32?

        public var serverXml: String?

        public var uriEncoding: String?

        public var useAdvancedServerXml: Bool?

        public var useBodyEncoding: Bool?

        public var useDefaultConfig: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contextInputType != nil {
                map["ContextInputType"] = self.contextInputType!
            }
            if self.contextPath != nil {
                map["ContextPath"] = self.contextPath!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.maxThreads != nil {
                map["MaxThreads"] = self.maxThreads!
            }
            if self.serverXml != nil {
                map["ServerXml"] = self.serverXml!
            }
            if self.uriEncoding != nil {
                map["UriEncoding"] = self.uriEncoding!
            }
            if self.useAdvancedServerXml != nil {
                map["UseAdvancedServerXml"] = self.useAdvancedServerXml!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            if self.useDefaultConfig != nil {
                map["UseDefaultConfig"] = self.useDefaultConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ContextInputType"] as? String {
                self.contextInputType = value
            }
            if let value = dict["ContextPath"] as? String {
                self.contextPath = value
            }
            if let value = dict["HttpPort"] as? Int32 {
                self.httpPort = value
            }
            if let value = dict["MaxThreads"] as? Int32 {
                self.maxThreads = value
            }
            if let value = dict["ServerXml"] as? String {
                self.serverXml = value
            }
            if let value = dict["UriEncoding"] as? String {
                self.uriEncoding = value
            }
            if let value = dict["UseAdvancedServerXml"] as? Bool {
                self.useAdvancedServerXml = value
            }
            if let value = dict["UseBodyEncoding"] as? Bool {
                self.useBodyEncoding = value
            }
            if let value = dict["UseDefaultConfig"] as? Bool {
                self.useDefaultConfig = value
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var webContainerConfig: GetWebContainerConfigResponseBody.WebContainerConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webContainerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.webContainerConfig != nil {
            map["WebContainerConfig"] = self.webContainerConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["WebContainerConfig"] as? [String: Any?] {
            var model = GetWebContainerConfigResponseBody.WebContainerConfig()
            model.fromMap(value)
            self.webContainerConfig = model
        }
    }
}

public class GetWebContainerConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWebContainerConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWebContainerConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ImportK8sClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public var enableAsm: Bool?

    public var mode: Int32?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.enableAsm != nil {
            map["EnableAsm"] = self.enableAsm!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["EnableAsm"] as? Bool {
            self.enableAsm = value
        }
        if let value = dict["Mode"] as? Int32 {
            self.mode = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class ImportK8sClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ImportK8sClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportK8sClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ImportK8sClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertApplicationRequest : Tea.TeaModel {
    public var applicationName: String?

    public var buildPackId: Int32?

    public var clusterId: String?

    public var componentIds: String?

    public var cpu: Int32?

    public var description_: String?

    public var ecuInfo: String?

    public var enablePortCheck: Bool?

    public var enableUrlCheck: Bool?

    public var healthCheckUrl: String?

    public var hooks: String?

    public var jdk: String?

    public var jvmOptions: String?

    public var logicalRegionId: String?

    public var maxHeapSize: Int32?

    public var maxPermSize: Int32?

    public var mem: Int32?

    public var minHeapSize: Int32?

    public var packageType: String?

    public var reservedPortStr: String?

    public var resourceGroupId: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentIds != nil {
            map["ComponentIds"] = self.componentIds!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ecuInfo != nil {
            map["EcuInfo"] = self.ecuInfo!
        }
        if self.enablePortCheck != nil {
            map["EnablePortCheck"] = self.enablePortCheck!
        }
        if self.enableUrlCheck != nil {
            map["EnableUrlCheck"] = self.enableUrlCheck!
        }
        if self.healthCheckUrl != nil {
            map["HealthCheckUrl"] = self.healthCheckUrl!
        }
        if self.hooks != nil {
            map["Hooks"] = self.hooks!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.jvmOptions != nil {
            map["JvmOptions"] = self.jvmOptions!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.maxHeapSize != nil {
            map["MaxHeapSize"] = self.maxHeapSize!
        }
        if self.maxPermSize != nil {
            map["MaxPermSize"] = self.maxPermSize!
        }
        if self.mem != nil {
            map["Mem"] = self.mem!
        }
        if self.minHeapSize != nil {
            map["MinHeapSize"] = self.minHeapSize!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.reservedPortStr != nil {
            map["ReservedPortStr"] = self.reservedPortStr!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["BuildPackId"] as? Int32 {
            self.buildPackId = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["ComponentIds"] as? String {
            self.componentIds = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EcuInfo"] as? String {
            self.ecuInfo = value
        }
        if let value = dict["EnablePortCheck"] as? Bool {
            self.enablePortCheck = value
        }
        if let value = dict["EnableUrlCheck"] as? Bool {
            self.enableUrlCheck = value
        }
        if let value = dict["HealthCheckUrl"] as? String {
            self.healthCheckUrl = value
        }
        if let value = dict["Hooks"] as? String {
            self.hooks = value
        }
        if let value = dict["Jdk"] as? String {
            self.jdk = value
        }
        if let value = dict["JvmOptions"] as? String {
            self.jvmOptions = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
        if let value = dict["MaxHeapSize"] as? Int32 {
            self.maxHeapSize = value
        }
        if let value = dict["MaxPermSize"] as? Int32 {
            self.maxPermSize = value
        }
        if let value = dict["Mem"] as? Int32 {
            self.mem = value
        }
        if let value = dict["MinHeapSize"] as? Int32 {
            self.minHeapSize = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["ReservedPortStr"] as? String {
            self.reservedPortStr = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["WebContainer"] as? String {
            self.webContainer = value
        }
    }
}

public class InsertApplicationResponseBody : Tea.TeaModel {
    public class ApplicationInfo : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var changeOrderId: String?

        public var dockerize: Bool?

        public var owner: String?

        public var port: Int32?

        public var regionName: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.dockerize != nil {
                map["Dockerize"] = self.dockerize!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
            if let value = dict["Dockerize"] as? Bool {
                self.dockerize = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["RegionName"] as? String {
                self.regionName = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var applicationInfo: InsertApplicationResponseBody.ApplicationInfo?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationInfo != nil {
            map["ApplicationInfo"] = self.applicationInfo?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationInfo"] as? [String: Any?] {
            var model = InsertApplicationResponseBody.ApplicationInfo()
            model.fromMap(value)
            self.applicationInfo = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InsertApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertClusterRequest : Tea.TeaModel {
    public var clusterName: String?

    public var clusterType: Int32?

    public var iaasProvider: String?

    public var logicalRegionId: String?

    public var networkMode: Int32?

    public var oversoldFactor: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.iaasProvider != nil {
            map["IaasProvider"] = self.iaasProvider!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.networkMode != nil {
            map["NetworkMode"] = self.networkMode!
        }
        if self.oversoldFactor != nil {
            map["OversoldFactor"] = self.oversoldFactor!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterName"] as? String {
            self.clusterName = value
        }
        if let value = dict["ClusterType"] as? Int32 {
            self.clusterType = value
        }
        if let value = dict["IaasProvider"] as? String {
            self.iaasProvider = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
        if let value = dict["NetworkMode"] as? Int32 {
            self.networkMode = value
        }
        if let value = dict["OversoldFactor"] as? Int32 {
            self.oversoldFactor = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class InsertClusterResponseBody : Tea.TeaModel {
    public class Cluster : Tea.TeaModel {
        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: Int32?

        public var iaasProvider: String?

        public var networkMode: Int32?

        public var oversoldFactor: Int32?

        public var regionId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.iaasProvider != nil {
                map["IaasProvider"] = self.iaasProvider!
            }
            if self.networkMode != nil {
                map["NetworkMode"] = self.networkMode!
            }
            if self.oversoldFactor != nil {
                map["OversoldFactor"] = self.oversoldFactor!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["ClusterName"] as? String {
                self.clusterName = value
            }
            if let value = dict["ClusterType"] as? Int32 {
                self.clusterType = value
            }
            if let value = dict["IaasProvider"] as? String {
                self.iaasProvider = value
            }
            if let value = dict["NetworkMode"] as? Int32 {
                self.networkMode = value
            }
            if let value = dict["OversoldFactor"] as? Int32 {
                self.oversoldFactor = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var cluster: InsertClusterResponseBody.Cluster?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cluster?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cluster != nil {
            map["Cluster"] = self.cluster?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cluster"] as? [String: Any?] {
            var model = InsertClusterResponseBody.Cluster()
            model.fromMap(value)
            self.cluster = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InsertClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertClusterMemberRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceIds: String?

    public var password: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["clusterId"] = self.clusterId!
        }
        if self.instanceIds != nil {
            map["instanceIds"] = self.instanceIds!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["instanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["password"] as? String {
            self.password = value
        }
    }
}

public class InsertClusterMemberResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InsertClusterMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertClusterMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertClusterMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertDeployGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var groupName: String?

    public var initPackageVersionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.initPackageVersionId != nil {
            map["InitPackageVersionId"] = self.initPackageVersionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["InitPackageVersionId"] as? String {
            self.initPackageVersionId = value
        }
    }
}

public class InsertDeployGroupResponseBody : Tea.TeaModel {
    public class DeployGroupEntity : Tea.TeaModel {
        public var appId: String?

        public var appVersionId: String?

        public var clusterId: String?

        public var createTime: Int64?

        public var groupName: String?

        public var groupType: Int32?

        public var id: String?

        public var packageVersionId: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appVersionId != nil {
                map["AppVersionId"] = self.appVersionId!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.packageVersionId != nil {
                map["PackageVersionId"] = self.packageVersionId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppVersionId"] as? String {
                self.appVersionId = value
            }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["GroupType"] as? Int32 {
                self.groupType = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["PackageVersionId"] as? String {
                self.packageVersionId = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var code: Int32?

    public var deployGroupEntity: InsertDeployGroupResponseBody.DeployGroupEntity?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployGroupEntity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.deployGroupEntity != nil {
            map["DeployGroupEntity"] = self.deployGroupEntity?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["DeployGroupEntity"] as? [String: Any?] {
            var model = InsertDeployGroupResponseBody.DeployGroupEntity()
            model.fromMap(value)
            self.deployGroupEntity = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InsertDeployGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertDeployGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertDeployGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertK8sApplicationRequest : Tea.TeaModel {
    public var annotations: String?

    public var appConfig: String?

    public var appName: String?

    public var appTemplateName: String?

    public var applicationDescription: String?

    public var buildPackId: String?

    public var clusterId: String?

    public var command: String?

    public var commandArgs: String?

    public var configMountDescs: String?

    public var containerRegistryId: String?

    public var csClusterId: String?

    public var customAffinity: String?

    public var customAgentVersion: String?

    public var customTolerations: String?

    public var deployAcrossNodes: String?

    public var deployAcrossZones: String?

    public var edasContainerVersion: String?

    public var emptyDirs: String?

    public var enableAhas: Bool?

    public var enableAsm: Bool?

    public var enableEmptyPushReject: Bool?

    public var enableLosslessRule: Bool?

    public var envFroms: String?

    public var envs: String?

    public var featureConfig: String?

    public var imagePlatforms: String?

    public var imageUrl: String?

    public var initContainers: String?

    public var internetSlbId: String?

    public var internetSlbPort: Int32?

    public var internetSlbProtocol: String?

    public var internetTargetPort: Int32?

    public var intranetSlbId: String?

    public var intranetSlbPort: Int32?

    public var intranetSlbProtocol: String?

    public var intranetTargetPort: Int32?

    public var isMultilingualApp: Bool?

    public var JDK: String?

    public var javaStartUpConfig: String?

    public var labels: String?

    public var limitCpu: Int32?

    public var limitEphemeralStorage: Int32?

    public var limitMem: Int32?

    public var limitmCpu: Int32?

    public var liveness: String?

    public var localVolume: String?

    public var logicalRegionId: String?

    public var losslessRuleAligned: Bool?

    public var losslessRuleDelayTime: Int32?

    public var losslessRuleFuncType: Int32?

    public var losslessRuleRelated: Bool?

    public var losslessRuleWarmupTime: Int32?

    public var mountDescs: String?

    public var namespace: String?

    public var nasId: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var postStart: String?

    public var preStop: String?

    public var pvcMountDescs: String?

    public var readiness: String?

    public var replicas: Int32?

    public var repoId: String?

    public var requestsCpu: Int32?

    public var requestsEphemeralStorage: Int32?

    public var requestsMem: Int32?

    public var requestsmCpu: Int32?

    public var resourceGroupId: String?

    public var runtimeClassName: String?

    public var secretName: String?

    public var serviceConfigs: String?

    public var sidecars: String?

    public var slsConfigs: String?

    public var startup: String?

    public var storageType: String?

    public var terminateGracePeriod: Int32?

    public var timeout: Int32?

    public var uriEncoding: String?

    public var useBodyEncoding: Bool?

    public var userBaseImageUrl: String?

    public var webContainer: String?

    public var webContainerConfig: String?

    public var workloadType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.appConfig != nil {
            map["AppConfig"] = self.appConfig!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appTemplateName != nil {
            map["AppTemplateName"] = self.appTemplateName!
        }
        if self.applicationDescription != nil {
            map["ApplicationDescription"] = self.applicationDescription!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMountDescs != nil {
            map["ConfigMountDescs"] = self.configMountDescs!
        }
        if self.containerRegistryId != nil {
            map["ContainerRegistryId"] = self.containerRegistryId!
        }
        if self.csClusterId != nil {
            map["CsClusterId"] = self.csClusterId!
        }
        if self.customAffinity != nil {
            map["CustomAffinity"] = self.customAffinity!
        }
        if self.customAgentVersion != nil {
            map["CustomAgentVersion"] = self.customAgentVersion!
        }
        if self.customTolerations != nil {
            map["CustomTolerations"] = self.customTolerations!
        }
        if self.deployAcrossNodes != nil {
            map["DeployAcrossNodes"] = self.deployAcrossNodes!
        }
        if self.deployAcrossZones != nil {
            map["DeployAcrossZones"] = self.deployAcrossZones!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.emptyDirs != nil {
            map["EmptyDirs"] = self.emptyDirs!
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        if self.enableAsm != nil {
            map["EnableAsm"] = self.enableAsm!
        }
        if self.enableEmptyPushReject != nil {
            map["EnableEmptyPushReject"] = self.enableEmptyPushReject!
        }
        if self.enableLosslessRule != nil {
            map["EnableLosslessRule"] = self.enableLosslessRule!
        }
        if self.envFroms != nil {
            map["EnvFroms"] = self.envFroms!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.featureConfig != nil {
            map["FeatureConfig"] = self.featureConfig!
        }
        if self.imagePlatforms != nil {
            map["ImagePlatforms"] = self.imagePlatforms!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.initContainers != nil {
            map["InitContainers"] = self.initContainers!
        }
        if self.internetSlbId != nil {
            map["InternetSlbId"] = self.internetSlbId!
        }
        if self.internetSlbPort != nil {
            map["InternetSlbPort"] = self.internetSlbPort!
        }
        if self.internetSlbProtocol != nil {
            map["InternetSlbProtocol"] = self.internetSlbProtocol!
        }
        if self.internetTargetPort != nil {
            map["InternetTargetPort"] = self.internetTargetPort!
        }
        if self.intranetSlbId != nil {
            map["IntranetSlbId"] = self.intranetSlbId!
        }
        if self.intranetSlbPort != nil {
            map["IntranetSlbPort"] = self.intranetSlbPort!
        }
        if self.intranetSlbProtocol != nil {
            map["IntranetSlbProtocol"] = self.intranetSlbProtocol!
        }
        if self.intranetTargetPort != nil {
            map["IntranetTargetPort"] = self.intranetTargetPort!
        }
        if self.isMultilingualApp != nil {
            map["IsMultilingualApp"] = self.isMultilingualApp!
        }
        if self.JDK != nil {
            map["JDK"] = self.JDK!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.limitCpu != nil {
            map["LimitCpu"] = self.limitCpu!
        }
        if self.limitEphemeralStorage != nil {
            map["LimitEphemeralStorage"] = self.limitEphemeralStorage!
        }
        if self.limitMem != nil {
            map["LimitMem"] = self.limitMem!
        }
        if self.limitmCpu != nil {
            map["LimitmCpu"] = self.limitmCpu!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.localVolume != nil {
            map["LocalVolume"] = self.localVolume!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.losslessRuleAligned != nil {
            map["LosslessRuleAligned"] = self.losslessRuleAligned!
        }
        if self.losslessRuleDelayTime != nil {
            map["LosslessRuleDelayTime"] = self.losslessRuleDelayTime!
        }
        if self.losslessRuleFuncType != nil {
            map["LosslessRuleFuncType"] = self.losslessRuleFuncType!
        }
        if self.losslessRuleRelated != nil {
            map["LosslessRuleRelated"] = self.losslessRuleRelated!
        }
        if self.losslessRuleWarmupTime != nil {
            map["LosslessRuleWarmupTime"] = self.losslessRuleWarmupTime!
        }
        if self.mountDescs != nil {
            map["MountDescs"] = self.mountDescs!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.pvcMountDescs != nil {
            map["PvcMountDescs"] = self.pvcMountDescs!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.repoId != nil {
            map["RepoId"] = self.repoId!
        }
        if self.requestsCpu != nil {
            map["RequestsCpu"] = self.requestsCpu!
        }
        if self.requestsEphemeralStorage != nil {
            map["RequestsEphemeralStorage"] = self.requestsEphemeralStorage!
        }
        if self.requestsMem != nil {
            map["RequestsMem"] = self.requestsMem!
        }
        if self.requestsmCpu != nil {
            map["RequestsmCpu"] = self.requestsmCpu!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.runtimeClassName != nil {
            map["RuntimeClassName"] = self.runtimeClassName!
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        if self.serviceConfigs != nil {
            map["ServiceConfigs"] = self.serviceConfigs!
        }
        if self.sidecars != nil {
            map["Sidecars"] = self.sidecars!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.startup != nil {
            map["Startup"] = self.startup!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        if self.terminateGracePeriod != nil {
            map["TerminateGracePeriod"] = self.terminateGracePeriod!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.uriEncoding != nil {
            map["UriEncoding"] = self.uriEncoding!
        }
        if self.useBodyEncoding != nil {
            map["UseBodyEncoding"] = self.useBodyEncoding!
        }
        if self.userBaseImageUrl != nil {
            map["UserBaseImageUrl"] = self.userBaseImageUrl!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        if self.webContainerConfig != nil {
            map["WebContainerConfig"] = self.webContainerConfig!
        }
        if self.workloadType != nil {
            map["WorkloadType"] = self.workloadType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Annotations"] as? String {
            self.annotations = value
        }
        if let value = dict["AppConfig"] as? String {
            self.appConfig = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AppTemplateName"] as? String {
            self.appTemplateName = value
        }
        if let value = dict["ApplicationDescription"] as? String {
            self.applicationDescription = value
        }
        if let value = dict["BuildPackId"] as? String {
            self.buildPackId = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["ConfigMountDescs"] as? String {
            self.configMountDescs = value
        }
        if let value = dict["ContainerRegistryId"] as? String {
            self.containerRegistryId = value
        }
        if let value = dict["CsClusterId"] as? String {
            self.csClusterId = value
        }
        if let value = dict["CustomAffinity"] as? String {
            self.customAffinity = value
        }
        if let value = dict["CustomAgentVersion"] as? String {
            self.customAgentVersion = value
        }
        if let value = dict["CustomTolerations"] as? String {
            self.customTolerations = value
        }
        if let value = dict["DeployAcrossNodes"] as? String {
            self.deployAcrossNodes = value
        }
        if let value = dict["DeployAcrossZones"] as? String {
            self.deployAcrossZones = value
        }
        if let value = dict["EdasContainerVersion"] as? String {
            self.edasContainerVersion = value
        }
        if let value = dict["EmptyDirs"] as? String {
            self.emptyDirs = value
        }
        if let value = dict["EnableAhas"] as? Bool {
            self.enableAhas = value
        }
        if let value = dict["EnableAsm"] as? Bool {
            self.enableAsm = value
        }
        if let value = dict["EnableEmptyPushReject"] as? Bool {
            self.enableEmptyPushReject = value
        }
        if let value = dict["EnableLosslessRule"] as? Bool {
            self.enableLosslessRule = value
        }
        if let value = dict["EnvFroms"] as? String {
            self.envFroms = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["FeatureConfig"] as? String {
            self.featureConfig = value
        }
        if let value = dict["ImagePlatforms"] as? String {
            self.imagePlatforms = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["InitContainers"] as? String {
            self.initContainers = value
        }
        if let value = dict["InternetSlbId"] as? String {
            self.internetSlbId = value
        }
        if let value = dict["InternetSlbPort"] as? Int32 {
            self.internetSlbPort = value
        }
        if let value = dict["InternetSlbProtocol"] as? String {
            self.internetSlbProtocol = value
        }
        if let value = dict["InternetTargetPort"] as? Int32 {
            self.internetTargetPort = value
        }
        if let value = dict["IntranetSlbId"] as? String {
            self.intranetSlbId = value
        }
        if let value = dict["IntranetSlbPort"] as? Int32 {
            self.intranetSlbPort = value
        }
        if let value = dict["IntranetSlbProtocol"] as? String {
            self.intranetSlbProtocol = value
        }
        if let value = dict["IntranetTargetPort"] as? Int32 {
            self.intranetTargetPort = value
        }
        if let value = dict["IsMultilingualApp"] as? Bool {
            self.isMultilingualApp = value
        }
        if let value = dict["JDK"] as? String {
            self.JDK = value
        }
        if let value = dict["JavaStartUpConfig"] as? String {
            self.javaStartUpConfig = value
        }
        if let value = dict["Labels"] as? String {
            self.labels = value
        }
        if let value = dict["LimitCpu"] as? Int32 {
            self.limitCpu = value
        }
        if let value = dict["LimitEphemeralStorage"] as? Int32 {
            self.limitEphemeralStorage = value
        }
        if let value = dict["LimitMem"] as? Int32 {
            self.limitMem = value
        }
        if let value = dict["LimitmCpu"] as? Int32 {
            self.limitmCpu = value
        }
        if let value = dict["Liveness"] as? String {
            self.liveness = value
        }
        if let value = dict["LocalVolume"] as? String {
            self.localVolume = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
        if let value = dict["LosslessRuleAligned"] as? Bool {
            self.losslessRuleAligned = value
        }
        if let value = dict["LosslessRuleDelayTime"] as? Int32 {
            self.losslessRuleDelayTime = value
        }
        if let value = dict["LosslessRuleFuncType"] as? Int32 {
            self.losslessRuleFuncType = value
        }
        if let value = dict["LosslessRuleRelated"] as? Bool {
            self.losslessRuleRelated = value
        }
        if let value = dict["LosslessRuleWarmupTime"] as? Int32 {
            self.losslessRuleWarmupTime = value
        }
        if let value = dict["MountDescs"] as? String {
            self.mountDescs = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["NasId"] as? String {
            self.nasId = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["PackageUrl"] as? String {
            self.packageUrl = value
        }
        if let value = dict["PackageVersion"] as? String {
            self.packageVersion = value
        }
        if let value = dict["PostStart"] as? String {
            self.postStart = value
        }
        if let value = dict["PreStop"] as? String {
            self.preStop = value
        }
        if let value = dict["PvcMountDescs"] as? String {
            self.pvcMountDescs = value
        }
        if let value = dict["Readiness"] as? String {
            self.readiness = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["RepoId"] as? String {
            self.repoId = value
        }
        if let value = dict["RequestsCpu"] as? Int32 {
            self.requestsCpu = value
        }
        if let value = dict["RequestsEphemeralStorage"] as? Int32 {
            self.requestsEphemeralStorage = value
        }
        if let value = dict["RequestsMem"] as? Int32 {
            self.requestsMem = value
        }
        if let value = dict["RequestsmCpu"] as? Int32 {
            self.requestsmCpu = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["RuntimeClassName"] as? String {
            self.runtimeClassName = value
        }
        if let value = dict["SecretName"] as? String {
            self.secretName = value
        }
        if let value = dict["ServiceConfigs"] as? String {
            self.serviceConfigs = value
        }
        if let value = dict["Sidecars"] as? String {
            self.sidecars = value
        }
        if let value = dict["SlsConfigs"] as? String {
            self.slsConfigs = value
        }
        if let value = dict["Startup"] as? String {
            self.startup = value
        }
        if let value = dict["StorageType"] as? String {
            self.storageType = value
        }
        if let value = dict["TerminateGracePeriod"] as? Int32 {
            self.terminateGracePeriod = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["UriEncoding"] as? String {
            self.uriEncoding = value
        }
        if let value = dict["UseBodyEncoding"] as? Bool {
            self.useBodyEncoding = value
        }
        if let value = dict["UserBaseImageUrl"] as? String {
            self.userBaseImageUrl = value
        }
        if let value = dict["WebContainer"] as? String {
            self.webContainer = value
        }
        if let value = dict["WebContainerConfig"] as? String {
            self.webContainerConfig = value
        }
        if let value = dict["WorkloadType"] as? String {
            self.workloadType = value
        }
    }
}

public class InsertK8sApplicationResponseBody : Tea.TeaModel {
    public class ApplicationInfo : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var changeOrderId: String?

        public var clusterType: Int32?

        public var dockerize: Bool?

        public var edasId: String?

        public var owner: String?

        public var regionId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.dockerize != nil {
                map["Dockerize"] = self.dockerize!
            }
            if self.edasId != nil {
                map["EdasId"] = self.edasId!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
            if let value = dict["ClusterType"] as? Int32 {
                self.clusterType = value
            }
            if let value = dict["Dockerize"] as? Bool {
                self.dockerize = value
            }
            if let value = dict["EdasId"] as? String {
                self.edasId = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var applicationInfo: InsertK8sApplicationResponseBody.ApplicationInfo?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationInfo != nil {
            map["ApplicationInfo"] = self.applicationInfo?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationInfo"] as? [String: Any?] {
            var model = InsertK8sApplicationResponseBody.ApplicationInfo()
            model.fromMap(value)
            self.applicationInfo = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InsertK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertK8sApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertOrUpdateRegionRequest : Tea.TeaModel {
    public var debugEnable: Bool?

    public var description_: String?

    public var id: Int64?

    public var mseInstanceId: String?

    public var regionName: String?

    public var regionTag: String?

    public var registryType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.debugEnable != nil {
            map["DebugEnable"] = self.debugEnable!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mseInstanceId != nil {
            map["MseInstanceId"] = self.mseInstanceId!
        }
        if self.regionName != nil {
            map["RegionName"] = self.regionName!
        }
        if self.regionTag != nil {
            map["RegionTag"] = self.regionTag!
        }
        if self.registryType != nil {
            map["RegistryType"] = self.registryType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DebugEnable"] as? Bool {
            self.debugEnable = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["MseInstanceId"] as? String {
            self.mseInstanceId = value
        }
        if let value = dict["RegionName"] as? String {
            self.regionName = value
        }
        if let value = dict["RegionTag"] as? String {
            self.regionTag = value
        }
        if let value = dict["RegistryType"] as? String {
            self.registryType = value
        }
    }
}

public class InsertOrUpdateRegionResponseBody : Tea.TeaModel {
    public class UserDefineRegionEntity : Tea.TeaModel {
        public var belongRegion: String?

        public var debugEnable: Bool?

        public var description_: String?

        public var id: Int64?

        public var regionId: String?

        public var regionName: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.belongRegion != nil {
                map["BelongRegion"] = self.belongRegion!
            }
            if self.debugEnable != nil {
                map["DebugEnable"] = self.debugEnable!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BelongRegion"] as? String {
                self.belongRegion = value
            }
            if let value = dict["DebugEnable"] as? Bool {
                self.debugEnable = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RegionName"] as? String {
                self.regionName = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var userDefineRegionEntity: InsertOrUpdateRegionResponseBody.UserDefineRegionEntity?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userDefineRegionEntity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userDefineRegionEntity != nil {
            map["UserDefineRegionEntity"] = self.userDefineRegionEntity?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UserDefineRegionEntity"] as? [String: Any?] {
            var model = InsertOrUpdateRegionResponseBody.UserDefineRegionEntity()
            model.fromMap(value)
            self.userDefineRegionEntity = model
        }
    }
}

public class InsertOrUpdateRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertOrUpdateRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertOrUpdateRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertRoleRequest : Tea.TeaModel {
    public var actionData: String?

    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionData != nil {
            map["ActionData"] = self.actionData!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActionData"] as? String {
            self.actionData = value
        }
        if let value = dict["RoleName"] as? String {
            self.roleName = value
        }
    }
}

public class InsertRoleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var roleId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RoleId"] as? Int32 {
            self.roleId = value
        }
    }
}

public class InsertRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertServiceGroupRequest : Tea.TeaModel {
    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
    }
}

public class InsertServiceGroupResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InsertServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertServiceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertSwimmingLaneRequest : Tea.TeaModel {
    public var appInfos: String?

    public var enableRules: Bool?

    public var entryRules: String?

    public var groupId: Int64?

    public var logicalRegionId: String?

    public var name: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfos != nil {
            map["AppInfos"] = self.appInfos!
        }
        if self.enableRules != nil {
            map["EnableRules"] = self.enableRules!
        }
        if self.entryRules != nil {
            map["EntryRules"] = self.entryRules!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppInfos"] as? String {
            self.appInfos = value
        }
        if let value = dict["EnableRules"] as? Bool {
            self.enableRules = value
        }
        if let value = dict["EntryRules"] as? String {
            self.entryRules = value
        }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Tag"] as? String {
            self.tag = value
        }
    }
}

public class InsertSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SwimmingLaneAppRelationShipList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var laneId: Int64?

            public var rules: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.laneId != nil {
                    map["LaneId"] = self.laneId!
                }
                if self.rules != nil {
                    map["Rules"] = self.rules!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["LaneId"] as? Int64 {
                    self.laneId = value
                }
                if let value = dict["Rules"] as? String {
                    self.rules = value
                }
            }
        }
        public var appInfos: String?

        public var entryRule: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public var swimmingLaneAppRelationShipList: [InsertSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList]?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appInfos != nil {
                map["AppInfos"] = self.appInfos!
            }
            if self.entryRule != nil {
                map["EntryRule"] = self.entryRule!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.swimmingLaneAppRelationShipList != nil {
                var tmp : [Any] = []
                for k in self.swimmingLaneAppRelationShipList! {
                    tmp.append(k.toMap())
                }
                map["SwimmingLaneAppRelationShipList"] = tmp
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppInfos"] as? String {
                self.appInfos = value
            }
            if let value = dict["EntryRule"] as? String {
                self.entryRule = value
            }
            if let value = dict["GroupId"] as? Int64 {
                self.groupId = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["SwimmingLaneAppRelationShipList"] as? [Any?] {
                var tmp : [InsertSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList] = []
                for v in value {
                    if v != nil {
                        var model = InsertSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.swimmingLaneAppRelationShipList = tmp
            }
            if let value = dict["Tag"] as? String {
                self.tag = value
            }
        }
    }
    public var code: Int32?

    public var data: InsertSwimmingLaneResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = InsertSwimmingLaneResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InsertSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertSwimmingLaneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InsertSwimmingLaneGroupRequest : Tea.TeaModel {
    public var appIds: String?

    public var entryApp: String?

    public var logicalRegionId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.entryApp != nil {
            map["EntryApp"] = self.entryApp!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIds"] as? String {
            self.appIds = value
        }
        if let value = dict["EntryApp"] as? String {
            self.entryApp = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class InsertSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApplicationList : Tea.TeaModel {
            public class Application : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppName"] as? String {
                        self.appName = value
                    }
                }
            }
            public var application: [InsertSwimmingLaneGroupResponseBody.Data.ApplicationList.Application]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.application != nil {
                    var tmp : [Any] = []
                    for k in self.application! {
                        tmp.append(k.toMap())
                    }
                    map["Application"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Application"] as? [Any?] {
                    var tmp : [InsertSwimmingLaneGroupResponseBody.Data.ApplicationList.Application] = []
                    for v in value {
                        if v != nil {
                            var model = InsertSwimmingLaneGroupResponseBody.Data.ApplicationList.Application()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.application = tmp
                }
            }
        }
        public class EntryApplication : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
            }
        }
        public var applicationList: InsertSwimmingLaneGroupResponseBody.Data.ApplicationList?

        public var entryApplication: InsertSwimmingLaneGroupResponseBody.Data.EntryApplication?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.applicationList?.validate()
            try self.entryApplication?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationList != nil {
                map["ApplicationList"] = self.applicationList?.toMap()
            }
            if self.entryApplication != nil {
                map["EntryApplication"] = self.entryApplication?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationList"] as? [String: Any?] {
                var model = InsertSwimmingLaneGroupResponseBody.Data.ApplicationList()
                model.fromMap(value)
                self.applicationList = model
            }
            if let value = dict["EntryApplication"] as? [String: Any?] {
                var model = InsertSwimmingLaneGroupResponseBody.Data.EntryApplication()
                model.fromMap(value)
                self.entryApplication = model
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
        }
    }
    public var code: Int32?

    public var data: InsertSwimmingLaneGroupResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = InsertSwimmingLaneGroupResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InsertSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InsertSwimmingLaneGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InstallAgentRequest : Tea.TeaModel {
    public var clusterId: String?

    public var doAsync: Bool?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.doAsync != nil {
            map["DoAsync"] = self.doAsync!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DoAsync"] as? Bool {
            self.doAsync = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
    }
}

public class InstallAgentResponseBody : Tea.TeaModel {
    public class ExecutionResultList : Tea.TeaModel {
        public class ExecutionResult : Tea.TeaModel {
            public var finishedTime: String?

            public var instanceId: String?

            public var invokeRecordStatus: String?

            public var status: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.invokeRecordStatus != nil {
                    map["InvokeRecordStatus"] = self.invokeRecordStatus!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FinishedTime"] as? String {
                    self.finishedTime = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InvokeRecordStatus"] as? String {
                    self.invokeRecordStatus = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var executionResult: [InstallAgentResponseBody.ExecutionResultList.ExecutionResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.executionResult != nil {
                var tmp : [Any] = []
                for k in self.executionResult! {
                    tmp.append(k.toMap())
                }
                map["ExecutionResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ExecutionResult"] as? [Any?] {
                var tmp : [InstallAgentResponseBody.ExecutionResultList.ExecutionResult] = []
                for v in value {
                    if v != nil {
                        var model = InstallAgentResponseBody.ExecutionResultList.ExecutionResult()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.executionResult = tmp
            }
        }
    }
    public var code: Int32?

    public var executionResultList: InstallAgentResponseBody.ExecutionResultList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.executionResultList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.executionResultList != nil {
            map["ExecutionResultList"] = self.executionResultList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["ExecutionResultList"] as? [String: Any?] {
            var model = InstallAgentResponseBody.ExecutionResultList()
            model.fromMap(value)
            self.executionResultList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InstallAgentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallAgentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InstallAgentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAliyunRegionResponseBody : Tea.TeaModel {
    public class RegionEntityList : Tea.TeaModel {
        public class RegionEntity : Tea.TeaModel {
            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var regionEntity: [ListAliyunRegionResponseBody.RegionEntityList.RegionEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.regionEntity != nil {
                var tmp : [Any] = []
                for k in self.regionEntity! {
                    tmp.append(k.toMap())
                }
                map["RegionEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RegionEntity"] as? [Any?] {
                var tmp : [ListAliyunRegionResponseBody.RegionEntityList.RegionEntity] = []
                for v in value {
                    if v != nil {
                        var model = ListAliyunRegionResponseBody.RegionEntityList.RegionEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.regionEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regionEntityList: ListAliyunRegionResponseBody.RegionEntityList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regionEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regionEntityList != nil {
            map["RegionEntityList"] = self.regionEntityList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RegionEntityList"] as? [String: Any?] {
            var model = ListAliyunRegionResponseBody.RegionEntityList()
            model.fromMap(value)
            self.regionEntityList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAliyunRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAliyunRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAliyunRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationRequest : Tea.TeaModel {
    public var appIds: String?

    public var appName: String?

    public var clusterId: String?

    public var currentPage: Int32?

    public var logicalRegionId: String?

    public var logicalRegionIdFilter: String?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.logicalRegionIdFilter != nil {
            map["LogicalRegionIdFilter"] = self.logicalRegionIdFilter!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIds"] as? String {
            self.appIds = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
        if let value = dict["LogicalRegionIdFilter"] as? String {
            self.logicalRegionIdFilter = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class ListApplicationResponseBody : Tea.TeaModel {
    public class ApplicationList : Tea.TeaModel {
        public class Application : Tea.TeaModel {
            public var appId: String?

            public var applicationType: String?

            public var buildPackageId: Int64?

            public var clusterId: String?

            public var clusterType: Int32?

            public var createTime: Int64?

            public var extSlbIp: String?

            public var extSlbListenerPort: Int32?

            public var instances: Int32?

            public var k8sNamespace: String?

            public var name: String?

            public var namespaceId: String?

            public var port: Int32?

            public var regionId: String?

            public var resourceGroupId: String?

            public var runningInstanceCount: Int32?

            public var slbIp: String?

            public var slbListenerPort: Int32?

            public var slbPort: Int32?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.applicationType != nil {
                    map["ApplicationType"] = self.applicationType!
                }
                if self.buildPackageId != nil {
                    map["BuildPackageId"] = self.buildPackageId!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.extSlbIp != nil {
                    map["ExtSlbIp"] = self.extSlbIp!
                }
                if self.extSlbListenerPort != nil {
                    map["ExtSlbListenerPort"] = self.extSlbListenerPort!
                }
                if self.instances != nil {
                    map["Instances"] = self.instances!
                }
                if self.k8sNamespace != nil {
                    map["K8sNamespace"] = self.k8sNamespace!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.runningInstanceCount != nil {
                    map["RunningInstanceCount"] = self.runningInstanceCount!
                }
                if self.slbIp != nil {
                    map["SlbIp"] = self.slbIp!
                }
                if self.slbListenerPort != nil {
                    map["SlbListenerPort"] = self.slbListenerPort!
                }
                if self.slbPort != nil {
                    map["SlbPort"] = self.slbPort!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["ApplicationType"] as? String {
                    self.applicationType = value
                }
                if let value = dict["BuildPackageId"] as? Int64 {
                    self.buildPackageId = value
                }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["ClusterType"] as? Int32 {
                    self.clusterType = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["ExtSlbIp"] as? String {
                    self.extSlbIp = value
                }
                if let value = dict["ExtSlbListenerPort"] as? Int32 {
                    self.extSlbListenerPort = value
                }
                if let value = dict["Instances"] as? Int32 {
                    self.instances = value
                }
                if let value = dict["K8sNamespace"] as? String {
                    self.k8sNamespace = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NamespaceId"] as? String {
                    self.namespaceId = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RunningInstanceCount"] as? Int32 {
                    self.runningInstanceCount = value
                }
                if let value = dict["SlbIp"] as? String {
                    self.slbIp = value
                }
                if let value = dict["SlbListenerPort"] as? Int32 {
                    self.slbListenerPort = value
                }
                if let value = dict["SlbPort"] as? Int32 {
                    self.slbPort = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
            }
        }
        public var application: [ListApplicationResponseBody.ApplicationList.Application]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.application != nil {
                var tmp : [Any] = []
                for k in self.application! {
                    tmp.append(k.toMap())
                }
                map["Application"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Application"] as? [Any?] {
                var tmp : [ListApplicationResponseBody.ApplicationList.Application] = []
                for v in value {
                    if v != nil {
                        var model = ListApplicationResponseBody.ApplicationList.Application()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.application = tmp
            }
        }
    }
    public var applicationList: ListApplicationResponseBody.ApplicationList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationList != nil {
            map["ApplicationList"] = self.applicationList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationList"] as? [String: Any?] {
            var model = ListApplicationResponseBody.ApplicationList()
            model.fromMap(value)
            self.applicationList = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationEcuRequest : Tea.TeaModel {
    public var appId: String?

    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
    }
}

public class ListApplicationEcuResponseBody : Tea.TeaModel {
    public class EcuInfoList : Tea.TeaModel {
        public class EcuEntity : Tea.TeaModel {
            public var appId: String?

            public var availableCpu: Int32?

            public var availableMem: Int32?

            public var cpu: Int32?

            public var createTime: Int64?

            public var dockerEnv: Bool?

            public var ecuId: String?

            public var heartbeatTime: Int64?

            public var instanceId: String?

            public var ipAddr: String?

            public var mem: Int32?

            public var name: String?

            public var online: Bool?

            public var regionId: String?

            public var updateTime: Int64?

            public var userId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.availableCpu != nil {
                    map["AvailableCpu"] = self.availableCpu!
                }
                if self.availableMem != nil {
                    map["AvailableMem"] = self.availableMem!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerEnv != nil {
                    map["DockerEnv"] = self.dockerEnv!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.heartbeatTime != nil {
                    map["HeartbeatTime"] = self.heartbeatTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipAddr != nil {
                    map["IpAddr"] = self.ipAddr!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AvailableCpu"] as? Int32 {
                    self.availableCpu = value
                }
                if let value = dict["AvailableMem"] as? Int32 {
                    self.availableMem = value
                }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DockerEnv"] as? Bool {
                    self.dockerEnv = value
                }
                if let value = dict["EcuId"] as? String {
                    self.ecuId = value
                }
                if let value = dict["HeartbeatTime"] as? Int64 {
                    self.heartbeatTime = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["IpAddr"] as? String {
                    self.ipAddr = value
                }
                if let value = dict["Mem"] as? Int32 {
                    self.mem = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Online"] as? Bool {
                    self.online = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var ecuEntity: [ListApplicationEcuResponseBody.EcuInfoList.EcuEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecuEntity != nil {
                var tmp : [Any] = []
                for k in self.ecuEntity! {
                    tmp.append(k.toMap())
                }
                map["EcuEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EcuEntity"] as? [Any?] {
                var tmp : [ListApplicationEcuResponseBody.EcuInfoList.EcuEntity] = []
                for v in value {
                    if v != nil {
                        var model = ListApplicationEcuResponseBody.EcuInfoList.EcuEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ecuEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var ecuInfoList: ListApplicationEcuResponseBody.EcuInfoList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecuInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecuInfoList != nil {
            map["EcuInfoList"] = self.ecuInfoList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["EcuInfoList"] as? [String: Any?] {
            var model = ListApplicationEcuResponseBody.EcuInfoList()
            model.fromMap(value)
            self.ecuInfoList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListApplicationEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationEcuResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAuthorityResponseBody : Tea.TeaModel {
    public class AuthorityList : Tea.TeaModel {
        public class Authority : Tea.TeaModel {
            public class ActionList : Tea.TeaModel {
                public class Action : Tea.TeaModel {
                    public var code: String?

                    public var description_: String?

                    public var groupId: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.groupId != nil {
                            map["GroupId"] = self.groupId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Code"] as? String {
                            self.code = value
                        }
                        if let value = dict["Description"] as? String {
                            self.description_ = value
                        }
                        if let value = dict["GroupId"] as? String {
                            self.groupId = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                    }
                }
                public var action: [ListAuthorityResponseBody.AuthorityList.Authority.ActionList.Action]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        var tmp : [Any] = []
                        for k in self.action! {
                            tmp.append(k.toMap())
                        }
                        map["Action"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Action"] as? [Any?] {
                        var tmp : [ListAuthorityResponseBody.AuthorityList.Authority.ActionList.Action] = []
                        for v in value {
                            if v != nil {
                                var model = ListAuthorityResponseBody.AuthorityList.Authority.ActionList.Action()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.action = tmp
                    }
                }
            }
            public var actionList: ListAuthorityResponseBody.AuthorityList.Authority.ActionList?

            public var description_: String?

            public var groupId: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.actionList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionList != nil {
                    map["ActionList"] = self.actionList?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActionList"] as? [String: Any?] {
                    var model = ListAuthorityResponseBody.AuthorityList.Authority.ActionList()
                    model.fromMap(value)
                    self.actionList = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var authority: [ListAuthorityResponseBody.AuthorityList.Authority]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authority != nil {
                var tmp : [Any] = []
                for k in self.authority! {
                    tmp.append(k.toMap())
                }
                map["Authority"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Authority"] as? [Any?] {
                var tmp : [ListAuthorityResponseBody.AuthorityList.Authority] = []
                for v in value {
                    if v != nil {
                        var model = ListAuthorityResponseBody.AuthorityList.Authority()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.authority = tmp
            }
        }
    }
    public var authorityList: ListAuthorityResponseBody.AuthorityList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorityList != nil {
            map["AuthorityList"] = self.authorityList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthorityList"] as? [String: Any?] {
            var model = ListAuthorityResponseBody.AuthorityList()
            model.fromMap(value)
            self.authorityList = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAuthorityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListBuildPackResponseBody : Tea.TeaModel {
    public class BuildPackList : Tea.TeaModel {
        public class BuildPack : Tea.TeaModel {
            public var configId: Int64?

            public var disabled: Bool?

            public var feature: String?

            public var imageId: String?

            public var multipleTenant: Bool?

            public var packVersion: String?

            public var pandoraDesc: String?

            public var pandoraDownloadUrl: String?

            public var pandoraVersion: String?

            public var pluginInfo: String?

            public var scriptName: String?

            public var scriptVersion: String?

            public var supportFeatures: String?

            public var tengineDownloadUrl: String?

            public var tengineImageId: String?

            public var tomcatDesc: String?

            public var tomcatDownloadUrl: String?

            public var tomcatPath: String?

            public var tomcatVersion: String?

            public var withTengine: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.disabled != nil {
                    map["Disabled"] = self.disabled!
                }
                if self.feature != nil {
                    map["Feature"] = self.feature!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.multipleTenant != nil {
                    map["MultipleTenant"] = self.multipleTenant!
                }
                if self.packVersion != nil {
                    map["PackVersion"] = self.packVersion!
                }
                if self.pandoraDesc != nil {
                    map["PandoraDesc"] = self.pandoraDesc!
                }
                if self.pandoraDownloadUrl != nil {
                    map["PandoraDownloadUrl"] = self.pandoraDownloadUrl!
                }
                if self.pandoraVersion != nil {
                    map["PandoraVersion"] = self.pandoraVersion!
                }
                if self.pluginInfo != nil {
                    map["PluginInfo"] = self.pluginInfo!
                }
                if self.scriptName != nil {
                    map["ScriptName"] = self.scriptName!
                }
                if self.scriptVersion != nil {
                    map["ScriptVersion"] = self.scriptVersion!
                }
                if self.supportFeatures != nil {
                    map["SupportFeatures"] = self.supportFeatures!
                }
                if self.tengineDownloadUrl != nil {
                    map["TengineDownloadUrl"] = self.tengineDownloadUrl!
                }
                if self.tengineImageId != nil {
                    map["TengineImageId"] = self.tengineImageId!
                }
                if self.tomcatDesc != nil {
                    map["TomcatDesc"] = self.tomcatDesc!
                }
                if self.tomcatDownloadUrl != nil {
                    map["TomcatDownloadUrl"] = self.tomcatDownloadUrl!
                }
                if self.tomcatPath != nil {
                    map["TomcatPath"] = self.tomcatPath!
                }
                if self.tomcatVersion != nil {
                    map["TomcatVersion"] = self.tomcatVersion!
                }
                if self.withTengine != nil {
                    map["WithTengine"] = self.withTengine!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigId"] as? Int64 {
                    self.configId = value
                }
                if let value = dict["Disabled"] as? Bool {
                    self.disabled = value
                }
                if let value = dict["Feature"] as? String {
                    self.feature = value
                }
                if let value = dict["ImageId"] as? String {
                    self.imageId = value
                }
                if let value = dict["MultipleTenant"] as? Bool {
                    self.multipleTenant = value
                }
                if let value = dict["PackVersion"] as? String {
                    self.packVersion = value
                }
                if let value = dict["PandoraDesc"] as? String {
                    self.pandoraDesc = value
                }
                if let value = dict["PandoraDownloadUrl"] as? String {
                    self.pandoraDownloadUrl = value
                }
                if let value = dict["PandoraVersion"] as? String {
                    self.pandoraVersion = value
                }
                if let value = dict["PluginInfo"] as? String {
                    self.pluginInfo = value
                }
                if let value = dict["ScriptName"] as? String {
                    self.scriptName = value
                }
                if let value = dict["ScriptVersion"] as? String {
                    self.scriptVersion = value
                }
                if let value = dict["SupportFeatures"] as? String {
                    self.supportFeatures = value
                }
                if let value = dict["TengineDownloadUrl"] as? String {
                    self.tengineDownloadUrl = value
                }
                if let value = dict["TengineImageId"] as? String {
                    self.tengineImageId = value
                }
                if let value = dict["TomcatDesc"] as? String {
                    self.tomcatDesc = value
                }
                if let value = dict["TomcatDownloadUrl"] as? String {
                    self.tomcatDownloadUrl = value
                }
                if let value = dict["TomcatPath"] as? String {
                    self.tomcatPath = value
                }
                if let value = dict["TomcatVersion"] as? String {
                    self.tomcatVersion = value
                }
                if let value = dict["WithTengine"] as? Bool {
                    self.withTengine = value
                }
            }
        }
        public var buildPack: [ListBuildPackResponseBody.BuildPackList.BuildPack]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buildPack != nil {
                var tmp : [Any] = []
                for k in self.buildPack! {
                    tmp.append(k.toMap())
                }
                map["BuildPack"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BuildPack"] as? [Any?] {
                var tmp : [ListBuildPackResponseBody.BuildPackList.BuildPack] = []
                for v in value {
                    if v != nil {
                        var model = ListBuildPackResponseBody.BuildPackList.BuildPack()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.buildPack = tmp
            }
        }
    }
    public var buildPackList: ListBuildPackResponseBody.BuildPackList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.buildPackList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.buildPackList != nil {
            map["BuildPackList"] = self.buildPackList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BuildPackList"] as? [String: Any?] {
            var model = ListBuildPackResponseBody.BuildPackList()
            model.fromMap(value)
            self.buildPackList = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListBuildPackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBuildPackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListBuildPackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListClusterRequest : Tea.TeaModel {
    public var logicalRegionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class ListClusterResponseBody : Tea.TeaModel {
    public class ClusterList : Tea.TeaModel {
        public class Cluster : Tea.TeaModel {
            public var clusterId: String?

            public var clusterName: String?

            public var clusterType: Int32?

            public var cpu: Int32?

            public var cpuUsed: Int32?

            public var createTime: Int64?

            public var csClusterId: String?

            public var description_: String?

            public var iaasProvider: String?

            public var mem: Int32?

            public var memUsed: Int32?

            public var networkMode: Int32?

            public var nodeNum: Int32?

            public var oversoldFactor: Int32?

            public var regionId: String?

            public var resourceGroupId: String?

            public var updateTime: Int64?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.cpuUsed != nil {
                    map["CpuUsed"] = self.cpuUsed!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.csClusterId != nil {
                    map["CsClusterId"] = self.csClusterId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.iaasProvider != nil {
                    map["IaasProvider"] = self.iaasProvider!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.memUsed != nil {
                    map["MemUsed"] = self.memUsed!
                }
                if self.networkMode != nil {
                    map["NetworkMode"] = self.networkMode!
                }
                if self.nodeNum != nil {
                    map["NodeNum"] = self.nodeNum!
                }
                if self.oversoldFactor != nil {
                    map["OversoldFactor"] = self.oversoldFactor!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["ClusterName"] as? String {
                    self.clusterName = value
                }
                if let value = dict["ClusterType"] as? Int32 {
                    self.clusterType = value
                }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["CpuUsed"] as? Int32 {
                    self.cpuUsed = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CsClusterId"] as? String {
                    self.csClusterId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["IaasProvider"] as? String {
                    self.iaasProvider = value
                }
                if let value = dict["Mem"] as? Int32 {
                    self.mem = value
                }
                if let value = dict["MemUsed"] as? Int32 {
                    self.memUsed = value
                }
                if let value = dict["NetworkMode"] as? Int32 {
                    self.networkMode = value
                }
                if let value = dict["NodeNum"] as? Int32 {
                    self.nodeNum = value
                }
                if let value = dict["OversoldFactor"] as? Int32 {
                    self.oversoldFactor = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var cluster: [ListClusterResponseBody.ClusterList.Cluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cluster != nil {
                var tmp : [Any] = []
                for k in self.cluster! {
                    tmp.append(k.toMap())
                }
                map["Cluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cluster"] as? [Any?] {
                var tmp : [ListClusterResponseBody.ClusterList.Cluster] = []
                for v in value {
                    if v != nil {
                        var model = ListClusterResponseBody.ClusterList.Cluster()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.cluster = tmp
            }
        }
    }
    public var clusterList: ListClusterResponseBody.ClusterList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterList != nil {
            map["ClusterList"] = self.clusterList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterList"] as? [String: Any?] {
            var model = ListClusterResponseBody.ClusterList()
            model.fromMap(value)
            self.clusterList = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListClusterMembersRequest : Tea.TeaModel {
    public var clusterId: String?

    public var currentPage: Int32?

    public var ecsList: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.ecsList != nil {
            map["EcsList"] = self.ecsList!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["EcsList"] as? String {
            self.ecsList = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListClusterMembersResponseBody : Tea.TeaModel {
    public class ClusterMemberPage : Tea.TeaModel {
        public class ClusterMemberList : Tea.TeaModel {
            public class ClusterMember : Tea.TeaModel {
                public var clusterId: String?

                public var clusterMemberId: String?

                public var createTime: Int64?

                public var ecsId: String?

                public var ecuId: String?

                public var privateIp: String?

                public var status: Int32?

                public var updateTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterId != nil {
                        map["ClusterId"] = self.clusterId!
                    }
                    if self.clusterMemberId != nil {
                        map["ClusterMemberId"] = self.clusterMemberId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.ecsId != nil {
                        map["EcsId"] = self.ecsId!
                    }
                    if self.ecuId != nil {
                        map["EcuId"] = self.ecuId!
                    }
                    if self.privateIp != nil {
                        map["PrivateIp"] = self.privateIp!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ClusterId"] as? String {
                        self.clusterId = value
                    }
                    if let value = dict["ClusterMemberId"] as? String {
                        self.clusterMemberId = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["EcsId"] as? String {
                        self.ecsId = value
                    }
                    if let value = dict["EcuId"] as? String {
                        self.ecuId = value
                    }
                    if let value = dict["PrivateIp"] as? String {
                        self.privateIp = value
                    }
                    if let value = dict["Status"] as? Int32 {
                        self.status = value
                    }
                    if let value = dict["UpdateTime"] as? Int64 {
                        self.updateTime = value
                    }
                }
            }
            public var clusterMember: [ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList.ClusterMember]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterMember != nil {
                    var tmp : [Any] = []
                    for k in self.clusterMember! {
                        tmp.append(k.toMap())
                    }
                    map["ClusterMember"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClusterMember"] as? [Any?] {
                    var tmp : [ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList.ClusterMember] = []
                    for v in value {
                        if v != nil {
                            var model = ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList.ClusterMember()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.clusterMember = tmp
                }
            }
        }
        public var clusterMemberList: ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clusterMemberList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterMemberList != nil {
                map["ClusterMemberList"] = self.clusterMemberList?.toMap()
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterMemberList"] as? [String: Any?] {
                var model = ListClusterMembersResponseBody.ClusterMemberPage.ClusterMemberList()
                model.fromMap(value)
                self.clusterMemberList = model
            }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var clusterMemberPage: ListClusterMembersResponseBody.ClusterMemberPage?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterMemberPage?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterMemberPage != nil {
            map["ClusterMemberPage"] = self.clusterMemberPage?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterMemberPage"] as? [String: Any?] {
            var model = ListClusterMembersResponseBody.ClusterMemberPage()
            model.fromMap(value)
            self.clusterMemberPage = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListClusterMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListClusterMembersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListComponentsResponseBody : Tea.TeaModel {
    public class ComponentList : Tea.TeaModel {
        public class Component : Tea.TeaModel {
            public var componentId: String?

            public var componentKey: String?

            public var desc: String?

            public var expired: Bool?

            public var type: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.componentId != nil {
                    map["ComponentId"] = self.componentId!
                }
                if self.componentKey != nil {
                    map["ComponentKey"] = self.componentKey!
                }
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComponentId"] as? String {
                    self.componentId = value
                }
                if let value = dict["ComponentKey"] as? String {
                    self.componentKey = value
                }
                if let value = dict["Desc"] as? String {
                    self.desc = value
                }
                if let value = dict["Expired"] as? Bool {
                    self.expired = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Version"] as? String {
                    self.version = value
                }
            }
        }
        public var component: [ListComponentsResponseBody.ComponentList.Component]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.component != nil {
                var tmp : [Any] = []
                for k in self.component! {
                    tmp.append(k.toMap())
                }
                map["Component"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Component"] as? [Any?] {
                var tmp : [ListComponentsResponseBody.ComponentList.Component] = []
                for v in value {
                    if v != nil {
                        var model = ListComponentsResponseBody.ComponentList.Component()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.component = tmp
            }
        }
    }
    public var code: Int32?

    public var componentList: ListComponentsResponseBody.ComponentList?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.componentList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.componentList != nil {
            map["ComponentList"] = self.componentList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["ComponentList"] as? [String: Any?] {
            var model = ListComponentsResponseBody.ComponentList()
            model.fromMap(value)
            self.componentList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
    }
}

public class ListComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListComponentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConfigTemplatesRequest : Tea.TeaModel {
    public var currentPage: Int64?

    public var id: Int64?

    public var name: String?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CurrentPage"] as? Int64 {
            self.currentPage = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListConfigTemplatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var content: String?

            public var description_: String?

            public var format: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Format"] as? String {
                    self.format = value
                }
                if let value = dict["GmtCreate"] as? Int64 {
                    self.gmtCreate = value
                }
                if let value = dict["GmtModified"] as? Int64 {
                    self.gmtModified = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var result: [ListConfigTemplatesResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [ListConfigTemplatesResponseBody.Data.Result] = []
                for v in value {
                    if v != nil {
                        var model = ListConfigTemplatesResponseBody.Data.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
            if let value = dict["TotalSize"] as? Int64 {
                self.totalSize = value
            }
        }
    }
    public var code: Int32?

    public var data: ListConfigTemplatesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListConfigTemplatesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListConfigTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConfigTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConsumedServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListConsumedServicesResponseBody : Tea.TeaModel {
    public class ConsumedServicesList : Tea.TeaModel {
        public class ListConsumedServices : Tea.TeaModel {
            public class Groups : Tea.TeaModel {
                public var group: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.group != nil {
                        map["group"] = self.group!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["group"] as? [String] {
                        self.group = value
                    }
                }
            }
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ip"] as? [String] {
                        self.ip = value
                    }
                }
            }
            public var appId: String?

            public var dockerApplication: Bool?

            public var group2Ip: String?

            public var groups: ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices.Groups?

            public var ips: ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices.Ips?

            public var name: String?

            public var type: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groups?.validate()
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.dockerApplication != nil {
                    map["DockerApplication"] = self.dockerApplication!
                }
                if self.group2Ip != nil {
                    map["Group2Ip"] = self.group2Ip!
                }
                if self.groups != nil {
                    map["Groups"] = self.groups?.toMap()
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["DockerApplication"] as? Bool {
                    self.dockerApplication = value
                }
                if let value = dict["Group2Ip"] as? String {
                    self.group2Ip = value
                }
                if let value = dict["Groups"] as? [String: Any?] {
                    var model = ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices.Groups()
                    model.fromMap(value)
                    self.groups = model
                }
                if let value = dict["Ips"] as? [String: Any?] {
                    var model = ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices.Ips()
                    model.fromMap(value)
                    self.ips = model
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Version"] as? String {
                    self.version = value
                }
            }
        }
        public var listConsumedServices: [ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.listConsumedServices != nil {
                var tmp : [Any] = []
                for k in self.listConsumedServices! {
                    tmp.append(k.toMap())
                }
                map["ListConsumedServices"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ListConsumedServices"] as? [Any?] {
                var tmp : [ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices] = []
                for v in value {
                    if v != nil {
                        var model = ListConsumedServicesResponseBody.ConsumedServicesList.ListConsumedServices()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.listConsumedServices = tmp
            }
        }
    }
    public var code: Int32?

    public var consumedServicesList: ListConsumedServicesResponseBody.ConsumedServicesList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.consumedServicesList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.consumedServicesList != nil {
            map["ConsumedServicesList"] = self.consumedServicesList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["ConsumedServicesList"] as? [String: Any?] {
            var model = ListConsumedServicesResponseBody.ConsumedServicesList()
            model.fromMap(value)
            self.consumedServicesList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListConsumedServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConsumedServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConsumedServicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConvertableEcuRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["clusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clusterId"] as? String {
            self.clusterId = value
        }
    }
}

public class ListConvertableEcuResponseBody : Tea.TeaModel {
    public class InstanceList : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var cpu: Int32?

            public var ecuId: String?

            public var eip: String?

            public var expired: Bool?

            public var innerIp: String?

            public var instanceId: String?

            public var instanceName: String?

            public var mem: Int32?

            public var privateIp: String?

            public var publicIp: String?

            public var regionId: String?

            public var status: String?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.eip != nil {
                    map["Eip"] = self.eip!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.innerIp != nil {
                    map["InnerIp"] = self.innerIp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.privateIp != nil {
                    map["PrivateIp"] = self.privateIp!
                }
                if self.publicIp != nil {
                    map["PublicIp"] = self.publicIp!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["EcuId"] as? String {
                    self.ecuId = value
                }
                if let value = dict["Eip"] as? String {
                    self.eip = value
                }
                if let value = dict["Expired"] as? Bool {
                    self.expired = value
                }
                if let value = dict["InnerIp"] as? String {
                    self.innerIp = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["Mem"] as? Int32 {
                    self.mem = value
                }
                if let value = dict["PrivateIp"] as? String {
                    self.privateIp = value
                }
                if let value = dict["PublicIp"] as? String {
                    self.publicIp = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["VpcName"] as? String {
                    self.vpcName = value
                }
            }
        }
        public var instance: [ListConvertableEcuResponseBody.InstanceList.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Instance"] as? [Any?] {
                var tmp : [ListConvertableEcuResponseBody.InstanceList.Instance] = []
                for v in value {
                    if v != nil {
                        var model = ListConvertableEcuResponseBody.InstanceList.Instance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instance = tmp
            }
        }
    }
    public var code: Int32?

    public var instanceList: ListConvertableEcuResponseBody.InstanceList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceList != nil {
            map["InstanceList"] = self.instanceList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["InstanceList"] as? [String: Any?] {
            var model = ListConvertableEcuResponseBody.InstanceList()
            model.fromMap(value)
            self.instanceList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListConvertableEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConvertableEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConvertableEcuResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDeployGroupRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListDeployGroupResponseBody : Tea.TeaModel {
    public class DeployGroupList : Tea.TeaModel {
        public class DeployGroup : Tea.TeaModel {
            public var appId: String?

            public var appVersionId: String?

            public var baseComponentMetaName: String?

            public var clusterId: String?

            public var clusterName: String?

            public var cpuLimit: String?

            public var cpuRequest: String?

            public var createTime: Int64?

            public var csClusterId: String?

            public var deploymentName: String?

            public var env: String?

            public var ephemeralStorageLimit: String?

            public var ephemeralStorageRequest: String?

            public var groupId: String?

            public var groupName: String?

            public var groupType: Int32?

            public var labels: String?

            public var lastUpdateTime: Int64?

            public var memoryLimit: String?

            public var memoryRequest: String?

            public var nameSpace: String?

            public var packagePublicUrl: String?

            public var packageUrl: String?

            public var packageVersion: String?

            public var packageVersionId: String?

            public var postStart: String?

            public var preStop: String?

            public var reversion: String?

            public var selector: String?

            public var status: String?

            public var strategy: String?

            public var updateTime: Int64?

            public var VExtServerGroupId: String?

            public var VServerGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appVersionId != nil {
                    map["AppVersionId"] = self.appVersionId!
                }
                if self.baseComponentMetaName != nil {
                    map["BaseComponentMetaName"] = self.baseComponentMetaName!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.cpuLimit != nil {
                    map["CpuLimit"] = self.cpuLimit!
                }
                if self.cpuRequest != nil {
                    map["CpuRequest"] = self.cpuRequest!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.csClusterId != nil {
                    map["CsClusterId"] = self.csClusterId!
                }
                if self.deploymentName != nil {
                    map["DeploymentName"] = self.deploymentName!
                }
                if self.env != nil {
                    map["Env"] = self.env!
                }
                if self.ephemeralStorageLimit != nil {
                    map["EphemeralStorageLimit"] = self.ephemeralStorageLimit!
                }
                if self.ephemeralStorageRequest != nil {
                    map["EphemeralStorageRequest"] = self.ephemeralStorageRequest!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.lastUpdateTime != nil {
                    map["LastUpdateTime"] = self.lastUpdateTime!
                }
                if self.memoryLimit != nil {
                    map["MemoryLimit"] = self.memoryLimit!
                }
                if self.memoryRequest != nil {
                    map["MemoryRequest"] = self.memoryRequest!
                }
                if self.nameSpace != nil {
                    map["NameSpace"] = self.nameSpace!
                }
                if self.packagePublicUrl != nil {
                    map["PackagePublicUrl"] = self.packagePublicUrl!
                }
                if self.packageUrl != nil {
                    map["PackageUrl"] = self.packageUrl!
                }
                if self.packageVersion != nil {
                    map["PackageVersion"] = self.packageVersion!
                }
                if self.packageVersionId != nil {
                    map["PackageVersionId"] = self.packageVersionId!
                }
                if self.postStart != nil {
                    map["PostStart"] = self.postStart!
                }
                if self.preStop != nil {
                    map["PreStop"] = self.preStop!
                }
                if self.reversion != nil {
                    map["Reversion"] = self.reversion!
                }
                if self.selector != nil {
                    map["Selector"] = self.selector!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.VExtServerGroupId != nil {
                    map["VExtServerGroupId"] = self.VExtServerGroupId!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppVersionId"] as? String {
                    self.appVersionId = value
                }
                if let value = dict["BaseComponentMetaName"] as? String {
                    self.baseComponentMetaName = value
                }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["ClusterName"] as? String {
                    self.clusterName = value
                }
                if let value = dict["CpuLimit"] as? String {
                    self.cpuLimit = value
                }
                if let value = dict["CpuRequest"] as? String {
                    self.cpuRequest = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CsClusterId"] as? String {
                    self.csClusterId = value
                }
                if let value = dict["DeploymentName"] as? String {
                    self.deploymentName = value
                }
                if let value = dict["Env"] as? String {
                    self.env = value
                }
                if let value = dict["EphemeralStorageLimit"] as? String {
                    self.ephemeralStorageLimit = value
                }
                if let value = dict["EphemeralStorageRequest"] as? String {
                    self.ephemeralStorageRequest = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? Int32 {
                    self.groupType = value
                }
                if let value = dict["Labels"] as? String {
                    self.labels = value
                }
                if let value = dict["LastUpdateTime"] as? Int64 {
                    self.lastUpdateTime = value
                }
                if let value = dict["MemoryLimit"] as? String {
                    self.memoryLimit = value
                }
                if let value = dict["MemoryRequest"] as? String {
                    self.memoryRequest = value
                }
                if let value = dict["NameSpace"] as? String {
                    self.nameSpace = value
                }
                if let value = dict["PackagePublicUrl"] as? String {
                    self.packagePublicUrl = value
                }
                if let value = dict["PackageUrl"] as? String {
                    self.packageUrl = value
                }
                if let value = dict["PackageVersion"] as? String {
                    self.packageVersion = value
                }
                if let value = dict["PackageVersionId"] as? String {
                    self.packageVersionId = value
                }
                if let value = dict["PostStart"] as? String {
                    self.postStart = value
                }
                if let value = dict["PreStop"] as? String {
                    self.preStop = value
                }
                if let value = dict["Reversion"] as? String {
                    self.reversion = value
                }
                if let value = dict["Selector"] as? String {
                    self.selector = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Strategy"] as? String {
                    self.strategy = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["VExtServerGroupId"] as? String {
                    self.VExtServerGroupId = value
                }
                if let value = dict["VServerGroupId"] as? String {
                    self.VServerGroupId = value
                }
            }
        }
        public var deployGroup: [ListDeployGroupResponseBody.DeployGroupList.DeployGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployGroup != nil {
                var tmp : [Any] = []
                for k in self.deployGroup! {
                    tmp.append(k.toMap())
                }
                map["DeployGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeployGroup"] as? [Any?] {
                var tmp : [ListDeployGroupResponseBody.DeployGroupList.DeployGroup] = []
                for v in value {
                    if v != nil {
                        var model = ListDeployGroupResponseBody.DeployGroupList.DeployGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.deployGroup = tmp
            }
        }
    }
    public var code: Int32?

    public var deployGroupList: ListDeployGroupResponseBody.DeployGroupList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployGroupList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.deployGroupList != nil {
            map["DeployGroupList"] = self.deployGroupList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["DeployGroupList"] as? [String: Any?] {
            var model = ListDeployGroupResponseBody.DeployGroupList()
            model.fromMap(value)
            self.deployGroupList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDeployGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDeployGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDeployGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEcsNotInClusterRequest : Tea.TeaModel {
    public var networkMode: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkMode != nil {
            map["NetworkMode"] = self.networkMode!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkMode"] as? Int32 {
            self.networkMode = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ListEcsNotInClusterResponseBody : Tea.TeaModel {
    public class EcsEntityList : Tea.TeaModel {
        public class EcsEntity : Tea.TeaModel {
            public var cpu: Int32?

            public var eip: String?

            public var expired: Bool?

            public var innerIp: String?

            public var instanceId: String?

            public var instanceName: String?

            public var mem: Int32?

            public var privateIp: String?

            public var publicIp: String?

            public var regionId: String?

            public var status: String?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.eip != nil {
                    map["Eip"] = self.eip!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.innerIp != nil {
                    map["InnerIp"] = self.innerIp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.privateIp != nil {
                    map["PrivateIp"] = self.privateIp!
                }
                if self.publicIp != nil {
                    map["PublicIp"] = self.publicIp!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["Eip"] as? String {
                    self.eip = value
                }
                if let value = dict["Expired"] as? Bool {
                    self.expired = value
                }
                if let value = dict["InnerIp"] as? String {
                    self.innerIp = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["Mem"] as? Int32 {
                    self.mem = value
                }
                if let value = dict["PrivateIp"] as? String {
                    self.privateIp = value
                }
                if let value = dict["PublicIp"] as? String {
                    self.publicIp = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["VpcName"] as? String {
                    self.vpcName = value
                }
            }
        }
        public var ecsEntity: [ListEcsNotInClusterResponseBody.EcsEntityList.EcsEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecsEntity != nil {
                var tmp : [Any] = []
                for k in self.ecsEntity! {
                    tmp.append(k.toMap())
                }
                map["EcsEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EcsEntity"] as? [Any?] {
                var tmp : [ListEcsNotInClusterResponseBody.EcsEntityList.EcsEntity] = []
                for v in value {
                    if v != nil {
                        var model = ListEcsNotInClusterResponseBody.EcsEntityList.EcsEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ecsEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var ecsEntityList: ListEcsNotInClusterResponseBody.EcsEntityList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecsEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecsEntityList != nil {
            map["EcsEntityList"] = self.ecsEntityList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["EcsEntityList"] as? [String: Any?] {
            var model = ListEcsNotInClusterResponseBody.EcsEntityList()
            model.fromMap(value)
            self.ecsEntityList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListEcsNotInClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEcsNotInClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEcsNotInClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEcuByRegionRequest : Tea.TeaModel {
    public var act: String?

    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.act != nil {
            map["Act"] = self.act!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Act"] as? String {
            self.act = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
    }
}

public class ListEcuByRegionResponseBody : Tea.TeaModel {
    public class EcuEntityList : Tea.TeaModel {
        public class EcuEntity : Tea.TeaModel {
            public var availableCpu: Int32?

            public var availableMem: Int32?

            public var cpu: Int32?

            public var createTime: Int64?

            public var dockerEnv: Bool?

            public var ecuId: String?

            public var heartbeatTime: Int64?

            public var instanceId: String?

            public var ipAddr: String?

            public var mem: Int32?

            public var name: String?

            public var online: Bool?

            public var regionId: String?

            public var updateTime: Int64?

            public var userId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableCpu != nil {
                    map["AvailableCpu"] = self.availableCpu!
                }
                if self.availableMem != nil {
                    map["AvailableMem"] = self.availableMem!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerEnv != nil {
                    map["DockerEnv"] = self.dockerEnv!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.heartbeatTime != nil {
                    map["HeartbeatTime"] = self.heartbeatTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipAddr != nil {
                    map["IpAddr"] = self.ipAddr!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableCpu"] as? Int32 {
                    self.availableCpu = value
                }
                if let value = dict["AvailableMem"] as? Int32 {
                    self.availableMem = value
                }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DockerEnv"] as? Bool {
                    self.dockerEnv = value
                }
                if let value = dict["EcuId"] as? String {
                    self.ecuId = value
                }
                if let value = dict["HeartbeatTime"] as? Int64 {
                    self.heartbeatTime = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["IpAddr"] as? String {
                    self.ipAddr = value
                }
                if let value = dict["Mem"] as? Int32 {
                    self.mem = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Online"] as? Bool {
                    self.online = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var ecuEntity: [ListEcuByRegionResponseBody.EcuEntityList.EcuEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecuEntity != nil {
                var tmp : [Any] = []
                for k in self.ecuEntity! {
                    tmp.append(k.toMap())
                }
                map["EcuEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EcuEntity"] as? [Any?] {
                var tmp : [ListEcuByRegionResponseBody.EcuEntityList.EcuEntity] = []
                for v in value {
                    if v != nil {
                        var model = ListEcuByRegionResponseBody.EcuEntityList.EcuEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ecuEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var ecuEntityList: ListEcuByRegionResponseBody.EcuEntityList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecuEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecuEntityList != nil {
            map["EcuEntityList"] = self.ecuEntityList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["EcuEntityList"] as? [String: Any?] {
            var model = ListEcuByRegionResponseBody.EcuEntityList()
            model.fromMap(value)
            self.ecuEntityList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListEcuByRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEcuByRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEcuByRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListHistoryDeployVersionRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListHistoryDeployVersionResponseBody : Tea.TeaModel {
    public class PackageVersionList : Tea.TeaModel {
        public class PackageVersion : Tea.TeaModel {
            public var appId: String?

            public var createTime: Int64?

            public var description_: String?

            public var id: String?

            public var packageVersion: String?

            public var publicUrl: String?

            public var type: String?

            public var updateTime: Int64?

            public var warUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.packageVersion != nil {
                    map["PackageVersion"] = self.packageVersion!
                }
                if self.publicUrl != nil {
                    map["PublicUrl"] = self.publicUrl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.warUrl != nil {
                    map["WarUrl"] = self.warUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["PackageVersion"] as? String {
                    self.packageVersion = value
                }
                if let value = dict["PublicUrl"] as? String {
                    self.publicUrl = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["WarUrl"] as? String {
                    self.warUrl = value
                }
            }
        }
        public var packageVersion: [ListHistoryDeployVersionResponseBody.PackageVersionList.PackageVersion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.packageVersion != nil {
                var tmp : [Any] = []
                for k in self.packageVersion! {
                    tmp.append(k.toMap())
                }
                map["PackageVersion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PackageVersion"] as? [Any?] {
                var tmp : [ListHistoryDeployVersionResponseBody.PackageVersionList.PackageVersion] = []
                for v in value {
                    if v != nil {
                        var model = ListHistoryDeployVersionResponseBody.PackageVersionList.PackageVersion()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.packageVersion = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var packageVersionList: ListHistoryDeployVersionResponseBody.PackageVersionList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.packageVersionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.packageVersionList != nil {
            map["PackageVersionList"] = self.packageVersionList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PackageVersionList"] as? [String: Any?] {
            var model = ListHistoryDeployVersionResponseBody.PackageVersionList()
            model.fromMap(value)
            self.packageVersionList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListHistoryDeployVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHistoryDeployVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListHistoryDeployVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListK8sConfigMapsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var condition: [String: Any]?

    public var namespace: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var showRelatedApps: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.condition != nil {
            map["Condition"] = self.condition!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showRelatedApps != nil {
            map["ShowRelatedApps"] = self.showRelatedApps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Condition"] as? [String: Any] {
            self.condition = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowRelatedApps"] as? Bool {
            self.showRelatedApps = value
        }
    }
}

public class ListK8sConfigMapsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ConfigMaps : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class RelatedApps : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppName"] as? String {
                        self.appName = value
                    }
                }
            }
            public var clusterId: String?

            public var clusterName: String?

            public var creationTime: String?

            public var data: [ListK8sConfigMapsResponseBody.Result.ConfigMaps.Data]?

            public var name: String?

            public var namespace: String?

            public var relatedApps: [ListK8sConfigMapsResponseBody.Result.ConfigMaps.RelatedApps]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["Data"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.relatedApps != nil {
                    var tmp : [Any] = []
                    for k in self.relatedApps! {
                        tmp.append(k.toMap())
                    }
                    map["RelatedApps"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["ClusterName"] as? String {
                    self.clusterName = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Data"] as? [Any?] {
                    var tmp : [ListK8sConfigMapsResponseBody.Result.ConfigMaps.Data] = []
                    for v in value {
                        if v != nil {
                            var model = ListK8sConfigMapsResponseBody.Result.ConfigMaps.Data()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.data = tmp
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Namespace"] as? String {
                    self.namespace = value
                }
                if let value = dict["RelatedApps"] as? [Any?] {
                    var tmp : [ListK8sConfigMapsResponseBody.Result.ConfigMaps.RelatedApps] = []
                    for v in value {
                        if v != nil {
                            var model = ListK8sConfigMapsResponseBody.Result.ConfigMaps.RelatedApps()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.relatedApps = tmp
                }
            }
        }
        public var configMaps: [ListK8sConfigMapsResponseBody.Result.ConfigMaps]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMaps != nil {
                var tmp : [Any] = []
                for k in self.configMaps! {
                    tmp.append(k.toMap())
                }
                map["ConfigMaps"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigMaps"] as? [Any?] {
                var tmp : [ListK8sConfigMapsResponseBody.Result.ConfigMaps] = []
                for v in value {
                    if v != nil {
                        var model = ListK8sConfigMapsResponseBody.Result.ConfigMaps()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configMaps = tmp
            }
            if let value = dict["Total"] as? Int32 {
                self.total = value
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var result: ListK8sConfigMapsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListK8sConfigMapsResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListK8sConfigMapsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListK8sConfigMapsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListK8sConfigMapsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListK8sIngressRulesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var condition: String?

    public var namespace: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.condition != nil {
            map["Condition"] = self.condition!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Condition"] as? String {
            self.condition = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListK8sIngressRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class IngressConfs : Tea.TeaModel {
            public class Rules : Tea.TeaModel {
                public class Paths : Tea.TeaModel {
                    public class Backend : Tea.TeaModel {
                        public var serviceName: String?

                        public var servicePort: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.serviceName != nil {
                                map["ServiceName"] = self.serviceName!
                            }
                            if self.servicePort != nil {
                                map["ServicePort"] = self.servicePort!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["ServiceName"] as? String {
                                self.serviceName = value
                            }
                            if let value = dict["ServicePort"] as? String {
                                self.servicePort = value
                            }
                        }
                    }
                    public var appId: String?

                    public var appName: String?

                    public var backend: ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths.Backend?

                    public var collectRate: Int32?

                    public var path: String?

                    public var pathType: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.backend?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appId != nil {
                            map["AppId"] = self.appId!
                        }
                        if self.appName != nil {
                            map["AppName"] = self.appName!
                        }
                        if self.backend != nil {
                            map["Backend"] = self.backend?.toMap()
                        }
                        if self.collectRate != nil {
                            map["CollectRate"] = self.collectRate!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.pathType != nil {
                            map["PathType"] = self.pathType!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AppId"] as? String {
                            self.appId = value
                        }
                        if let value = dict["AppName"] as? String {
                            self.appName = value
                        }
                        if let value = dict["Backend"] as? [String: Any?] {
                            var model = ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths.Backend()
                            model.fromMap(value)
                            self.backend = model
                        }
                        if let value = dict["CollectRate"] as? Int32 {
                            self.collectRate = value
                        }
                        if let value = dict["Path"] as? String {
                            self.path = value
                        }
                        if let value = dict["PathType"] as? String {
                            self.pathType = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                    }
                }
                public var enableTls: Bool?

                public var host: String?

                public var paths: [ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths]?

                public var secretName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableTls != nil {
                        map["EnableTls"] = self.enableTls!
                    }
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    if self.paths != nil {
                        var tmp : [Any] = []
                        for k in self.paths! {
                            tmp.append(k.toMap())
                        }
                        map["Paths"] = tmp
                    }
                    if self.secretName != nil {
                        map["SecretName"] = self.secretName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EnableTls"] as? Bool {
                        self.enableTls = value
                    }
                    if let value = dict["Host"] as? String {
                        self.host = value
                    }
                    if let value = dict["Paths"] as? [Any?] {
                        var tmp : [ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths] = []
                        for v in value {
                            if v != nil {
                                var model = ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules.Paths()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.paths = tmp
                    }
                    if let value = dict["SecretName"] as? String {
                        self.secretName = value
                    }
                }
            }
            public var albId: String?

            public var annotations: String?

            public var creationTime: String?

            public var dashboardUrl: String?

            public var endpoint: String?

            public var ingressType: String?

            public var labels: String?

            public var mseGatewayId: String?

            public var mseGatewayName: String?

            public var name: String?

            public var namespace: String?

            public var officalBasicUrl: String?

            public var officalRequestUrl: String?

            public var rules: [ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules]?

            public var sslRedirect: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albId != nil {
                    map["AlbId"] = self.albId!
                }
                if self.annotations != nil {
                    map["Annotations"] = self.annotations!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.dashboardUrl != nil {
                    map["DashboardUrl"] = self.dashboardUrl!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.ingressType != nil {
                    map["IngressType"] = self.ingressType!
                }
                if self.labels != nil {
                    map["Labels"] = self.labels!
                }
                if self.mseGatewayId != nil {
                    map["MseGatewayId"] = self.mseGatewayId!
                }
                if self.mseGatewayName != nil {
                    map["MseGatewayName"] = self.mseGatewayName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.officalBasicUrl != nil {
                    map["OfficalBasicUrl"] = self.officalBasicUrl!
                }
                if self.officalRequestUrl != nil {
                    map["OfficalRequestUrl"] = self.officalRequestUrl!
                }
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["Rules"] = tmp
                }
                if self.sslRedirect != nil {
                    map["SslRedirect"] = self.sslRedirect!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlbId"] as? String {
                    self.albId = value
                }
                if let value = dict["Annotations"] as? String {
                    self.annotations = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DashboardUrl"] as? String {
                    self.dashboardUrl = value
                }
                if let value = dict["Endpoint"] as? String {
                    self.endpoint = value
                }
                if let value = dict["IngressType"] as? String {
                    self.ingressType = value
                }
                if let value = dict["Labels"] as? String {
                    self.labels = value
                }
                if let value = dict["MseGatewayId"] as? String {
                    self.mseGatewayId = value
                }
                if let value = dict["MseGatewayName"] as? String {
                    self.mseGatewayName = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Namespace"] as? String {
                    self.namespace = value
                }
                if let value = dict["OfficalBasicUrl"] as? String {
                    self.officalBasicUrl = value
                }
                if let value = dict["OfficalRequestUrl"] as? String {
                    self.officalRequestUrl = value
                }
                if let value = dict["Rules"] as? [Any?] {
                    var tmp : [ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules] = []
                    for v in value {
                        if v != nil {
                            var model = ListK8sIngressRulesResponseBody.Data.IngressConfs.Rules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rules = tmp
                }
                if let value = dict["SslRedirect"] as? Bool {
                    self.sslRedirect = value
                }
            }
        }
        public var clusterId: String?

        public var clusterName: String?

        public var ingressConfs: [ListK8sIngressRulesResponseBody.Data.IngressConfs]?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.ingressConfs != nil {
                var tmp : [Any] = []
                for k in self.ingressConfs! {
                    tmp.append(k.toMap())
                }
                map["IngressConfs"] = tmp
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["ClusterName"] as? String {
                self.clusterName = value
            }
            if let value = dict["IngressConfs"] as? [Any?] {
                var tmp : [ListK8sIngressRulesResponseBody.Data.IngressConfs] = []
                for v in value {
                    if v != nil {
                        var model = ListK8sIngressRulesResponseBody.Data.IngressConfs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ingressConfs = tmp
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var code: Int32?

    public var data: [ListK8sIngressRulesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListK8sIngressRulesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListK8sIngressRulesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListK8sIngressRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListK8sIngressRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListK8sIngressRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListK8sNamespacesRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
    }
}

public class ListK8sNamespacesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var namespace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Namespace"] as? String {
                self.namespace = value
            }
        }
    }
    public var code: Int32?

    public var data: [ListK8sNamespacesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListK8sNamespacesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListK8sNamespacesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListK8sNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListK8sNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListK8sNamespacesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListK8sSecretsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var condition: String?

    public var namespace: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var showRelatedApps: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.condition != nil {
            map["Condition"] = self.condition!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showRelatedApps != nil {
            map["ShowRelatedApps"] = self.showRelatedApps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Condition"] as? String {
            self.condition = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowRelatedApps"] as? Bool {
            self.showRelatedApps = value
        }
    }
}

public class ListK8sSecretsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Secrets : Tea.TeaModel {
            public class CertDetail : Tea.TeaModel {
                public var domainNames: [String]?

                public var endTime: String?

                public var issuer: String?

                public var startTime: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.domainNames != nil {
                        map["DomainNames"] = self.domainNames!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.issuer != nil {
                        map["Issuer"] = self.issuer!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DomainNames"] as? [String] {
                        self.domainNames = value
                    }
                    if let value = dict["EndTime"] as? String {
                        self.endTime = value
                    }
                    if let value = dict["Issuer"] as? String {
                        self.issuer = value
                    }
                    if let value = dict["StartTime"] as? String {
                        self.startTime = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public class Data : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class RelatedApps : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppName"] as? String {
                        self.appName = value
                    }
                }
            }
            public class RelatedIngressRules : Tea.TeaModel {
                public class RelatedApps : Tea.TeaModel {
                    public var appId: String?

                    public var appName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appId != nil {
                            map["AppId"] = self.appId!
                        }
                        if self.appName != nil {
                            map["AppName"] = self.appName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AppId"] as? String {
                            self.appId = value
                        }
                        if let value = dict["AppName"] as? String {
                            self.appName = value
                        }
                    }
                }
                public var name: String?

                public var namespace: String?

                public var relatedApps: [ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules.RelatedApps]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.relatedApps != nil {
                        var tmp : [Any] = []
                        for k in self.relatedApps! {
                            tmp.append(k.toMap())
                        }
                        map["RelatedApps"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Namespace"] as? String {
                        self.namespace = value
                    }
                    if let value = dict["RelatedApps"] as? [Any?] {
                        var tmp : [ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules.RelatedApps] = []
                        for v in value {
                            if v != nil {
                                var model = ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules.RelatedApps()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.relatedApps = tmp
                    }
                }
            }
            public var base64Encoded: Bool?

            public var certDetail: ListK8sSecretsResponseBody.Result.Secrets.CertDetail?

            public var certId: String?

            public var certRegionId: String?

            public var clusterId: String?

            public var clusterName: String?

            public var creationTime: String?

            public var data: [ListK8sSecretsResponseBody.Result.Secrets.Data]?

            public var name: String?

            public var namespace: String?

            public var relatedApps: [ListK8sSecretsResponseBody.Result.Secrets.RelatedApps]?

            public var relatedIngressRules: [ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.certDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.base64Encoded != nil {
                    map["Base64Encoded"] = self.base64Encoded!
                }
                if self.certDetail != nil {
                    map["CertDetail"] = self.certDetail?.toMap()
                }
                if self.certId != nil {
                    map["CertId"] = self.certId!
                }
                if self.certRegionId != nil {
                    map["CertRegionId"] = self.certRegionId!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.data != nil {
                    var tmp : [Any] = []
                    for k in self.data! {
                        tmp.append(k.toMap())
                    }
                    map["Data"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.relatedApps != nil {
                    var tmp : [Any] = []
                    for k in self.relatedApps! {
                        tmp.append(k.toMap())
                    }
                    map["RelatedApps"] = tmp
                }
                if self.relatedIngressRules != nil {
                    var tmp : [Any] = []
                    for k in self.relatedIngressRules! {
                        tmp.append(k.toMap())
                    }
                    map["RelatedIngressRules"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Base64Encoded"] as? Bool {
                    self.base64Encoded = value
                }
                if let value = dict["CertDetail"] as? [String: Any?] {
                    var model = ListK8sSecretsResponseBody.Result.Secrets.CertDetail()
                    model.fromMap(value)
                    self.certDetail = model
                }
                if let value = dict["CertId"] as? String {
                    self.certId = value
                }
                if let value = dict["CertRegionId"] as? String {
                    self.certRegionId = value
                }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["ClusterName"] as? String {
                    self.clusterName = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Data"] as? [Any?] {
                    var tmp : [ListK8sSecretsResponseBody.Result.Secrets.Data] = []
                    for v in value {
                        if v != nil {
                            var model = ListK8sSecretsResponseBody.Result.Secrets.Data()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.data = tmp
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Namespace"] as? String {
                    self.namespace = value
                }
                if let value = dict["RelatedApps"] as? [Any?] {
                    var tmp : [ListK8sSecretsResponseBody.Result.Secrets.RelatedApps] = []
                    for v in value {
                        if v != nil {
                            var model = ListK8sSecretsResponseBody.Result.Secrets.RelatedApps()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.relatedApps = tmp
                }
                if let value = dict["RelatedIngressRules"] as? [Any?] {
                    var tmp : [ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules] = []
                    for v in value {
                        if v != nil {
                            var model = ListK8sSecretsResponseBody.Result.Secrets.RelatedIngressRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.relatedIngressRules = tmp
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var secrets: [ListK8sSecretsResponseBody.Result.Secrets]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secrets != nil {
                var tmp : [Any] = []
                for k in self.secrets! {
                    tmp.append(k.toMap())
                }
                map["Secrets"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Secrets"] as? [Any?] {
                var tmp : [ListK8sSecretsResponseBody.Result.Secrets] = []
                for v in value {
                    if v != nil {
                        var model = ListK8sSecretsResponseBody.Result.Secrets()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.secrets = tmp
            }
            if let value = dict["Total"] as? Int32 {
                self.total = value
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var result: ListK8sSecretsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListK8sSecretsResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListK8sSecretsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListK8sSecretsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListK8sSecretsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMethodsRequest : Tea.TeaModel {
    public var appId: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ServiceName"] as? String {
            self.serviceName = value
        }
    }
}

public class ListMethodsResponseBody : Tea.TeaModel {
    public class ServiceMethodList : Tea.TeaModel {
        public class ServiceMethod : Tea.TeaModel {
            public class InputParams : Tea.TeaModel {
                public var inputParam: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputParam != nil {
                        map["InputParam"] = self.inputParam!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InputParam"] as? [String] {
                        self.inputParam = value
                    }
                }
            }
            public class ParamTypes : Tea.TeaModel {
                public var paramType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.paramType != nil {
                        map["ParamType"] = self.paramType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ParamType"] as? [String] {
                        self.paramType = value
                    }
                }
            }
            public var appName: String?

            public var inputParams: ListMethodsResponseBody.ServiceMethodList.ServiceMethod.InputParams?

            public var methodName: String?

            public var output: String?

            public var paramTypes: ListMethodsResponseBody.ServiceMethodList.ServiceMethod.ParamTypes?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inputParams?.validate()
                try self.paramTypes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.inputParams != nil {
                    map["InputParams"] = self.inputParams?.toMap()
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.output != nil {
                    map["Output"] = self.output!
                }
                if self.paramTypes != nil {
                    map["ParamTypes"] = self.paramTypes?.toMap()
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["InputParams"] as? [String: Any?] {
                    var model = ListMethodsResponseBody.ServiceMethodList.ServiceMethod.InputParams()
                    model.fromMap(value)
                    self.inputParams = model
                }
                if let value = dict["MethodName"] as? String {
                    self.methodName = value
                }
                if let value = dict["Output"] as? String {
                    self.output = value
                }
                if let value = dict["ParamTypes"] as? [String: Any?] {
                    var model = ListMethodsResponseBody.ServiceMethodList.ServiceMethod.ParamTypes()
                    model.fromMap(value)
                    self.paramTypes = model
                }
                if let value = dict["ServiceName"] as? String {
                    self.serviceName = value
                }
            }
        }
        public var serviceMethod: [ListMethodsResponseBody.ServiceMethodList.ServiceMethod]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceMethod != nil {
                var tmp : [Any] = []
                for k in self.serviceMethod! {
                    tmp.append(k.toMap())
                }
                map["ServiceMethod"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ServiceMethod"] as? [Any?] {
                var tmp : [ListMethodsResponseBody.ServiceMethodList.ServiceMethod] = []
                for v in value {
                    if v != nil {
                        var model = ListMethodsResponseBody.ServiceMethodList.ServiceMethod()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.serviceMethod = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var serviceMethodList: ListMethodsResponseBody.ServiceMethodList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serviceMethodList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceMethodList != nil {
            map["ServiceMethodList"] = self.serviceMethodList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ServiceMethodList"] as? [String: Any?] {
            var model = ListMethodsResponseBody.ServiceMethodList()
            model.fromMap(value)
            self.serviceMethodList = model
        }
    }
}

public class ListMethodsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMethodsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMethodsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPublishedServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListPublishedServicesResponseBody : Tea.TeaModel {
    public class PublishedServicesList : Tea.TeaModel {
        public class ListPublishedServices : Tea.TeaModel {
            public class Groups : Tea.TeaModel {
                public var group: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.group != nil {
                        map["group"] = self.group!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["group"] as? [String] {
                        self.group = value
                    }
                }
            }
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ip"] as? [String] {
                        self.ip = value
                    }
                }
            }
            public var appId: String?

            public var dockerApplication: Bool?

            public var group2Ip: String?

            public var groups: ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices.Groups?

            public var ips: ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices.Ips?

            public var name: String?

            public var type: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groups?.validate()
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.dockerApplication != nil {
                    map["DockerApplication"] = self.dockerApplication!
                }
                if self.group2Ip != nil {
                    map["Group2Ip"] = self.group2Ip!
                }
                if self.groups != nil {
                    map["Groups"] = self.groups?.toMap()
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["DockerApplication"] as? Bool {
                    self.dockerApplication = value
                }
                if let value = dict["Group2Ip"] as? String {
                    self.group2Ip = value
                }
                if let value = dict["Groups"] as? [String: Any?] {
                    var model = ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices.Groups()
                    model.fromMap(value)
                    self.groups = model
                }
                if let value = dict["Ips"] as? [String: Any?] {
                    var model = ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices.Ips()
                    model.fromMap(value)
                    self.ips = model
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Version"] as? String {
                    self.version = value
                }
            }
        }
        public var listPublishedServices: [ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.listPublishedServices != nil {
                var tmp : [Any] = []
                for k in self.listPublishedServices! {
                    tmp.append(k.toMap())
                }
                map["ListPublishedServices"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ListPublishedServices"] as? [Any?] {
                var tmp : [ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices] = []
                for v in value {
                    if v != nil {
                        var model = ListPublishedServicesResponseBody.PublishedServicesList.ListPublishedServices()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.listPublishedServices = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var publishedServicesList: ListPublishedServicesResponseBody.PublishedServicesList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.publishedServicesList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.publishedServicesList != nil {
            map["PublishedServicesList"] = self.publishedServicesList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PublishedServicesList"] as? [String: Any?] {
            var model = ListPublishedServicesResponseBody.PublishedServicesList()
            model.fromMap(value)
            self.publishedServicesList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListPublishedServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublishedServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPublishedServicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRecentChangeOrderRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListRecentChangeOrderResponseBody : Tea.TeaModel {
    public class ChangeOrderList : Tea.TeaModel {
        public class ChangeOrder : Tea.TeaModel {
            public var appId: String?

            public var batchCount: Int32?

            public var batchType: String?

            public var changeOrderDescription: String?

            public var changeOrderId: String?

            public var coType: String?

            public var coTypeCode: String?

            public var createTime: String?

            public var createUserId: String?

            public var finishTime: String?

            public var groupId: String?

            public var source: String?

            public var status: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.batchCount != nil {
                    map["BatchCount"] = self.batchCount!
                }
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.changeOrderDescription != nil {
                    map["ChangeOrderDescription"] = self.changeOrderDescription!
                }
                if self.changeOrderId != nil {
                    map["ChangeOrderId"] = self.changeOrderId!
                }
                if self.coType != nil {
                    map["CoType"] = self.coType!
                }
                if self.coTypeCode != nil {
                    map["CoTypeCode"] = self.coTypeCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["BatchCount"] as? Int32 {
                    self.batchCount = value
                }
                if let value = dict["BatchType"] as? String {
                    self.batchType = value
                }
                if let value = dict["ChangeOrderDescription"] as? String {
                    self.changeOrderDescription = value
                }
                if let value = dict["ChangeOrderId"] as? String {
                    self.changeOrderId = value
                }
                if let value = dict["CoType"] as? String {
                    self.coType = value
                }
                if let value = dict["CoTypeCode"] as? String {
                    self.coTypeCode = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateUserId"] as? String {
                    self.createUserId = value
                }
                if let value = dict["FinishTime"] as? String {
                    self.finishTime = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["Source"] as? String {
                    self.source = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var changeOrder: [ListRecentChangeOrderResponseBody.ChangeOrderList.ChangeOrder]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrder != nil {
                var tmp : [Any] = []
                for k in self.changeOrder! {
                    tmp.append(k.toMap())
                }
                map["ChangeOrder"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrder"] as? [Any?] {
                var tmp : [ListRecentChangeOrderResponseBody.ChangeOrderList.ChangeOrder] = []
                for v in value {
                    if v != nil {
                        var model = ListRecentChangeOrderResponseBody.ChangeOrderList.ChangeOrder()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.changeOrder = tmp
            }
        }
    }
    public var changeOrderList: ListRecentChangeOrderResponseBody.ChangeOrderList?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.changeOrderList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderList != nil {
            map["ChangeOrderList"] = self.changeOrderList?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderList"] as? [String: Any?] {
            var model = ListRecentChangeOrderResponseBody.ChangeOrderList()
            model.fromMap(value)
            self.changeOrderList = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListRecentChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRecentChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRecentChangeOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListResourceGroupResponseBody : Tea.TeaModel {
    public class ResourceGroupList : Tea.TeaModel {
        public class ResGroupEntity : Tea.TeaModel {
            public class SlbList : Tea.TeaModel {
                public class SlbEntity : Tea.TeaModel {
                    public var address: String?

                    public var addressType: String?

                    public var expired: Bool?

                    public var groupId: Int32?

                    public var networkType: String?

                    public var regionId: String?

                    public var slbId: String?

                    public var slbName: String?

                    public var slbStatus: String?

                    public var userId: String?

                    public var vpcId: String?

                    public var vswitchId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.addressType != nil {
                            map["AddressType"] = self.addressType!
                        }
                        if self.expired != nil {
                            map["Expired"] = self.expired!
                        }
                        if self.groupId != nil {
                            map["GroupId"] = self.groupId!
                        }
                        if self.networkType != nil {
                            map["NetworkType"] = self.networkType!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.slbId != nil {
                            map["SlbId"] = self.slbId!
                        }
                        if self.slbName != nil {
                            map["SlbName"] = self.slbName!
                        }
                        if self.slbStatus != nil {
                            map["SlbStatus"] = self.slbStatus!
                        }
                        if self.userId != nil {
                            map["UserId"] = self.userId!
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        if self.vswitchId != nil {
                            map["VswitchId"] = self.vswitchId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Address"] as? String {
                            self.address = value
                        }
                        if let value = dict["AddressType"] as? String {
                            self.addressType = value
                        }
                        if let value = dict["Expired"] as? Bool {
                            self.expired = value
                        }
                        if let value = dict["GroupId"] as? Int32 {
                            self.groupId = value
                        }
                        if let value = dict["NetworkType"] as? String {
                            self.networkType = value
                        }
                        if let value = dict["RegionId"] as? String {
                            self.regionId = value
                        }
                        if let value = dict["SlbId"] as? String {
                            self.slbId = value
                        }
                        if let value = dict["SlbName"] as? String {
                            self.slbName = value
                        }
                        if let value = dict["SlbStatus"] as? String {
                            self.slbStatus = value
                        }
                        if let value = dict["UserId"] as? String {
                            self.userId = value
                        }
                        if let value = dict["VpcId"] as? String {
                            self.vpcId = value
                        }
                        if let value = dict["VswitchId"] as? String {
                            self.vswitchId = value
                        }
                    }
                }
                public var slbEntity: [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList.SlbEntity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.slbEntity != nil {
                        var tmp : [Any] = []
                        for k in self.slbEntity! {
                            tmp.append(k.toMap())
                        }
                        map["SlbEntity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SlbEntity"] as? [Any?] {
                        var tmp : [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList.SlbEntity] = []
                        for v in value {
                            if v != nil {
                                var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList.SlbEntity()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.slbEntity = tmp
                    }
                }
            }
            public class EcsList : Tea.TeaModel {
                public class EcsEntity : Tea.TeaModel {
                    public class EcuEntity : Tea.TeaModel {
                        public var availableCpu: Int32?

                        public var availableMem: Int32?

                        public var cpu: Int32?

                        public var createTime: Int64?

                        public var dockerEnv: Bool?

                        public var ecuId: String?

                        public var heartbeatTime: Int64?

                        public var instanceId: String?

                        public var ipAddr: String?

                        public var mem: Int32?

                        public var name: String?

                        public var online: Bool?

                        public var regionId: String?

                        public var updateTime: Int64?

                        public var userId: String?

                        public var vpcId: String?

                        public var zoneId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableCpu != nil {
                                map["AvailableCpu"] = self.availableCpu!
                            }
                            if self.availableMem != nil {
                                map["AvailableMem"] = self.availableMem!
                            }
                            if self.cpu != nil {
                                map["Cpu"] = self.cpu!
                            }
                            if self.createTime != nil {
                                map["CreateTime"] = self.createTime!
                            }
                            if self.dockerEnv != nil {
                                map["DockerEnv"] = self.dockerEnv!
                            }
                            if self.ecuId != nil {
                                map["EcuId"] = self.ecuId!
                            }
                            if self.heartbeatTime != nil {
                                map["HeartbeatTime"] = self.heartbeatTime!
                            }
                            if self.instanceId != nil {
                                map["InstanceId"] = self.instanceId!
                            }
                            if self.ipAddr != nil {
                                map["IpAddr"] = self.ipAddr!
                            }
                            if self.mem != nil {
                                map["Mem"] = self.mem!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            if self.online != nil {
                                map["Online"] = self.online!
                            }
                            if self.regionId != nil {
                                map["RegionId"] = self.regionId!
                            }
                            if self.updateTime != nil {
                                map["UpdateTime"] = self.updateTime!
                            }
                            if self.userId != nil {
                                map["UserId"] = self.userId!
                            }
                            if self.vpcId != nil {
                                map["VpcId"] = self.vpcId!
                            }
                            if self.zoneId != nil {
                                map["ZoneId"] = self.zoneId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["AvailableCpu"] as? Int32 {
                                self.availableCpu = value
                            }
                            if let value = dict["AvailableMem"] as? Int32 {
                                self.availableMem = value
                            }
                            if let value = dict["Cpu"] as? Int32 {
                                self.cpu = value
                            }
                            if let value = dict["CreateTime"] as? Int64 {
                                self.createTime = value
                            }
                            if let value = dict["DockerEnv"] as? Bool {
                                self.dockerEnv = value
                            }
                            if let value = dict["EcuId"] as? String {
                                self.ecuId = value
                            }
                            if let value = dict["HeartbeatTime"] as? Int64 {
                                self.heartbeatTime = value
                            }
                            if let value = dict["InstanceId"] as? String {
                                self.instanceId = value
                            }
                            if let value = dict["IpAddr"] as? String {
                                self.ipAddr = value
                            }
                            if let value = dict["Mem"] as? Int32 {
                                self.mem = value
                            }
                            if let value = dict["Name"] as? String {
                                self.name = value
                            }
                            if let value = dict["Online"] as? Bool {
                                self.online = value
                            }
                            if let value = dict["RegionId"] as? String {
                                self.regionId = value
                            }
                            if let value = dict["UpdateTime"] as? Int64 {
                                self.updateTime = value
                            }
                            if let value = dict["UserId"] as? String {
                                self.userId = value
                            }
                            if let value = dict["VpcId"] as? String {
                                self.vpcId = value
                            }
                            if let value = dict["ZoneId"] as? String {
                                self.zoneId = value
                            }
                        }
                    }
                    public class VpcEntity : Tea.TeaModel {
                        public var cidrblock: String?

                        public var description_: String?

                        public var ecsNum: Int32?

                        public var expired: Bool?

                        public var regionId: String?

                        public var status: String?

                        public var userId: String?

                        public var vpcId: String?

                        public var vpcName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.cidrblock != nil {
                                map["Cidrblock"] = self.cidrblock!
                            }
                            if self.description_ != nil {
                                map["Description"] = self.description_!
                            }
                            if self.ecsNum != nil {
                                map["EcsNum"] = self.ecsNum!
                            }
                            if self.expired != nil {
                                map["Expired"] = self.expired!
                            }
                            if self.regionId != nil {
                                map["RegionId"] = self.regionId!
                            }
                            if self.status != nil {
                                map["Status"] = self.status!
                            }
                            if self.userId != nil {
                                map["UserId"] = self.userId!
                            }
                            if self.vpcId != nil {
                                map["VpcId"] = self.vpcId!
                            }
                            if self.vpcName != nil {
                                map["VpcName"] = self.vpcName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Cidrblock"] as? String {
                                self.cidrblock = value
                            }
                            if let value = dict["Description"] as? String {
                                self.description_ = value
                            }
                            if let value = dict["EcsNum"] as? Int32 {
                                self.ecsNum = value
                            }
                            if let value = dict["Expired"] as? Bool {
                                self.expired = value
                            }
                            if let value = dict["RegionId"] as? String {
                                self.regionId = value
                            }
                            if let value = dict["Status"] as? String {
                                self.status = value
                            }
                            if let value = dict["UserId"] as? String {
                                self.userId = value
                            }
                            if let value = dict["VpcId"] as? String {
                                self.vpcId = value
                            }
                            if let value = dict["VpcName"] as? String {
                                self.vpcName = value
                            }
                        }
                    }
                    public var cpu: Int32?

                    public var description_: String?

                    public var ecuEntity: ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity.EcuEntity?

                    public var eip: String?

                    public var expired: Bool?

                    public var groupId: String?

                    public var hostName: String?

                    public var innerIp: String?

                    public var instanceId: String?

                    public var instanceName: String?

                    public var mem: Int32?

                    public var privateIp: String?

                    public var publicIp: String?

                    public var regionId: String?

                    public var serialNum: String?

                    public var sgId: String?

                    public var status: String?

                    public var userId: String?

                    public var vpcEntity: ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity.VpcEntity?

                    public var vpcId: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.ecuEntity?.validate()
                        try self.vpcEntity?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cpu != nil {
                            map["Cpu"] = self.cpu!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.ecuEntity != nil {
                            map["EcuEntity"] = self.ecuEntity?.toMap()
                        }
                        if self.eip != nil {
                            map["Eip"] = self.eip!
                        }
                        if self.expired != nil {
                            map["Expired"] = self.expired!
                        }
                        if self.groupId != nil {
                            map["GroupId"] = self.groupId!
                        }
                        if self.hostName != nil {
                            map["HostName"] = self.hostName!
                        }
                        if self.innerIp != nil {
                            map["InnerIp"] = self.innerIp!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceName != nil {
                            map["InstanceName"] = self.instanceName!
                        }
                        if self.mem != nil {
                            map["Mem"] = self.mem!
                        }
                        if self.privateIp != nil {
                            map["PrivateIp"] = self.privateIp!
                        }
                        if self.publicIp != nil {
                            map["PublicIp"] = self.publicIp!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.serialNum != nil {
                            map["SerialNum"] = self.serialNum!
                        }
                        if self.sgId != nil {
                            map["SgId"] = self.sgId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.userId != nil {
                            map["UserId"] = self.userId!
                        }
                        if self.vpcEntity != nil {
                            map["VpcEntity"] = self.vpcEntity?.toMap()
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Cpu"] as? Int32 {
                            self.cpu = value
                        }
                        if let value = dict["Description"] as? String {
                            self.description_ = value
                        }
                        if let value = dict["EcuEntity"] as? [String: Any?] {
                            var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity.EcuEntity()
                            model.fromMap(value)
                            self.ecuEntity = model
                        }
                        if let value = dict["Eip"] as? String {
                            self.eip = value
                        }
                        if let value = dict["Expired"] as? Bool {
                            self.expired = value
                        }
                        if let value = dict["GroupId"] as? String {
                            self.groupId = value
                        }
                        if let value = dict["HostName"] as? String {
                            self.hostName = value
                        }
                        if let value = dict["InnerIp"] as? String {
                            self.innerIp = value
                        }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                        if let value = dict["InstanceName"] as? String {
                            self.instanceName = value
                        }
                        if let value = dict["Mem"] as? Int32 {
                            self.mem = value
                        }
                        if let value = dict["PrivateIp"] as? String {
                            self.privateIp = value
                        }
                        if let value = dict["PublicIp"] as? String {
                            self.publicIp = value
                        }
                        if let value = dict["RegionId"] as? String {
                            self.regionId = value
                        }
                        if let value = dict["SerialNum"] as? String {
                            self.serialNum = value
                        }
                        if let value = dict["SgId"] as? String {
                            self.sgId = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                        if let value = dict["UserId"] as? String {
                            self.userId = value
                        }
                        if let value = dict["VpcEntity"] as? [String: Any?] {
                            var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity.VpcEntity()
                            model.fromMap(value)
                            self.vpcEntity = model
                        }
                        if let value = dict["VpcId"] as? String {
                            self.vpcId = value
                        }
                        if let value = dict["ZoneId"] as? String {
                            self.zoneId = value
                        }
                    }
                }
                public var ecsEntity: [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ecsEntity != nil {
                        var tmp : [Any] = []
                        for k in self.ecsEntity! {
                            tmp.append(k.toMap())
                        }
                        map["EcsEntity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EcsEntity"] as? [Any?] {
                        var tmp : [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity] = []
                        for v in value {
                            if v != nil {
                                var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList.EcsEntity()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ecsEntity = tmp
                    }
                }
            }
            public var adminUserId: String?

            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var name: String?

            public var regionId: String?

            public var slbList: ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList?

            public var updateTime: Int64?

            public var ecsList: ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.slbList?.validate()
                try self.ecsList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adminUserId != nil {
                    map["AdminUserId"] = self.adminUserId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.slbList != nil {
                    map["SlbList"] = self.slbList?.toMap()
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.ecsList != nil {
                    map["ecsList"] = self.ecsList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AdminUserId"] as? String {
                    self.adminUserId = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SlbList"] as? [String: Any?] {
                    var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.SlbList()
                    model.fromMap(value)
                    self.slbList = model
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["ecsList"] as? [String: Any?] {
                    var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity.EcsList()
                    model.fromMap(value)
                    self.ecsList = model
                }
            }
        }
        public var resGroupEntity: [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resGroupEntity != nil {
                var tmp : [Any] = []
                for k in self.resGroupEntity! {
                    tmp.append(k.toMap())
                }
                map["ResGroupEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResGroupEntity"] as? [Any?] {
                var tmp : [ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity] = []
                for v in value {
                    if v != nil {
                        var model = ListResourceGroupResponseBody.ResourceGroupList.ResGroupEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resGroupEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var resourceGroupList: ListResourceGroupResponseBody.ResourceGroupList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceGroupList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupList != nil {
            map["ResourceGroupList"] = self.resourceGroupList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupList"] as? [String: Any?] {
            var model = ListResourceGroupResponseBody.ResourceGroupList()
            model.fromMap(value)
            self.resourceGroupList = model
        }
    }
}

public class ListResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRoleResponseBody : Tea.TeaModel {
    public class RoleList : Tea.TeaModel {
        public class RoleItem : Tea.TeaModel {
            public class ActionList : Tea.TeaModel {
                public class Action : Tea.TeaModel {
                    public var code: String?

                    public var description_: String?

                    public var groupId: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.groupId != nil {
                            map["GroupId"] = self.groupId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Code"] as? String {
                            self.code = value
                        }
                        if let value = dict["Description"] as? String {
                            self.description_ = value
                        }
                        if let value = dict["GroupId"] as? String {
                            self.groupId = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                    }
                }
                public var action: [ListRoleResponseBody.RoleList.RoleItem.ActionList.Action]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        var tmp : [Any] = []
                        for k in self.action! {
                            tmp.append(k.toMap())
                        }
                        map["Action"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Action"] as? [Any?] {
                        var tmp : [ListRoleResponseBody.RoleList.RoleItem.ActionList.Action] = []
                        for v in value {
                            if v != nil {
                                var model = ListRoleResponseBody.RoleList.RoleItem.ActionList.Action()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.action = tmp
                    }
                }
            }
            public class Role : Tea.TeaModel {
                public var adminUserId: String?

                public var createTime: Int64?

                public var id: Int32?

                public var isDefault: Bool?

                public var name: String?

                public var updateTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adminUserId != nil {
                        map["AdminUserId"] = self.adminUserId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.isDefault != nil {
                        map["IsDefault"] = self.isDefault!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AdminUserId"] as? String {
                        self.adminUserId = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["Id"] as? Int32 {
                        self.id = value
                    }
                    if let value = dict["IsDefault"] as? Bool {
                        self.isDefault = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["UpdateTime"] as? Int64 {
                        self.updateTime = value
                    }
                }
            }
            public var actionList: ListRoleResponseBody.RoleList.RoleItem.ActionList?

            public var role: ListRoleResponseBody.RoleList.RoleItem.Role?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.actionList?.validate()
                try self.role?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionList != nil {
                    map["ActionList"] = self.actionList?.toMap()
                }
                if self.role != nil {
                    map["Role"] = self.role?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActionList"] as? [String: Any?] {
                    var model = ListRoleResponseBody.RoleList.RoleItem.ActionList()
                    model.fromMap(value)
                    self.actionList = model
                }
                if let value = dict["Role"] as? [String: Any?] {
                    var model = ListRoleResponseBody.RoleList.RoleItem.Role()
                    model.fromMap(value)
                    self.role = model
                }
            }
        }
        public var roleItem: [ListRoleResponseBody.RoleList.RoleItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roleItem != nil {
                var tmp : [Any] = []
                for k in self.roleItem! {
                    tmp.append(k.toMap())
                }
                map["RoleItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RoleItem"] as? [Any?] {
                var tmp : [ListRoleResponseBody.RoleList.RoleItem] = []
                for v in value {
                    if v != nil {
                        var model = ListRoleResponseBody.RoleList.RoleItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.roleItem = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var roleList: ListRoleResponseBody.RoleList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.roleList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.roleList != nil {
            map["RoleList"] = self.roleList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RoleList"] as? [String: Any?] {
            var model = ListRoleResponseBody.RoleList()
            model.fromMap(value)
            self.roleList = model
        }
    }
}

public class ListRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListScaleOutEcuRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var cpu: Int32?

    public var groupId: String?

    public var instanceNum: Int32?

    public var logicalRegionId: String?

    public var mem: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceNum != nil {
            map["InstanceNum"] = self.instanceNum!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        if self.mem != nil {
            map["Mem"] = self.mem!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InstanceNum"] as? Int32 {
            self.instanceNum = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
        if let value = dict["Mem"] as? Int32 {
            self.mem = value
        }
    }
}

public class ListScaleOutEcuResponseBody : Tea.TeaModel {
    public class EcuInfoList : Tea.TeaModel {
        public class EcuInfo : Tea.TeaModel {
            public var availableCpu: Int32?

            public var availableMem: Int32?

            public var createTime: Int64?

            public var dockerEnv: Bool?

            public var ecuId: String?

            public var heartbeatTime: Int64?

            public var instanceId: String?

            public var ipAddr: String?

            public var name: String?

            public var online: Bool?

            public var regionId: String?

            public var updateTime: Int64?

            public var userId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableCpu != nil {
                    map["AvailableCpu"] = self.availableCpu!
                }
                if self.availableMem != nil {
                    map["AvailableMem"] = self.availableMem!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerEnv != nil {
                    map["DockerEnv"] = self.dockerEnv!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.heartbeatTime != nil {
                    map["HeartbeatTime"] = self.heartbeatTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipAddr != nil {
                    map["IpAddr"] = self.ipAddr!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableCpu"] as? Int32 {
                    self.availableCpu = value
                }
                if let value = dict["AvailableMem"] as? Int32 {
                    self.availableMem = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DockerEnv"] as? Bool {
                    self.dockerEnv = value
                }
                if let value = dict["EcuId"] as? String {
                    self.ecuId = value
                }
                if let value = dict["HeartbeatTime"] as? Int64 {
                    self.heartbeatTime = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["IpAddr"] as? String {
                    self.ipAddr = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Online"] as? Bool {
                    self.online = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var ecuInfo: [ListScaleOutEcuResponseBody.EcuInfoList.EcuInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecuInfo != nil {
                var tmp : [Any] = []
                for k in self.ecuInfo! {
                    tmp.append(k.toMap())
                }
                map["EcuInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EcuInfo"] as? [Any?] {
                var tmp : [ListScaleOutEcuResponseBody.EcuInfoList.EcuInfo] = []
                for v in value {
                    if v != nil {
                        var model = ListScaleOutEcuResponseBody.EcuInfoList.EcuInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ecuInfo = tmp
            }
        }
    }
    public var code: Int32?

    public var ecuInfoList: ListScaleOutEcuResponseBody.EcuInfoList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecuInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecuInfoList != nil {
            map["EcuInfoList"] = self.ecuInfoList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["EcuInfoList"] as? [String: Any?] {
            var model = ListScaleOutEcuResponseBody.EcuInfoList()
            model.fromMap(value)
            self.ecuInfoList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListScaleOutEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScaleOutEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListScaleOutEcuResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListServiceGroupsResponseBody : Tea.TeaModel {
    public class ServiceGroupsList : Tea.TeaModel {
        public class ListServiceGroups : Tea.TeaModel {
            public var createTime: String?

            public var groupId: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
            }
        }
        public var listServiceGroups: [ListServiceGroupsResponseBody.ServiceGroupsList.ListServiceGroups]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.listServiceGroups != nil {
                var tmp : [Any] = []
                for k in self.listServiceGroups! {
                    tmp.append(k.toMap())
                }
                map["ListServiceGroups"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ListServiceGroups"] as? [Any?] {
                var tmp : [ListServiceGroupsResponseBody.ServiceGroupsList.ListServiceGroups] = []
                for v in value {
                    if v != nil {
                        var model = ListServiceGroupsResponseBody.ServiceGroupsList.ListServiceGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.listServiceGroups = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var serviceGroupsList: ListServiceGroupsResponseBody.ServiceGroupsList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serviceGroupsList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceGroupsList != nil {
            map["ServiceGroupsList"] = self.serviceGroupsList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ServiceGroupsList"] as? [String: Any?] {
            var model = ListServiceGroupsResponseBody.ServiceGroupsList()
            model.fromMap(value)
            self.serviceGroupsList = model
        }
    }
}

public class ListServiceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListServiceGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSlbRequest : Tea.TeaModel {
    public var addressType: String?

    public var slbType: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressType != nil {
            map["AddressType"] = self.addressType!
        }
        if self.slbType != nil {
            map["SlbType"] = self.slbType!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressType"] as? String {
            self.addressType = value
        }
        if let value = dict["SlbType"] as? String {
            self.slbType = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ListSlbResponseBody : Tea.TeaModel {
    public class SlbList : Tea.TeaModel {
        public class SlbEntity : Tea.TeaModel {
            public var address: String?

            public var addressType: String?

            public var expired: Bool?

            public var groupId: Int32?

            public var networkType: String?

            public var regionId: String?

            public var reusable: Bool?

            public var slbId: String?

            public var slbName: String?

            public var slbStatus: String?

            public var tags: String?

            public var userId: String?

            public var vpcId: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressType != nil {
                    map["AddressType"] = self.addressType!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reusable != nil {
                    map["Reusable"] = self.reusable!
                }
                if self.slbId != nil {
                    map["SlbId"] = self.slbId!
                }
                if self.slbName != nil {
                    map["SlbName"] = self.slbName!
                }
                if self.slbStatus != nil {
                    map["SlbStatus"] = self.slbStatus!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vswitchId != nil {
                    map["VswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Address"] as? String {
                    self.address = value
                }
                if let value = dict["AddressType"] as? String {
                    self.addressType = value
                }
                if let value = dict["Expired"] as? Bool {
                    self.expired = value
                }
                if let value = dict["GroupId"] as? Int32 {
                    self.groupId = value
                }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Reusable"] as? Bool {
                    self.reusable = value
                }
                if let value = dict["SlbId"] as? String {
                    self.slbId = value
                }
                if let value = dict["SlbName"] as? String {
                    self.slbName = value
                }
                if let value = dict["SlbStatus"] as? String {
                    self.slbStatus = value
                }
                if let value = dict["Tags"] as? String {
                    self.tags = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["VswitchId"] as? String {
                    self.vswitchId = value
                }
            }
        }
        public var slbEntity: [ListSlbResponseBody.SlbList.SlbEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbEntity != nil {
                var tmp : [Any] = []
                for k in self.slbEntity! {
                    tmp.append(k.toMap())
                }
                map["SlbEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SlbEntity"] as? [Any?] {
                var tmp : [ListSlbResponseBody.SlbList.SlbEntity] = []
                for v in value {
                    if v != nil {
                        var model = ListSlbResponseBody.SlbList.SlbEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.slbEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var slbList: ListSlbResponseBody.SlbList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.slbList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slbList != nil {
            map["SlbList"] = self.slbList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SlbList"] as? [String: Any?] {
            var model = ListSlbResponseBody.SlbList()
            model.fromMap(value)
            self.slbList = model
        }
    }
}

public class ListSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSubAccountResponseBody : Tea.TeaModel {
    public class SubAccountList : Tea.TeaModel {
        public class SubAccount : Tea.TeaModel {
            public var adminEdasId: String?

            public var adminUserId: String?

            public var adminUserKp: String?

            public var email: String?

            public var phone: String?

            public var subEdasId: String?

            public var subUserId: String?

            public var subUserKp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adminEdasId != nil {
                    map["AdminEdasId"] = self.adminEdasId!
                }
                if self.adminUserId != nil {
                    map["AdminUserId"] = self.adminUserId!
                }
                if self.adminUserKp != nil {
                    map["AdminUserKp"] = self.adminUserKp!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.subEdasId != nil {
                    map["SubEdasId"] = self.subEdasId!
                }
                if self.subUserId != nil {
                    map["SubUserId"] = self.subUserId!
                }
                if self.subUserKp != nil {
                    map["SubUserKp"] = self.subUserKp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AdminEdasId"] as? String {
                    self.adminEdasId = value
                }
                if let value = dict["AdminUserId"] as? String {
                    self.adminUserId = value
                }
                if let value = dict["AdminUserKp"] as? String {
                    self.adminUserKp = value
                }
                if let value = dict["Email"] as? String {
                    self.email = value
                }
                if let value = dict["Phone"] as? String {
                    self.phone = value
                }
                if let value = dict["SubEdasId"] as? String {
                    self.subEdasId = value
                }
                if let value = dict["SubUserId"] as? String {
                    self.subUserId = value
                }
                if let value = dict["SubUserKp"] as? String {
                    self.subUserKp = value
                }
            }
        }
        public var subAccount: [ListSubAccountResponseBody.SubAccountList.SubAccount]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subAccount != nil {
                var tmp : [Any] = []
                for k in self.subAccount! {
                    tmp.append(k.toMap())
                }
                map["SubAccount"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SubAccount"] as? [Any?] {
                var tmp : [ListSubAccountResponseBody.SubAccountList.SubAccount] = []
                for v in value {
                    if v != nil {
                        var model = ListSubAccountResponseBody.SubAccountList.SubAccount()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.subAccount = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var subAccountList: ListSubAccountResponseBody.SubAccountList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subAccountList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subAccountList != nil {
            map["SubAccountList"] = self.subAccountList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SubAccountList"] as? [String: Any?] {
            var model = ListSubAccountResponseBody.SubAccountList()
            model.fromMap(value)
            self.subAccountList = model
        }
    }
}

public class ListSubAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSubAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSubAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSwimmingLaneRequest : Tea.TeaModel {
    public var groupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
    }
}

public class ListSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SwimmingLaneAppRelationShipList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var extra: String?

            public var laneId: Int64?

            public var rules: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.extra != nil {
                    map["Extra"] = self.extra!
                }
                if self.laneId != nil {
                    map["LaneId"] = self.laneId!
                }
                if self.rules != nil {
                    map["Rules"] = self.rules!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["Extra"] as? String {
                    self.extra = value
                }
                if let value = dict["LaneId"] as? Int64 {
                    self.laneId = value
                }
                if let value = dict["Rules"] as? String {
                    self.rules = value
                }
            }
        }
        public var enableRules: Bool?

        public var entryRule: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public var scenarioSign: String?

        public var swimmingLaneAppRelationShipList: [ListSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList]?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableRules != nil {
                map["EnableRules"] = self.enableRules!
            }
            if self.entryRule != nil {
                map["EntryRule"] = self.entryRule!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.scenarioSign != nil {
                map["ScenarioSign"] = self.scenarioSign!
            }
            if self.swimmingLaneAppRelationShipList != nil {
                var tmp : [Any] = []
                for k in self.swimmingLaneAppRelationShipList! {
                    tmp.append(k.toMap())
                }
                map["SwimmingLaneAppRelationShipList"] = tmp
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableRules"] as? Bool {
                self.enableRules = value
            }
            if let value = dict["EntryRule"] as? String {
                self.entryRule = value
            }
            if let value = dict["GroupId"] as? Int64 {
                self.groupId = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["ScenarioSign"] as? String {
                self.scenarioSign = value
            }
            if let value = dict["SwimmingLaneAppRelationShipList"] as? [Any?] {
                var tmp : [ListSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList] = []
                for v in value {
                    if v != nil {
                        var model = ListSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.swimmingLaneAppRelationShipList = tmp
            }
            if let value = dict["Tag"] as? String {
                self.tag = value
            }
        }
    }
    public var code: Int32?

    public var data: [ListSwimmingLaneResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListSwimmingLaneResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListSwimmingLaneResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSwimmingLaneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSwimmingLaneGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
    }
}

public class ListSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApplicationList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
            }
        }
        public class EntryApplication : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var source: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["Source"] as? String {
                    self.source = value
                }
            }
        }
        public var applicationList: [ListSwimmingLaneGroupResponseBody.Data.ApplicationList]?

        public var entryApplication: ListSwimmingLaneGroupResponseBody.Data.EntryApplication?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.entryApplication?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationList != nil {
                var tmp : [Any] = []
                for k in self.applicationList! {
                    tmp.append(k.toMap())
                }
                map["ApplicationList"] = tmp
            }
            if self.entryApplication != nil {
                map["EntryApplication"] = self.entryApplication?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationList"] as? [Any?] {
                var tmp : [ListSwimmingLaneGroupResponseBody.Data.ApplicationList] = []
                for v in value {
                    if v != nil {
                        var model = ListSwimmingLaneGroupResponseBody.Data.ApplicationList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.applicationList = tmp
            }
            if let value = dict["EntryApplication"] as? [String: Any?] {
                var model = ListSwimmingLaneGroupResponseBody.Data.EntryApplication()
                model.fromMap(value)
                self.entryApplication = model
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
        }
    }
    public var code: Int32?

    public var data: [ListSwimmingLaneGroupResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListSwimmingLaneGroupResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListSwimmingLaneGroupResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSwimmingLaneGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public var resourceIds: [String: Any]?

    public var resourceRegionId: String?

    public var resourceType: String?

    public var tags: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceRegionId != nil {
            map["ResourceRegionId"] = self.resourceRegionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ResourceIds"] as? [String: Any] {
            self.resourceIds = value
        }
        if let value = dict["ResourceRegionId"] as? String {
            self.resourceRegionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tags"] as? [String: Any] {
            self.tags = value
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = ListTagResourcesResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUserDefineRegionRequest : Tea.TeaModel {
    public var debugEnable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.debugEnable != nil {
            map["DebugEnable"] = self.debugEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DebugEnable"] as? Bool {
            self.debugEnable = value
        }
    }
}

public class ListUserDefineRegionResponseBody : Tea.TeaModel {
    public class UserDefineRegionList : Tea.TeaModel {
        public class UserDefineRegionEntity : Tea.TeaModel {
            public var belongRegion: String?

            public var debugEnable: Bool?

            public var description_: String?

            public var id: Int64?

            public var mseInstanceId: String?

            public var regionId: String?

            public var regionName: String?

            public var registryType: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.belongRegion != nil {
                    map["BelongRegion"] = self.belongRegion!
                }
                if self.debugEnable != nil {
                    map["DebugEnable"] = self.debugEnable!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.mseInstanceId != nil {
                    map["MseInstanceId"] = self.mseInstanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.regionName != nil {
                    map["RegionName"] = self.regionName!
                }
                if self.registryType != nil {
                    map["RegistryType"] = self.registryType!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BelongRegion"] as? String {
                    self.belongRegion = value
                }
                if let value = dict["DebugEnable"] as? Bool {
                    self.debugEnable = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["MseInstanceId"] as? String {
                    self.mseInstanceId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RegionName"] as? String {
                    self.regionName = value
                }
                if let value = dict["RegistryType"] as? String {
                    self.registryType = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var userDefineRegionEntity: [ListUserDefineRegionResponseBody.UserDefineRegionList.UserDefineRegionEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userDefineRegionEntity != nil {
                var tmp : [Any] = []
                for k in self.userDefineRegionEntity! {
                    tmp.append(k.toMap())
                }
                map["UserDefineRegionEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["UserDefineRegionEntity"] as? [Any?] {
                var tmp : [ListUserDefineRegionResponseBody.UserDefineRegionList.UserDefineRegionEntity] = []
                for v in value {
                    if v != nil {
                        var model = ListUserDefineRegionResponseBody.UserDefineRegionList.UserDefineRegionEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.userDefineRegionEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var userDefineRegionList: ListUserDefineRegionResponseBody.UserDefineRegionList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userDefineRegionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userDefineRegionList != nil {
            map["UserDefineRegionList"] = self.userDefineRegionList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UserDefineRegionList"] as? [String: Any?] {
            var model = ListUserDefineRegionResponseBody.UserDefineRegionList()
            model.fromMap(value)
            self.userDefineRegionList = model
        }
    }
}

public class ListUserDefineRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserDefineRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUserDefineRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListVpcResponseBody : Tea.TeaModel {
    public class VpcList : Tea.TeaModel {
        public class VpcEntity : Tea.TeaModel {
            public var ecsNum: Int32?

            public var expired: Bool?

            public var regionId: String?

            public var userId: String?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecsNum != nil {
                    map["EcsNum"] = self.ecsNum!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EcsNum"] as? Int32 {
                    self.ecsNum = value
                }
                if let value = dict["Expired"] as? Bool {
                    self.expired = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["VpcName"] as? String {
                    self.vpcName = value
                }
            }
        }
        public var vpcEntity: [ListVpcResponseBody.VpcList.VpcEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpcEntity != nil {
                var tmp : [Any] = []
                for k in self.vpcEntity! {
                    tmp.append(k.toMap())
                }
                map["VpcEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VpcEntity"] as? [Any?] {
                var tmp : [ListVpcResponseBody.VpcList.VpcEntity] = []
                for v in value {
                    if v != nil {
                        var model = ListVpcResponseBody.VpcList.VpcEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vpcEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var vpcList: ListVpcResponseBody.VpcList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpcList != nil {
            map["VpcList"] = self.vpcList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VpcList"] as? [String: Any?] {
            var model = ListVpcResponseBody.VpcList()
            model.fromMap(value)
            self.vpcList = model
        }
    }
}

public class ListVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MigrateEcuRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
    }
}

public class MigrateEcuResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class MigrateEcuResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateEcuResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MigrateEcuResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyScalingRuleRequest : Tea.TeaModel {
    public var acceptEULA: Bool?

    public var appId: String?

    public var groupId: String?

    public var inCondition: String?

    public var inCpu: Int32?

    public var inDuration: Int32?

    public var inEnable: Bool?

    public var inInstanceNum: Int32?

    public var inLoad: Int32?

    public var inRT: Int32?

    public var inStep: Int32?

    public var keyPairName: String?

    public var multiAzPolicy: String?

    public var outCPU: Int32?

    public var outCondition: String?

    public var outDuration: Int32?

    public var outEnable: Bool?

    public var outInstanceNum: Int32?

    public var outLoad: Int32?

    public var outRT: Int32?

    public var outStep: Int32?

    public var password: String?

    public var resourceFrom: String?

    public var scalingPolicy: String?

    public var templateId: String?

    public var templateInstanceId: String?

    public var templateInstanceName: String?

    public var templateVersion: Int32?

    public var vSwitchIds: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptEULA != nil {
            map["AcceptEULA"] = self.acceptEULA!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.inCondition != nil {
            map["InCondition"] = self.inCondition!
        }
        if self.inCpu != nil {
            map["InCpu"] = self.inCpu!
        }
        if self.inDuration != nil {
            map["InDuration"] = self.inDuration!
        }
        if self.inEnable != nil {
            map["InEnable"] = self.inEnable!
        }
        if self.inInstanceNum != nil {
            map["InInstanceNum"] = self.inInstanceNum!
        }
        if self.inLoad != nil {
            map["InLoad"] = self.inLoad!
        }
        if self.inRT != nil {
            map["InRT"] = self.inRT!
        }
        if self.inStep != nil {
            map["InStep"] = self.inStep!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.multiAzPolicy != nil {
            map["MultiAzPolicy"] = self.multiAzPolicy!
        }
        if self.outCPU != nil {
            map["OutCPU"] = self.outCPU!
        }
        if self.outCondition != nil {
            map["OutCondition"] = self.outCondition!
        }
        if self.outDuration != nil {
            map["OutDuration"] = self.outDuration!
        }
        if self.outEnable != nil {
            map["OutEnable"] = self.outEnable!
        }
        if self.outInstanceNum != nil {
            map["OutInstanceNum"] = self.outInstanceNum!
        }
        if self.outLoad != nil {
            map["OutLoad"] = self.outLoad!
        }
        if self.outRT != nil {
            map["OutRT"] = self.outRT!
        }
        if self.outStep != nil {
            map["OutStep"] = self.outStep!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.resourceFrom != nil {
            map["ResourceFrom"] = self.resourceFrom!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateInstanceId != nil {
            map["TemplateInstanceId"] = self.templateInstanceId!
        }
        if self.templateInstanceName != nil {
            map["TemplateInstanceName"] = self.templateInstanceName!
        }
        if self.templateVersion != nil {
            map["TemplateVersion"] = self.templateVersion!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptEULA"] as? Bool {
            self.acceptEULA = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InCondition"] as? String {
            self.inCondition = value
        }
        if let value = dict["InCpu"] as? Int32 {
            self.inCpu = value
        }
        if let value = dict["InDuration"] as? Int32 {
            self.inDuration = value
        }
        if let value = dict["InEnable"] as? Bool {
            self.inEnable = value
        }
        if let value = dict["InInstanceNum"] as? Int32 {
            self.inInstanceNum = value
        }
        if let value = dict["InLoad"] as? Int32 {
            self.inLoad = value
        }
        if let value = dict["InRT"] as? Int32 {
            self.inRT = value
        }
        if let value = dict["InStep"] as? Int32 {
            self.inStep = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["MultiAzPolicy"] as? String {
            self.multiAzPolicy = value
        }
        if let value = dict["OutCPU"] as? Int32 {
            self.outCPU = value
        }
        if let value = dict["OutCondition"] as? String {
            self.outCondition = value
        }
        if let value = dict["OutDuration"] as? Int32 {
            self.outDuration = value
        }
        if let value = dict["OutEnable"] as? Bool {
            self.outEnable = value
        }
        if let value = dict["OutInstanceNum"] as? Int32 {
            self.outInstanceNum = value
        }
        if let value = dict["OutLoad"] as? Int32 {
            self.outLoad = value
        }
        if let value = dict["OutRT"] as? Int32 {
            self.outRT = value
        }
        if let value = dict["OutStep"] as? Int32 {
            self.outStep = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["ResourceFrom"] as? String {
            self.resourceFrom = value
        }
        if let value = dict["ScalingPolicy"] as? String {
            self.scalingPolicy = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["TemplateInstanceId"] as? String {
            self.templateInstanceId = value
        }
        if let value = dict["TemplateInstanceName"] as? String {
            self.templateInstanceName = value
        }
        if let value = dict["TemplateVersion"] as? Int32 {
            self.templateVersion = value
        }
        if let value = dict["VSwitchIds"] as? String {
            self.vSwitchIds = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ModifyScalingRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryApplicationStatusRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class QueryApplicationStatusResponseBody : Tea.TeaModel {
    public class AppInfo : Tea.TeaModel {
        public class Application : Tea.TeaModel {
            public var applicationId: String?

            public var buildPackageId: Int32?

            public var clusterId: String?

            public var cpu: Int32?

            public var createTime: Int64?

            public var dockerize: Bool?

            public var email: String?

            public var healthCheckUrl: String?

            public var instanceCount: Int32?

            public var launchTime: Int64?

            public var memory: Int32?

            public var name: String?

            public var owner: String?

            public var phone: String?

            public var port: Int32?

            public var regionId: String?

            public var runningInstanceCount: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationId != nil {
                    map["ApplicationId"] = self.applicationId!
                }
                if self.buildPackageId != nil {
                    map["BuildPackageId"] = self.buildPackageId!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerize != nil {
                    map["Dockerize"] = self.dockerize!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.healthCheckUrl != nil {
                    map["HealthCheckUrl"] = self.healthCheckUrl!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.launchTime != nil {
                    map["LaunchTime"] = self.launchTime!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.runningInstanceCount != nil {
                    map["RunningInstanceCount"] = self.runningInstanceCount!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApplicationId"] as? String {
                    self.applicationId = value
                }
                if let value = dict["BuildPackageId"] as? Int32 {
                    self.buildPackageId = value
                }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Dockerize"] as? Bool {
                    self.dockerize = value
                }
                if let value = dict["Email"] as? String {
                    self.email = value
                }
                if let value = dict["HealthCheckUrl"] as? String {
                    self.healthCheckUrl = value
                }
                if let value = dict["InstanceCount"] as? Int32 {
                    self.instanceCount = value
                }
                if let value = dict["LaunchTime"] as? Int64 {
                    self.launchTime = value
                }
                if let value = dict["Memory"] as? Int32 {
                    self.memory = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Phone"] as? String {
                    self.phone = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RunningInstanceCount"] as? Int32 {
                    self.runningInstanceCount = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public class DeployRecordList : Tea.TeaModel {
            public class DeployRecord : Tea.TeaModel {
                public var createTime: Int64?

                public var deployRecordId: String?

                public var eccId: String?

                public var ecuId: String?

                public var packageMd5: String?

                public var packageVersionId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.deployRecordId != nil {
                        map["DeployRecordId"] = self.deployRecordId!
                    }
                    if self.eccId != nil {
                        map["EccId"] = self.eccId!
                    }
                    if self.ecuId != nil {
                        map["EcuId"] = self.ecuId!
                    }
                    if self.packageMd5 != nil {
                        map["PackageMd5"] = self.packageMd5!
                    }
                    if self.packageVersionId != nil {
                        map["PackageVersionId"] = self.packageVersionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["DeployRecordId"] as? String {
                        self.deployRecordId = value
                    }
                    if let value = dict["EccId"] as? String {
                        self.eccId = value
                    }
                    if let value = dict["EcuId"] as? String {
                        self.ecuId = value
                    }
                    if let value = dict["PackageMd5"] as? String {
                        self.packageMd5 = value
                    }
                    if let value = dict["PackageVersionId"] as? String {
                        self.packageVersionId = value
                    }
                }
            }
            public var deployRecord: [QueryApplicationStatusResponseBody.AppInfo.DeployRecordList.DeployRecord]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deployRecord != nil {
                    var tmp : [Any] = []
                    for k in self.deployRecord! {
                        tmp.append(k.toMap())
                    }
                    map["DeployRecord"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DeployRecord"] as? [Any?] {
                    var tmp : [QueryApplicationStatusResponseBody.AppInfo.DeployRecordList.DeployRecord] = []
                    for v in value {
                        if v != nil {
                            var model = QueryApplicationStatusResponseBody.AppInfo.DeployRecordList.DeployRecord()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.deployRecord = tmp
                }
            }
        }
        public class EccList : Tea.TeaModel {
            public class Ecc : Tea.TeaModel {
                public var appId: String?

                public var appState: Int32?

                public var containerStatus: String?

                public var createTime: Int64?

                public var eccId: String?

                public var ecuId: String?

                public var groupId: String?

                public var ip: String?

                public var taskState: Int32?

                public var updateTime: Int64?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appState != nil {
                        map["AppState"] = self.appState!
                    }
                    if self.containerStatus != nil {
                        map["ContainerStatus"] = self.containerStatus!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.eccId != nil {
                        map["EccId"] = self.eccId!
                    }
                    if self.ecuId != nil {
                        map["EcuId"] = self.ecuId!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.taskState != nil {
                        map["TaskState"] = self.taskState!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppState"] as? Int32 {
                        self.appState = value
                    }
                    if let value = dict["ContainerStatus"] as? String {
                        self.containerStatus = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["EccId"] as? String {
                        self.eccId = value
                    }
                    if let value = dict["EcuId"] as? String {
                        self.ecuId = value
                    }
                    if let value = dict["GroupId"] as? String {
                        self.groupId = value
                    }
                    if let value = dict["Ip"] as? String {
                        self.ip = value
                    }
                    if let value = dict["TaskState"] as? Int32 {
                        self.taskState = value
                    }
                    if let value = dict["UpdateTime"] as? Int64 {
                        self.updateTime = value
                    }
                    if let value = dict["VpcId"] as? String {
                        self.vpcId = value
                    }
                }
            }
            public var ecc: [QueryApplicationStatusResponseBody.AppInfo.EccList.Ecc]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecc != nil {
                    var tmp : [Any] = []
                    for k in self.ecc! {
                        tmp.append(k.toMap())
                    }
                    map["Ecc"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ecc"] as? [Any?] {
                    var tmp : [QueryApplicationStatusResponseBody.AppInfo.EccList.Ecc] = []
                    for v in value {
                        if v != nil {
                            var model = QueryApplicationStatusResponseBody.AppInfo.EccList.Ecc()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ecc = tmp
                }
            }
        }
        public class EcuList : Tea.TeaModel {
            public class Ecu : Tea.TeaModel {
                public var availableCpu: Int32?

                public var availableMem: Int32?

                public var createTime: Int64?

                public var dockerEnv: Bool?

                public var ecuId: String?

                public var groupId: String?

                public var heartbeatTime: Int64?

                public var instanceId: String?

                public var ipAddr: String?

                public var name: String?

                public var online: Bool?

                public var regionId: String?

                public var updateTime: Int64?

                public var userId: String?

                public var vpcId: String?

                public var zoneId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableCpu != nil {
                        map["AvailableCpu"] = self.availableCpu!
                    }
                    if self.availableMem != nil {
                        map["AvailableMem"] = self.availableMem!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.dockerEnv != nil {
                        map["DockerEnv"] = self.dockerEnv!
                    }
                    if self.ecuId != nil {
                        map["EcuId"] = self.ecuId!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.heartbeatTime != nil {
                        map["HeartbeatTime"] = self.heartbeatTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.ipAddr != nil {
                        map["IpAddr"] = self.ipAddr!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.online != nil {
                        map["Online"] = self.online!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    if self.zoneId != nil {
                        map["ZoneId"] = self.zoneId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AvailableCpu"] as? Int32 {
                        self.availableCpu = value
                    }
                    if let value = dict["AvailableMem"] as? Int32 {
                        self.availableMem = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["DockerEnv"] as? Bool {
                        self.dockerEnv = value
                    }
                    if let value = dict["EcuId"] as? String {
                        self.ecuId = value
                    }
                    if let value = dict["GroupId"] as? String {
                        self.groupId = value
                    }
                    if let value = dict["HeartbeatTime"] as? Int64 {
                        self.heartbeatTime = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                    if let value = dict["IpAddr"] as? String {
                        self.ipAddr = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Online"] as? Bool {
                        self.online = value
                    }
                    if let value = dict["RegionId"] as? String {
                        self.regionId = value
                    }
                    if let value = dict["UpdateTime"] as? Int64 {
                        self.updateTime = value
                    }
                    if let value = dict["UserId"] as? String {
                        self.userId = value
                    }
                    if let value = dict["VpcId"] as? String {
                        self.vpcId = value
                    }
                    if let value = dict["ZoneId"] as? String {
                        self.zoneId = value
                    }
                }
            }
            public var ecu: [QueryApplicationStatusResponseBody.AppInfo.EcuList.Ecu]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecu != nil {
                    var tmp : [Any] = []
                    for k in self.ecu! {
                        tmp.append(k.toMap())
                    }
                    map["Ecu"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ecu"] as? [Any?] {
                    var tmp : [QueryApplicationStatusResponseBody.AppInfo.EcuList.Ecu] = []
                    for v in value {
                        if v != nil {
                            var model = QueryApplicationStatusResponseBody.AppInfo.EcuList.Ecu()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ecu = tmp
                }
            }
        }
        public class GroupList : Tea.TeaModel {
            public class Group : Tea.TeaModel {
                public var appId: String?

                public var appVersionId: String?

                public var clusterId: String?

                public var createTime: Int64?

                public var groupId: String?

                public var groupName: String?

                public var groupType: Int32?

                public var packageVersionId: String?

                public var updateTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appVersionId != nil {
                        map["AppVersionId"] = self.appVersionId!
                    }
                    if self.clusterId != nil {
                        map["ClusterId"] = self.clusterId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.groupType != nil {
                        map["GroupType"] = self.groupType!
                    }
                    if self.packageVersionId != nil {
                        map["PackageVersionId"] = self.packageVersionId!
                    }
                    if self.updateTime != nil {
                        map["UpdateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppVersionId"] as? String {
                        self.appVersionId = value
                    }
                    if let value = dict["ClusterId"] as? String {
                        self.clusterId = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["GroupId"] as? String {
                        self.groupId = value
                    }
                    if let value = dict["GroupName"] as? String {
                        self.groupName = value
                    }
                    if let value = dict["GroupType"] as? Int32 {
                        self.groupType = value
                    }
                    if let value = dict["PackageVersionId"] as? String {
                        self.packageVersionId = value
                    }
                    if let value = dict["UpdateTime"] as? Int64 {
                        self.updateTime = value
                    }
                }
            }
            public var group: [QueryApplicationStatusResponseBody.AppInfo.GroupList.Group]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.group != nil {
                    var tmp : [Any] = []
                    for k in self.group! {
                        tmp.append(k.toMap())
                    }
                    map["Group"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Group"] as? [Any?] {
                    var tmp : [QueryApplicationStatusResponseBody.AppInfo.GroupList.Group] = []
                    for v in value {
                        if v != nil {
                            var model = QueryApplicationStatusResponseBody.AppInfo.GroupList.Group()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.group = tmp
                }
            }
        }
        public var application: QueryApplicationStatusResponseBody.AppInfo.Application?

        public var deployRecordList: QueryApplicationStatusResponseBody.AppInfo.DeployRecordList?

        public var eccList: QueryApplicationStatusResponseBody.AppInfo.EccList?

        public var ecuList: QueryApplicationStatusResponseBody.AppInfo.EcuList?

        public var groupList: QueryApplicationStatusResponseBody.AppInfo.GroupList?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.application?.validate()
            try self.deployRecordList?.validate()
            try self.eccList?.validate()
            try self.ecuList?.validate()
            try self.groupList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.application != nil {
                map["Application"] = self.application?.toMap()
            }
            if self.deployRecordList != nil {
                map["DeployRecordList"] = self.deployRecordList?.toMap()
            }
            if self.eccList != nil {
                map["EccList"] = self.eccList?.toMap()
            }
            if self.ecuList != nil {
                map["EcuList"] = self.ecuList?.toMap()
            }
            if self.groupList != nil {
                map["GroupList"] = self.groupList?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Application"] as? [String: Any?] {
                var model = QueryApplicationStatusResponseBody.AppInfo.Application()
                model.fromMap(value)
                self.application = model
            }
            if let value = dict["DeployRecordList"] as? [String: Any?] {
                var model = QueryApplicationStatusResponseBody.AppInfo.DeployRecordList()
                model.fromMap(value)
                self.deployRecordList = model
            }
            if let value = dict["EccList"] as? [String: Any?] {
                var model = QueryApplicationStatusResponseBody.AppInfo.EccList()
                model.fromMap(value)
                self.eccList = model
            }
            if let value = dict["EcuList"] as? [String: Any?] {
                var model = QueryApplicationStatusResponseBody.AppInfo.EcuList()
                model.fromMap(value)
                self.ecuList = model
            }
            if let value = dict["GroupList"] as? [String: Any?] {
                var model = QueryApplicationStatusResponseBody.AppInfo.GroupList()
                model.fromMap(value)
                self.groupList = model
            }
        }
    }
    public var appInfo: QueryApplicationStatusResponseBody.AppInfo?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfo != nil {
            map["AppInfo"] = self.appInfo?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppInfo"] as? [String: Any?] {
            var model = QueryApplicationStatusResponseBody.AppInfo()
            model.fromMap(value)
            self.appInfo = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class QueryApplicationStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryApplicationStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryApplicationStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryEccInfoRequest : Tea.TeaModel {
    public var eccId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eccId != nil {
            map["EccId"] = self.eccId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EccId"] as? String {
            self.eccId = value
        }
    }
}

public class QueryEccInfoResponseBody : Tea.TeaModel {
    public class EccInfo : Tea.TeaModel {
        public var appId: String?

        public var eccId: String?

        public var ecuId: String?

        public var groupId: String?

        public var groupName: String?

        public var packageMd5: String?

        public var packageVersion: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.eccId != nil {
                map["EccId"] = self.eccId!
            }
            if self.ecuId != nil {
                map["EcuId"] = self.ecuId!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.packageMd5 != nil {
                map["PackageMd5"] = self.packageMd5!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["EccId"] as? String {
                self.eccId = value
            }
            if let value = dict["EcuId"] as? String {
                self.ecuId = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["PackageMd5"] as? String {
                self.packageMd5 = value
            }
            if let value = dict["PackageVersion"] as? String {
                self.packageVersion = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var code: Int32?

    public var eccInfo: QueryEccInfoResponseBody.EccInfo?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eccInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["EccInfo"] as? [String: Any?] {
            var model = QueryEccInfoResponseBody.EccInfo()
            model.fromMap(value)
            self.eccInfo = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class QueryEccInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryEccInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryEccInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryMigrateEcuListRequest : Tea.TeaModel {
    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
    }
}

public class QueryMigrateEcuListResponseBody : Tea.TeaModel {
    public class EcuEntityList : Tea.TeaModel {
        public class EcuEntity : Tea.TeaModel {
            public var availableCpu: Int32?

            public var availableMem: Int32?

            public var cpu: Int32?

            public var createTime: Int64?

            public var dockerEnv: Bool?

            public var ecuId: String?

            public var heartbeatTime: Int64?

            public var instanceId: String?

            public var ipAddr: String?

            public var mem: Int32?

            public var name: String?

            public var online: Bool?

            public var regionId: String?

            public var updateTime: Int64?

            public var userId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableCpu != nil {
                    map["AvailableCpu"] = self.availableCpu!
                }
                if self.availableMem != nil {
                    map["AvailableMem"] = self.availableMem!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dockerEnv != nil {
                    map["DockerEnv"] = self.dockerEnv!
                }
                if self.ecuId != nil {
                    map["EcuId"] = self.ecuId!
                }
                if self.heartbeatTime != nil {
                    map["HeartbeatTime"] = self.heartbeatTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipAddr != nil {
                    map["IpAddr"] = self.ipAddr!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableCpu"] as? Int32 {
                    self.availableCpu = value
                }
                if let value = dict["AvailableMem"] as? Int32 {
                    self.availableMem = value
                }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DockerEnv"] as? Bool {
                    self.dockerEnv = value
                }
                if let value = dict["EcuId"] as? String {
                    self.ecuId = value
                }
                if let value = dict["HeartbeatTime"] as? Int64 {
                    self.heartbeatTime = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["IpAddr"] as? String {
                    self.ipAddr = value
                }
                if let value = dict["Mem"] as? Int32 {
                    self.mem = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Online"] as? Bool {
                    self.online = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var ecuEntity: [QueryMigrateEcuListResponseBody.EcuEntityList.EcuEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecuEntity != nil {
                var tmp : [Any] = []
                for k in self.ecuEntity! {
                    tmp.append(k.toMap())
                }
                map["EcuEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EcuEntity"] as? [Any?] {
                var tmp : [QueryMigrateEcuListResponseBody.EcuEntityList.EcuEntity] = []
                for v in value {
                    if v != nil {
                        var model = QueryMigrateEcuListResponseBody.EcuEntityList.EcuEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ecuEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var ecuEntityList: QueryMigrateEcuListResponseBody.EcuEntityList?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecuEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ecuEntityList != nil {
            map["EcuEntityList"] = self.ecuEntityList?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["EcuEntityList"] as? [String: Any?] {
            var model = QueryMigrateEcuListResponseBody.EcuEntityList()
            model.fromMap(value)
            self.ecuEntityList = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class QueryMigrateEcuListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMigrateEcuListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryMigrateEcuListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryMigrateRegionListRequest : Tea.TeaModel {
    public var logicalRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logicalRegionId != nil {
            map["LogicalRegionId"] = self.logicalRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LogicalRegionId"] as? String {
            self.logicalRegionId = value
        }
    }
}

public class QueryMigrateRegionListResponseBody : Tea.TeaModel {
    public class RegionEntityList : Tea.TeaModel {
        public class RegionEntity : Tea.TeaModel {
            public var regionName: String?

            public var regionNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.regionName != nil {
                    map["RegionName"] = self.regionName!
                }
                if self.regionNo != nil {
                    map["RegionNo"] = self.regionNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RegionName"] as? String {
                    self.regionName = value
                }
                if let value = dict["RegionNo"] as? String {
                    self.regionNo = value
                }
            }
        }
        public var regionEntity: [QueryMigrateRegionListResponseBody.RegionEntityList.RegionEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.regionEntity != nil {
                var tmp : [Any] = []
                for k in self.regionEntity! {
                    tmp.append(k.toMap())
                }
                map["RegionEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RegionEntity"] as? [Any?] {
                var tmp : [QueryMigrateRegionListResponseBody.RegionEntityList.RegionEntity] = []
                for v in value {
                    if v != nil {
                        var model = QueryMigrateRegionListResponseBody.RegionEntityList.RegionEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.regionEntity = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regionEntityList: QueryMigrateRegionListResponseBody.RegionEntityList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regionEntityList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regionEntityList != nil {
            map["RegionEntityList"] = self.regionEntityList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RegionEntityList"] as? [String: Any?] {
            var model = QueryMigrateRegionListResponseBody.RegionEntityList()
            model.fromMap(value)
            self.regionEntityList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class QueryMigrateRegionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMigrateRegionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryMigrateRegionListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryRegionConfigResponseBody : Tea.TeaModel {
    public class RegionConfig : Tea.TeaModel {
        public class FileServerConfig : Tea.TeaModel {
            public var bucket: String?

            public var internalUrl: String?

            public var publicUrl: String?

            public var vpcUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.internalUrl != nil {
                    map["InternalUrl"] = self.internalUrl!
                }
                if self.publicUrl != nil {
                    map["PublicUrl"] = self.publicUrl!
                }
                if self.vpcUrl != nil {
                    map["VpcUrl"] = self.vpcUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Bucket"] as? String {
                    self.bucket = value
                }
                if let value = dict["InternalUrl"] as? String {
                    self.internalUrl = value
                }
                if let value = dict["PublicUrl"] as? String {
                    self.publicUrl = value
                }
                if let value = dict["VpcUrl"] as? String {
                    self.vpcUrl = value
                }
            }
        }
        public var addressServerHost: String?

        public var agentInstallScript: String?

        public var fileServerConfig: QueryRegionConfigResponseBody.RegionConfig.FileServerConfig?

        public var fileServerType: String?

        public var id: String?

        public var imageId: String?

        public var name: String?

        public var no: Int32?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.fileServerConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressServerHost != nil {
                map["AddressServerHost"] = self.addressServerHost!
            }
            if self.agentInstallScript != nil {
                map["AgentInstallScript"] = self.agentInstallScript!
            }
            if self.fileServerConfig != nil {
                map["FileServerConfig"] = self.fileServerConfig?.toMap()
            }
            if self.fileServerType != nil {
                map["FileServerType"] = self.fileServerType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.no != nil {
                map["No"] = self.no!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddressServerHost"] as? String {
                self.addressServerHost = value
            }
            if let value = dict["AgentInstallScript"] as? String {
                self.agentInstallScript = value
            }
            if let value = dict["FileServerConfig"] as? [String: Any?] {
                var model = QueryRegionConfigResponseBody.RegionConfig.FileServerConfig()
                model.fromMap(value)
                self.fileServerConfig = model
            }
            if let value = dict["FileServerType"] as? String {
                self.fileServerType = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["No"] as? Int32 {
                self.no = value
            }
            if let value = dict["Tag"] as? String {
                self.tag = value
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regionConfig: QueryRegionConfigResponseBody.RegionConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regionConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regionConfig != nil {
            map["RegionConfig"] = self.regionConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RegionConfig"] as? [String: Any?] {
            var model = QueryRegionConfigResponseBody.RegionConfig()
            model.fromMap(value)
            self.regionConfig = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class QueryRegionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRegionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryRegionConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QuerySlsLogStoreListRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class QuerySlsLogStoreListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consumerSide: String?

        public var createTime: String?

        public var link: String?

        public var logstore: String?

        public var project: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumerSide != nil {
                map["ConsumerSide"] = self.consumerSide!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.logstore != nil {
                map["Logstore"] = self.logstore!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConsumerSide"] as? String {
                self.consumerSide = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["Link"] as? String {
                self.link = value
            }
            if let value = dict["Logstore"] as? String {
                self.logstore = value
            }
            if let value = dict["Project"] as? String {
                self.project = value
            }
            if let value = dict["Source"] as? String {
                self.source = value
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var result: [QuerySlsLogStoreListResponseBody.Result]?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [QuerySlsLogStoreListResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = QuerySlsLogStoreListResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["TotalSize"] as? Int32 {
            self.totalSize = value
        }
    }
}

public class QuerySlsLogStoreListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySlsLogStoreListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QuerySlsLogStoreListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResetApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EccInfo"] as? String {
            self.eccInfo = value
        }
    }
}

public class ResetApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResetApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResetApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EccInfo"] as? String {
            self.eccInfo = value
        }
    }
}

public class RestartApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RestartApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class RestartK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RestartK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartK8sApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RetryChangeOrderTaskRequest : Tea.TeaModel {
    public var retryStatus: Bool?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.retryStatus != nil {
            map["RetryStatus"] = self.retryStatus!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RetryStatus"] as? Bool {
            self.retryStatus = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class RetryChangeOrderTaskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RetryChangeOrderTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryChangeOrderTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RetryChangeOrderTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RollbackApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var batch: Int32?

    public var batchWaitTime: Int32?

    public var groupId: String?

    public var historyVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.batch != nil {
            map["Batch"] = self.batch!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.historyVersion != nil {
            map["HistoryVersion"] = self.historyVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Batch"] as? Int32 {
            self.batch = value
        }
        if let value = dict["BatchWaitTime"] as? Int32 {
            self.batchWaitTime = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["HistoryVersion"] as? String {
            self.historyVersion = value
        }
    }
}

public class RollbackApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RollbackApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RollbackApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RollbackChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
    }
}

public class RollbackChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: Int32?

    public var data: RollbackChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = RollbackChangeOrderResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class RollbackChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RollbackChangeOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ScaleInApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public var forceStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        if self.forceStatus != nil {
            map["ForceStatus"] = self.forceStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EccInfo"] as? String {
            self.eccInfo = value
        }
        if let value = dict["ForceStatus"] as? Bool {
            self.forceStatus = value
        }
    }
}

public class ScaleInApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
    }
}

public class ScaleInApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleInApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ScaleInApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ScaleK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var replicas: Int32?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class ScaleK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ScaleK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ScaleK8sApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ScaleOutApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var deployGroup: String?

    public var ecuInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deployGroup != nil {
            map["DeployGroup"] = self.deployGroup!
        }
        if self.ecuInfo != nil {
            map["EcuInfo"] = self.ecuInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DeployGroup"] as? String {
            self.deployGroup = value
        }
        if let value = dict["EcuInfo"] as? String {
            self.ecuInfo = value
        }
    }
}

public class ScaleOutApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ScaleOutApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleOutApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ScaleOutApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ScaleoutApplicationWithNewInstancesRequest : Tea.TeaModel {
    public var appId: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clusterId: String?

    public var groupId: String?

    public var instanceChargePeriod: Int32?

    public var instanceChargePeriodUnit: String?

    public var instanceChargeType: String?

    public var scalingNum: Int32?

    public var scalingPolicy: String?

    public var templateId: String?

    public var templateInstanceId: String?

    public var templateVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceChargePeriod != nil {
            map["InstanceChargePeriod"] = self.instanceChargePeriod!
        }
        if self.instanceChargePeriodUnit != nil {
            map["InstanceChargePeriodUnit"] = self.instanceChargePeriodUnit!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.scalingNum != nil {
            map["ScalingNum"] = self.scalingNum!
        }
        if self.scalingPolicy != nil {
            map["ScalingPolicy"] = self.scalingPolicy!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateInstanceId != nil {
            map["TemplateInstanceId"] = self.templateInstanceId!
        }
        if self.templateVersion != nil {
            map["TemplateVersion"] = self.templateVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InstanceChargePeriod"] as? Int32 {
            self.instanceChargePeriod = value
        }
        if let value = dict["InstanceChargePeriodUnit"] as? String {
            self.instanceChargePeriodUnit = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["ScalingNum"] as? Int32 {
            self.scalingNum = value
        }
        if let value = dict["ScalingPolicy"] as? String {
            self.scalingPolicy = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["TemplateInstanceId"] as? String {
            self.templateInstanceId = value
        }
        if let value = dict["TemplateVersion"] as? String {
            self.templateVersion = value
        }
    }
}

public class ScaleoutApplicationWithNewInstancesResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var instanceIds: [String]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ScaleoutApplicationWithNewInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScaleoutApplicationWithNewInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ScaleoutApplicationWithNewInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EccInfo"] as? String {
            self.eccInfo = value
        }
    }
}

public class StartApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartK8sAppPrecheckRequest : Tea.TeaModel {
    public var annotations: String?

    public var appId: String?

    public var appName: String?

    public var clusterId: String?

    public var componentIds: String?

    public var configMountDescs: String?

    public var emptyDirs: String?

    public var envFroms: String?

    public var envs: String?

    public var imageUrl: String?

    public var javaStartUpConfig: String?

    public var labels: String?

    public var limitEphemeralStorage: Int32?

    public var limitMem: Int32?

    public var limitmCpu: Int32?

    public var localVolume: String?

    public var namespace: String?

    public var packageUrl: String?

    public var pvcMountDescs: String?

    public var regionId: String?

    public var replicas: Int32?

    public var requestsEphemeralStorage: Int32?

    public var requestsMem: Int32?

    public var requestsmCpu: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentIds != nil {
            map["ComponentIds"] = self.componentIds!
        }
        if self.configMountDescs != nil {
            map["ConfigMountDescs"] = self.configMountDescs!
        }
        if self.emptyDirs != nil {
            map["EmptyDirs"] = self.emptyDirs!
        }
        if self.envFroms != nil {
            map["EnvFroms"] = self.envFroms!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.javaStartUpConfig != nil {
            map["JavaStartUpConfig"] = self.javaStartUpConfig!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.limitEphemeralStorage != nil {
            map["LimitEphemeralStorage"] = self.limitEphemeralStorage!
        }
        if self.limitMem != nil {
            map["LimitMem"] = self.limitMem!
        }
        if self.limitmCpu != nil {
            map["LimitmCpu"] = self.limitmCpu!
        }
        if self.localVolume != nil {
            map["LocalVolume"] = self.localVolume!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.pvcMountDescs != nil {
            map["PvcMountDescs"] = self.pvcMountDescs!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.requestsEphemeralStorage != nil {
            map["RequestsEphemeralStorage"] = self.requestsEphemeralStorage!
        }
        if self.requestsMem != nil {
            map["RequestsMem"] = self.requestsMem!
        }
        if self.requestsmCpu != nil {
            map["RequestsmCpu"] = self.requestsmCpu!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Annotations"] as? String {
            self.annotations = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["ComponentIds"] as? String {
            self.componentIds = value
        }
        if let value = dict["ConfigMountDescs"] as? String {
            self.configMountDescs = value
        }
        if let value = dict["EmptyDirs"] as? String {
            self.emptyDirs = value
        }
        if let value = dict["EnvFroms"] as? String {
            self.envFroms = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["JavaStartUpConfig"] as? String {
            self.javaStartUpConfig = value
        }
        if let value = dict["Labels"] as? String {
            self.labels = value
        }
        if let value = dict["LimitEphemeralStorage"] as? Int32 {
            self.limitEphemeralStorage = value
        }
        if let value = dict["LimitMem"] as? Int32 {
            self.limitMem = value
        }
        if let value = dict["LimitmCpu"] as? Int32 {
            self.limitmCpu = value
        }
        if let value = dict["LocalVolume"] as? String {
            self.localVolume = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["PackageUrl"] as? String {
            self.packageUrl = value
        }
        if let value = dict["PvcMountDescs"] as? String {
            self.pvcMountDescs = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["RequestsEphemeralStorage"] as? Int32 {
            self.requestsEphemeralStorage = value
        }
        if let value = dict["RequestsMem"] as? Int32 {
            self.requestsMem = value
        }
        if let value = dict["RequestsmCpu"] as? Int32 {
            self.requestsmCpu = value
        }
    }
}

public class StartK8sAppPrecheckResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobs: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobs != nil {
                map["Jobs"] = self.jobs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Jobs"] as? [String] {
                self.jobs = value
            }
        }
    }
    public var code: Int32?

    public var data: StartK8sAppPrecheckResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = StartK8sAppPrecheckResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartK8sAppPrecheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartK8sAppPrecheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartK8sAppPrecheckResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var replicas: Int32?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class StartK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartK8sApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var eccInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.eccInfo != nil {
            map["EccInfo"] = self.eccInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EccInfo"] as? String {
            self.eccInfo = value
        }
    }
}

public class StopApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopK8sApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class StopK8sApplicationResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopK8sApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopK8sApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopK8sApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SwitchAdvancedMonitoringRequest : Tea.TeaModel {
    public var appId: String?

    public var enableAdvancedMonitoring: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.enableAdvancedMonitoring != nil {
            map["EnableAdvancedMonitoring"] = self.enableAdvancedMonitoring!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EnableAdvancedMonitoring"] as? Bool {
            self.enableAdvancedMonitoring = value
        }
    }
}

public class SwitchAdvancedMonitoringResponseBody : Tea.TeaModel {
    public var advancedMonitoringEnabled: Bool?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedMonitoringEnabled != nil {
            map["AdvancedMonitoringEnabled"] = self.advancedMonitoringEnabled!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdvancedMonitoringEnabled"] as? Bool {
            self.advancedMonitoringEnabled = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SwitchAdvancedMonitoringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchAdvancedMonitoringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SwitchAdvancedMonitoringResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SynchronizeResourceRequest : Tea.TeaModel {
    public var resourceIds: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ResourceIds"] as? String {
            self.resourceIds = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class SynchronizeResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SynchronizeResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SynchronizeResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SynchronizeResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public var resourceIds: String?

    public var resourceRegionId: String?

    public var resourceType: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceRegionId != nil {
            map["ResourceRegionId"] = self.resourceRegionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ResourceIds"] as? String {
            self.resourceIds = value
        }
        if let value = dict["ResourceRegionId"] as? String {
            self.resourceRegionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TransformClusterMemberRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var password: String?

    public var targetClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.targetClusterId != nil {
            map["TargetClusterId"] = self.targetClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["TargetClusterId"] as? String {
            self.targetClusterId = value
        }
    }
}

public class TransformClusterMemberResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TransformClusterMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransformClusterMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TransformClusterMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnbindK8sSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var slbName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.slbName != nil {
            map["SlbName"] = self.slbName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["SlbName"] as? String {
            self.slbName = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class UnbindK8sSlbResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnbindK8sSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindK8sSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnbindK8sSlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnbindSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var deleteListener: String?

    public var slbId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deleteListener != nil {
            map["DeleteListener"] = self.deleteListener!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DeleteListener"] as? String {
            self.deleteListener = value
        }
        if let value = dict["SlbId"] as? String {
            self.slbId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class UnbindSlbResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnbindSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnbindSlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var deleteAll: Bool?

    public var resourceIds: String?

    public var resourceRegionId: String?

    public var resourceType: String?

    public var tagKeys: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteAll != nil {
            map["DeleteAll"] = self.deleteAll!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceRegionId != nil {
            map["ResourceRegionId"] = self.resourceRegionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteAll"] as? Bool {
            self.deleteAll = value
        }
        if let value = dict["ResourceIds"] as? String {
            self.resourceIds = value
        }
        if let value = dict["ResourceRegionId"] as? String {
            self.resourceRegionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKeys"] as? String {
            self.tagKeys = value
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UntagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAccountInfoRequest : Tea.TeaModel {
    public var email: String?

    public var name: String?

    public var telephone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.telephone != nil {
            map["Telephone"] = self.telephone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Email"] as? String {
            self.email = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Telephone"] as? String {
            self.telephone = value
        }
    }
}

public class UpdateAccountInfoResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateAccountInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAccountInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAccountInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateApplicationBaseInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var desc: String?

    public var owner: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Desc"] as? String {
            self.desc = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
    }
}

public class UpdateApplicationBaseInfoResponseBody : Tea.TeaModel {
    public class Applcation : Tea.TeaModel {
        public var appId: String?

        public var applicationType: String?

        public var buildPackageId: Int64?

        public var clusterId: String?

        public var clusterType: Int32?

        public var cpu: Int32?

        public var createTime: Int64?

        public var description_: String?

        public var dockerize: Bool?

        public var extSlbId: String?

        public var extSlbIp: String?

        public var extSlbName: String?

        public var healthCheckUrl: String?

        public var instanceCount: Int32?

        public var memory: Int32?

        public var name: String?

        public var owner: String?

        public var port: Int32?

        public var regionId: String?

        public var runningInstanceCount: Int32?

        public var slbId: String?

        public var slbIp: String?

        public var slbName: String?

        public var slbPort: Int32?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.applicationType != nil {
                map["ApplicationType"] = self.applicationType!
            }
            if self.buildPackageId != nil {
                map["BuildPackageId"] = self.buildPackageId!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dockerize != nil {
                map["Dockerize"] = self.dockerize!
            }
            if self.extSlbId != nil {
                map["ExtSlbId"] = self.extSlbId!
            }
            if self.extSlbIp != nil {
                map["ExtSlbIp"] = self.extSlbIp!
            }
            if self.extSlbName != nil {
                map["ExtSlbName"] = self.extSlbName!
            }
            if self.healthCheckUrl != nil {
                map["HealthCheckUrl"] = self.healthCheckUrl!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.runningInstanceCount != nil {
                map["RunningInstanceCount"] = self.runningInstanceCount!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbIp != nil {
                map["SlbIp"] = self.slbIp!
            }
            if self.slbName != nil {
                map["SlbName"] = self.slbName!
            }
            if self.slbPort != nil {
                map["SlbPort"] = self.slbPort!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["ApplicationType"] as? String {
                self.applicationType = value
            }
            if let value = dict["BuildPackageId"] as? Int64 {
                self.buildPackageId = value
            }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["ClusterType"] as? Int32 {
                self.clusterType = value
            }
            if let value = dict["Cpu"] as? Int32 {
                self.cpu = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Dockerize"] as? Bool {
                self.dockerize = value
            }
            if let value = dict["ExtSlbId"] as? String {
                self.extSlbId = value
            }
            if let value = dict["ExtSlbIp"] as? String {
                self.extSlbIp = value
            }
            if let value = dict["ExtSlbName"] as? String {
                self.extSlbName = value
            }
            if let value = dict["HealthCheckUrl"] as? String {
                self.healthCheckUrl = value
            }
            if let value = dict["InstanceCount"] as? Int32 {
                self.instanceCount = value
            }
            if let value = dict["Memory"] as? Int32 {
                self.memory = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RunningInstanceCount"] as? Int32 {
                self.runningInstanceCount = value
            }
            if let value = dict["SlbId"] as? String {
                self.slbId = value
            }
            if let value = dict["SlbIp"] as? String {
                self.slbIp = value
            }
            if let value = dict["SlbName"] as? String {
                self.slbName = value
            }
            if let value = dict["SlbPort"] as? Int32 {
                self.slbPort = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var applcation: UpdateApplicationBaseInfoResponseBody.Applcation?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applcation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applcation != nil {
            map["Applcation"] = self.applcation?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Applcation"] as? [String: Any?] {
            var model = UpdateApplicationBaseInfoResponseBody.Applcation()
            model.fromMap(value)
            self.applcation = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateApplicationBaseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationBaseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateApplicationBaseInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingBehaviour: String?

    public var scalingRuleEnable: Bool?

    public var scalingRuleMetric: String?

    public var scalingRuleName: String?

    public var scalingRuleTimer: String?

    public var scalingRuleTrigger: String?

    public var scalingRuleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingBehaviour != nil {
            map["ScalingBehaviour"] = self.scalingBehaviour!
        }
        if self.scalingRuleEnable != nil {
            map["ScalingRuleEnable"] = self.scalingRuleEnable!
        }
        if self.scalingRuleMetric != nil {
            map["ScalingRuleMetric"] = self.scalingRuleMetric!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleTimer != nil {
            map["ScalingRuleTimer"] = self.scalingRuleTimer!
        }
        if self.scalingRuleTrigger != nil {
            map["ScalingRuleTrigger"] = self.scalingRuleTrigger!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ScalingBehaviour"] as? String {
            self.scalingBehaviour = value
        }
        if let value = dict["ScalingRuleEnable"] as? Bool {
            self.scalingRuleEnable = value
        }
        if let value = dict["ScalingRuleMetric"] as? String {
            self.scalingRuleMetric = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
        if let value = dict["ScalingRuleTimer"] as? String {
            self.scalingRuleTimer = value
        }
        if let value = dict["ScalingRuleTrigger"] as? String {
            self.scalingRuleTrigger = value
        }
        if let value = dict["ScalingRuleType"] as? String {
            self.scalingRuleType = value
        }
    }
}

public class UpdateApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class AppScalingRule : Tea.TeaModel {
        public class Behaviour : Tea.TeaModel {
            public class ScaleDown : Tea.TeaModel {
                public class Policies : Tea.TeaModel {
                    public var periodSeconds: Int32?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.periodSeconds != nil {
                            map["PeriodSeconds"] = self.periodSeconds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["PeriodSeconds"] as? Int32 {
                            self.periodSeconds = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var policies: [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies]?

                public var selectPolicy: String?

                public var stabilizationWindowSeconds: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.policies != nil {
                        var tmp : [Any] = []
                        for k in self.policies! {
                            tmp.append(k.toMap())
                        }
                        map["Policies"] = tmp
                    }
                    if self.selectPolicy != nil {
                        map["SelectPolicy"] = self.selectPolicy!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Policies"] as? [Any?] {
                        var tmp : [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies] = []
                        for v in value {
                            if v != nil {
                                var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown.Policies()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.policies = tmp
                    }
                    if let value = dict["SelectPolicy"] as? String {
                        self.selectPolicy = value
                    }
                    if let value = dict["StabilizationWindowSeconds"] as? Int32 {
                        self.stabilizationWindowSeconds = value
                    }
                }
            }
            public class ScaleUp : Tea.TeaModel {
                public class Policies : Tea.TeaModel {
                    public var periodSeconds: Int32?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.periodSeconds != nil {
                            map["PeriodSeconds"] = self.periodSeconds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["PeriodSeconds"] as? Int32 {
                            self.periodSeconds = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var policies: [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies]?

                public var selectPolicy: String?

                public var stabilizationWindowSeconds: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.policies != nil {
                        var tmp : [Any] = []
                        for k in self.policies! {
                            tmp.append(k.toMap())
                        }
                        map["Policies"] = tmp
                    }
                    if self.selectPolicy != nil {
                        map["SelectPolicy"] = self.selectPolicy!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Policies"] as? [Any?] {
                        var tmp : [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies] = []
                        for v in value {
                            if v != nil {
                                var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp.Policies()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.policies = tmp
                    }
                    if let value = dict["SelectPolicy"] as? String {
                        self.selectPolicy = value
                    }
                    if let value = dict["StabilizationWindowSeconds"] as? Int32 {
                        self.stabilizationWindowSeconds = value
                    }
                }
            }
            public var scaleDown: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown?

            public var scaleUp: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scaleDown?.validate()
                try self.scaleUp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scaleDown != nil {
                    map["ScaleDown"] = self.scaleDown?.toMap()
                }
                if self.scaleUp != nil {
                    map["ScaleUp"] = self.scaleUp?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ScaleDown"] as? [String: Any?] {
                    var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleDown()
                    model.fromMap(value)
                    self.scaleDown = model
                }
                if let value = dict["ScaleUp"] as? [String: Any?] {
                    var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour.ScaleUp()
                    model.fromMap(value)
                    self.scaleUp = model
                }
            }
        }
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricTargetAverageUtilization"] as? Int32 {
                        self.metricTargetAverageUtilization = value
                    }
                    if let value = dict["MetricType"] as? String {
                        self.metricType = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["Metrics"] as? [Any?] {
                    var tmp : [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric.Metrics()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.metrics = tmp
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public class Triggers : Tea.TeaModel {
                public var metaData: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metaData != nil {
                        map["MetaData"] = self.metaData!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetaData"] as? String {
                        self.metaData = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var minReplicas: Int32?

            public var triggers: [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.triggers != nil {
                    var tmp : [Any] = []
                    for k in self.triggers! {
                        tmp.append(k.toMap())
                    }
                    map["Triggers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
                if let value = dict["Triggers"] as? [Any?] {
                    var tmp : [UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger.Triggers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.triggers = tmp
                }
            }
        }
        public var appId: String?

        public var behaviour: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var maxReplicas: Int32?

        public var metric: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric?

        public var minReplicas: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var trigger: UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.behaviour?.validate()
            try self.metric?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.behaviour != nil {
                map["Behaviour"] = self.behaviour?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReplicas != nil {
                map["MinReplicas"] = self.minReplicas!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Behaviour"] as? [String: Any?] {
                var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Behaviour()
                model.fromMap(value)
                self.behaviour = model
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["LastDisableTime"] as? Int64 {
                self.lastDisableTime = value
            }
            if let value = dict["MaxReplicas"] as? Int32 {
                self.maxReplicas = value
            }
            if let value = dict["Metric"] as? [String: Any?] {
                var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Metric()
                model.fromMap(value)
                self.metric = model
            }
            if let value = dict["MinReplicas"] as? Int32 {
                self.minReplicas = value
            }
            if let value = dict["ScaleRuleEnabled"] as? Bool {
                self.scaleRuleEnabled = value
            }
            if let value = dict["ScaleRuleName"] as? String {
                self.scaleRuleName = value
            }
            if let value = dict["ScaleRuleType"] as? String {
                self.scaleRuleType = value
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var appScalingRule: UpdateApplicationScalingRuleResponseBody.AppScalingRule?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appScalingRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appScalingRule != nil {
            map["AppScalingRule"] = self.appScalingRule?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppScalingRule"] as? [String: Any?] {
            var model = UpdateApplicationScalingRuleResponseBody.AppScalingRule()
            model.fromMap(value)
            self.appScalingRule = model
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateConfigTemplateRequest : Tea.TeaModel {
    public var content: String?

    public var description_: String?

    public var format: String?

    public var id: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Format"] as? String {
            self.format = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class UpdateConfigTemplateResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateConfigTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateConfigTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateContainerRequest : Tea.TeaModel {
    public var appId: String?

    public var buildPackId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.buildPackId != nil {
            map["BuildPackId"] = self.buildPackId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BuildPackId"] as? Int32 {
            self.buildPackId = value
        }
    }
}

public class UpdateContainerResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateContainerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateContainerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateContainerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateContainerConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var contextPath: String?

    public var groupId: String?

    public var httpPort: Int32?

    public var maxThreads: Int32?

    public var URIEncoding: String?

    public var useBodyEncoding: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.contextPath != nil {
            map["ContextPath"] = self.contextPath!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.httpPort != nil {
            map["HttpPort"] = self.httpPort!
        }
        if self.maxThreads != nil {
            map["MaxThreads"] = self.maxThreads!
        }
        if self.URIEncoding != nil {
            map["URIEncoding"] = self.URIEncoding!
        }
        if self.useBodyEncoding != nil {
            map["UseBodyEncoding"] = self.useBodyEncoding!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ContextPath"] as? String {
            self.contextPath = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["HttpPort"] as? Int32 {
            self.httpPort = value
        }
        if let value = dict["MaxThreads"] as? Int32 {
            self.maxThreads = value
        }
        if let value = dict["URIEncoding"] as? String {
            self.URIEncoding = value
        }
        if let value = dict["UseBodyEncoding"] as? Bool {
            self.useBodyEncoding = value
        }
    }
}

public class UpdateContainerConfigurationResponseBody : Tea.TeaModel {
    public class ContainerConfiguration : Tea.TeaModel {
        public var contextPath: String?

        public var httpPort: Int32?

        public var maxThreads: Int32?

        public var URIEncoding: String?

        public var useBodyEncoding: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contextPath != nil {
                map["ContextPath"] = self.contextPath!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.maxThreads != nil {
                map["MaxThreads"] = self.maxThreads!
            }
            if self.URIEncoding != nil {
                map["URIEncoding"] = self.URIEncoding!
            }
            if self.useBodyEncoding != nil {
                map["UseBodyEncoding"] = self.useBodyEncoding!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ContextPath"] as? String {
                self.contextPath = value
            }
            if let value = dict["HttpPort"] as? Int32 {
                self.httpPort = value
            }
            if let value = dict["MaxThreads"] as? Int32 {
                self.maxThreads = value
            }
            if let value = dict["URIEncoding"] as? String {
                self.URIEncoding = value
            }
            if let value = dict["UseBodyEncoding"] as? Bool {
                self.useBodyEncoding = value
            }
        }
    }
    public var code: Int32?

    public var containerConfiguration: UpdateContainerConfigurationResponseBody.ContainerConfiguration?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.containerConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.containerConfiguration != nil {
            map["ContainerConfiguration"] = self.containerConfiguration?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["ContainerConfiguration"] as? [String: Any?] {
            var model = UpdateContainerConfigurationResponseBody.ContainerConfiguration()
            model.fromMap(value)
            self.containerConfiguration = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateContainerConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateContainerConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateContainerConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateHealthCheckUrlRequest : Tea.TeaModel {
    public var appId: String?

    public var hcURL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.hcURL != nil {
            map["hcURL"] = self.hcURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["hcURL"] as? String {
            self.hcURL = value
        }
    }
}

public class UpdateHealthCheckUrlResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var healthCheckURL: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.healthCheckURL != nil {
            map["HealthCheckURL"] = self.healthCheckURL!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["HealthCheckURL"] as? String {
            self.healthCheckURL = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateHealthCheckUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHealthCheckUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateHealthCheckUrlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateHookConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var hooks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.hooks != nil {
            map["Hooks"] = self.hooks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["Hooks"] as? String {
            self.hooks = value
        }
    }
}

public class UpdateHookConfigurationResponseBody : Tea.TeaModel {
    public class HooksConfiguration : Tea.TeaModel {
        public var ignoreFail: Bool?

        public var name: String?

        public var script: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoreFail != nil {
                map["IgnoreFail"] = self.ignoreFail!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.script != nil {
                map["Script"] = self.script!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IgnoreFail"] as? Bool {
                self.ignoreFail = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Script"] as? String {
                self.script = value
            }
        }
    }
    public var code: Int32?

    public var hooksConfiguration: [UpdateHookConfigurationResponseBody.HooksConfiguration]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.hooksConfiguration != nil {
            var tmp : [Any] = []
            for k in self.hooksConfiguration! {
                tmp.append(k.toMap())
            }
            map["HooksConfiguration"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["HooksConfiguration"] as? [Any?] {
            var tmp : [UpdateHookConfigurationResponseBody.HooksConfiguration] = []
            for v in value {
                if v != nil {
                    var model = UpdateHookConfigurationResponseBody.HooksConfiguration()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hooksConfiguration = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateHookConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHookConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateHookConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateJvmConfigurationRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var maxHeapSize: Int32?

    public var maxPermSize: Int32?

    public var minHeapSize: Int32?

    public var options: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.maxHeapSize != nil {
            map["MaxHeapSize"] = self.maxHeapSize!
        }
        if self.maxPermSize != nil {
            map["MaxPermSize"] = self.maxPermSize!
        }
        if self.minHeapSize != nil {
            map["MinHeapSize"] = self.minHeapSize!
        }
        if self.options != nil {
            map["Options"] = self.options!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["MaxHeapSize"] as? Int32 {
            self.maxHeapSize = value
        }
        if let value = dict["MaxPermSize"] as? Int32 {
            self.maxPermSize = value
        }
        if let value = dict["MinHeapSize"] as? Int32 {
            self.minHeapSize = value
        }
        if let value = dict["Options"] as? String {
            self.options = value
        }
    }
}

public class UpdateJvmConfigurationResponseBody : Tea.TeaModel {
    public class JvmConfiguration : Tea.TeaModel {
        public var maxHeapSize: Int32?

        public var maxPermSize: Int32?

        public var minHeapSize: Int32?

        public var options: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxHeapSize != nil {
                map["MaxHeapSize"] = self.maxHeapSize!
            }
            if self.maxPermSize != nil {
                map["MaxPermSize"] = self.maxPermSize!
            }
            if self.minHeapSize != nil {
                map["MinHeapSize"] = self.minHeapSize!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxHeapSize"] as? Int32 {
                self.maxHeapSize = value
            }
            if let value = dict["MaxPermSize"] as? Int32 {
                self.maxPermSize = value
            }
            if let value = dict["MinHeapSize"] as? Int32 {
                self.minHeapSize = value
            }
            if let value = dict["Options"] as? String {
                self.options = value
            }
        }
    }
    public var code: Int32?

    public var jvmConfiguration: UpdateJvmConfigurationResponseBody.JvmConfiguration?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jvmConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.jvmConfiguration != nil {
            map["JvmConfiguration"] = self.jvmConfiguration?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["JvmConfiguration"] as? [String: Any?] {
            var model = UpdateJvmConfigurationResponseBody.JvmConfiguration()
            model.fromMap(value)
            self.jvmConfiguration = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateJvmConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateJvmConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateJvmConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateK8sApplicationBaseInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var description_: String?

    public var email: String?

    public var owner: String?

    public var phoneNumber: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Email"] as? String {
            self.email = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PhoneNumber"] as? String {
            self.phoneNumber = value
        }
    }
}

public class UpdateK8sApplicationBaseInfoResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? String {
            self.result = value
        }
    }
}

public class UpdateK8sApplicationBaseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sApplicationBaseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateK8sApplicationBaseInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateK8sApplicationConfigRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var cpuLimit: String?

    public var cpuRequest: String?

    public var ephemeralStorageLimit: String?

    public var ephemeralStorageRequest: String?

    public var mcpuLimit: String?

    public var mcpuRequest: String?

    public var memoryLimit: String?

    public var memoryRequest: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cpuLimit != nil {
            map["CpuLimit"] = self.cpuLimit!
        }
        if self.cpuRequest != nil {
            map["CpuRequest"] = self.cpuRequest!
        }
        if self.ephemeralStorageLimit != nil {
            map["EphemeralStorageLimit"] = self.ephemeralStorageLimit!
        }
        if self.ephemeralStorageRequest != nil {
            map["EphemeralStorageRequest"] = self.ephemeralStorageRequest!
        }
        if self.mcpuLimit != nil {
            map["McpuLimit"] = self.mcpuLimit!
        }
        if self.mcpuRequest != nil {
            map["McpuRequest"] = self.mcpuRequest!
        }
        if self.memoryLimit != nil {
            map["MemoryLimit"] = self.memoryLimit!
        }
        if self.memoryRequest != nil {
            map["MemoryRequest"] = self.memoryRequest!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["CpuLimit"] as? String {
            self.cpuLimit = value
        }
        if let value = dict["CpuRequest"] as? String {
            self.cpuRequest = value
        }
        if let value = dict["EphemeralStorageLimit"] as? String {
            self.ephemeralStorageLimit = value
        }
        if let value = dict["EphemeralStorageRequest"] as? String {
            self.ephemeralStorageRequest = value
        }
        if let value = dict["McpuLimit"] as? String {
            self.mcpuLimit = value
        }
        if let value = dict["McpuRequest"] as? String {
            self.mcpuRequest = value
        }
        if let value = dict["MemoryLimit"] as? String {
            self.memoryLimit = value
        }
        if let value = dict["MemoryRequest"] as? String {
            self.memoryRequest = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class UpdateK8sApplicationConfigResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateK8sApplicationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sApplicationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateK8sApplicationConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateK8sConfigMapRequest : Tea.TeaModel {
    public var clusterId: String?

    public var data: [String: Any]?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Data"] as? [String: Any] {
            self.data = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
    }
}

public class UpdateK8sConfigMapResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateK8sConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateK8sConfigMapResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateK8sIngressRuleRequest : Tea.TeaModel {
    public var annotations: String?

    public var clusterId: String?

    public var ingressConf: [String: Any]?

    public var labels: String?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.annotations != nil {
            map["Annotations"] = self.annotations!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ingressConf != nil {
            map["IngressConf"] = self.ingressConf!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Annotations"] as? String {
            self.annotations = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["IngressConf"] as? [String: Any] {
            self.ingressConf = value
        }
        if let value = dict["Labels"] as? String {
            self.labels = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
    }
}

public class UpdateK8sIngressRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
    }
}

public class UpdateK8sIngressRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sIngressRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateK8sIngressRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateK8sResourceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var namespace: String?

    public var resourceContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.resourceContent != nil {
            map["ResourceContent"] = self.resourceContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["ResourceContent"] as? String {
            self.resourceContent = value
        }
    }
}

public class UpdateK8sResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateK8sResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateK8sResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateK8sSecretRequest : Tea.TeaModel {
    public var base64Encoded: Bool?

    public var certId: String?

    public var certRegionId: String?

    public var clusterId: String?

    public var data: String?

    public var name: String?

    public var namespace: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.base64Encoded != nil {
            map["Base64Encoded"] = self.base64Encoded!
        }
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certRegionId != nil {
            map["CertRegionId"] = self.certRegionId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Base64Encoded"] as? Bool {
            self.base64Encoded = value
        }
        if let value = dict["CertId"] as? String {
            self.certId = value
        }
        if let value = dict["CertRegionId"] as? String {
            self.certRegionId = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class UpdateK8sSecretResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateK8sSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateK8sSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateK8sServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var externalTrafficPolicy: String?

    public var name: String?

    public var servicePorts: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.externalTrafficPolicy != nil {
            map["ExternalTrafficPolicy"] = self.externalTrafficPolicy!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.servicePorts != nil {
            map["ServicePorts"] = self.servicePorts!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ExternalTrafficPolicy"] as? String {
            self.externalTrafficPolicy = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ServicePorts"] as? String {
            self.servicePorts = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class UpdateK8sServiceResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateK8sServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateK8sServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateK8sSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var clusterId: String?

    public var disableForceOverride: Bool?

    public var port: String?

    public var scheduler: String?

    public var servicePortInfos: String?

    public var slbName: String?

    public var slbProtocol: String?

    public var specification: String?

    public var targetPort: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.disableForceOverride != nil {
            map["DisableForceOverride"] = self.disableForceOverride!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.servicePortInfos != nil {
            map["ServicePortInfos"] = self.servicePortInfos!
        }
        if self.slbName != nil {
            map["SlbName"] = self.slbName!
        }
        if self.slbProtocol != nil {
            map["SlbProtocol"] = self.slbProtocol!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.targetPort != nil {
            map["TargetPort"] = self.targetPort!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["DisableForceOverride"] as? Bool {
            self.disableForceOverride = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["Scheduler"] as? String {
            self.scheduler = value
        }
        if let value = dict["ServicePortInfos"] as? String {
            self.servicePortInfos = value
        }
        if let value = dict["SlbName"] as? String {
            self.slbName = value
        }
        if let value = dict["SlbProtocol"] as? String {
            self.slbProtocol = value
        }
        if let value = dict["Specification"] as? String {
            self.specification = value
        }
        if let value = dict["TargetPort"] as? String {
            self.targetPort = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class UpdateK8sSlbResponseBody : Tea.TeaModel {
    public var changeOrderId: String?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateK8sSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateK8sSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateK8sSlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLocalitySettingRequest : Tea.TeaModel {
    public var appId: String?

    public var enabled: Bool?

    public var namespaceId: String?

    public var region: String?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["Threshold"] as? Double {
            self.threshold = value
        }
    }
}

public class UpdateLocalitySettingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enabled: Bool?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["Threshold"] as? Double {
                self.threshold = value
            }
        }
    }
    public var code: Int32?

    public var data: UpdateLocalitySettingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateLocalitySettingResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateLocalitySettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLocalitySettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLocalitySettingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRoleRequest : Tea.TeaModel {
    public var actionData: String?

    public var roleId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionData != nil {
            map["ActionData"] = self.actionData!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActionData"] as? String {
            self.actionData = value
        }
        if let value = dict["RoleId"] as? Int32 {
            self.roleId = value
        }
    }
}

public class UpdateRoleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateSlsLogStoreRequest : Tea.TeaModel {
    public var appId: String?

    public var configs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.configs != nil {
            map["Configs"] = self.configs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Configs"] as? String {
            self.configs = value
        }
    }
}

public class UpdateSlsLogStoreResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateSlsLogStoreResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSlsLogStoreResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateSlsLogStoreResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateSwimmingLaneRequest : Tea.TeaModel {
    public var appInfos: String?

    public var enableRules: Bool?

    public var entryRules: String?

    public var laneId: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfos != nil {
            map["AppInfos"] = self.appInfos!
        }
        if self.enableRules != nil {
            map["EnableRules"] = self.enableRules!
        }
        if self.entryRules != nil {
            map["EntryRules"] = self.entryRules!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppInfos"] as? String {
            self.appInfos = value
        }
        if let value = dict["EnableRules"] as? Bool {
            self.enableRules = value
        }
        if let value = dict["EntryRules"] as? String {
            self.entryRules = value
        }
        if let value = dict["LaneId"] as? Int64 {
            self.laneId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class UpdateSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SwimmingLaneAppRelationShipList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var laneId: Int64?

            public var rules: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.laneId != nil {
                    map["LaneId"] = self.laneId!
                }
                if self.rules != nil {
                    map["Rules"] = self.rules!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["LaneId"] as? Int64 {
                    self.laneId = value
                }
                if let value = dict["Rules"] as? String {
                    self.rules = value
                }
            }
        }
        public var entryRule: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public var swimmingLaneAppRelationShipList: [UpdateSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList]?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entryRule != nil {
                map["EntryRule"] = self.entryRule!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.swimmingLaneAppRelationShipList != nil {
                var tmp : [Any] = []
                for k in self.swimmingLaneAppRelationShipList! {
                    tmp.append(k.toMap())
                }
                map["SwimmingLaneAppRelationShipList"] = tmp
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EntryRule"] as? String {
                self.entryRule = value
            }
            if let value = dict["GroupId"] as? Int64 {
                self.groupId = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["SwimmingLaneAppRelationShipList"] as? [Any?] {
                var tmp : [UpdateSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList] = []
                for v in value {
                    if v != nil {
                        var model = UpdateSwimmingLaneResponseBody.Data.SwimmingLaneAppRelationShipList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.swimmingLaneAppRelationShipList = tmp
            }
            if let value = dict["Tag"] as? String {
                self.tag = value
            }
        }
    }
    public var code: Int32?

    public var data: UpdateSwimmingLaneResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateSwimmingLaneResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateSwimmingLaneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateSwimmingLaneGroupRequest : Tea.TeaModel {
    public var appIds: String?

    public var entryApp: String?

    public var groupId: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.entryApp != nil {
            map["EntryApp"] = self.entryApp!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIds"] as? String {
            self.appIds = value
        }
        if let value = dict["EntryApp"] as? String {
            self.entryApp = value
        }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class UpdateSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApplicationList : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
            }
        }
        public class EntryApplication : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
            }
        }
        public var applicationList: [UpdateSwimmingLaneGroupResponseBody.Data.ApplicationList]?

        public var entryApplication: UpdateSwimmingLaneGroupResponseBody.Data.EntryApplication?

        public var id: Int64?

        public var name: String?

        public var namespaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.entryApplication?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationList != nil {
                var tmp : [Any] = []
                for k in self.applicationList! {
                    tmp.append(k.toMap())
                }
                map["ApplicationList"] = tmp
            }
            if self.entryApplication != nil {
                map["EntryApplication"] = self.entryApplication?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationList"] as? [Any?] {
                var tmp : [UpdateSwimmingLaneGroupResponseBody.Data.ApplicationList] = []
                for v in value {
                    if v != nil {
                        var model = UpdateSwimmingLaneGroupResponseBody.Data.ApplicationList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.applicationList = tmp
            }
            if let value = dict["EntryApplication"] as? [String: Any?] {
                var model = UpdateSwimmingLaneGroupResponseBody.Data.EntryApplication()
                model.fromMap(value)
                self.entryApplication = model
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
        }
    }
    public var code: Int32?

    public var data: UpdateSwimmingLaneGroupResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateSwimmingLaneGroupResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateSwimmingLaneGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
